#include "BoneAnalyzer.h"
#include <iostream>
#include <algorithm>
#include <filesystem>
#include <sstream>
#include <cctype>
#include <ctime>
#include <Windows.h>

namespace BoneAnalyzer {
    // Global storage for tracking dumped enemy types
    std::unordered_set<std::string> g_dumpedEnemyNames;
    
    // Global map for storing bone data per enemy type
    std::unordered_map<std::string, EnemyBoneData> g_enemyBoneMap;
    
    // File path for storing bone data
    std::string g_boneDataFilePath;

    // Initialize the bone analyzer (load existing data from file)
    void Initialize() {
        // Create BoneData directory in current working directory
        std::string boneDataDir = "BoneData";
        if (!std::filesystem::exists(boneDataDir)) {
            std::filesystem::create_directory(boneDataDir);
            std::cout << "[BONE ANALYZER] Created directory: " << std::filesystem::absolute(boneDataDir) << std::endl;
        }
        
        // Set up file path
        g_boneDataFilePath = boneDataDir + "/enemy_bones.txt";
        std::cout << "[BONE ANALYZER] Bone data file: " << std::filesystem::absolute(g_boneDataFilePath) << std::endl;
        
        // Load existing bone data with error recovery
        try {
            LoadBoneDataFromFile();
        } catch (const std::exception& e) {
            std::cout << "[BONE ANALYZER] CRITICAL ERROR: Failed to load bone data: " << e.what() << std::endl;
            std::cout << "[BONE ANALYZER] Attempting to recover by backing up corrupted file..." << std::endl;
            
            // Create backup of corrupted file
            std::string backupPath = g_boneDataFilePath + ".corrupted." + std::to_string(time(nullptr));
            try {
                std::filesystem::copy_file(g_boneDataFilePath, backupPath);
                std::cout << "[BONE ANALYZER] Corrupted file backed up to: " << backupPath << std::endl;
                
                // Remove the corrupted file so we start fresh
                std::filesystem::remove(g_boneDataFilePath);
                std::cout << "[BONE ANALYZER] Removed corrupted file. Starting with fresh database." << std::endl;
                
            } catch (const std::exception& backupError) {
                std::cout << "[BONE ANALYZER] WARNING: Failed to backup corrupted file: " << backupError.what() << std::endl;
            }
        }
    }

    // Save bone data to file
    void SaveBoneDataToFile() {
        std::ofstream file(g_boneDataFilePath);
        if (!file.is_open()) {
            std::cout << "[BONE ANALYZER] ERROR: Failed to open file for writing: " << g_boneDataFilePath << std::endl;
            return;
        }

        std::cout << "[BONE ANALYZER] Saving bone data to file..." << std::endl;
        
        // Write header
        file << "# Enemy Bone Data File\n";
        file << "# Format: EnemyType|AnimBP|TargetBoneIndex|TargetBoneName|AllBones(Index:Name;...)\n";
        file << "# Generated by AbyssusHack BoneAnalyzer\n\n";

        int savedCount = 0;
        int skippedCount = 0;

        // Write each enemy's bone data with validation
        for (const auto& [enemyKey, boneData] : g_enemyBoneMap) {
            // Validate data before writing
            if (enemyKey.empty()) {
                std::cout << "[BONE ANALYZER] WARNING: Skipping entry with empty enemy key" << std::endl;
                skippedCount++;
                continue;
            }

            if (boneData.targetBoneIndex < -1) { // -1 is valid (means "not found")
                std::cout << "[BONE ANALYZER] WARNING: Skipping entry with invalid bone index: " << boneData.targetBoneIndex << std::endl;
                skippedCount++;
                continue;
            }

            if (boneData.targetBoneName.empty()) {
                std::cout << "[BONE ANALYZER] WARNING: Skipping entry with empty bone name for key: " << enemyKey << std::endl;
                skippedCount++;
                continue;
            }

            try {
                // The enemyKey is already in format "EnemyType|AnimBP", so we can write it directly
                // Format: EnemyKey|TargetBoneIndex|TargetBoneName|AllBones
                file << enemyKey << "|" << boneData.targetBoneIndex << "|" << boneData.targetBoneName << "|";
                
                // Write all bones with validation
                for (size_t i = 0; i < boneData.allBones.size(); ++i) {
                    const auto& [boneIndex, boneName] = boneData.allBones[i];
                    
                    // Skip invalid bone entries
                    if (boneIndex < 0 || boneName.empty()) {
                        continue;
                    }
                    
                    file << boneIndex << ":" << boneName;
                    if (i < boneData.allBones.size() - 1) {
                        file << ";";
                    }
                }
                file << "\n";
                savedCount++;

            } catch (const std::exception& e) {
                std::cout << "[BONE ANALYZER] ERROR: Failed to write entry for " << enemyKey << ": " << e.what() << std::endl;
                skippedCount++;
            }
        }

        file.close();
        std::cout << "[BONE ANALYZER] Saved " << savedCount << " enemy bone entries to file." << std::endl;
        if (skippedCount > 0) {
            std::cout << "[BONE ANALYZER] Skipped " << skippedCount << " invalid entries." << std::endl;
        }
    }

    // Load bone data from file
    void LoadBoneDataFromFile() {
        std::ifstream file(g_boneDataFilePath);
        if (!file.is_open()) {
            std::cout << "[BONE ANALYZER] No existing bone data file found. Starting fresh." << std::endl;
            return;
        }

        std::cout << "[BONE ANALYZER] Loading bone data from file..." << std::endl;
        
        std::string line;
        int loadedCount = 0;
        int skippedCount = 0;
        
        while (std::getline(file, line)) {
            // Skip comments and empty lines
            if (line.empty() || line[0] == '#') {
                continue;
            }

            try {
                // Parse line: EnemyType|AnimBP|TargetBoneIndex|TargetBoneName|AllBones
                size_t pos1 = line.find('|');           // First delimiter after EnemyType
                size_t pos2 = line.find('|', pos1 + 1); // Second delimiter after AnimBP  
                size_t pos3 = line.find('|', pos2 + 1); // Third delimiter after TargetBoneIndex
                size_t pos4 = line.find('|', pos3 + 1); // Fourth delimiter after TargetBoneName
                
                if (pos1 == std::string::npos || pos2 == std::string::npos || pos3 == std::string::npos || pos4 == std::string::npos) {
                    std::cout << "[BONE ANALYZER] WARNING: Skipping malformed line (missing delimiters): " << line << std::endl;
                    skippedCount++;
                    continue;
                }

                std::string enemyType = line.substr(0, pos1);
                std::string animBP = line.substr(pos1 + 1, pos2 - pos1 - 1);
                std::string targetBoneIndexStr = line.substr(pos2 + 1, pos3 - pos2 - 1);
                std::string targetBoneName = line.substr(pos3 + 1, pos4 - pos3 - 1);
                std::string allBonesStr = line.substr(pos4 + 1);

                // Build the enemy key from the parsed components (EnemyType|AnimBP)
                std::string enemyKey = enemyType + "|" + animBP;

                // Validate that the bone index string is not empty and contains only digits and minus sign
                if (targetBoneIndexStr.empty()) {
                    std::cout << "[BONE ANALYZER] WARNING: Skipping line with empty bone index: " << line << std::endl;
                    skippedCount++;
                    continue;
                }

                // Validate that the bone index string contains only valid characters for an integer
                bool validInteger = true;
                for (size_t i = 0; i < targetBoneIndexStr.length(); i++) {
                    char c = targetBoneIndexStr[i];
                    if (i == 0 && c == '-') continue; // Allow minus sign at the beginning
                    if (!std::isdigit(c)) {
                        validInteger = false;
                        break;
                    }
                }

                if (!validInteger) {
                    std::cout << "[BONE ANALYZER] WARNING: Skipping line with invalid bone index '" << targetBoneIndexStr << "': " << line << std::endl;
                    skippedCount++;
                    continue;
                }

                // Parse the bone index with additional error checking
                int targetBoneIndex;
                try {
                    targetBoneIndex = std::stoi(targetBoneIndexStr);
                } catch (const std::invalid_argument& e) {
                    std::cout << "[BONE ANALYZER] WARNING: Invalid bone index format '" << targetBoneIndexStr << "': " << e.what() << std::endl;
                    skippedCount++;
                    continue;
                } catch (const std::out_of_range& e) {
                    std::cout << "[BONE ANALYZER] WARNING: Bone index out of range '" << targetBoneIndexStr << "': " << e.what() << std::endl;
                    skippedCount++;
                    continue;
                }

                EnemyBoneData boneData;
                boneData.targetBoneIndex = targetBoneIndex;
                boneData.targetBoneName = targetBoneName;

                // Parse all bones with error handling
                if (!allBonesStr.empty()) {
                    std::string currentBone;
                    std::stringstream ss(allBonesStr);
                    
                    while (std::getline(ss, currentBone, ';')) {
                        size_t colonPos = currentBone.find(':');
                        if (colonPos != std::string::npos) {
                            std::string boneIndexStr = currentBone.substr(0, colonPos);
                            std::string boneName = currentBone.substr(colonPos + 1);
                            
                            try {
                                int boneIndex = std::stoi(boneIndexStr);
                                boneData.allBones.emplace_back(boneIndex, boneName);
                            } catch (const std::exception& e) {
                                std::cout << "[BONE ANALYZER] WARNING: Skipping invalid bone entry '" << currentBone << "': " << e.what() << std::endl;
                                // Continue processing other bones rather than failing the entire entry
                            }
                        }
                    }
                }

                g_enemyBoneMap[enemyKey] = boneData;
                g_dumpedEnemyNames.insert(enemyKey);
                loadedCount++;

            } catch (const std::exception& e) {
                std::cout << "[BONE ANALYZER] ERROR: Exception while parsing line '" << line << "': " << e.what() << std::endl;
                skippedCount++;
                continue;
            }
        }

        file.close();
        std::cout << "[BONE ANALYZER] Loaded " << loadedCount << " enemy bone entries from file." << std::endl;
        if (skippedCount > 0) {
            std::cout << "[BONE ANALYZER] Skipped " << skippedCount << " malformed entries." << std::endl;
        }
    }

    // Helper function to get a stable class name from an object by parsing GetFullName() and removing instance IDs
    std::string GetUObjectClassName(SDK::UObject* obj)
    {
        if (!obj) return std::string();
        std::string full = obj->GetFullName();
        size_t sp = full.find(' ');
        if (sp != std::string::npos) {
            std::string className = full.substr(0, sp);
            
            // Remove instance ID suffixes like "_2147475704" to get base class name
            size_t lastUnderscore = className.find_last_of('_');
            if (lastUnderscore != std::string::npos) {
                std::string potentialId = className.substr(lastUnderscore + 1);
                // Check if it's all digits (instance ID)
                bool isAllDigits = !potentialId.empty() && 
                    std::all_of(potentialId.begin(), potentialId.end(), ::isdigit);
                if (isAllDigits) {
                    className = className.substr(0, lastUnderscore);
                }
            }
            return className;
        }
        return full; // fallback
    }

    // Helper function to build a unique enemy key from an enemy pawn and its skeletal mesh
    std::string BuildEnemyKey(SDK::AREnemyPawnBase* enemy, SDK::USkeletalMeshComponent* mesh) {
        if (!enemy || !mesh) {
            return std::string();
        }
        
        // Build enemy key for bone database lookup
        std::string pawnBaseClassName = GetUObjectClassName(enemy);
        std::string animBPBaseClassName;
        if (auto animInstance = mesh->GetAnimInstance()) {
            animBPBaseClassName = GetUObjectClassName(animInstance);
        }
        
        return pawnBaseClassName + "|" + animBPBaseClassName;
    }

    // Function to find the best target bone from a list of bones with prioritization
    // Priority: "head" -> "Body" -> "Core" -> "Spine_01" -> first bone
    EnemyBoneData AnalyzeBones(SDK::USkeletalMeshComponent* mesh) {
        EnemyBoneData boneData;
        
        if (!mesh) {
            std::cout << "[BONE ANALYZER] ERROR: SkeletalMeshComponent is null!" << std::endl;
            return boneData;
        }

        int boneCount = mesh->GetNumBones();
        std::cout << "[BONE ANALYZER] Analyzing " << boneCount << " bones..." << std::endl;
        
        // Priority list for target bones (case insensitive matching)
        std::vector<std::string> priorityBones = {"head", "Body", "Core", "Spine_01"};
        
        // Collect all bones
        for (int i = 0; i < boneCount; i++) {
            std::string boneName = mesh->GetBoneName(i).ToString();
            boneData.allBones.emplace_back(i, boneName);
        }

        // Helper function to convert string to lowercase for case-insensitive comparison
        auto toLower = [](std::string str) {
            std::transform(str.begin(), str.end(), str.begin(), ::tolower);
            return str;
        };

        // Find target bone using priority system (case insensitive)
        for (const std::string& priorityBone : priorityBones) {
            std::string priorityBoneLower = toLower(priorityBone);
            
            for (const auto& [boneIndex, boneName] : boneData.allBones) {
                std::string boneNameLower = toLower(boneName);
                
                if (boneNameLower == priorityBoneLower) {
                    boneData.targetBoneIndex = boneIndex;
                    boneData.targetBoneName = boneName; // Keep original case for display
                    std::cout << "[BONE ANALYZER] Selected priority bone: " << boneName << " (index " << boneIndex << ")" << std::endl;
                    return boneData;
                }
            }
        }

        // If no priority bones found, use the first bone
        if (!boneData.allBones.empty()) {
            boneData.targetBoneIndex = boneData.allBones[0].first;
            boneData.targetBoneName = boneData.allBones[0].second;
            std::cout << "[BONE ANALYZER] No priority bones found, using first bone: " << boneData.targetBoneName 
                      << " (index " << boneData.targetBoneIndex << ")" << std::endl;
        } else {
            std::cout << "[BONE ANALYZER] WARNING: No bones found in mesh!" << std::endl;
        }

        return boneData;
    }

    // Function to dump bones for a single skeletal mesh component
    void DumpBones(SDK::USkeletalMeshComponent* mesh)
    {
		
        if (!mesh) {
            std::cout << "ERROR: SkeletalMeshComponent is null!" << std::endl;
            return;
        }

        int boneCount = mesh->GetNumBones();
        std::cout << "  Total bones: " << boneCount << std::endl;
        
        for (int b = 0; b < boneCount; b++) {
            std::string boneName = mesh->GetBoneName(b).ToString();
            std::cout << "    Bone [" << b << "]: " << boneName << std::endl;
        }
    }

    // Main function to iterate enemies and dump bones only once per unique enemy "type"
    void DumpUniqueEnemyBones(SDK::UWorld* World)
    {
        if (!World || !World->PersistentLevel) {
            std::cout << "ERROR: World or PersistentLevel not available!" << '\n';
            return;
        }

        auto& currentActors = World->PersistentLevel->Actors;
        std::cout << "\n=== F3 PRESSED - ENEMY BONES DUMP ===" << '\n';
        std::cout << "Total actors count: " << currentActors.Num() << std::endl;

        int enemiesSeen = 0;
        int newlyDumped = 0;

        if (currentActors.Num() > 0) {
            for (int i = 0; i < currentActors.Num(); ++i) {
                auto actor = currentActors[i];
                if (actor && actor->IsA(SDK::AREnemyPawnBase::StaticClass())) {
                    auto enemy = static_cast<SDK::AREnemyPawnBase*>(actor);

                    // Use the exposed SkeletalMesh property
                    SDK::USkeletalMeshComponent* mesh = enemy->SkeletalMesh;
                    if (!mesh) {
                        continue;
                    }

                    // Build a stable uniqueness key using the helper function
                    std::string uniqueKey = BuildEnemyKey(enemy, mesh);
                    if (uniqueKey.empty()) {
                        std::cout << "ERROR: Failed to build enemy key for " << enemy->GetName() << std::endl;
                        continue;
                    }

                    ++enemiesSeen;

                    if (g_dumpedEnemyNames.contains(uniqueKey)) {
                        std::cout << "Skipping already analyzed enemy type: " << uniqueKey << std::endl;
                        continue;
                    }

                    std::cout << "Analyzing bones for enemy type: " << uniqueKey << std::endl;
                    std::cout << "  (Instance: " << enemy->GetName() << ")" << std::endl;
                    
                    // Analyze bones and store the data
                    EnemyBoneData boneData = AnalyzeBones(mesh);
                    g_enemyBoneMap[uniqueKey] = boneData;
                    
                    // Also dump all bones for reference
                    DumpBones(mesh);
                    
                    g_dumpedEnemyNames.insert(uniqueKey);
                    ++newlyDumped;
                }
            }
        }

        // Save updated bone data to file
        if (newlyDumped > 0) {
            SaveBoneDataToFile();
        }

        std::cout << "Enemy actors encountered: " << enemiesSeen << std::endl;
        std::cout << "New unique types analyzed this run: " << newlyDumped << std::endl;
        std::cout << "Previously analyzed types (skipped) this run: "
                  << (enemiesSeen - newlyDumped) << std::endl;
        std::cout << "Total enemy types in database: " << g_enemyBoneMap.size() << std::endl;
        std::cout << "=== END ENEMY BONES DUMP ===\n" << std::endl;
    }

    // Get the target bone index for a specific enemy type (for use by aimbot)
    int GetTargetBoneIndex(const std::string& enemyKey) {
        auto it = g_enemyBoneMap.find(enemyKey);
        if (it != g_enemyBoneMap.end()) {
            return it->second.targetBoneIndex;
        }
        return -1; // Not found
    }

    // Get the target bone name for a specific enemy type (for debugging)
    std::string GetTargetBoneName(const std::string& enemyKey) {
        auto it = g_enemyBoneMap.find(enemyKey);
        if (it != g_enemyBoneMap.end()) {
            return it->second.targetBoneName;
        }
        return "Unknown"; // Not found
    }

    // Automatically analyze and add a single enemy to the database
    bool AnalyzeAndAddEnemy(SDK::AREnemyPawnBase* enemy, SDK::USkeletalMeshComponent* mesh) {
        if (!enemy || !mesh) {
            std::cout << "[BONE ANALYZER] AnalyzeAndAddEnemy: Invalid parameters (enemy or mesh is null)" << std::endl;
            return false;
        }

        // Build enemy key
        std::string enemyKey = BuildEnemyKey(enemy, mesh);
        if (enemyKey.empty()) {
            std::cout << "[BONE ANALYZER] AnalyzeAndAddEnemy: Failed to build enemy key" << std::endl;
            return false;
        }

        // Check if already exists (shouldn't happen, but safety check)
        if (g_enemyBoneMap.find(enemyKey) != g_enemyBoneMap.end()) {
            std::cout << "[BONE ANALYZER] AnalyzeAndAddEnemy: Enemy already exists in database: " << enemyKey << std::endl;
            return true; // Already exists, consider it success
        }

        std::cout << "[BONE ANALYZER] Auto-analyzing new enemy type: " << enemyKey << std::endl;
        std::cout << "[BONE ANALYZER] - Instance: " << enemy->GetName() << std::endl;

        // Analyze bones and store the data
        EnemyBoneData boneData = AnalyzeBones(mesh);
        if (boneData.targetBoneIndex == -1) {
            std::cout << "[BONE ANALYZER] AnalyzeAndAddEnemy: Failed to find target bone for " << enemyKey << std::endl;
            return false;
        }

        // Add to database
        g_enemyBoneMap[enemyKey] = boneData;
        g_dumpedEnemyNames.insert(enemyKey);

        std::cout << "[BONE ANALYZER] Successfully added new enemy type: " << enemyKey << std::endl;
        std::cout << "[BONE ANALYZER] - Target bone: " << boneData.targetBoneName << " (index " << boneData.targetBoneIndex << ")" << std::endl;

        // Save to file immediately so the data persists
        SaveBoneDataToFile();

        return true;
    }

    // Display current bone database status (for debugging)
    void DisplayBoneDatabase() {
        std::cout << "\n=== BONE DATABASE STATUS ===" << std::endl;
        std::cout << "Total enemy types analyzed: " << g_enemyBoneMap.size() << std::endl;
        std::cout << "Bone data file: " << g_boneDataFilePath << std::endl;
        
        if (!g_enemyBoneMap.empty()) {
            std::cout << "\nEnemy types and their target bones:" << std::endl;
            for (const auto& [enemyKey, boneData] : g_enemyBoneMap) {
                std::cout << "  " << enemyKey << " -> " << boneData.targetBoneName 
                          << " (index " << boneData.targetBoneIndex << ")" << std::endl;
            }
        } else {
            std::cout << "No enemy bone data available. Use F3 to scan for enemies." << std::endl;
        }
        std::cout << "=== END BONE DATABASE STATUS ===\n" << std::endl;
    }
}