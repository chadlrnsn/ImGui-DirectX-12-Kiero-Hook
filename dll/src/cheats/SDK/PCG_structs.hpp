#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PCG

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum PCG.EPCGAttributeAccessorFlags
// NumValues: 0x0007
enum class EPCGAttributeAccessorFlags : uint8
{
	StrictType                               = 1,
	AllowBroadcast                           = 2,
	AllowConstructible                       = 4,
	AllowSetDefaultValue                     = 8,
	AllowReuseMetadataEntryKey               = 16,
	AllowBroadcastAndConstructible           = 6,
	EPCGAttributeAccessorFlags_MAX           = 17,
};

// Enum PCG.EPCGAttractMode
// NumValues: 0x0005
enum class EPCGAttractMode : uint8
{
	Closest                                  = 0,
	MinAttribute                             = 1,
	MaxAttribute                             = 2,
	FromIndex                                = 3,
	EPCGAttractMode_MAX                      = 4,
};

// Enum PCG.EPCGAttributeFilterOperator
// NumValues: 0x000A
enum class EPCGAttributeFilterOperator : uint8
{
	Greater                                  = 0,
	GreaterOrEqual                           = 1,
	Lesser                                   = 2,
	LesserOrEqual                            = 3,
	Equal                                    = 4,
	NotEqual                                 = 5,
	InRange                                  = 6,
	Substring                                = 7,
	Matches                                  = 8,
	EPCGAttributeFilterOperator_MAX          = 9,
};

// Enum PCG.EPCGAttributePropertySelection
// NumValues: 0x0004
enum class EPCGAttributePropertySelection : uint32
{
	Attribute                                = 0,
	PointProperty                            = 1,
	ExtraProperty                            = 2,
	EPCGAttributePropertySelection_MAX       = 3,
};

// Enum PCG.EPCGExtraProperties
// NumValues: 0x0002
enum class EPCGExtraProperties : uint8
{
	Index                                    = 0,
	EPCGExtraProperties_MAX                  = 1,
};

// Enum PCG.EPCGBlurElementMode
// NumValues: 0x0004
enum class EPCGBlurElementMode : uint32
{
	Constant                                 = 0,
	Linear                                   = 1,
	Gaussian                                 = 2,
	EPCGBlurElementMode_MAX                  = 3,
};

// Enum PCG.EPCGControlPointFuseMode
// NumValues: 0x0005
enum class EPCGControlPointFuseMode : uint32
{
	KeepFirst                                = 0,
	KeepSecond                               = 1,
	Merge                                    = 2,
	Auto                                     = 3,
	EPCGControlPointFuseMode_MAX             = 4,
};

// Enum PCG.EPCGClusterAlgorithm
// NumValues: 0x0003
enum class EPCGClusterAlgorithm : uint32
{
	KMeans                                   = 0,
	EM                                       = 1,
	EPCGClusterAlgorithm_MAX                 = 2,
};

// Enum PCG.EPCGCollapseMode
// NumValues: 0x0003
enum class EPCGCollapseMode : uint8
{
	PairwiseClosest                          = 0,
	AbsoluteClosest                          = 1,
	EPCGCollapseMode_MAX                     = 2,
};

// Enum PCG.EPCGCollapseComparisonMode
// NumValues: 0x0003
enum class EPCGCollapseComparisonMode : uint8
{
	Position                                 = 0,
	Center                                   = 1,
	EPCGCollapseComparisonMode_MAX           = 2,
};

// Enum PCG.EPCGCollapseVisitOrder
// NumValues: 0x0005
enum class EPCGCollapseVisitOrder : uint8
{
	Ordered                                  = 0,
	Random                                   = 1,
	MinAttribute                             = 2,
	MaxAttribute                             = 3,
	EPCGCollapseVisitOrder_MAX               = 4,
};

// Enum PCG.EPCGChangeType
// NumValues: 0x000A
enum class EPCGChangeType : uint8
{
	None                                     = 0,
	Cosmetic                                 = 1,
	Settings                                 = 2,
	Input                                    = 4,
	Edge                                     = 8,
	Node                                     = 16,
	Structural                               = 32,
	GenerationGrid                           = 64,
	ShaderSource                             = 128,
	EPCGChangeType_MAX                       = 129,
};

// Enum PCG.EPCGDataType
// NumValues: 0x0016
enum class EPCGDataType : uint32
{
	None                                     = 0,
	Point                                    = 2,
	Spline                                   = 4,
	LandscapeSpline                          = 8,
	PolyLine                                 = 12,
	Landscape                                = 16,
	Texture                                  = 32,
	RenderTarget                             = 64,
	BaseTexture                              = 96,
	Surface                                  = 112,
	Volume                                   = 128,
	Primitive                                = 256,
	DynamicMesh                              = 1024,
	Concrete                                 = 1534,
	Composite                                = 512,
	Spatial                                  = 2046,
	Param                                    = 134217728,
	PointOrParam                             = 134217730,
	Settings                                 = 268435456,
	Other                                    = 536870912,
	Any                                      = 1073741823,
	EPCGDataType_MAX                         = 1073741824,
};

// Enum PCG.EPCGExclusiveDataType
// NumValues: 0x0016
enum class EPCGExclusiveDataType : uint8
{
	None                                     = 0,
	Point                                    = 1,
	Spline                                   = 2,
	LandscapeSpline                          = 3,
	PolyLine                                 = 4,
	Landscape                                = 5,
	Texture                                  = 6,
	RenderTarget                             = 7,
	BaseTexture                              = 8,
	Surface                                  = 9,
	Volume                                   = 10,
	Primitive                                = 11,
	Concrete                                 = 12,
	Composite                                = 13,
	Spatial                                  = 14,
	Param                                    = 15,
	Settings                                 = 16,
	Other                                    = 17,
	Any                                      = 18,
	PointOrParam                             = 19,
	DynamicMesh                              = 20,
	EPCGExclusiveDataType_MAX                = 21,
};

// Enum PCG.EPCGCoordinateSpace
// NumValues: 0x0004
enum class EPCGCoordinateSpace : uint8
{
	World                                    = 0,
	OriginalComponent                        = 1,
	LocalComponent                           = 2,
	EPCGCoordinateSpace_MAX                  = 3,
};

// Enum PCG.EPCGStringMatchingOperator
// NumValues: 0x0004
enum class EPCGStringMatchingOperator : uint8
{
	Equal                                    = 0,
	Substring                                = 1,
	Matches                                  = 2,
	EPCGStringMatchingOperator_MAX           = 3,
};

// Enum PCG.EPCGHiGenGrid
// NumValues: 0x001A
enum class EPCGHiGenGrid : uint32
{
	Uninitialized                            = 0,
	Grid4                                    = 4,
	Grid8                                    = 8,
	Grid16                                   = 16,
	Grid32                                   = 32,
	Grid64                                   = 64,
	Grid128                                  = 128,
	Grid256                                  = 256,
	Grid512                                  = 512,
	Grid1024                                 = 1024,
	Grid2048                                 = 2048,
	Grid4096                                 = 4096,
	Grid8192                                 = 8192,
	Grid16384                                = 16384,
	Grid32768                                = 32768,
	Grid65536                                = 65536,
	Grid131072                               = 131072,
	Grid262144                               = 262144,
	Grid524288                               = 524288,
	Grid1048576                              = 1048576,
	Grid2097152                              = 2097152,
	Grid4194304                              = 4194304,
	GridMin                                  = 4,
	GridMax                                  = 4194304,
	Unbounded                                = 2147483648,
	EPCGHiGenGrid_MAX                        = 2147483649,
};

// Enum PCG.EPCGAttachOptions
// NumValues: 0x0006
enum class EPCGAttachOptions : uint32
{
	NotAttached                              = 0,
	Attached                                 = 1,
	InFolder                                 = 2,
	InGraphFolder                            = 3,
	InGeneratedFolder                        = 4,
	EPCGAttachOptions_MAX                    = 5,
};

// Enum PCG.EPCGEditorDirtyMode
// NumValues: 0x0004
enum class EPCGEditorDirtyMode : uint8
{
	Normal                                   = 0,
	Preview                                  = 1,
	LoadAsPreview                            = 2,
	EPCGEditorDirtyMode_MAX                  = 3,
};

// Enum PCG.EPCGNodeTitleType
// NumValues: 0x0003
enum class EPCGNodeTitleType : uint8
{
	FullTitle                                = 0,
	ListView                                 = 1,
	EPCGNodeTitleType_MAX                    = 2,
};

// Enum PCG.EPCGDensityMergeOperation
// NumValues: 0x0009
enum class EPCGDensityMergeOperation : uint8
{
	Set                                      = 0,
	Ignore                                   = 1,
	Minimum                                  = 2,
	Maximum                                  = 3,
	Add                                      = 4,
	Subtract                                 = 5,
	Multiply                                 = 6,
	Divide                                   = 7,
	EPCGDensityMergeOperation_MAX            = 8,
};

// Enum PCG.EPCGGenerationStatus
// NumValues: 0x0003
enum class EPCGGenerationStatus : uint8
{
	Completed                                = 0,
	Aborted                                  = 1,
	EPCGGenerationStatus_MAX                 = 2,
};

// Enum PCG.EPCGControlFlowSelectionMode
// NumValues: 0x0004
enum class EPCGControlFlowSelectionMode : uint8
{
	Integer                                  = 0,
	Enum                                     = 1,
	String                                   = 2,
	EPCGControlFlowSelectionMode_MAX         = 3,
};

// Enum PCG.EPCGCopyAttributesOperation
// NumValues: 0x0004
enum class EPCGCopyAttributesOperation : uint32
{
	CopyEachSourceToEachTargetRespectively   = 0,
	MergeSourcesAndCopyToAllTargets          = 1,
	CopyEachSourceOnEveryTarget              = 2,
	EPCGCopyAttributesOperation_MAX          = 3,
};

// Enum PCG.EPCGLocalGridPivot
// NumValues: 0x0004
enum class EPCGLocalGridPivot : uint8
{
	Global                                   = 0,
	OriginalComponent                        = 1,
	LocalComponent                           = 2,
	EPCGLocalGridPivot_MAX                   = 3,
};

// Enum PCG.EPCGPointPosition
// NumValues: 0x0003
enum class EPCGPointPosition : uint8
{
	CellCenter                               = 0,
	CellCorners                              = 1,
	EPCGPointPosition_MAX                    = 2,
};

// Enum PCG.EPCGGridPivot
// NumValues: 0x0004
enum class EPCGGridPivot : uint8
{
	Global                                   = 0,
	OriginalComponent                        = 1,
	LocalComponent                           = 2,
	EPCGGridPivot_MAX                        = 3,
};

// Enum PCG.EPCGCullPointsMode
// NumValues: 0x0003
enum class EPCGCullPointsMode : uint8
{
	Ordered                                  = 0,
	Unordered                                = 1,
	EPCGCullPointsMode_MAX                   = 2,
};

// Enum PCG.EPCGReadbackMode
// NumValues: 0x0005
enum class EPCGReadbackMode : uint8
{
	None                                     = 0,
	GraphOutput                              = 2,
	Inspection                               = 4,
	DebugVisualization                       = 8,
	EPCGReadbackMode_MAX                     = 9,
};

// Enum PCG.EPCGKernelAttributeType
// NumValues: 0x000E
enum class EPCGKernelAttributeType : uint8
{
	None                                     = 0,
	Bool                                     = 1,
	Int                                      = 2,
	Float                                    = 3,
	Float2                                   = 4,
	Float3                                   = 5,
	Float4                                   = 6,
	Rotator                                  = 7,
	Quat                                     = 8,
	Transform                                = 9,
	StringKey                                = 10,
	Name                                     = 11,
	Invalid                                  = 255,
	EPCGKernelAttributeType_MAX              = 256,
};

// Enum PCG.EPCGAttributeFilterOperation
// NumValues: 0x0003
enum class EPCGAttributeFilterOperation : uint32
{
	KeepSelectedAttributes                   = 0,
	DeleteSelectedAttributes                 = 1,
	EPCGAttributeFilterOperation_MAX         = 2,
};

// Enum PCG.EPCGTagFilterOperation
// NumValues: 0x0003
enum class EPCGTagFilterOperation : uint32
{
	KeepOnlySelectedTags                     = 0,
	DeleteSelectedTags                       = 1,
	EPCGTagFilterOperation_MAX               = 2,
};

// Enum PCG.PCGDistanceShape
// NumValues: 0x0004
enum class EPCGDistanceShape : uint32
{
	SphereBounds                             = 0,
	BoxBounds                                = 1,
	Center                                   = 2,
	PCGDistanceShape_MAX                     = 3,
};

// Enum PCG.EPCGUnitTestDummyEnum
// NumValues: 0x0004
enum class EPCGUnitTestDummyEnum : uint64
{
	One                                      = 0,
	Two                                      = 1,
	Three                                    = 2,
	EPCGUnitTestDummyEnum_MAX                = 3,
};

// Enum PCG.EPCGMetadataTypes
// NumValues: 0x0012
enum class EPCGMetadataTypes : uint8
{
	Float                                    = 0,
	Double                                   = 1,
	Integer32                                = 2,
	Integer64                                = 3,
	Vector2                                  = 4,
	Vector                                   = 5,
	Vector4                                  = 6,
	Quaternion                               = 7,
	Transform                                = 8,
	String                                   = 9,
	Boolean                                  = 10,
	Rotator                                  = 11,
	Name                                     = 12,
	SoftObjectPath                           = 13,
	SoftClassPath                            = 14,
	Count                                    = 15,
	Unknown                                  = 255,
	EPCGMetadataTypes_MAX                    = 256,
};

// Enum PCG.EPCGMetadataOp
// NumValues: 0x0008
enum class EPCGMetadataOp : uint8
{
	Min                                      = 0,
	Max                                      = 1,
	Sub                                      = 2,
	Add                                      = 3,
	Mul                                      = 4,
	Div                                      = 5,
	SourceValue                              = 6,
	TargetValue                              = 7,
};

// Enum PCG.EPCGMetadataFilterMode
// NumValues: 0x0003
enum class EPCGMetadataFilterMode : uint8
{
	ExcludeAttributes                        = 0,
	IncludeAttributes                        = 1,
	EPCGMetadataFilterMode_MAX               = 2,
};

// Enum PCG.EPCGMetadataMakeRotatorOp
// NumValues: 0x000C
enum class EPCGMetadataMakeRotatorOp : uint8
{
	MakeRotFromX                             = 0,
	MakeRotFromY                             = 1,
	MakeRotFromZ                             = 2,
	MakeRotFromXY                            = 3,
	MakeRotFromYX                            = 4,
	MakeRotFromXZ                            = 5,
	MakeRotFromZX                            = 6,
	MakeRotFromYZ                            = 7,
	MakeRotFromZY                            = 8,
	MakeRotFromAxes                          = 9,
	MakeRotFromAngles                        = 10,
	EPCGMetadataMakeRotatorOp_MAX            = 11,
};

// Enum PCG.EPCGMetadataTypesConstantStructStringMode
// NumValues: 0x0004
enum class EPCGMetadataTypesConstantStructStringMode : uint32
{
	String                                   = 0,
	SoftObjectPath                           = 1,
	SoftClassPath                            = 2,
	EPCGMetadataTypesConstantStructStringMode_MAX = 3,
};

// Enum PCG.PCGNormalToDensityMode
// NumValues: 0x0008
enum class EPCGNormalToDensityMode : uint8
{
	Set                                      = 0,
	Minimum                                  = 1,
	Maximum                                  = 2,
	Add                                      = 3,
	Subtract                                 = 4,
	Multiply                                 = 5,
	Divide                                   = 6,
	PCGNormalToDensityMode_MAX               = 7,
};

// Enum PCG.EPCGPathfindingSplineMode
// NumValues: 0x0003
enum class EPCGPathfindingSplineMode : uint8
{
	Curve                                    = 0,
	Linear                                   = 1,
	EPCGPathfindingSplineMode_MAX            = 2,
};

// Enum PCG.EPCGPathfindingCostFunctionMode
// NumValues: 0x0004
enum class EPCGPathfindingCostFunctionMode : uint8
{
	Distance                                 = 0,
	FitnessScore                             = 1,
	CostMultiplier                           = 2,
	EPCGPathfindingCostFunctionMode_MAX      = 3,
};

// Enum PCG.EPCGPointNeighborhoodDensityMode
// NumValues: 0x0004
enum class EPCGPointNeighborhoodDensityMode : uint32
{
	None                                     = 0,
	SetNormalizedDistanceToDensity           = 1,
	SetAverageDensity                        = 2,
	EPCGPointNeighborhoodDensityMode_MAX     = 3,
};

// Enum PCG.EPCGPrintVerbosity
// NumValues: 0x0004
enum class EPCGPrintVerbosity : uint8
{
	Log                                      = 5,
	Warning                                  = 3,
	Error                                    = 2,
	EPCGPrintVerbosity_MAX                   = 6,
};

// Enum PCG.EPCGProjectionColorBlendMode
// NumValues: 0x0006
enum class EPCGProjectionColorBlendMode : uint8
{
	SourceValue                              = 0,
	TargetValue                              = 1,
	Add                                      = 2,
	Subtract                                 = 3,
	Multiply                                 = 4,
	EPCGProjectionColorBlendMode_MAX         = 5,
};

// Enum PCG.EPCGProjectionTagMergeMode
// NumValues: 0x0004
enum class EPCGProjectionTagMergeMode : uint8
{
	Source                                   = 0,
	Target                                   = 1,
	Both                                     = 2,
	EPCGProjectionTagMergeMode_MAX           = 3,
};

// Enum PCG.EPCGTextureMappingMethod
// NumValues: 0x0003
enum class EPCGTextureMappingMethod : uint8
{
	Planar                                   = 0,
	UVCoordinates                            = 1,
	EPCGTextureMappingMethod_MAX             = 2,
};

// Enum PCG.EPCGSelectGrammarComparator
// NumValues: 0x000B
enum class EPCGSelectGrammarComparator : uint16
{
	BinaryOps                                = 32,
	Select                                   = 33,
	LessThan                                 = 34,
	LessThanEqualTo                          = 35,
	EqualTo                                  = 36,
	GreaterThanEqualTo                       = 37,
	GreaterThan                              = 38,
	TernaryOps                               = 64,
	RangeExclusive                           = 65,
	RangeInclusive                           = 66,
	EPCGSelectGrammarComparator_MAX          = 67,
};

// Enum PCG.EPCGSortMethod
// NumValues: 0x0003
enum class EPCGSortMethod : uint8
{
	Ascending                                = 0,
	Descending                               = 1,
	EPCGSortMethod_MAX                       = 2,
};

// Enum PCG.EPCGReverseSplineOperation
// NumValues: 0x0004
enum class EPCGReverseSplineOperation : uint32
{
	Reverse                                  = 0,
	ForceClockwise                           = 1,
	ForceCounterClockwise                    = 2,
	EPCGReverseSplineOperation_MAX           = 3,
};

// Enum PCG.EPCGSplitAxis
// NumValues: 0x0004
enum class EPCGSplitAxis : uint32
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	EPCGSplitAxis_MAX                        = 3,
};

// Enum PCG.EPCGUserParameterSource
// NumValues: 0x0004
enum class EPCGUserParameterSource : uint8
{
	Current                                  = 0,
	Upstream                                 = 1,
	Root                                     = 2,
	EPCGUserParameterSource_MAX              = 3,
};

// Enum PCG.EPCGWorldRaycastMode
// NumValues: 0x0005
enum class EPCGWorldRaycastMode : uint8
{
	Infinite                                 = 0,
	ScaledVector                             = 1,
	NormalizedWithLength                     = 2,
	Segments                                 = 3,
	EPCGWorldRaycastMode_MAX                 = 4,
};

// Enum PCG.EPCGKernelType
// NumValues: 0x0004
enum class EPCGKernelType : uint8
{
	PointProcessor                           = 0,
	PointGenerator                           = 1,
	Custom                                   = 2,
	EPCGKernelType_MAX                       = 3,
};

// Enum PCG.EPCGDispatchThreadCount
// NumValues: 0x0004
enum class EPCGDispatchThreadCount : uint8
{
	FromFirstOutputPin                       = 0,
	Fixed                                    = 1,
	FromProductOfInputPins                   = 2,
	EPCGDispatchThreadCount_MAX              = 3,
};

// Enum PCG.EPCGPinInitMode
// NumValues: 0x0003
enum class EPCGPinInitMode : uint8
{
	FromInputPins                            = 0,
	Custom                                   = 1,
	EPCGPinInitMode_MAX                      = 2,
};

// Enum PCG.EPCGDataCountMode
// NumValues: 0x0003
enum class EPCGDataCountMode : uint8
{
	FromInputData                            = 0,
	Fixed                                    = 1,
	EPCGDataCountMode_MAX                    = 2,
};

// Enum PCG.EPCGElementCountMode
// NumValues: 0x0003
enum class EPCGElementCountMode : uint8
{
	FromInputData                            = 0,
	Fixed                                    = 1,
	EPCGElementCountMode_MAX                 = 2,
};

// Enum PCG.EPCGDataMultiplicity
// NumValues: 0x0003
enum class EPCGDataMultiplicity : uint8
{
	Pairwise                                 = 0,
	CartesianProduct                         = 1,
	EPCGDataMultiplicity_MAX                 = 2,
};

// Enum PCG.EPCGElementMultiplicity
// NumValues: 0x0003
enum class EPCGElementMultiplicity : uint8
{
	Product                                  = 0,
	Sum                                      = 1,
	EPCGElementMultiplicity_MAX              = 2,
};

// Enum PCG.EPCGAttributeInheritanceMode
// NumValues: 0x0003
enum class EPCGAttributeInheritanceMode : uint8
{
	None                                     = 0,
	CopyAttributeSetup                       = 1,
	EPCGAttributeInheritanceMode_MAX         = 2,
};

// Enum PCG.EPCGCollisionQueryFlag
// NumValues: 0x0005
enum class EPCGCollisionQueryFlag : uint8
{
	Simple                                   = 0,
	Complex                                  = 1,
	SimpleFirst                              = 2,
	ComplexFirst                             = 3,
	EPCGCollisionQueryFlag_MAX               = 4,
};

// Enum PCG.EPCGDifferenceDensityFunction
// NumValues: 0x0004
enum class EPCGDifferenceDensityFunction : uint8
{
	Minimum                                  = 0,
	ClampedSubstraction                      = 1,
	Binary                                   = 2,
	EPCGDifferenceDensityFunction_MAX        = 3,
};

// Enum PCG.EPCGDifferenceMode
// NumValues: 0x0004
enum class EPCGDifferenceMode : uint8
{
	Inferred                                 = 0,
	Continuous                               = 1,
	Discrete                                 = 2,
	EPCGDifferenceMode_MAX                   = 3,
};

// Enum PCG.EPCGIntersectionDensityFunction
// NumValues: 0x0003
enum class EPCGIntersectionDensityFunction : uint8
{
	Multiply                                 = 0,
	Minimum                                  = 1,
	EPCGIntersectionDensityFunction_MAX      = 2,
};

// Enum PCG.EPCGTextureColorChannel
// NumValues: 0x0005
enum class EPCGTextureColorChannel : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Alpha                                    = 3,
	EPCGTextureColorChannel_MAX              = 4,
};

// Enum PCG.EPCGTextureDensityFunction
// NumValues: 0x0003
enum class EPCGTextureDensityFunction : uint8
{
	Ignore                                   = 0,
	Multiply                                 = 1,
	EPCGTextureDensityFunction_MAX           = 2,
};

// Enum PCG.EPCGTextureFilter
// NumValues: 0x0003
enum class EPCGTextureFilter : uint8
{
	Point                                    = 0,
	Bilinear                                 = 1,
	EPCGTextureFilter_MAX                    = 2,
};

// Enum PCG.EPCGTextureAddressMode
// NumValues: 0x0003
enum class EPCGTextureAddressMode : uint8
{
	Clamp                                    = 0,
	Wrap                                     = 1,
	EPCGTextureAddressMode_MAX               = 2,
};

// Enum PCG.EPCGUnionType
// NumValues: 0x0004
enum class EPCGUnionType : uint8
{
	LeftToRightPriority                      = 0,
	RightToLeftPriority                      = 1,
	KeepAll                                  = 2,
	EPCGUnionType_MAX                        = 3,
};

// Enum PCG.EPCGUnionDensityFunction
// NumValues: 0x0004
enum class EPCGUnionDensityFunction : uint8
{
	Maximum                                  = 0,
	ClampedAddition                          = 1,
	Binary                                   = 2,
	EPCGUnionDensityFunction_MAX             = 3,
};

// Enum PCG.EPCGWorldQueryFilterByTag
// NumValues: 0x0004
enum class EPCGWorldQueryFilterByTag : uint32
{
	NoTagFilter                              = 0,
	IncludeTagged                            = 1,
	ExcludeTagged                            = 2,
	EPCGWorldQueryFilterByTag_MAX            = 3,
};

// Enum PCG.EPCGWorldQuerySelectLandscapeHits
// NumValues: 0x0004
enum class EPCGWorldQuerySelectLandscapeHits : uint8
{
	Exclude                                  = 0,
	Include                                  = 1,
	Require                                  = 2,
	EPCGWorldQuerySelectLandscapeHits_MAX    = 3,
};

// Enum PCG.EPCGMetadataBitwiseOperation
// NumValues: 0x0005
enum class EPCGMetadataBitwiseOperation : uint16
{
	And                                      = 0,
	Not                                      = 1,
	Or                                       = 2,
	Xor                                      = 3,
	EPCGMetadataBitwiseOperation_MAX         = 4,
};

// Enum PCG.EPCGMetadataBooleanOperation
// NumValues: 0x0005
enum class EPCGMetadataBooleanOperation : uint16
{
	And                                      = 0,
	Not                                      = 1,
	Or                                       = 2,
	Xor                                      = 3,
	EPCGMetadataBooleanOperation_MAX         = 4,
};

// Enum PCG.EPCGMetadataCompareOperation
// NumValues: 0x0007
enum class EPCGMetadataCompareOperation : uint16
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Greater                                  = 2,
	GreaterOrEqual                           = 3,
	Less                                     = 4,
	LessOrEqual                              = 5,
	EPCGMetadataCompareOperation_MAX         = 6,
};

// Enum PCG.EPCGMetadataMakeVector3
// NumValues: 0x0003
enum class EPCGMetadataMakeVector3 : uint8
{
	ThreeValues                              = 0,
	Vector2AndValue                          = 1,
	EPCGMetadataMakeVector3_MAX              = 2,
};

// Enum PCG.EPCGMetadataMakeVector4
// NumValues: 0x0005
enum class EPCGMetadataMakeVector4 : uint8
{
	FourValues                               = 0,
	Vector2AndTwoValues                      = 1,
	TwoVector2                               = 2,
	Vector3AndValue                          = 3,
	EPCGMetadataMakeVector4_MAX              = 4,
};

// Enum PCG.EPCGMetadataMathsOperation
// NumValues: 0x001C
enum class EPCGMetadataMathsOperation : uint16
{
	UnaryOp                                  = 1024,
	Sign                                     = 1025,
	Frac                                     = 1026,
	Truncate                                 = 1027,
	Round                                    = 1028,
	Sqrt                                     = 1029,
	Abs                                      = 1030,
	Floor                                    = 1031,
	Ceil                                     = 1032,
	OneMinus                                 = 1033,
	Inc                                      = 1034,
	Dec                                      = 1035,
	Negate                                   = 1036,
	BinaryOp                                 = 2048,
	Add                                      = 2049,
	Subtract                                 = 2050,
	Multiply                                 = 2051,
	Divide                                   = 2052,
	Max                                      = 2053,
	Min                                      = 2054,
	Pow                                      = 2055,
	ClampMin                                 = 2056,
	ClampMax                                 = 2057,
	Modulo                                   = 2058,
	Set                                      = 2059,
	TernaryOp                                = 4096,
	Clamp                                    = 4097,
	Lerp                                     = 4098,
};

// Enum PCG.EPCGMetadataSettingsBaseMode
// NumValues: 0x0004
enum class EPCGMetadataSettingsBaseMode : uint8
{
	Inferred                                 = 0,
	NoBroadcast                              = 1,
	Broadcast                                = 2,
	EPCGMetadataSettingsBaseMode_MAX         = 3,
};

// Enum PCG.EPCGMetadataSettingsBaseTypes
// NumValues: 0x0003
enum class EPCGMetadataSettingsBaseTypes : uint8
{
	AutoUpcastTypes                          = 0,
	StrictTypes                              = 1,
	EPCGMetadataSettingsBaseTypes_MAX        = 2,
};

// Enum PCG.EPCGMetadataRotatorOperation
// NumValues: 0x0009
enum class EPCGMetadataRotatorOperation : uint16
{
	RotatorOp                                = 0,
	Combine                                  = 1,
	Invert                                   = 2,
	Lerp                                     = 3,
	Normalize                                = 4,
	TransformOp                              = 100,
	TransformRotation                        = 101,
	InverseTransformRotation                 = 102,
	EPCGMetadataRotatorOperation_MAX         = 103,
};

// Enum PCG.EPCGMetadataStringOperation
// NumValues: 0x0003
enum class EPCGMetadataStringOperation : uint16
{
	Append                                   = 0,
	Replace                                  = 1,
	EPCGMetadataStringOperation_MAX          = 2,
};

// Enum PCG.EPCGMetadataTransformOperation
// NumValues: 0x0004
enum class EPCGMetadataTransformOperation : uint16
{
	Compose                                  = 0,
	Invert                                   = 1,
	Lerp                                     = 2,
	EPCGMetadataTransformOperation_MAX       = 3,
};

// Enum PCG.EPCGTransformLerpMode
// NumValues: 0x0004
enum class EPCGTransformLerpMode : uint16
{
	QuatInterp                               = 0,
	EulerInterp                              = 1,
	DualQuatInterp                           = 2,
	EPCGTransformLerpMode_MAX                = 3,
};

// Enum PCG.EPCGMetadataTrigOperation
// NumValues: 0x000A
enum class EPCGMetadataTrigOperation : uint16
{
	Acos                                     = 0,
	Asin                                     = 1,
	Atan                                     = 2,
	Atan2                                    = 3,
	Cos                                      = 4,
	Sin                                      = 5,
	Tan                                      = 6,
	DegToRad                                 = 7,
	RadToDeg                                 = 8,
	EPCGMetadataTrigOperation_MAX            = 9,
};

// Enum PCG.EPCGMetadataVectorOperation
// NumValues: 0x000D
enum class EPCGMetadataVectorOperation : uint16
{
	VectorOp                                 = 0,
	Cross                                    = 1,
	Dot                                      = 2,
	Distance                                 = 3,
	Normalize                                = 4,
	Length                                   = 5,
	RotateAroundAxis                         = 6,
	TransformOp                              = 100,
	TransformDirection                       = 101,
	TransformLocation                        = 102,
	InverseTransformDirection                = 103,
	InverseTransformLocation                 = 104,
	EPCGMetadataVectorOperation_MAX          = 105,
};

// Enum PCG.EPCGActorSelection
// NumValues: 0x0006
enum class EPCGActorSelection : uint8
{
	ByTag                                    = 0,
	ByName                                   = 1,
	ByClass                                  = 2,
	ByPath                                   = 3,
	Unknown                                  = 4,
	EPCGActorSelection_MAX                   = 5,
};

// Enum PCG.EPCGComponentSelection
// NumValues: 0x0004
enum class EPCGComponentSelection : uint8
{
	ByTag                                    = 0,
	ByClass                                  = 1,
	Unknown                                  = 2,
	EPCGComponentSelection_MAX               = 3,
};

// Enum PCG.EPCGActorFilter
// NumValues: 0x0007
enum class EPCGActorFilter : uint8
{
	Self                                     = 0,
	Parent                                   = 1,
	Root                                     = 2,
	AllWorldActors                           = 3,
	Original                                 = 4,
	FromInput                                = 5,
	EPCGActorFilter_MAX                      = 6,
};

// Enum PCG.EPCGAttributeNoiseMode
// NumValues: 0x0006
enum class EPCGAttributeNoiseMode : uint8
{
	Set                                      = 0,
	Minimum                                  = 1,
	Maximum                                  = 2,
	Add                                      = 3,
	Multiply                                 = 4,
	EPCGAttributeNoiseMode_MAX               = 5,
};

// Enum PCG.EPCGAttributeReduceOperation
// NumValues: 0x0005
enum class EPCGAttributeReduceOperation : uint32
{
	Average                                  = 0,
	Max                                      = 1,
	Min                                      = 2,
	Sum                                      = 3,
	Join                                     = 4,
};

// Enum PCG.EPCGAttributeSelectOperation
// NumValues: 0x0003
enum class EPCGAttributeSelectOperation : uint32
{
	Min                                      = 0,
	Max                                      = 1,
	Median                                   = 2,
};

// Enum PCG.EPCGAttributeSelectAxis
// NumValues: 0x0006
enum class EPCGAttributeSelectAxis : uint32
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	W                                        = 3,
	CustomAxis                               = 4,
	EPCGAttributeSelectAxis_MAX              = 5,
};

// Enum PCG.EPCGBoundsModifierMode
// NumValues: 0x0006
enum class EPCGBoundsModifierMode : uint8
{
	Set                                      = 0,
	Intersect                                = 1,
	Include                                  = 2,
	Translate                                = 3,
	Scale                                    = 4,
	EPCGBoundsModifierMode_MAX               = 5,
};

// Enum PCG.EPCGCopyPointsInheritanceMode
// NumValues: 0x0004
enum class EPCGCopyPointsInheritanceMode : uint8
{
	Relative                                 = 0,
	Source                                   = 1,
	Target                                   = 2,
	EPCGCopyPointsInheritanceMode_MAX        = 3,
};

// Enum PCG.EPCGCopyPointsTagInheritanceMode
// NumValues: 0x0004
enum class EPCGCopyPointsTagInheritanceMode : uint8
{
	Both                                     = 0,
	Source                                   = 1,
	Target                                   = 2,
	EPCGCopyPointsTagInheritanceMode_MAX     = 3,
};

// Enum PCG.EPCGCopyPointsMetadataInheritanceMode
// NumValues: 0x0006
enum class EPCGCopyPointsMetadataInheritanceMode : uint8
{
	SourceFirst                              = 0,
	TargetFirst                              = 1,
	SourceOnly                               = 2,
	TargetOnly                               = 3,
	None                                     = 4,
	EPCGCopyPointsMetadataInheritanceMode_MAX = 5,
};

// Enum PCG.EPCGSphereGeneration
// NumValues: 0x0006
enum class EPCGSphereGeneration : uint8
{
	Geodesic                                 = 0,
	Angle                                    = 1,
	Segments                                 = 2,
	Random                                   = 3,
	Poisson                                  = 4,
	EPCGSphereGeneration_MAX                 = 5,
};

// Enum PCG.EPCGGeodesicSphereRepresentation
// NumValues: 0x0002
enum class EPCGGeodesicSphereRepresentation : uint8
{
	Icosahedron                              = 0,
	EPCGGeodesicSphereRepresentation_MAX     = 1,
};

// Enum PCG.EPCGSpherePointOrientation
// NumValues: 0x0004
enum class EPCGSpherePointOrientation : uint8
{
	Radial                                   = 0,
	Centric                                  = 1,
	None                                     = 2,
	EPCGSpherePointOrientation_MAX           = 3,
};

// Enum PCG.EPCGCreateSplineMode
// NumValues: 0x0003
enum class EPCGCreateSplineMode : uint8
{
	CreateDataOnly                           = 0,
	CreateComponent                          = 1,
	EPCGCreateSplineMode_MAX                 = 2,
};

// Enum PCG.EPCGGetDataFromActorMode
// NumValues: 0x0008
enum class EPCGGetDataFromActorMode : uint8
{
	ParseActorComponents                     = 0,
	GetSinglePoint                           = 1,
	GetDataFromProperty                      = 2,
	GetDataFromPCGComponent                  = 3,
	GetDataFromPCGComponentOrParseComponents = 4,
	GetActorReference                        = 5,
	GetComponentsReference                   = 6,
	EPCGGetDataFromActorMode_MAX             = 7,
};

// Enum PCG.EPCGFilterByTagOperation
// NumValues: 0x0003
enum class EPCGFilterByTagOperation : uint32
{
	KeepTagged                               = 0,
	RemoveTagged                             = 1,
	EPCGFilterByTagOperation_MAX             = 2,
};

// Enum PCG.EPCGProxyInterfaceMode
// NumValues: 0x0004
enum class EPCGProxyInterfaceMode : uint8
{
	ByNativeElement                          = 0,
	ByBlueprintElement                       = 1,
	BySettings                               = 2,
	EPCGProxyInterfaceMode_MAX               = 3,
};

// Enum PCG.EPCGMatchMaxDistanceMode
// NumValues: 0x0004
enum class EPCGMatchMaxDistanceMode : uint32
{
	NoMaxDistance                            = 0,
	UseConstantMaxDistance                   = 1,
	AttributeMaxDistance                     = 2,
	EPCGMatchMaxDistanceMode_MAX             = 3,
};

// Enum PCG.EPCGPointExtentsModifierMode
// NumValues: 0x0006
enum class EPCGPointExtentsModifierMode : uint8
{
	Set                                      = 0,
	Minimum                                  = 1,
	Maximum                                  = 2,
	Add                                      = 3,
	Multiply                                 = 4,
	EPCGPointExtentsModifierMode_MAX         = 5,
};

// Enum PCG.EPCGSelfPruningType
// NumValues: 0x0006
enum class EPCGSelfPruningType : uint8
{
	LargeToSmall                             = 0,
	SmallToLarge                             = 1,
	AllEqual                                 = 2,
	None                                     = 3,
	RemoveDuplicates                         = 4,
	EPCGSelfPruningType_MAX                  = 5,
};

// Enum PCG.PCGSpatialNoiseMode
// NumValues: 0x0006
enum class EPCGSpatialNoiseMode : uint32
{
	Perlin2D                                 = 0,
	Caustic2D                                = 1,
	Voronoi2D                                = 2,
	FractionalBrownian2D                     = 3,
	EdgeMask2D                               = 4,
	PCGSpatialNoiseMode_MAX                  = 5,
};

// Enum PCG.PCGSpatialNoiseMask2DMode
// NumValues: 0x0004
enum class EPCGSpatialNoiseMask2DMode : uint32
{
	Perlin                                   = 0,
	Caustic                                  = 1,
	FractionalBrownian                       = 2,
	PCGSpatialNoiseMask2DMode_MAX            = 3,
};

// Enum PCG.EPCGSpawnActorOption
// NumValues: 0x0004
enum class EPCGSpawnActorOption : uint8
{
	CollapseActors                           = 0,
	MergePCGOnly                             = 1,
	NoMerging                                = 2,
	EPCGSpawnActorOption_MAX                 = 3,
};

// Enum PCG.EPCGSpawnActorGenerationTrigger
// NumValues: 0x0005
enum class EPCGSpawnActorGenerationTrigger : uint8
{
	Default                                  = 0,
	ForceGenerate                            = 1,
	DoNotGenerateInEditor                    = 2,
	DoNotGenerate                            = 3,
	EPCGSpawnActorGenerationTrigger_MAX      = 4,
};

// Enum PCG.EPCGSplineMeshForwardAxis
// NumValues: 0x0004
enum class EPCGSplineMeshForwardAxis : uint32
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	EPCGSplineMeshForwardAxis_MAX            = 3,
};

// Enum PCG.EPCGSplineSamplingMode
// NumValues: 0x0004
enum class EPCGSplineSamplingMode : uint8
{
	Subdivision                              = 0,
	Distance                                 = 1,
	NumberOfSamples                          = 2,
	EPCGSplineSamplingMode_MAX               = 3,
};

// Enum PCG.EPCGSplineSamplingDimension
// NumValues: 0x0006
enum class EPCGSplineSamplingDimension : uint8
{
	OnSpline                                 = 0,
	OnHorizontal                             = 1,
	OnVertical                               = 2,
	OnVolume                                 = 3,
	OnInterior                               = 4,
	EPCGSplineSamplingDimension_MAX          = 5,
};

// Enum PCG.EPCGSplineSamplingFill
// NumValues: 0x0003
enum class EPCGSplineSamplingFill : uint8
{
	Fill                                     = 0,
	EdgesOnly                                = 1,
	EPCGSplineSamplingFill_MAX               = 2,
};

// Enum PCG.EPCGSplineSamplingInteriorOrientation
// NumValues: 0x0003
enum class EPCGSplineSamplingInteriorOrientation : uint8
{
	Uniform                                  = 0,
	FollowCurvature                          = 1,
	EPCGSplineSamplingInteriorOrientation_MAX = 2,
};

// Enum PCG.EPCGSplineSamplingSeedingMode
// NumValues: 0x0003
enum class EPCGSplineSamplingSeedingMode : uint8
{
	SeedFromPosition                         = 0,
	SeedFromIndex                            = 1,
	EPCGSplineSamplingSeedingMode_MAX        = 2,
};

// Enum PCG.EPCGElementSource
// NumValues: 0x0006
enum class EPCGElementSource : uint32
{
	Trivial                                  = 0,
	TrivialPostGraph                         = 1,
	Gather                                   = 2,
	FromNode                                 = 3,
	FromCookedSettings                       = 4,
	EPCGElementSource_MAX                    = 5,
};

// Enum PCG.EPCGLandscapeCacheSerializationMode
// NumValues: 0x0004
enum class EPCGLandscapeCacheSerializationMode : uint8
{
	SerializeOnlyAtCook                      = 0,
	NeverSerialize                           = 1,
	AlwaysSerialize                          = 2,
	EPCGLandscapeCacheSerializationMode_MAX  = 3,
};

// Enum PCG.EPCGLandscapeCacheSerializationContents
// NumValues: 0x0004
enum class EPCGLandscapeCacheSerializationContents : uint8
{
	SerializeOnlyPositionsAndNormals         = 0,
	SerializeOnlyLayerData                   = 1,
	SerializeAll                             = 2,
	EPCGLandscapeCacheSerializationContents_MAX = 3,
};

// Enum PCG.EPCGMeshSelectorMaterialOverrideMode
// NumValues: 0x0004
enum class EPCGMeshSelectorMaterialOverrideMode : uint8
{
	NoOverride                               = 0,
	StaticOverride                           = 1,
	ByAttributeOverride                      = 2,
	EPCGMeshSelectorMaterialOverrideMode_MAX = 3,
};

// Enum PCG.EPCGComponentInput
// NumValues: 0x0004
enum class EPCGComponentInput : uint8
{
	Actor                                    = 0,
	Landscape                                = 1,
	Other                                    = 2,
	EPCGComponentInput_MAX                   = 3,
};

// Enum PCG.EPCGComponentGenerationTrigger
// NumValues: 0x0004
enum class EPCGComponentGenerationTrigger : uint8
{
	GenerateOnLoad                           = 0,
	GenerateOnDemand                         = 1,
	GenerateAtRuntime                        = 2,
	EPCGComponentGenerationTrigger_MAX       = 3,
};

// Enum PCG.EPCGComponentDirtyFlag
// NumValues: 0x0007
enum class EPCGComponentDirtyFlag : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	Landscape                                = 2,
	Input                                    = 4,
	Data                                     = 8,
	All                                      = 15,
	EPCGComponentDirtyFlag_MAX               = 16,
};

// Enum PCG.EPCGExecutionPhase
// NumValues: 0x0006
enum class EPCGExecutionPhase : uint8
{
	NotExecuted                              = 0,
	PrepareData                              = 1,
	Execute                                  = 2,
	PostExecute                              = 3,
	Done                                     = 4,
	EPCGExecutionPhase_MAX                   = 5,
};

// Enum PCG.EPCGDebugVisScaleMethod
// NumValues: 0x0004
enum class EPCGDebugVisScaleMethod : uint8
{
	Relative                                 = 0,
	Absolute                                 = 1,
	Extents                                  = 2,
	EPCGDebugVisScaleMethod_MAX              = 3,
};

// Enum PCG.EPCGPinUsage
// NumValues: 0x0005
enum class EPCGPinUsage : uint8
{
	Normal                                   = 0,
	Loop                                     = 1,
	Feedback                                 = 2,
	DependencyOnly                           = 3,
	EPCGPinUsage_MAX                         = 4,
};

// Enum PCG.EPCGPinStatus
// NumValues: 0x0005
enum class EPCGPinStatus : uint8
{
	Normal                                   = 0,
	Required                                 = 1,
	Advanced                                 = 2,
	OverrideOrUserParam                      = 3,
	EPCGPinStatus_MAX                        = 4,
};

// Enum PCG.EPCGTypeConversion
// NumValues: 0x0007
enum class EPCGTypeConversion : uint8
{
	NoConversionRequired                     = 0,
	CollapseToPoint                          = 1,
	Filter                                   = 2,
	MakeConcrete                             = 3,
	SplineToSurface                          = 4,
	Failed                                   = 5,
	EPCGTypeConversion_MAX                   = 6,
};

// Enum PCG.EPCGPointProperties
// NumValues: 0x000F
enum class EPCGPointProperties : uint8
{
	Density                                  = 0,
	BoundsMin                                = 1,
	BoundsMax                                = 2,
	Extents                                  = 3,
	Color                                    = 4,
	Position                                 = 5,
	Rotation                                 = 6,
	Scale                                    = 7,
	Transform                                = 8,
	Steepness                                = 9,
	LocalCenter                              = 10,
	Seed                                     = 11,
	LocalSize                                = 12,
	ScaledLocalSize                          = 13,
	EPCGPointProperties_MAX                  = 14,
};

// Enum PCG.EPCGSettingsExecutionMode
// NumValues: 0x0005
enum class EPCGSettingsExecutionMode : uint8
{
	Enabled                                  = 0,
	Debug                                    = 1,
	Isolated                                 = 2,
	Disabled                                 = 3,
	EPCGSettingsExecutionMode_MAX            = 4,
};

// Enum PCG.EPCGSettingsType
// NumValues: 0x0014
enum class EPCGSettingsType : uint8
{
	InputOutput                              = 0,
	Spatial                                  = 1,
	Density                                  = 2,
	Blueprint                                = 3,
	Metadata                                 = 4,
	Filter                                   = 5,
	Sampler                                  = 6,
	Spawner                                  = 7,
	Subgraph                                 = 8,
	Debug                                    = 9,
	Generic                                  = 10,
	Param                                    = 11,
	HierarchicalGeneration                   = 12,
	ControlFlow                              = 13,
	PointOps                                 = 14,
	GraphParameters                          = 15,
	Reroute                                  = 16,
	GPU                                      = 17,
	DynamicMesh                              = 18,
	EPCGSettingsType_MAX                     = 19,
};

// Enum PCG.EDeterminismLevel
// NumValues: 0x0008
enum class EDeterminismLevel : uint8
{
	None                                     = 0,
	NoDeterminism                            = 0,
	Basic                                    = 1,
	OrderOrthogonal                          = 2,
	OrderConsistent                          = 3,
	OrderIndependent                         = 4,
	Deterministic                            = 4,
	EDeterminismLevel_MAX                    = 5,
};

// ScriptStruct PCG.PCGAssetExporterParameters
// 0x0030 (0x0030 - 0x0000)
struct FPCGAssetExporterParameters final
{
public:
	bool                                          bOpenSaveDialog;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AssetName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetPath;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSaveOnExportEnded;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGAssetExporterParameters) == 0x000008, "Wrong alignment on FPCGAssetExporterParameters");
static_assert(sizeof(FPCGAssetExporterParameters) == 0x000030, "Wrong size on FPCGAssetExporterParameters");
static_assert(offsetof(FPCGAssetExporterParameters, bOpenSaveDialog) == 0x000000, "Member 'FPCGAssetExporterParameters::bOpenSaveDialog' has a wrong offset!");
static_assert(offsetof(FPCGAssetExporterParameters, AssetName) == 0x000008, "Member 'FPCGAssetExporterParameters::AssetName' has a wrong offset!");
static_assert(offsetof(FPCGAssetExporterParameters, AssetPath) == 0x000018, "Member 'FPCGAssetExporterParameters::AssetPath' has a wrong offset!");
static_assert(offsetof(FPCGAssetExporterParameters, bSaveOnExportEnded) == 0x000028, "Member 'FPCGAssetExporterParameters::bSaveOnExportEnded' has a wrong offset!");

// ScriptStruct PCG.PCGAttributeExtractorTestStructDepth2
// 0x0004 (0x0004 - 0x0000)
struct FPCGAttributeExtractorTestStructDepth2 final
{
public:
	int32                                         IntValue;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGAttributeExtractorTestStructDepth2) == 0x000004, "Wrong alignment on FPCGAttributeExtractorTestStructDepth2");
static_assert(sizeof(FPCGAttributeExtractorTestStructDepth2) == 0x000004, "Wrong size on FPCGAttributeExtractorTestStructDepth2");
static_assert(offsetof(FPCGAttributeExtractorTestStructDepth2, IntValue) == 0x000000, "Member 'FPCGAttributeExtractorTestStructDepth2::IntValue' has a wrong offset!");

// ScriptStruct PCG.PCGAttributeExtractorTestStructDepth1
// 0x0008 (0x0008 - 0x0000)
struct FPCGAttributeExtractorTestStructDepth1 final
{
public:
	struct FPCGAttributeExtractorTestStructDepth2 Depth2Struct;                                      // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGAttributeExtractorTestStructDepth1) == 0x000004, "Wrong alignment on FPCGAttributeExtractorTestStructDepth1");
static_assert(sizeof(FPCGAttributeExtractorTestStructDepth1) == 0x000008, "Wrong size on FPCGAttributeExtractorTestStructDepth1");
static_assert(offsetof(FPCGAttributeExtractorTestStructDepth1, Depth2Struct) == 0x000000, "Member 'FPCGAttributeExtractorTestStructDepth1::Depth2Struct' has a wrong offset!");
static_assert(offsetof(FPCGAttributeExtractorTestStructDepth1, FloatValue) == 0x000004, "Member 'FPCGAttributeExtractorTestStructDepth1::FloatValue' has a wrong offset!");

// ScriptStruct PCG.PCGAttributeExtractorTestStruct
// 0x0010 (0x0010 - 0x0000)
struct FPCGAttributeExtractorTestStruct final
{
public:
	struct FPCGAttributeExtractorTestStructDepth1 DepthStruct;                                       // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	class UPCGAttributeExtractorTestObject*       Object;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGAttributeExtractorTestStruct) == 0x000008, "Wrong alignment on FPCGAttributeExtractorTestStruct");
static_assert(sizeof(FPCGAttributeExtractorTestStruct) == 0x000010, "Wrong size on FPCGAttributeExtractorTestStruct");
static_assert(offsetof(FPCGAttributeExtractorTestStruct, DepthStruct) == 0x000000, "Member 'FPCGAttributeExtractorTestStruct::DepthStruct' has a wrong offset!");
static_assert(offsetof(FPCGAttributeExtractorTestStruct, Object) == 0x000008, "Member 'FPCGAttributeExtractorTestStruct::Object' has a wrong offset!");

// ScriptStruct PCG.PCGAttributePropertySelector
// 0x0028 (0x0028 - 0x0000)
struct FPCGAttributePropertySelector
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPCGAttributePropertySelection                Selection;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttributeName;                                     // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPCGPointProperties                           PointProperty;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPCGExtraProperties                           ExtraProperty;                                     // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ExtraNames;                                        // 0x0018(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPCGAttributePropertySelector) == 0x000008, "Wrong alignment on FPCGAttributePropertySelector");
static_assert(sizeof(FPCGAttributePropertySelector) == 0x000028, "Wrong size on FPCGAttributePropertySelector");
static_assert(offsetof(FPCGAttributePropertySelector, Selection) == 0x000008, "Member 'FPCGAttributePropertySelector::Selection' has a wrong offset!");
static_assert(offsetof(FPCGAttributePropertySelector, AttributeName) == 0x00000C, "Member 'FPCGAttributePropertySelector::AttributeName' has a wrong offset!");
static_assert(offsetof(FPCGAttributePropertySelector, PointProperty) == 0x000014, "Member 'FPCGAttributePropertySelector::PointProperty' has a wrong offset!");
static_assert(offsetof(FPCGAttributePropertySelector, ExtraProperty) == 0x000015, "Member 'FPCGAttributePropertySelector::ExtraProperty' has a wrong offset!");
static_assert(offsetof(FPCGAttributePropertySelector, ExtraNames) == 0x000018, "Member 'FPCGAttributePropertySelector::ExtraNames' has a wrong offset!");

// ScriptStruct PCG.PCGAttributePropertyInputSelector
// 0x0000 (0x0028 - 0x0028)
struct FPCGAttributePropertyInputSelector final : public FPCGAttributePropertySelector
{
};
static_assert(alignof(FPCGAttributePropertyInputSelector) == 0x000008, "Wrong alignment on FPCGAttributePropertyInputSelector");
static_assert(sizeof(FPCGAttributePropertyInputSelector) == 0x000028, "Wrong size on FPCGAttributePropertyInputSelector");

// ScriptStruct PCG.PCGMetadataTypesConstantStruct
// 0x0170 (0x0170 - 0x0000)
struct FPCGMetadataTypesConstantStruct final
{
public:
	EPCGMetadataTypes                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPCGMetadataTypesConstantStructStringMode     StringMode;                                        // 0x0004(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int32Value;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DoubleValue;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         IntValue;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector2Value;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorValue;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Vector4Value;                                      // 0x0050(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  QuatValue;                                         // 0x0070(0x0020)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TransformValue;                                    // 0x0090(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringValue;                                       // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotatorValue;                                      // 0x0108(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   NameValue;                                         // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SoftClassPathValue;                                // 0x0128(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoftObjectPathValue;                               // 0x0148(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowsTypeChange;                                 // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGMetadataTypesConstantStruct) == 0x000010, "Wrong alignment on FPCGMetadataTypesConstantStruct");
static_assert(sizeof(FPCGMetadataTypesConstantStruct) == 0x000170, "Wrong size on FPCGMetadataTypesConstantStruct");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, Type) == 0x000000, "Member 'FPCGMetadataTypesConstantStruct::Type' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, StringMode) == 0x000004, "Member 'FPCGMetadataTypesConstantStruct::StringMode' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, FloatValue) == 0x000008, "Member 'FPCGMetadataTypesConstantStruct::FloatValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, Int32Value) == 0x00000C, "Member 'FPCGMetadataTypesConstantStruct::Int32Value' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, DoubleValue) == 0x000010, "Member 'FPCGMetadataTypesConstantStruct::DoubleValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, IntValue) == 0x000018, "Member 'FPCGMetadataTypesConstantStruct::IntValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, Vector2Value) == 0x000020, "Member 'FPCGMetadataTypesConstantStruct::Vector2Value' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, VectorValue) == 0x000030, "Member 'FPCGMetadataTypesConstantStruct::VectorValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, Vector4Value) == 0x000050, "Member 'FPCGMetadataTypesConstantStruct::Vector4Value' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, QuatValue) == 0x000070, "Member 'FPCGMetadataTypesConstantStruct::QuatValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, TransformValue) == 0x000090, "Member 'FPCGMetadataTypesConstantStruct::TransformValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, StringValue) == 0x0000F0, "Member 'FPCGMetadataTypesConstantStruct::StringValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, BoolValue) == 0x000100, "Member 'FPCGMetadataTypesConstantStruct::BoolValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, RotatorValue) == 0x000108, "Member 'FPCGMetadataTypesConstantStruct::RotatorValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, NameValue) == 0x000120, "Member 'FPCGMetadataTypesConstantStruct::NameValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, SoftClassPathValue) == 0x000128, "Member 'FPCGMetadataTypesConstantStruct::SoftClassPathValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, SoftObjectPathValue) == 0x000148, "Member 'FPCGMetadataTypesConstantStruct::SoftObjectPathValue' has a wrong offset!");
static_assert(offsetof(FPCGMetadataTypesConstantStruct, bAllowsTypeChange) == 0x000168, "Member 'FPCGMetadataTypesConstantStruct::bAllowsTypeChange' has a wrong offset!");

// ScriptStruct PCG.PCGAttributeFilterThresholdSettings
// 0x01B0 (0x01B0 - 0x0000)
struct FPCGAttributeFilterThresholdSettings final
{
public:
	bool                                          bInclusive;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantThreshold;                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGAttributePropertyInputSelector     ThresholdAttribute;                                // 0x0008(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSpatialQuery;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGMetadataTypesConstantStruct        AttributeTypes;                                    // 0x0040(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGAttributeFilterThresholdSettings) == 0x000010, "Wrong alignment on FPCGAttributeFilterThresholdSettings");
static_assert(sizeof(FPCGAttributeFilterThresholdSettings) == 0x0001B0, "Wrong size on FPCGAttributeFilterThresholdSettings");
static_assert(offsetof(FPCGAttributeFilterThresholdSettings, bInclusive) == 0x000000, "Member 'FPCGAttributeFilterThresholdSettings::bInclusive' has a wrong offset!");
static_assert(offsetof(FPCGAttributeFilterThresholdSettings, bUseConstantThreshold) == 0x000001, "Member 'FPCGAttributeFilterThresholdSettings::bUseConstantThreshold' has a wrong offset!");
static_assert(offsetof(FPCGAttributeFilterThresholdSettings, ThresholdAttribute) == 0x000008, "Member 'FPCGAttributeFilterThresholdSettings::ThresholdAttribute' has a wrong offset!");
static_assert(offsetof(FPCGAttributeFilterThresholdSettings, bUseSpatialQuery) == 0x000030, "Member 'FPCGAttributeFilterThresholdSettings::bUseSpatialQuery' has a wrong offset!");
static_assert(offsetof(FPCGAttributeFilterThresholdSettings, AttributeTypes) == 0x000040, "Member 'FPCGAttributeFilterThresholdSettings::AttributeTypes' has a wrong offset!");

// ScriptStruct PCG.PCGAttributePropertyOutputSelector
// 0x0000 (0x0028 - 0x0028)
struct FPCGAttributePropertyOutputSelector final : public FPCGAttributePropertySelector
{
};
static_assert(alignof(FPCGAttributePropertyOutputSelector) == 0x000008, "Wrong alignment on FPCGAttributePropertyOutputSelector");
static_assert(sizeof(FPCGAttributePropertyOutputSelector) == 0x000028, "Wrong size on FPCGAttributePropertyOutputSelector");

// ScriptStruct PCG.PCGAttributePropertyOutputNoSourceSelector
// 0x0000 (0x0028 - 0x0028)
struct FPCGAttributePropertyOutputNoSourceSelector final : public FPCGAttributePropertySelector
{
};
static_assert(alignof(FPCGAttributePropertyOutputNoSourceSelector) == 0x000008, "Wrong alignment on FPCGAttributePropertyOutputNoSourceSelector");
static_assert(sizeof(FPCGAttributePropertyOutputNoSourceSelector) == 0x000028, "Wrong size on FPCGAttributePropertyOutputNoSourceSelector");

// ScriptStruct PCG.PCGRuntimeGenerationRadii
// 0x0060 (0x0060 - 0x0000)
struct FPCGRuntimeGenerationRadii final
{
public:
	double                                        GenerationRadius;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius400;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius800;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius1600;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius3200;                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius6400;                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius12800;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius25600;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius51200;                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius102400;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GenerationRadius204800;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CleanupRadiusMultiplier;                           // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGRuntimeGenerationRadii) == 0x000008, "Wrong alignment on FPCGRuntimeGenerationRadii");
static_assert(sizeof(FPCGRuntimeGenerationRadii) == 0x000060, "Wrong size on FPCGRuntimeGenerationRadii");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius) == 0x000000, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius400) == 0x000008, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius400' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius800) == 0x000010, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius800' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius1600) == 0x000018, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius1600' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius3200) == 0x000020, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius3200' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius6400) == 0x000028, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius6400' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius12800) == 0x000030, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius12800' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius25600) == 0x000038, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius25600' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius51200) == 0x000040, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius51200' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius102400) == 0x000048, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius102400' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, GenerationRadius204800) == 0x000050, "Member 'FPCGRuntimeGenerationRadii::GenerationRadius204800' has a wrong offset!");
static_assert(offsetof(FPCGRuntimeGenerationRadii, CleanupRadiusMultiplier) == 0x000058, "Member 'FPCGRuntimeGenerationRadii::CleanupRadiusMultiplier' has a wrong offset!");

// ScriptStruct PCG.PCGPartitionActorRecord
// 0x0020 (0x0020 - 0x0000)
struct FPCGPartitionActorRecord final
{
public:
	struct FGuid                                  GridGuid;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        GridSize;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GridCoords;                                        // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPartitionActorRecord) == 0x000004, "Wrong alignment on FPCGPartitionActorRecord");
static_assert(sizeof(FPCGPartitionActorRecord) == 0x000020, "Wrong size on FPCGPartitionActorRecord");
static_assert(offsetof(FPCGPartitionActorRecord, GridGuid) == 0x000000, "Member 'FPCGPartitionActorRecord::GridGuid' has a wrong offset!");
static_assert(offsetof(FPCGPartitionActorRecord, GridSize) == 0x000010, "Member 'FPCGPartitionActorRecord::GridSize' has a wrong offset!");
static_assert(offsetof(FPCGPartitionActorRecord, GridCoords) == 0x000014, "Member 'FPCGPartitionActorRecord::GridCoords' has a wrong offset!");

// ScriptStruct PCG.EnumSelector
// 0x0010 (0x0010 - 0x0000)
struct FEnumSelector final
{
public:
	class UEnum*                                  Class;                                             // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Value;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnumSelector) == 0x000008, "Wrong alignment on FEnumSelector");
static_assert(sizeof(FEnumSelector) == 0x000010, "Wrong size on FEnumSelector");
static_assert(offsetof(FEnumSelector, Class) == 0x000000, "Member 'FEnumSelector::Class' has a wrong offset!");
static_assert(offsetof(FEnumSelector, Value) == 0x000008, "Member 'FEnumSelector::Value' has a wrong offset!");

// ScriptStruct PCG.PCGCrc
// 0x0008 (0x0008 - 0x0000)
struct FPCGCrc final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bValid;                                            // 0x0004(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGCrc) == 0x000004, "Wrong alignment on FPCGCrc");
static_assert(sizeof(FPCGCrc) == 0x000008, "Wrong size on FPCGCrc");
static_assert(offsetof(FPCGCrc, Value) == 0x000000, "Member 'FPCGCrc::Value' has a wrong offset!");
static_assert(offsetof(FPCGCrc, bValid) == 0x000004, "Member 'FPCGCrc::bValid' has a wrong offset!");

// ScriptStruct PCG.PCGSpawnerPrimitives
// 0x0060 (0x0060 - 0x0000)
struct FPCGSpawnerPrimitives final
{
public:
	TArray<class UPrimitiveComponent*>            Primitives;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FBox>                           PrimitiveMeshBounds;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 SelectionCDF;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        NumCustomFloats;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUintVector4>                   AttributeIdOffsetStrides;                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SelectorAttributeId;                               // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PrimitiveStringKeys;                               // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSpawnerPrimitives) == 0x000008, "Wrong alignment on FPCGSpawnerPrimitives");
static_assert(sizeof(FPCGSpawnerPrimitives) == 0x000060, "Wrong size on FPCGSpawnerPrimitives");
static_assert(offsetof(FPCGSpawnerPrimitives, Primitives) == 0x000000, "Member 'FPCGSpawnerPrimitives::Primitives' has a wrong offset!");
static_assert(offsetof(FPCGSpawnerPrimitives, PrimitiveMeshBounds) == 0x000010, "Member 'FPCGSpawnerPrimitives::PrimitiveMeshBounds' has a wrong offset!");
static_assert(offsetof(FPCGSpawnerPrimitives, SelectionCDF) == 0x000020, "Member 'FPCGSpawnerPrimitives::SelectionCDF' has a wrong offset!");
static_assert(offsetof(FPCGSpawnerPrimitives, NumCustomFloats) == 0x000030, "Member 'FPCGSpawnerPrimitives::NumCustomFloats' has a wrong offset!");
static_assert(offsetof(FPCGSpawnerPrimitives, AttributeIdOffsetStrides) == 0x000038, "Member 'FPCGSpawnerPrimitives::AttributeIdOffsetStrides' has a wrong offset!");
static_assert(offsetof(FPCGSpawnerPrimitives, SelectorAttributeId) == 0x000048, "Member 'FPCGSpawnerPrimitives::SelectorAttributeId' has a wrong offset!");
static_assert(offsetof(FPCGSpawnerPrimitives, PrimitiveStringKeys) == 0x000050, "Member 'FPCGSpawnerPrimitives::PrimitiveStringKeys' has a wrong offset!");

// ScriptStruct PCG.PCGKernelAttributeKey
// 0x000C (0x000C - 0x0000)
struct FPCGKernelAttributeKey final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGKernelAttributeType                       Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGKernelAttributeKey) == 0x000004, "Wrong alignment on FPCGKernelAttributeKey");
static_assert(sizeof(FPCGKernelAttributeKey) == 0x00000C, "Wrong size on FPCGKernelAttributeKey");
static_assert(offsetof(FPCGKernelAttributeKey, Name) == 0x000000, "Member 'FPCGKernelAttributeKey::Name' has a wrong offset!");
static_assert(offsetof(FPCGKernelAttributeKey, Type) == 0x000008, "Member 'FPCGKernelAttributeKey::Type' has a wrong offset!");

// ScriptStruct PCG.PCGKernelAttributeIDAndType
// 0x0008 (0x0008 - 0x0000)
struct FPCGKernelAttributeIDAndType final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGKernelAttributeType                       Type;                                              // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGKernelAttributeIDAndType) == 0x000004, "Wrong alignment on FPCGKernelAttributeIDAndType");
static_assert(sizeof(FPCGKernelAttributeIDAndType) == 0x000008, "Wrong size on FPCGKernelAttributeIDAndType");
static_assert(offsetof(FPCGKernelAttributeIDAndType, ID) == 0x000000, "Member 'FPCGKernelAttributeIDAndType::ID' has a wrong offset!");
static_assert(offsetof(FPCGKernelAttributeIDAndType, Type) == 0x000004, "Member 'FPCGKernelAttributeIDAndType::Type' has a wrong offset!");

// ScriptStruct PCG.PCGTaggedData
// 0x0068 (0x0068 - 0x0000)
struct FPCGTaggedData final
{
public:
	class UPCGData*                               Data;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FString>                           Tags;                                              // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   Pin;                                               // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPinlessData;                                      // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsedMultipleTimes;                              // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGTaggedData) == 0x000008, "Wrong alignment on FPCGTaggedData");
static_assert(sizeof(FPCGTaggedData) == 0x000068, "Wrong size on FPCGTaggedData");
static_assert(offsetof(FPCGTaggedData, Data) == 0x000000, "Member 'FPCGTaggedData::Data' has a wrong offset!");
static_assert(offsetof(FPCGTaggedData, Tags) == 0x000008, "Member 'FPCGTaggedData::Tags' has a wrong offset!");
static_assert(offsetof(FPCGTaggedData, Pin) == 0x000058, "Member 'FPCGTaggedData::Pin' has a wrong offset!");
static_assert(offsetof(FPCGTaggedData, bPinlessData) == 0x000060, "Member 'FPCGTaggedData::bPinlessData' has a wrong offset!");
static_assert(offsetof(FPCGTaggedData, bIsUsedMultipleTimes) == 0x000061, "Member 'FPCGTaggedData::bIsUsedMultipleTimes' has a wrong offset!");

// ScriptStruct PCG.PCGDataCollection
// 0x0030 (0x0030 - 0x0000)
struct FPCGDataCollection final
{
public:
	TArray<struct FPCGTaggedData>                 TaggedData;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCancelExecutionOnEmpty;                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1F];                                      // 0x0011(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGDataCollection) == 0x000008, "Wrong alignment on FPCGDataCollection");
static_assert(sizeof(FPCGDataCollection) == 0x000030, "Wrong size on FPCGDataCollection");
static_assert(offsetof(FPCGDataCollection, TaggedData) == 0x000000, "Member 'FPCGDataCollection::TaggedData' has a wrong offset!");
static_assert(offsetof(FPCGDataCollection, bCancelExecutionOnEmpty) == 0x000010, "Member 'FPCGDataCollection::bCancelExecutionOnEmpty' has a wrong offset!");

// ScriptStruct PCG.PCGDataForGPU
// 0x00D0 (0x00D0 - 0x0000)
struct FPCGDataForGPU final
{
public:
	TSet<TSoftObjectPtr<class UPCGPin>>           InputPins;                                         // 0x0000(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UPCGPin>, class FName> InputPinLabelAliases;                           // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	struct FPCGDataCollection                     InputDataCollection;                               // 0x00A0(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGDataForGPU) == 0x000008, "Wrong alignment on FPCGDataForGPU");
static_assert(sizeof(FPCGDataForGPU) == 0x0000D0, "Wrong size on FPCGDataForGPU");
static_assert(offsetof(FPCGDataForGPU, InputPins) == 0x000000, "Member 'FPCGDataForGPU::InputPins' has a wrong offset!");
static_assert(offsetof(FPCGDataForGPU, InputPinLabelAliases) == 0x000050, "Member 'FPCGDataForGPU::InputPinLabelAliases' has a wrong offset!");
static_assert(offsetof(FPCGDataForGPU, InputDataCollection) == 0x0000A0, "Member 'FPCGDataForGPU::InputDataCollection' has a wrong offset!");

// ScriptStruct PCG.PCGDataTableRowToParamDataTestStruct
// 0x00A0 (0x00A0 - 0x0000)
struct FPCGDataTableRowToParamDataTestStruct final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         I32;                                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         I64;                                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         F32;                                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        F64;                                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              v2;                                                // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V3;                                                // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               V4;                                                // 0x0060(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoftPath;                                          // 0x0080(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGDataTableRowToParamDataTestStruct) == 0x000010, "Wrong alignment on FPCGDataTableRowToParamDataTestStruct");
static_assert(sizeof(FPCGDataTableRowToParamDataTestStruct) == 0x0000A0, "Wrong size on FPCGDataTableRowToParamDataTestStruct");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, Name) == 0x000000, "Member 'FPCGDataTableRowToParamDataTestStruct::Name' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, String) == 0x000008, "Member 'FPCGDataTableRowToParamDataTestStruct::String' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, I32) == 0x000018, "Member 'FPCGDataTableRowToParamDataTestStruct::I32' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, I64) == 0x000020, "Member 'FPCGDataTableRowToParamDataTestStruct::I64' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, F32) == 0x000028, "Member 'FPCGDataTableRowToParamDataTestStruct::F32' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, F64) == 0x000030, "Member 'FPCGDataTableRowToParamDataTestStruct::F64' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, v2) == 0x000038, "Member 'FPCGDataTableRowToParamDataTestStruct::v2' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, V3) == 0x000048, "Member 'FPCGDataTableRowToParamDataTestStruct::V3' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, V4) == 0x000060, "Member 'FPCGDataTableRowToParamDataTestStruct::V4' has a wrong offset!");
static_assert(offsetof(FPCGDataTableRowToParamDataTestStruct, SoftPath) == 0x000080, "Member 'FPCGDataTableRowToParamDataTestStruct::SoftPath' has a wrong offset!");

// ScriptStruct PCG.PCGDeterminismSettings
// 0x0010 (0x0010 - 0x0000)
struct FPCGDeterminismSettings final
{
public:
	bool                                          bNativeTests;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBlueprintDeterminismTest;                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPCGDeterminismTestBlueprintBase> DeterminismTestBlueprint;                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGDeterminismSettings) == 0x000008, "Wrong alignment on FPCGDeterminismSettings");
static_assert(sizeof(FPCGDeterminismSettings) == 0x000010, "Wrong size on FPCGDeterminismSettings");
static_assert(offsetof(FPCGDeterminismSettings, bNativeTests) == 0x000000, "Member 'FPCGDeterminismSettings::bNativeTests' has a wrong offset!");
static_assert(offsetof(FPCGDeterminismSettings, bUseBlueprintDeterminismTest) == 0x000001, "Member 'FPCGDeterminismSettings::bUseBlueprintDeterminismTest' has a wrong offset!");
static_assert(offsetof(FPCGDeterminismSettings, DeterminismTestBlueprint) == 0x000008, "Member 'FPCGDeterminismSettings::DeterminismTestBlueprint' has a wrong offset!");

// ScriptStruct PCG.PCGDummyGetPropertyLevel2Struct
// 0x0010 (0x0010 - 0x0000)
struct FPCGDummyGetPropertyLevel2Struct final
{
public:
	TArray<double>                                DoubleArrayProperty;                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGDummyGetPropertyLevel2Struct) == 0x000008, "Wrong alignment on FPCGDummyGetPropertyLevel2Struct");
static_assert(sizeof(FPCGDummyGetPropertyLevel2Struct) == 0x000010, "Wrong size on FPCGDummyGetPropertyLevel2Struct");
static_assert(offsetof(FPCGDummyGetPropertyLevel2Struct, DoubleArrayProperty) == 0x000000, "Member 'FPCGDummyGetPropertyLevel2Struct::DoubleArrayProperty' has a wrong offset!");

// ScriptStruct PCG.PCGDummyGetPropertyStruct
// 0x0028 (0x0028 - 0x0000)
struct FPCGDummyGetPropertyStruct final
{
public:
	TArray<int32>                                 IntArrayProperty;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FloatProperty;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGDummyGetPropertyLevel2Struct       Level2Struct;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGDummyGetPropertyStruct) == 0x000008, "Wrong alignment on FPCGDummyGetPropertyStruct");
static_assert(sizeof(FPCGDummyGetPropertyStruct) == 0x000028, "Wrong size on FPCGDummyGetPropertyStruct");
static_assert(offsetof(FPCGDummyGetPropertyStruct, IntArrayProperty) == 0x000000, "Member 'FPCGDummyGetPropertyStruct::IntArrayProperty' has a wrong offset!");
static_assert(offsetof(FPCGDummyGetPropertyStruct, FloatProperty) == 0x000010, "Member 'FPCGDummyGetPropertyStruct::FloatProperty' has a wrong offset!");
static_assert(offsetof(FPCGDummyGetPropertyStruct, Level2Struct) == 0x000018, "Member 'FPCGDummyGetPropertyStruct::Level2Struct' has a wrong offset!");

// ScriptStruct PCG.PCGTestMyColorStruct
// 0x0020 (0x0020 - 0x0000)
struct FPCGTestMyColorStruct final
{
public:
	double                                        B;                                                 // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        G;                                                 // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        R;                                                 // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        A;                                                 // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGTestMyColorStruct) == 0x000008, "Wrong alignment on FPCGTestMyColorStruct");
static_assert(sizeof(FPCGTestMyColorStruct) == 0x000020, "Wrong size on FPCGTestMyColorStruct");
static_assert(offsetof(FPCGTestMyColorStruct, B) == 0x000000, "Member 'FPCGTestMyColorStruct::B' has a wrong offset!");
static_assert(offsetof(FPCGTestMyColorStruct, G) == 0x000008, "Member 'FPCGTestMyColorStruct::G' has a wrong offset!");
static_assert(offsetof(FPCGTestMyColorStruct, R) == 0x000010, "Member 'FPCGTestMyColorStruct::R' has a wrong offset!");
static_assert(offsetof(FPCGTestMyColorStruct, A) == 0x000018, "Member 'FPCGTestMyColorStruct::A' has a wrong offset!");

// ScriptStruct PCG.PCGGrammarSelection
// 0x0040 (0x0040 - 0x0000)
struct FPCGGrammarSelection final
{
public:
	bool                                          bGrammarAsAttribute;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GrammarString;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPCGAttributePropertyInputSelector     GrammarAttribute;                                  // 0x0018(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGGrammarSelection) == 0x000008, "Wrong alignment on FPCGGrammarSelection");
static_assert(sizeof(FPCGGrammarSelection) == 0x000040, "Wrong size on FPCGGrammarSelection");
static_assert(offsetof(FPCGGrammarSelection, bGrammarAsAttribute) == 0x000000, "Member 'FPCGGrammarSelection::bGrammarAsAttribute' has a wrong offset!");
static_assert(offsetof(FPCGGrammarSelection, GrammarString) == 0x000008, "Member 'FPCGGrammarSelection::GrammarString' has a wrong offset!");
static_assert(offsetof(FPCGGrammarSelection, GrammarAttribute) == 0x000018, "Member 'FPCGGrammarSelection::GrammarAttribute' has a wrong offset!");

// ScriptStruct PCG.PCGPinProperties
// 0x0014 (0x0014 - 0x0000)
struct FPCGPinProperties
{
public:
	class FName                                   Label;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGPinUsage                                  Usage;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPCGDataType                                  AllowedTypes;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleData;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGPinStatus                                 PinStatus;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvisiblePin;                                     // 0x0012(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleConnections;                         // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPCGPinProperties) == 0x000004, "Wrong alignment on FPCGPinProperties");
static_assert(sizeof(FPCGPinProperties) == 0x000014, "Wrong size on FPCGPinProperties");
static_assert(offsetof(FPCGPinProperties, Label) == 0x000000, "Member 'FPCGPinProperties::Label' has a wrong offset!");
static_assert(offsetof(FPCGPinProperties, Usage) == 0x000008, "Member 'FPCGPinProperties::Usage' has a wrong offset!");
static_assert(offsetof(FPCGPinProperties, AllowedTypes) == 0x00000C, "Member 'FPCGPinProperties::AllowedTypes' has a wrong offset!");
static_assert(offsetof(FPCGPinProperties, bAllowMultipleData) == 0x000010, "Member 'FPCGPinProperties::bAllowMultipleData' has a wrong offset!");
static_assert(offsetof(FPCGPinProperties, PinStatus) == 0x000011, "Member 'FPCGPinProperties::PinStatus' has a wrong offset!");
static_assert(offsetof(FPCGPinProperties, bInvisiblePin) == 0x000012, "Member 'FPCGPinProperties::bInvisiblePin' has a wrong offset!");
static_assert(offsetof(FPCGPinProperties, bAllowMultipleConnections) == 0x000013, "Member 'FPCGPinProperties::bAllowMultipleConnections' has a wrong offset!");

// ScriptStruct PCG.PCGGraphTaskInput
// 0x0040 (0x0040 - 0x0000)
struct FPCGGraphTaskInput final
{
public:
	uint64                                        TaskId;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TOptional<struct FPCGPinProperties>           UpstreamPin;                                       // 0x0008(0x0018)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TOptional<struct FPCGPinProperties>           DownstreamPin;                                     // 0x0020(0x0018)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProvideData;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsedMultipleTimes;                              // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGGraphTaskInput) == 0x000008, "Wrong alignment on FPCGGraphTaskInput");
static_assert(sizeof(FPCGGraphTaskInput) == 0x000040, "Wrong size on FPCGGraphTaskInput");
static_assert(offsetof(FPCGGraphTaskInput, TaskId) == 0x000000, "Member 'FPCGGraphTaskInput::TaskId' has a wrong offset!");
static_assert(offsetof(FPCGGraphTaskInput, UpstreamPin) == 0x000008, "Member 'FPCGGraphTaskInput::UpstreamPin' has a wrong offset!");
static_assert(offsetof(FPCGGraphTaskInput, DownstreamPin) == 0x000020, "Member 'FPCGGraphTaskInput::DownstreamPin' has a wrong offset!");
static_assert(offsetof(FPCGGraphTaskInput, bProvideData) == 0x000038, "Member 'FPCGGraphTaskInput::bProvideData' has a wrong offset!");
static_assert(offsetof(FPCGGraphTaskInput, bIsUsedMultipleTimes) == 0x000039, "Member 'FPCGGraphTaskInput::bIsUsedMultipleTimes' has a wrong offset!");

// ScriptStruct PCG.PCGPinDependencyExpression
// 0x0010 (0x0010 - 0x0000)
struct FPCGPinDependencyExpression final
{
public:
	TArray<uint64>                                Expression;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPCGPinDependencyExpression) == 0x000008, "Wrong alignment on FPCGPinDependencyExpression");
static_assert(sizeof(FPCGPinDependencyExpression) == 0x000010, "Wrong size on FPCGPinDependencyExpression");
static_assert(offsetof(FPCGPinDependencyExpression, Expression) == 0x000000, "Member 'FPCGPinDependencyExpression::Expression' has a wrong offset!");

// ScriptStruct PCG.PCGGraphTask
// 0x0140 (0x0140 - 0x0000)
struct FPCGGraphTask final
{
public:
	TArray<struct FPCGGraphTaskInput>             Inputs;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EPCGElementSource                             ElementSource;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPCGNode>                NodePtr;                                           // 0x0018(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPCGSettings*                           CookedSettings;                                    // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        NodeID;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        CompiledTaskId;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        ParentID;                                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPCGPinDependencyExpression            PinDependency;                                     // 0x0060(0x0010)(NativeAccessSpecifierPublic)
	int32                                         StackIndex;                                        // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xCC];                                      // 0x0074(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGGraphTask) == 0x000008, "Wrong alignment on FPCGGraphTask");
static_assert(sizeof(FPCGGraphTask) == 0x000140, "Wrong size on FPCGGraphTask");
static_assert(offsetof(FPCGGraphTask, Inputs) == 0x000000, "Member 'FPCGGraphTask::Inputs' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, ElementSource) == 0x000010, "Member 'FPCGGraphTask::ElementSource' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, NodePtr) == 0x000018, "Member 'FPCGGraphTask::NodePtr' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, CookedSettings) == 0x000040, "Member 'FPCGGraphTask::CookedSettings' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, NodeID) == 0x000048, "Member 'FPCGGraphTask::NodeID' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, CompiledTaskId) == 0x000050, "Member 'FPCGGraphTask::CompiledTaskId' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, ParentID) == 0x000058, "Member 'FPCGGraphTask::ParentID' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, PinDependency) == 0x000060, "Member 'FPCGGraphTask::PinDependency' has a wrong offset!");
static_assert(offsetof(FPCGGraphTask, StackIndex) == 0x000070, "Member 'FPCGGraphTask::StackIndex' has a wrong offset!");

// ScriptStruct PCG.PCGGraphTasks
// 0x0010 (0x0010 - 0x0000)
struct FPCGGraphTasks final
{
public:
	TArray<struct FPCGGraphTask>                  GraphTasks;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGGraphTasks) == 0x000008, "Wrong alignment on FPCGGraphTasks");
static_assert(sizeof(FPCGGraphTasks) == 0x000010, "Wrong size on FPCGGraphTasks");
static_assert(offsetof(FPCGGraphTasks, GraphTasks) == 0x000000, "Member 'FPCGGraphTasks::GraphTasks' has a wrong offset!");

// ScriptStruct PCG.PCGComputeGraphs
// 0x0010 (0x0010 - 0x0000)
struct FPCGComputeGraphs final
{
public:
	TArray<class UPCGComputeGraph*>               ComputeGraphs;                                     // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGComputeGraphs) == 0x000008, "Wrong alignment on FPCGComputeGraphs");
static_assert(sizeof(FPCGComputeGraphs) == 0x000010, "Wrong size on FPCGComputeGraphs");
static_assert(offsetof(FPCGComputeGraphs, ComputeGraphs) == 0x000000, "Member 'FPCGComputeGraphs::ComputeGraphs' has a wrong offset!");

// ScriptStruct PCG.PCGGridDescriptor
// 0x0014 (0x0014 - 0x0000)
struct FPCGGridDescriptor final
{
public:
	uint32                                        GridSize;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIs2DGrid;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRuntime;                                        // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        RuntimeHash;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGGridDescriptor) == 0x000004, "Wrong alignment on FPCGGridDescriptor");
static_assert(sizeof(FPCGGridDescriptor) == 0x000014, "Wrong size on FPCGGridDescriptor");
static_assert(offsetof(FPCGGridDescriptor, GridSize) == 0x000000, "Member 'FPCGGridDescriptor::GridSize' has a wrong offset!");
static_assert(offsetof(FPCGGridDescriptor, bIs2DGrid) == 0x000004, "Member 'FPCGGridDescriptor::bIs2DGrid' has a wrong offset!");
static_assert(offsetof(FPCGGridDescriptor, bIsRuntime) == 0x000005, "Member 'FPCGGridDescriptor::bIsRuntime' has a wrong offset!");
static_assert(offsetof(FPCGGridDescriptor, RuntimeHash) == 0x000008, "Member 'FPCGGridDescriptor::RuntimeHash' has a wrong offset!");

// ScriptStruct PCG.PCGGridCellDescriptor
// 0x0020 (0x0020 - 0x0000)
struct FPCGGridCellDescriptor final
{
public:
	struct FPCGGridDescriptor                     Descriptor;                                        // 0x0000(0x0014)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GridCoords;                                        // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGGridCellDescriptor) == 0x000004, "Wrong alignment on FPCGGridCellDescriptor");
static_assert(sizeof(FPCGGridCellDescriptor) == 0x000020, "Wrong size on FPCGGridCellDescriptor");
static_assert(offsetof(FPCGGridCellDescriptor, Descriptor) == 0x000000, "Member 'FPCGGridCellDescriptor::Descriptor' has a wrong offset!");
static_assert(offsetof(FPCGGridCellDescriptor, GridCoords) == 0x000014, "Member 'FPCGGridCellDescriptor::GridCoords' has a wrong offset!");

// ScriptStruct PCG.PCGObjectPropertyOverrideDescription
// 0x0038 (0x0038 - 0x0000)
struct FPCGObjectPropertyOverrideDescription final
{
public:
	struct FPCGAttributePropertyInputSelector     InputSource;                                       // 0x0000(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyTarget;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGObjectPropertyOverrideDescription) == 0x000008, "Wrong alignment on FPCGObjectPropertyOverrideDescription");
static_assert(sizeof(FPCGObjectPropertyOverrideDescription) == 0x000038, "Wrong size on FPCGObjectPropertyOverrideDescription");
static_assert(offsetof(FPCGObjectPropertyOverrideDescription, InputSource) == 0x000000, "Member 'FPCGObjectPropertyOverrideDescription::InputSource' has a wrong offset!");
static_assert(offsetof(FPCGObjectPropertyOverrideDescription, PropertyTarget) == 0x000028, "Member 'FPCGObjectPropertyOverrideDescription::PropertyTarget' has a wrong offset!");

// ScriptStruct PCG.PCGActorPropertyOverride
// 0x0038 (0x0038 - 0x0000)
struct FPCGActorPropertyOverride final
{
public:
	struct FPCGAttributePropertyInputSelector     InputSource;                                       // 0x0000(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyTarget;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGActorPropertyOverride) == 0x000008, "Wrong alignment on FPCGActorPropertyOverride");
static_assert(sizeof(FPCGActorPropertyOverride) == 0x000038, "Wrong size on FPCGActorPropertyOverride");
static_assert(offsetof(FPCGActorPropertyOverride, InputSource) == 0x000000, "Member 'FPCGActorPropertyOverride::InputSource' has a wrong offset!");
static_assert(offsetof(FPCGActorPropertyOverride, PropertyTarget) == 0x000028, "Member 'FPCGActorPropertyOverride::PropertyTarget' has a wrong offset!");

// ScriptStruct PCG.PCGProceduralISMComponentDescriptor
// 0x0098 (0x0098 - 0x0000)
struct FPCGProceduralISMComponentDescriptor final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Hash;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OverrideMaterials;                                 // 0x0018(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverlayMaterial;                                   // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URuntimeVirtualTexture*>         RuntimeVirtualTextures;                            // 0x0030(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         NumInstances;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCustomFloats;                                   // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   LocalBounds;                                       // 0x0048(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InstanceStartCullDistance;                         // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceEndCullDistance;                           // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ComponentTags;                                     // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGProceduralISMComponentDescriptor) == 0x000008, "Wrong alignment on FPCGProceduralISMComponentDescriptor");
static_assert(sizeof(FPCGProceduralISMComponentDescriptor) == 0x000098, "Wrong size on FPCGProceduralISMComponentDescriptor");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, Hash) == 0x000008, "Member 'FPCGProceduralISMComponentDescriptor::Hash' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, StaticMesh) == 0x000010, "Member 'FPCGProceduralISMComponentDescriptor::StaticMesh' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, OverrideMaterials) == 0x000018, "Member 'FPCGProceduralISMComponentDescriptor::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, OverlayMaterial) == 0x000028, "Member 'FPCGProceduralISMComponentDescriptor::OverlayMaterial' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, RuntimeVirtualTextures) == 0x000030, "Member 'FPCGProceduralISMComponentDescriptor::RuntimeVirtualTextures' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, NumInstances) == 0x000040, "Member 'FPCGProceduralISMComponentDescriptor::NumInstances' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, NumCustomFloats) == 0x000044, "Member 'FPCGProceduralISMComponentDescriptor::NumCustomFloats' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, LocalBounds) == 0x000048, "Member 'FPCGProceduralISMComponentDescriptor::LocalBounds' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, InstanceStartCullDistance) == 0x000080, "Member 'FPCGProceduralISMComponentDescriptor::InstanceStartCullDistance' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, InstanceEndCullDistance) == 0x000084, "Member 'FPCGProceduralISMComponentDescriptor::InstanceEndCullDistance' has a wrong offset!");
static_assert(offsetof(FPCGProceduralISMComponentDescriptor, ComponentTags) == 0x000088, "Member 'FPCGProceduralISMComponentDescriptor::ComponentTags' has a wrong offset!");

// ScriptStruct PCG.PCGProjectionParams
// 0x0020 (0x0020 - 0x0000)
struct FPCGProjectionParams final
{
public:
	bool                                          bProjectPositions;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectRotations;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectScales;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGProjectionColorBlendMode                  ColorBlendMode;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttributeList;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGMetadataFilterMode                        AttributeMode;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGMetadataOp                                AttributeMergeOperation;                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGProjectionTagMergeMode                    TagMergeOperation;                                 // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGProjectionParams) == 0x000008, "Wrong alignment on FPCGProjectionParams");
static_assert(sizeof(FPCGProjectionParams) == 0x000020, "Wrong size on FPCGProjectionParams");
static_assert(offsetof(FPCGProjectionParams, bProjectPositions) == 0x000000, "Member 'FPCGProjectionParams::bProjectPositions' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, bProjectRotations) == 0x000001, "Member 'FPCGProjectionParams::bProjectRotations' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, bProjectScales) == 0x000002, "Member 'FPCGProjectionParams::bProjectScales' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, ColorBlendMode) == 0x000003, "Member 'FPCGProjectionParams::ColorBlendMode' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, AttributeList) == 0x000008, "Member 'FPCGProjectionParams::AttributeList' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, AttributeMode) == 0x000018, "Member 'FPCGProjectionParams::AttributeMode' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, AttributeMergeOperation) == 0x000019, "Member 'FPCGProjectionParams::AttributeMergeOperation' has a wrong offset!");
static_assert(offsetof(FPCGProjectionParams, TagMergeOperation) == 0x00001A, "Member 'FPCGProjectionParams::TagMergeOperation' has a wrong offset!");

// ScriptStruct PCG.PCGSelectGrammarCriterion
// 0x0030 (0x0030 - 0x0000)
struct FPCGSelectGrammarCriterion final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGSelectGrammarComparator                   Comparator;                                        // 0x0008(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        FirstValue;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SecondValue;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Grammar;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSelectGrammarCriterion) == 0x000008, "Wrong alignment on FPCGSelectGrammarCriterion");
static_assert(sizeof(FPCGSelectGrammarCriterion) == 0x000030, "Wrong size on FPCGSelectGrammarCriterion");
static_assert(offsetof(FPCGSelectGrammarCriterion, Key) == 0x000000, "Member 'FPCGSelectGrammarCriterion::Key' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriterion, Comparator) == 0x000008, "Member 'FPCGSelectGrammarCriterion::Comparator' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriterion, FirstValue) == 0x000010, "Member 'FPCGSelectGrammarCriterion::FirstValue' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriterion, SecondValue) == 0x000018, "Member 'FPCGSelectGrammarCriterion::SecondValue' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriterion, Grammar) == 0x000020, "Member 'FPCGSelectGrammarCriterion::Grammar' has a wrong offset!");

// ScriptStruct PCG.PCGSelectGrammarCriteriaAttributeNames
// 0x0028 (0x0028 - 0x0000)
struct FPCGSelectGrammarCriteriaAttributeNames final
{
public:
	class FName                                   KeyAttributeName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComparatorAttributeName;                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstValueAttributeName;                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondValueAttributeName;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrammarAttributeName;                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSelectGrammarCriteriaAttributeNames) == 0x000004, "Wrong alignment on FPCGSelectGrammarCriteriaAttributeNames");
static_assert(sizeof(FPCGSelectGrammarCriteriaAttributeNames) == 0x000028, "Wrong size on FPCGSelectGrammarCriteriaAttributeNames");
static_assert(offsetof(FPCGSelectGrammarCriteriaAttributeNames, KeyAttributeName) == 0x000000, "Member 'FPCGSelectGrammarCriteriaAttributeNames::KeyAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriteriaAttributeNames, ComparatorAttributeName) == 0x000008, "Member 'FPCGSelectGrammarCriteriaAttributeNames::ComparatorAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriteriaAttributeNames, FirstValueAttributeName) == 0x000010, "Member 'FPCGSelectGrammarCriteriaAttributeNames::FirstValueAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriteriaAttributeNames, SecondValueAttributeName) == 0x000018, "Member 'FPCGSelectGrammarCriteriaAttributeNames::SecondValueAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSelectGrammarCriteriaAttributeNames, GrammarAttributeName) == 0x000020, "Member 'FPCGSelectGrammarCriteriaAttributeNames::GrammarAttributeName' has a wrong offset!");

// ScriptStruct PCG.PCGContext
// 0x01B8 (0x01B8 - 0x0000)
struct alignas(0x08) FPCGContext
{
public:
	uint8                                         Pad_0[0x1B8];                                      // 0x0000(0x01B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGContext) == 0x000008, "Wrong alignment on FPCGContext");
static_assert(sizeof(FPCGContext) == 0x0001B8, "Wrong size on FPCGContext");

// ScriptStruct PCG.PCGStaticMeshSpawnerContext
// 0x0208 (0x03C0 - 0x01B8)
struct FPCGStaticMeshSpawnerContext final : public FPCGContext
{
public:
	uint8                                         Pad_1B8[0x208];                                    // 0x01B8(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGStaticMeshSpawnerContext) == 0x000008, "Wrong alignment on FPCGStaticMeshSpawnerContext");
static_assert(sizeof(FPCGStaticMeshSpawnerContext) == 0x0003C0, "Wrong size on FPCGStaticMeshSpawnerContext");

// ScriptStruct PCG.PCGSubdivisionSubmodule
// 0x0040 (0x0040 - 0x0000)
struct FPCGSubdivisionSubmodule final
{
public:
	class FName                                   Symbol;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Size;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalable;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               DebugColor;                                        // 0x0020(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSubdivisionSubmodule) == 0x000010, "Wrong alignment on FPCGSubdivisionSubmodule");
static_assert(sizeof(FPCGSubdivisionSubmodule) == 0x000040, "Wrong size on FPCGSubdivisionSubmodule");
static_assert(offsetof(FPCGSubdivisionSubmodule, Symbol) == 0x000000, "Member 'FPCGSubdivisionSubmodule::Symbol' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionSubmodule, Size) == 0x000008, "Member 'FPCGSubdivisionSubmodule::Size' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionSubmodule, bScalable) == 0x000010, "Member 'FPCGSubdivisionSubmodule::bScalable' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionSubmodule, DebugColor) == 0x000020, "Member 'FPCGSubdivisionSubmodule::DebugColor' has a wrong offset!");

// ScriptStruct PCG.PCGSubdivisionModuleAttributeNames
// 0x0028 (0x0028 - 0x0000)
struct FPCGSubdivisionModuleAttributeNames final
{
public:
	class FName                                   SymbolAttributeName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SizeAttributeName;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProvideScalable;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ScalableAttributeName;                             // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProvideDebugColor;                                // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DebugColorAttributeName;                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSubdivisionModuleAttributeNames) == 0x000004, "Wrong alignment on FPCGSubdivisionModuleAttributeNames");
static_assert(sizeof(FPCGSubdivisionModuleAttributeNames) == 0x000028, "Wrong size on FPCGSubdivisionModuleAttributeNames");
static_assert(offsetof(FPCGSubdivisionModuleAttributeNames, SymbolAttributeName) == 0x000000, "Member 'FPCGSubdivisionModuleAttributeNames::SymbolAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionModuleAttributeNames, SizeAttributeName) == 0x000008, "Member 'FPCGSubdivisionModuleAttributeNames::SizeAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionModuleAttributeNames, bProvideScalable) == 0x000010, "Member 'FPCGSubdivisionModuleAttributeNames::bProvideScalable' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionModuleAttributeNames, ScalableAttributeName) == 0x000014, "Member 'FPCGSubdivisionModuleAttributeNames::ScalableAttributeName' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionModuleAttributeNames, bProvideDebugColor) == 0x00001C, "Member 'FPCGSubdivisionModuleAttributeNames::bProvideDebugColor' has a wrong offset!");
static_assert(offsetof(FPCGSubdivisionModuleAttributeNames, DebugColorAttributeName) == 0x000020, "Member 'FPCGSubdivisionModuleAttributeNames::DebugColorAttributeName' has a wrong offset!");

// ScriptStruct PCG.PCGPinPropertiesGPUStruct
// 0x0040 (0x0040 - 0x0000)
struct FPCGPinPropertiesGPUStruct final
{
public:
	EPCGPinInitMode                               InitializationMode;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PinsToInititalizeFrom;                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EPCGDataCountMode                             DataCountMode;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGDataMultiplicity                          DataMultiplicity;                                  // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DataCount;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGElementCountMode                          ElementCountMode;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGElementMultiplicity                       ElementMultiplicity;                               // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ElementCount;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGAttributeInheritanceMode                  AttributeInheritanceMode;                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGKernelAttributeKey>         CreatedKernelAttributeKeys;                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPinPropertiesGPUStruct) == 0x000008, "Wrong alignment on FPCGPinPropertiesGPUStruct");
static_assert(sizeof(FPCGPinPropertiesGPUStruct) == 0x000040, "Wrong size on FPCGPinPropertiesGPUStruct");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, InitializationMode) == 0x000000, "Member 'FPCGPinPropertiesGPUStruct::InitializationMode' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, PinsToInititalizeFrom) == 0x000008, "Member 'FPCGPinPropertiesGPUStruct::PinsToInititalizeFrom' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, DataCountMode) == 0x000018, "Member 'FPCGPinPropertiesGPUStruct::DataCountMode' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, DataMultiplicity) == 0x000019, "Member 'FPCGPinPropertiesGPUStruct::DataMultiplicity' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, DataCount) == 0x00001C, "Member 'FPCGPinPropertiesGPUStruct::DataCount' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, ElementCountMode) == 0x000020, "Member 'FPCGPinPropertiesGPUStruct::ElementCountMode' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, ElementMultiplicity) == 0x000021, "Member 'FPCGPinPropertiesGPUStruct::ElementMultiplicity' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, ElementCount) == 0x000024, "Member 'FPCGPinPropertiesGPUStruct::ElementCount' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, AttributeInheritanceMode) == 0x000028, "Member 'FPCGPinPropertiesGPUStruct::AttributeInheritanceMode' has a wrong offset!");
static_assert(offsetof(FPCGPinPropertiesGPUStruct, CreatedKernelAttributeKeys) == 0x000030, "Member 'FPCGPinPropertiesGPUStruct::CreatedKernelAttributeKeys' has a wrong offset!");

// ScriptStruct PCG.PCGPinPropertiesGPU
// 0x0044 (0x0058 - 0x0014)
struct FPCGPinPropertiesGPU final : public FPCGPinProperties
{
public:
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGPinPropertiesGPUStruct             PropertiesGPU;                                     // 0x0018(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPinPropertiesGPU) == 0x000008, "Wrong alignment on FPCGPinPropertiesGPU");
static_assert(sizeof(FPCGPinPropertiesGPU) == 0x000058, "Wrong size on FPCGPinPropertiesGPU");
static_assert(offsetof(FPCGPinPropertiesGPU, PropertiesGPU) == 0x000018, "Member 'FPCGPinPropertiesGPU::PropertiesGPU' has a wrong offset!");

// ScriptStruct PCG.PCGLandscapeDataProps
// 0x0005 (0x0005 - 0x0000)
struct FPCGLandscapeDataProps final
{
public:
	bool                                          bGetHeightOnly;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetLayerWeights;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetActorReference;                                // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetPhysicalMaterial;                              // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetComponentCoordinates;                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGLandscapeDataProps) == 0x000001, "Wrong alignment on FPCGLandscapeDataProps");
static_assert(sizeof(FPCGLandscapeDataProps) == 0x000005, "Wrong size on FPCGLandscapeDataProps");
static_assert(offsetof(FPCGLandscapeDataProps, bGetHeightOnly) == 0x000000, "Member 'FPCGLandscapeDataProps::bGetHeightOnly' has a wrong offset!");
static_assert(offsetof(FPCGLandscapeDataProps, bGetLayerWeights) == 0x000001, "Member 'FPCGLandscapeDataProps::bGetLayerWeights' has a wrong offset!");
static_assert(offsetof(FPCGLandscapeDataProps, bGetActorReference) == 0x000002, "Member 'FPCGLandscapeDataProps::bGetActorReference' has a wrong offset!");
static_assert(offsetof(FPCGLandscapeDataProps, bGetPhysicalMaterial) == 0x000003, "Member 'FPCGLandscapeDataProps::bGetPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FPCGLandscapeDataProps, bGetComponentCoordinates) == 0x000004, "Member 'FPCGLandscapeDataProps::bGetComponentCoordinates' has a wrong offset!");

// ScriptStruct PCG.PCGSplineStruct
// 0x0160 (0x0160 - 0x0000)
struct FPCGSplineStruct final
{
public:
	struct FSplineCurves                          SplineCurves;                                      // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0070(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultUpVector;                                   // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReparamStepsPerSegment;                            // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosedLoop;                                       // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxSphereBounds                       LocalBounds;                                       // 0x00F0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0128(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSplineStruct) == 0x000010, "Wrong alignment on FPCGSplineStruct");
static_assert(sizeof(FPCGSplineStruct) == 0x000160, "Wrong size on FPCGSplineStruct");
static_assert(offsetof(FPCGSplineStruct, SplineCurves) == 0x000000, "Member 'FPCGSplineStruct::SplineCurves' has a wrong offset!");
static_assert(offsetof(FPCGSplineStruct, Transform) == 0x000070, "Member 'FPCGSplineStruct::Transform' has a wrong offset!");
static_assert(offsetof(FPCGSplineStruct, DefaultUpVector) == 0x0000D0, "Member 'FPCGSplineStruct::DefaultUpVector' has a wrong offset!");
static_assert(offsetof(FPCGSplineStruct, ReparamStepsPerSegment) == 0x0000E8, "Member 'FPCGSplineStruct::ReparamStepsPerSegment' has a wrong offset!");
static_assert(offsetof(FPCGSplineStruct, bClosedLoop) == 0x0000EC, "Member 'FPCGSplineStruct::bClosedLoop' has a wrong offset!");
static_assert(offsetof(FPCGSplineStruct, LocalBounds) == 0x0000F0, "Member 'FPCGSplineStruct::LocalBounds' has a wrong offset!");
static_assert(offsetof(FPCGSplineStruct, Bounds) == 0x000128, "Member 'FPCGSplineStruct::Bounds' has a wrong offset!");

// ScriptStruct PCG.PCGWorldCommonQueryParams
// 0x0070 (0x0070 - 0x0000)
struct FPCGWorldCommonQueryParams
{
public:
	bool                                          bIgnorePCGHits;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelfHits;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGWorldQueryFilterByTag                     ActorTagFilter;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorTagsList;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGWorldQuerySelectLandscapeHits             SelectLandscapeHits;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetReferenceToActorHit;                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetReferenceToPhysicalMaterial;                   // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             ParsedActorTagsList;                               // 0x0020(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGWorldCommonQueryParams) == 0x000008, "Wrong alignment on FPCGWorldCommonQueryParams");
static_assert(sizeof(FPCGWorldCommonQueryParams) == 0x000070, "Wrong size on FPCGWorldCommonQueryParams");
static_assert(offsetof(FPCGWorldCommonQueryParams, bIgnorePCGHits) == 0x000000, "Member 'FPCGWorldCommonQueryParams::bIgnorePCGHits' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, bIgnoreSelfHits) == 0x000001, "Member 'FPCGWorldCommonQueryParams::bIgnoreSelfHits' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, CollisionChannel) == 0x000002, "Member 'FPCGWorldCommonQueryParams::CollisionChannel' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, bTraceComplex) == 0x000003, "Member 'FPCGWorldCommonQueryParams::bTraceComplex' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, ActorTagFilter) == 0x000004, "Member 'FPCGWorldCommonQueryParams::ActorTagFilter' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, ActorTagsList) == 0x000008, "Member 'FPCGWorldCommonQueryParams::ActorTagsList' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, SelectLandscapeHits) == 0x000018, "Member 'FPCGWorldCommonQueryParams::SelectLandscapeHits' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, bGetReferenceToActorHit) == 0x000019, "Member 'FPCGWorldCommonQueryParams::bGetReferenceToActorHit' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, bGetReferenceToPhysicalMaterial) == 0x00001A, "Member 'FPCGWorldCommonQueryParams::bGetReferenceToPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FPCGWorldCommonQueryParams, ParsedActorTagsList) == 0x000020, "Member 'FPCGWorldCommonQueryParams::ParsedActorTagsList' has a wrong offset!");

// ScriptStruct PCG.PCGWorldRaycastQueryParams
// 0x0010 (0x0080 - 0x0070)
struct FPCGWorldRaycastQueryParams : public FPCGWorldCommonQueryParams
{
public:
	uint8                                         bIgnoreBackfaceHits : 1;                           // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetImpact : 1;                                    // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetImpactPoint : 1;                               // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetImpactNormal : 1;                              // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetReflection : 1;                                // 0x0070(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetDistance : 1;                                  // 0x0070(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetLocalImpactPoint : 1;                          // 0x0070(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetReferenceToRenderMaterial : 1;                 // 0x0070(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetReferenceToStaticMesh : 1;                     // 0x0071(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetFaceIndex : 1;                                 // 0x0071(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetUVCoords : 1;                                  // 0x0071(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetElementIndex : 1;                              // 0x0071(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyMetadataFromLandscape : 1;                   // 0x0071(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RenderMaterialIndex;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UVChannel;                                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGWorldRaycastQueryParams) == 0x000008, "Wrong alignment on FPCGWorldRaycastQueryParams");
static_assert(sizeof(FPCGWorldRaycastQueryParams) == 0x000080, "Wrong size on FPCGWorldRaycastQueryParams");
static_assert(offsetof(FPCGWorldRaycastQueryParams, RenderMaterialIndex) == 0x000074, "Member 'FPCGWorldRaycastQueryParams::RenderMaterialIndex' has a wrong offset!");
static_assert(offsetof(FPCGWorldRaycastQueryParams, UVChannel) == 0x000078, "Member 'FPCGWorldRaycastQueryParams::UVChannel' has a wrong offset!");

// ScriptStruct PCG.PCGWorldVolumetricQueryParams
// 0x0008 (0x0078 - 0x0070)
struct FPCGWorldVolumetricQueryParams final : public FPCGWorldCommonQueryParams
{
public:
	bool                                          bSearchForOverlap;                                 // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGWorldVolumetricQueryParams) == 0x000008, "Wrong alignment on FPCGWorldVolumetricQueryParams");
static_assert(sizeof(FPCGWorldVolumetricQueryParams) == 0x000078, "Wrong size on FPCGWorldVolumetricQueryParams");
static_assert(offsetof(FPCGWorldVolumetricQueryParams, bSearchForOverlap) == 0x000070, "Member 'FPCGWorldVolumetricQueryParams::bSearchForOverlap' has a wrong offset!");

// ScriptStruct PCG.PCGWorldRayHitQueryParams
// 0x0040 (0x00C0 - 0x0080)
struct FPCGWorldRayHitQueryParams final : public FPCGWorldRaycastQueryParams
{
public:
	bool                                          bOverrideDefaultParams;                            // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RayOrigin;                                         // 0x0088(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayDirection;                                      // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RayLength;                                         // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGWorldRayHitQueryParams) == 0x000008, "Wrong alignment on FPCGWorldRayHitQueryParams");
static_assert(sizeof(FPCGWorldRayHitQueryParams) == 0x0000C0, "Wrong size on FPCGWorldRayHitQueryParams");
static_assert(offsetof(FPCGWorldRayHitQueryParams, bOverrideDefaultParams) == 0x000080, "Member 'FPCGWorldRayHitQueryParams::bOverrideDefaultParams' has a wrong offset!");
static_assert(offsetof(FPCGWorldRayHitQueryParams, RayOrigin) == 0x000088, "Member 'FPCGWorldRayHitQueryParams::RayOrigin' has a wrong offset!");
static_assert(offsetof(FPCGWorldRayHitQueryParams, RayDirection) == 0x0000A0, "Member 'FPCGWorldRayHitQueryParams::RayDirection' has a wrong offset!");
static_assert(offsetof(FPCGWorldRayHitQueryParams, RayLength) == 0x0000B8, "Member 'FPCGWorldRayHitQueryParams::RayLength' has a wrong offset!");

// ScriptStruct PCG.PCGSelectionKey
// 0x0040 (0x0040 - 0x0000)
struct FPCGSelectionKey final
{
public:
	EPCGActorFilter                               ActorFilter;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGActorSelection                            Selection;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    SelectionClass;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ObjectPath;                                        // 0x0018(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    OptionalExtraDependency;                           // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSelectionKey) == 0x000008, "Wrong alignment on FPCGSelectionKey");
static_assert(sizeof(FPCGSelectionKey) == 0x000040, "Wrong size on FPCGSelectionKey");
static_assert(offsetof(FPCGSelectionKey, ActorFilter) == 0x000000, "Member 'FPCGSelectionKey::ActorFilter' has a wrong offset!");
static_assert(offsetof(FPCGSelectionKey, Selection) == 0x000001, "Member 'FPCGSelectionKey::Selection' has a wrong offset!");
static_assert(offsetof(FPCGSelectionKey, Tag) == 0x000004, "Member 'FPCGSelectionKey::Tag' has a wrong offset!");
static_assert(offsetof(FPCGSelectionKey, SelectionClass) == 0x000010, "Member 'FPCGSelectionKey::SelectionClass' has a wrong offset!");
static_assert(offsetof(FPCGSelectionKey, ObjectPath) == 0x000018, "Member 'FPCGSelectionKey::ObjectPath' has a wrong offset!");
static_assert(offsetof(FPCGSelectionKey, OptionalExtraDependency) == 0x000038, "Member 'FPCGSelectionKey::OptionalExtraDependency' has a wrong offset!");

// ScriptStruct PCG.PCGActorSelectorSettings
// 0x0048 (0x0048 - 0x0000)
struct FPCGActorSelectorSettings final
{
public:
	EPCGActorFilter                               ActorFilter;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustOverlapSelf;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChildren;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableFilter;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGActorSelection                            ActorSelection;                                    // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorSelectionTag;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorSelectionClass;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPCGAttributePropertyInputSelector     ActorReferenceSelector;                            // 0x0018(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectMultiple;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelfAndChildren;                            // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowActorFilter;                                  // 0x0042(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowIncludeChildren;                              // 0x0043(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowActorSelection;                               // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowActorSelectionClass;                          // 0x0045(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSelectMultiple;                               // 0x0046(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowIgnoreSelfAndChildren;                        // 0x0047(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGActorSelectorSettings) == 0x000008, "Wrong alignment on FPCGActorSelectorSettings");
static_assert(sizeof(FPCGActorSelectorSettings) == 0x000048, "Wrong size on FPCGActorSelectorSettings");
static_assert(offsetof(FPCGActorSelectorSettings, ActorFilter) == 0x000000, "Member 'FPCGActorSelectorSettings::ActorFilter' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bMustOverlapSelf) == 0x000001, "Member 'FPCGActorSelectorSettings::bMustOverlapSelf' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bIncludeChildren) == 0x000002, "Member 'FPCGActorSelectorSettings::bIncludeChildren' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bDisableFilter) == 0x000003, "Member 'FPCGActorSelectorSettings::bDisableFilter' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, ActorSelection) == 0x000004, "Member 'FPCGActorSelectorSettings::ActorSelection' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, ActorSelectionTag) == 0x000008, "Member 'FPCGActorSelectorSettings::ActorSelectionTag' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, ActorSelectionClass) == 0x000010, "Member 'FPCGActorSelectorSettings::ActorSelectionClass' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, ActorReferenceSelector) == 0x000018, "Member 'FPCGActorSelectorSettings::ActorReferenceSelector' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bSelectMultiple) == 0x000040, "Member 'FPCGActorSelectorSettings::bSelectMultiple' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bIgnoreSelfAndChildren) == 0x000041, "Member 'FPCGActorSelectorSettings::bIgnoreSelfAndChildren' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bShowActorFilter) == 0x000042, "Member 'FPCGActorSelectorSettings::bShowActorFilter' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bShowIncludeChildren) == 0x000043, "Member 'FPCGActorSelectorSettings::bShowIncludeChildren' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bShowActorSelection) == 0x000044, "Member 'FPCGActorSelectorSettings::bShowActorSelection' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bShowActorSelectionClass) == 0x000045, "Member 'FPCGActorSelectorSettings::bShowActorSelectionClass' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bShowSelectMultiple) == 0x000046, "Member 'FPCGActorSelectorSettings::bShowSelectMultiple' has a wrong offset!");
static_assert(offsetof(FPCGActorSelectorSettings, bShowIgnoreSelfAndChildren) == 0x000047, "Member 'FPCGActorSelectorSettings::bShowIgnoreSelfAndChildren' has a wrong offset!");

// ScriptStruct PCG.PCGComponentSelectorSettings
// 0x0030 (0x0030 - 0x0000)
struct FPCGComponentSelectorSettings final
{
public:
	EPCGComponentSelection                        ComponentSelection;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ComponentSelectionTag;                             // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UActorComponent>            ComponentSelectionClass;                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowComponentSelection;                           // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowComponentSelectionClass;                      // 0x0019(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x16];                                      // 0x001A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGComponentSelectorSettings) == 0x000008, "Wrong alignment on FPCGComponentSelectorSettings");
static_assert(sizeof(FPCGComponentSelectorSettings) == 0x000030, "Wrong size on FPCGComponentSelectorSettings");
static_assert(offsetof(FPCGComponentSelectorSettings, ComponentSelection) == 0x000000, "Member 'FPCGComponentSelectorSettings::ComponentSelection' has a wrong offset!");
static_assert(offsetof(FPCGComponentSelectorSettings, ComponentSelectionTag) == 0x000004, "Member 'FPCGComponentSelectorSettings::ComponentSelectionTag' has a wrong offset!");
static_assert(offsetof(FPCGComponentSelectorSettings, ComponentSelectionClass) == 0x000010, "Member 'FPCGComponentSelectorSettings::ComponentSelectionClass' has a wrong offset!");
static_assert(offsetof(FPCGComponentSelectorSettings, bShowComponentSelection) == 0x000018, "Member 'FPCGComponentSelectorSettings::bShowComponentSelection' has a wrong offset!");
static_assert(offsetof(FPCGComponentSelectorSettings, bShowComponentSelectionClass) == 0x000019, "Member 'FPCGComponentSelectorSettings::bShowComponentSelectionClass' has a wrong offset!");

// ScriptStruct PCG.PCGSelfPruningParameters
// 0x0068 (0x0068 - 0x0000)
struct FPCGSelfPruningParameters final
{
public:
	EPCGSelfPruningType                           PruningType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGAttributePropertyInputSelector     ComparisonSource;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusSimilarityFactor;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizedPruning;                                // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCollisionAttribute;                            // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGAttributePropertyInputSelector     CollisionAttribute;                                // 0x0038(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGCollisionQueryFlag                        CollisionQueryFlag;                                // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGSelfPruningParameters) == 0x000008, "Wrong alignment on FPCGSelfPruningParameters");
static_assert(sizeof(FPCGSelfPruningParameters) == 0x000068, "Wrong size on FPCGSelfPruningParameters");
static_assert(offsetof(FPCGSelfPruningParameters, PruningType) == 0x000000, "Member 'FPCGSelfPruningParameters::PruningType' has a wrong offset!");
static_assert(offsetof(FPCGSelfPruningParameters, ComparisonSource) == 0x000008, "Member 'FPCGSelfPruningParameters::ComparisonSource' has a wrong offset!");
static_assert(offsetof(FPCGSelfPruningParameters, RadiusSimilarityFactor) == 0x000030, "Member 'FPCGSelfPruningParameters::RadiusSimilarityFactor' has a wrong offset!");
static_assert(offsetof(FPCGSelfPruningParameters, bRandomizedPruning) == 0x000034, "Member 'FPCGSelfPruningParameters::bRandomizedPruning' has a wrong offset!");
static_assert(offsetof(FPCGSelfPruningParameters, bUseCollisionAttribute) == 0x000035, "Member 'FPCGSelfPruningParameters::bUseCollisionAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSelfPruningParameters, CollisionAttribute) == 0x000038, "Member 'FPCGSelfPruningParameters::CollisionAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSelfPruningParameters, CollisionQueryFlag) == 0x000060, "Member 'FPCGSelfPruningParameters::CollisionQueryFlag' has a wrong offset!");

// ScriptStruct PCG.PCGSplineMeshParams
// 0x00C8 (0x00C8 - 0x0000)
struct FPCGSplineMeshParams final
{
public:
	EPCGSplineMeshForwardAxis                     ForwardAxis;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleMeshToBounds;                                // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleMeshToLandscapeSplineFullWidth;              // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SplineUpDir;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaniteClusterBoundsScale;                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineBoundaryMin;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineBoundaryMax;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothInterpRollScale;                            // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartPosition;                                     // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRollDegrees;                                  // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              StartScale;                                        // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPosition;                                       // 0x0078(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x0090(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRollDegrees;                                    // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              EndScale;                                          // 0x00B0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGSplineMeshParams) == 0x000008, "Wrong alignment on FPCGSplineMeshParams");
static_assert(sizeof(FPCGSplineMeshParams) == 0x0000C8, "Wrong size on FPCGSplineMeshParams");
static_assert(offsetof(FPCGSplineMeshParams, ForwardAxis) == 0x000000, "Member 'FPCGSplineMeshParams::ForwardAxis' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, bScaleMeshToBounds) == 0x000004, "Member 'FPCGSplineMeshParams::bScaleMeshToBounds' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, bScaleMeshToLandscapeSplineFullWidth) == 0x000005, "Member 'FPCGSplineMeshParams::bScaleMeshToLandscapeSplineFullWidth' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, SplineUpDir) == 0x000008, "Member 'FPCGSplineMeshParams::SplineUpDir' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, NaniteClusterBoundsScale) == 0x000020, "Member 'FPCGSplineMeshParams::NaniteClusterBoundsScale' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, SplineBoundaryMin) == 0x000024, "Member 'FPCGSplineMeshParams::SplineBoundaryMin' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, SplineBoundaryMax) == 0x000028, "Member 'FPCGSplineMeshParams::SplineBoundaryMax' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, bSmoothInterpRollScale) == 0x00002C, "Member 'FPCGSplineMeshParams::bSmoothInterpRollScale' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, StartPosition) == 0x000030, "Member 'FPCGSplineMeshParams::StartPosition' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, StartTangent) == 0x000048, "Member 'FPCGSplineMeshParams::StartTangent' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, StartRollDegrees) == 0x000060, "Member 'FPCGSplineMeshParams::StartRollDegrees' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, StartScale) == 0x000068, "Member 'FPCGSplineMeshParams::StartScale' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, EndPosition) == 0x000078, "Member 'FPCGSplineMeshParams::EndPosition' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, EndTangent) == 0x000090, "Member 'FPCGSplineMeshParams::EndTangent' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, EndRollDegrees) == 0x0000A8, "Member 'FPCGSplineMeshParams::EndRollDegrees' has a wrong offset!");
static_assert(offsetof(FPCGSplineMeshParams, EndScale) == 0x0000B0, "Member 'FPCGSplineMeshParams::EndScale' has a wrong offset!");

// ScriptStruct PCG.PCGSplineSamplerParams
// 0x0138 (0x0138 - 0x0000)
struct FPCGSplineSamplerParams final
{
public:
	EPCGSplineSamplingDimension                   Dimension;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGSplineSamplingMode                        Mode;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGSplineSamplingFill                        Fill;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubdivisionsPerSegment;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIncrement;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSamples;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlanarSubdivisions;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumHeightSubdivisions;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartOffset;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndOffset;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRandomOffsetNormalized;                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFitToCurve;                                       // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteriorSampleSpacing;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorBorderSampleSpacing;                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTreatSplineAsPolyline;                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGSplineSamplingInteriorOrientation         InteriorOrientation;                               // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectOntoSurface;                               // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     InteriorDensityFalloffCurve;                       // 0x0038(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bComputeDirectionDelta;                            // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NextDirectionDeltaAttribute;                       // 0x00C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeCurvature;                                 // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurvatureAttribute;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeSegmentIndex;                              // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SegmentIndexAttribute;                             // 0x00DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeSubsegmentIndex;                           // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SubsegmentIndexAttribute;                          // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeTangents;                                  // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ArriveTangentAttribute;                            // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeaveTangentAttribute;                             // 0x00FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeAlpha;                                     // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AlphaAttribute;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeDistance;                                  // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DistanceAttribute;                                 // 0x0114(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeInputKey;                                  // 0x011C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InputKeyAttribute;                                 // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbounded;                                        // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointSteepness;                                    // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGSplineSamplingSeedingMode                 SeedingMode;                                       // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeedFromLocalPosition;                            // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeedFrom2DPosition;                               // 0x0132(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x5];                                      // 0x0133(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGSplineSamplerParams) == 0x000008, "Wrong alignment on FPCGSplineSamplerParams");
static_assert(sizeof(FPCGSplineSamplerParams) == 0x000138, "Wrong size on FPCGSplineSamplerParams");
static_assert(offsetof(FPCGSplineSamplerParams, Dimension) == 0x000000, "Member 'FPCGSplineSamplerParams::Dimension' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, Mode) == 0x000001, "Member 'FPCGSplineSamplerParams::Mode' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, Fill) == 0x000002, "Member 'FPCGSplineSamplerParams::Fill' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, SubdivisionsPerSegment) == 0x000004, "Member 'FPCGSplineSamplerParams::SubdivisionsPerSegment' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, DistanceIncrement) == 0x000008, "Member 'FPCGSplineSamplerParams::DistanceIncrement' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, NumSamples) == 0x00000C, "Member 'FPCGSplineSamplerParams::NumSamples' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, NumPlanarSubdivisions) == 0x000010, "Member 'FPCGSplineSamplerParams::NumPlanarSubdivisions' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, NumHeightSubdivisions) == 0x000014, "Member 'FPCGSplineSamplerParams::NumHeightSubdivisions' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, StartOffset) == 0x000018, "Member 'FPCGSplineSamplerParams::StartOffset' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, EndOffset) == 0x00001C, "Member 'FPCGSplineSamplerParams::EndOffset' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, MaxRandomOffsetNormalized) == 0x000020, "Member 'FPCGSplineSamplerParams::MaxRandomOffsetNormalized' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bFitToCurve) == 0x000024, "Member 'FPCGSplineSamplerParams::bFitToCurve' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, InteriorSampleSpacing) == 0x000028, "Member 'FPCGSplineSamplerParams::InteriorSampleSpacing' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, InteriorBorderSampleSpacing) == 0x00002C, "Member 'FPCGSplineSamplerParams::InteriorBorderSampleSpacing' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bTreatSplineAsPolyline) == 0x000030, "Member 'FPCGSplineSamplerParams::bTreatSplineAsPolyline' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, InteriorOrientation) == 0x000031, "Member 'FPCGSplineSamplerParams::InteriorOrientation' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bProjectOntoSurface) == 0x000032, "Member 'FPCGSplineSamplerParams::bProjectOntoSurface' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, InteriorDensityFalloffCurve) == 0x000038, "Member 'FPCGSplineSamplerParams::InteriorDensityFalloffCurve' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeDirectionDelta) == 0x0000C0, "Member 'FPCGSplineSamplerParams::bComputeDirectionDelta' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, NextDirectionDeltaAttribute) == 0x0000C4, "Member 'FPCGSplineSamplerParams::NextDirectionDeltaAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeCurvature) == 0x0000CC, "Member 'FPCGSplineSamplerParams::bComputeCurvature' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, CurvatureAttribute) == 0x0000D0, "Member 'FPCGSplineSamplerParams::CurvatureAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeSegmentIndex) == 0x0000D8, "Member 'FPCGSplineSamplerParams::bComputeSegmentIndex' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, SegmentIndexAttribute) == 0x0000DC, "Member 'FPCGSplineSamplerParams::SegmentIndexAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeSubsegmentIndex) == 0x0000E4, "Member 'FPCGSplineSamplerParams::bComputeSubsegmentIndex' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, SubsegmentIndexAttribute) == 0x0000E8, "Member 'FPCGSplineSamplerParams::SubsegmentIndexAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeTangents) == 0x0000F0, "Member 'FPCGSplineSamplerParams::bComputeTangents' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, ArriveTangentAttribute) == 0x0000F4, "Member 'FPCGSplineSamplerParams::ArriveTangentAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, LeaveTangentAttribute) == 0x0000FC, "Member 'FPCGSplineSamplerParams::LeaveTangentAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeAlpha) == 0x000104, "Member 'FPCGSplineSamplerParams::bComputeAlpha' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, AlphaAttribute) == 0x000108, "Member 'FPCGSplineSamplerParams::AlphaAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeDistance) == 0x000110, "Member 'FPCGSplineSamplerParams::bComputeDistance' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, DistanceAttribute) == 0x000114, "Member 'FPCGSplineSamplerParams::DistanceAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bComputeInputKey) == 0x00011C, "Member 'FPCGSplineSamplerParams::bComputeInputKey' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, InputKeyAttribute) == 0x000120, "Member 'FPCGSplineSamplerParams::InputKeyAttribute' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bUnbounded) == 0x000128, "Member 'FPCGSplineSamplerParams::bUnbounded' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, PointSteepness) == 0x00012C, "Member 'FPCGSplineSamplerParams::PointSteepness' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, SeedingMode) == 0x000130, "Member 'FPCGSplineSamplerParams::SeedingMode' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bSeedFromLocalPosition) == 0x000131, "Member 'FPCGSplineSamplerParams::bSeedFromLocalPosition' has a wrong offset!");
static_assert(offsetof(FPCGSplineSamplerParams, bSeedFrom2DPosition) == 0x000132, "Member 'FPCGSplineSamplerParams::bSeedFrom2DPosition' has a wrong offset!");

// ScriptStruct PCG.PCGStackFrame
// 0x0030 (0x0030 - 0x0000)
struct FPCGStackFrame final
{
public:
	TSoftObjectPtr<class UObject>                 Object;                                            // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopIndex;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGStackFrame) == 0x000008, "Wrong alignment on FPCGStackFrame");
static_assert(sizeof(FPCGStackFrame) == 0x000030, "Wrong size on FPCGStackFrame");
static_assert(offsetof(FPCGStackFrame, Object) == 0x000000, "Member 'FPCGStackFrame::Object' has a wrong offset!");
static_assert(offsetof(FPCGStackFrame, LoopIndex) == 0x000028, "Member 'FPCGStackFrame::LoopIndex' has a wrong offset!");

// ScriptStruct PCG.PCGStack
// 0x0018 (0x0018 - 0x0000)
struct FPCGStack final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGStackFrame>                 StackFrames;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPCGStack) == 0x000008, "Wrong alignment on FPCGStack");
static_assert(sizeof(FPCGStack) == 0x000018, "Wrong size on FPCGStack");
static_assert(offsetof(FPCGStack, StackFrames) == 0x000008, "Member 'FPCGStack::StackFrames' has a wrong offset!");

// ScriptStruct PCG.PCGStackContext
// 0x0020 (0x0020 - 0x0000)
struct FPCGStackContext final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGStack>                      Stacks;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         CurrentStackIndex;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGStackContext) == 0x000008, "Wrong alignment on FPCGStackContext");
static_assert(sizeof(FPCGStackContext) == 0x000020, "Wrong size on FPCGStackContext");
static_assert(offsetof(FPCGStackContext, Stacks) == 0x000008, "Member 'FPCGStackContext::Stacks' has a wrong offset!");
static_assert(offsetof(FPCGStackContext, CurrentStackIndex) == 0x000018, "Member 'FPCGStackContext::CurrentStackIndex' has a wrong offset!");

// ScriptStruct PCG.PCGLandscapeLayerWeight
// 0x000C (0x000C - 0x0000)
struct FPCGLandscapeLayerWeight final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGLandscapeLayerWeight) == 0x000004, "Wrong alignment on FPCGLandscapeLayerWeight");
static_assert(sizeof(FPCGLandscapeLayerWeight) == 0x00000C, "Wrong size on FPCGLandscapeLayerWeight");
static_assert(offsetof(FPCGLandscapeLayerWeight, Name) == 0x000000, "Member 'FPCGLandscapeLayerWeight::Name' has a wrong offset!");
static_assert(offsetof(FPCGLandscapeLayerWeight, Weight) == 0x000008, "Member 'FPCGLandscapeLayerWeight::Weight' has a wrong offset!");

// ScriptStruct PCG.PCGPackedCustomData
// 0x0018 (0x0018 - 0x0000)
struct FPCGPackedCustomData final
{
public:
	int32                                         NumCustomDataFloats;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 customData;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPackedCustomData) == 0x000008, "Wrong alignment on FPCGPackedCustomData");
static_assert(sizeof(FPCGPackedCustomData) == 0x000018, "Wrong size on FPCGPackedCustomData");
static_assert(offsetof(FPCGPackedCustomData, NumCustomDataFloats) == 0x000000, "Member 'FPCGPackedCustomData::NumCustomDataFloats' has a wrong offset!");
static_assert(offsetof(FPCGPackedCustomData, customData) == 0x000008, "Member 'FPCGPackedCustomData::customData' has a wrong offset!");

// ScriptStruct PCG.PCGMatchAndSetByAttributeEntry
// 0x02E0 (0x02E0 - 0x0000)
struct FPCGMatchAndSetByAttributeEntry final
{
public:
	struct FPCGMetadataTypesConstantStruct        ValueToMatch;                                      // 0x0000(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPCGMetadataTypesConstantStruct        Value;                                             // 0x0170(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGMatchAndSetByAttributeEntry) == 0x000010, "Wrong alignment on FPCGMatchAndSetByAttributeEntry");
static_assert(sizeof(FPCGMatchAndSetByAttributeEntry) == 0x0002E0, "Wrong size on FPCGMatchAndSetByAttributeEntry");
static_assert(offsetof(FPCGMatchAndSetByAttributeEntry, ValueToMatch) == 0x000000, "Member 'FPCGMatchAndSetByAttributeEntry::ValueToMatch' has a wrong offset!");
static_assert(offsetof(FPCGMatchAndSetByAttributeEntry, Value) == 0x000170, "Member 'FPCGMatchAndSetByAttributeEntry::Value' has a wrong offset!");

// ScriptStruct PCG.PCGMatchAndSetWeightedEntry
// 0x0180 (0x0180 - 0x0000)
struct FPCGMatchAndSetWeightedEntry final
{
public:
	struct FPCGMetadataTypesConstantStruct        Value;                                             // 0x0000(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0xC];                                      // 0x0174(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGMatchAndSetWeightedEntry) == 0x000010, "Wrong alignment on FPCGMatchAndSetWeightedEntry");
static_assert(sizeof(FPCGMatchAndSetWeightedEntry) == 0x000180, "Wrong size on FPCGMatchAndSetWeightedEntry");
static_assert(offsetof(FPCGMatchAndSetWeightedEntry, Value) == 0x000000, "Member 'FPCGMatchAndSetWeightedEntry::Value' has a wrong offset!");
static_assert(offsetof(FPCGMatchAndSetWeightedEntry, Weight) == 0x000170, "Member 'FPCGMatchAndSetWeightedEntry::Weight' has a wrong offset!");

// ScriptStruct PCG.PCGMatchAndSetWeightedByCategoryEntryList
// 0x0190 (0x0190 - 0x0000)
struct FPCGMatchAndSetWeightedByCategoryEntryList final
{
public:
	struct FPCGMetadataTypesConstantStruct        CategoryValue;                                     // 0x0000(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsDefault;                                        // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGMatchAndSetWeightedEntry>   WeightedEntries;                                   // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGMatchAndSetWeightedByCategoryEntryList) == 0x000010, "Wrong alignment on FPCGMatchAndSetWeightedByCategoryEntryList");
static_assert(sizeof(FPCGMatchAndSetWeightedByCategoryEntryList) == 0x000190, "Wrong size on FPCGMatchAndSetWeightedByCategoryEntryList");
static_assert(offsetof(FPCGMatchAndSetWeightedByCategoryEntryList, CategoryValue) == 0x000000, "Member 'FPCGMatchAndSetWeightedByCategoryEntryList::CategoryValue' has a wrong offset!");
static_assert(offsetof(FPCGMatchAndSetWeightedByCategoryEntryList, bIsDefault) == 0x000170, "Member 'FPCGMatchAndSetWeightedByCategoryEntryList::bIsDefault' has a wrong offset!");
static_assert(offsetof(FPCGMatchAndSetWeightedByCategoryEntryList, WeightedEntries) == 0x000178, "Member 'FPCGMatchAndSetWeightedByCategoryEntryList::WeightedEntries' has a wrong offset!");

// ScriptStruct PCG.PCGSoftISMComponentDescriptor
// 0x0010 (0x0248 - 0x0238)
struct FPCGSoftISMComponentDescriptor final : public FSoftISMComponentDescriptor
{
public:
	TArray<class FName>                           ComponentTags;                                     // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGSoftISMComponentDescriptor) == 0x000008, "Wrong alignment on FPCGSoftISMComponentDescriptor");
static_assert(sizeof(FPCGSoftISMComponentDescriptor) == 0x000248, "Wrong size on FPCGSoftISMComponentDescriptor");
static_assert(offsetof(FPCGSoftISMComponentDescriptor, ComponentTags) == 0x000238, "Member 'FPCGSoftISMComponentDescriptor::ComponentTags' has a wrong offset!");

// ScriptStruct PCG.PCGMeshInstanceList
// 0x0278 (0x0278 - 0x0000)
struct FPCGMeshInstanceList final
{
public:
	struct FPCGSoftISMComponentDescriptor         Descriptor;                                        // 0x0000(0x0248)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Instances;                                         // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPCGPointData>           PointData;                                         // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 InstancesIndices;                                  // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGMeshInstanceList) == 0x000008, "Wrong alignment on FPCGMeshInstanceList");
static_assert(sizeof(FPCGMeshInstanceList) == 0x000278, "Wrong size on FPCGMeshInstanceList");
static_assert(offsetof(FPCGMeshInstanceList, Descriptor) == 0x000000, "Member 'FPCGMeshInstanceList::Descriptor' has a wrong offset!");
static_assert(offsetof(FPCGMeshInstanceList, Instances) == 0x000248, "Member 'FPCGMeshInstanceList::Instances' has a wrong offset!");
static_assert(offsetof(FPCGMeshInstanceList, PointData) == 0x000260, "Member 'FPCGMeshInstanceList::PointData' has a wrong offset!");
static_assert(offsetof(FPCGMeshInstanceList, InstancesIndices) == 0x000268, "Member 'FPCGMeshInstanceList::InstancesIndices' has a wrong offset!");

// ScriptStruct PCG.PCGMeshSelectorWeightedEntry
// 0x0250 (0x0250 - 0x0000)
struct FPCGMeshSelectorWeightedEntry final
{
public:
	struct FPCGSoftISMComponentDescriptor         Descriptor;                                        // 0x0000(0x0248)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGMeshSelectorWeightedEntry) == 0x000008, "Wrong alignment on FPCGMeshSelectorWeightedEntry");
static_assert(sizeof(FPCGMeshSelectorWeightedEntry) == 0x000250, "Wrong size on FPCGMeshSelectorWeightedEntry");
static_assert(offsetof(FPCGMeshSelectorWeightedEntry, Descriptor) == 0x000000, "Member 'FPCGMeshSelectorWeightedEntry::Descriptor' has a wrong offset!");
static_assert(offsetof(FPCGMeshSelectorWeightedEntry, Weight) == 0x000248, "Member 'FPCGMeshSelectorWeightedEntry::Weight' has a wrong offset!");

// ScriptStruct PCG.PCGWeightedByCategoryEntryList
// 0x0028 (0x0028 - 0x0000)
struct FPCGWeightedByCategoryEntryList final
{
public:
	class FString                                 CategoryEntry;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDefault;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGMeshSelectorWeightedEntry>  WeightedMeshEntries;                               // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGWeightedByCategoryEntryList) == 0x000008, "Wrong alignment on FPCGWeightedByCategoryEntryList");
static_assert(sizeof(FPCGWeightedByCategoryEntryList) == 0x000028, "Wrong size on FPCGWeightedByCategoryEntryList");
static_assert(offsetof(FPCGWeightedByCategoryEntryList, CategoryEntry) == 0x000000, "Member 'FPCGWeightedByCategoryEntryList::CategoryEntry' has a wrong offset!");
static_assert(offsetof(FPCGWeightedByCategoryEntryList, IsDefault) == 0x000010, "Member 'FPCGWeightedByCategoryEntryList::IsDefault' has a wrong offset!");
static_assert(offsetof(FPCGWeightedByCategoryEntryList, WeightedMeshEntries) == 0x000018, "Member 'FPCGWeightedByCategoryEntryList::WeightedMeshEntries' has a wrong offset!");

// ScriptStruct PCG.PCGComponentInstanceData
// 0x0008 (0x0070 - 0x0068)
struct FPCGComponentInstanceData final : public FActorComponentInstanceData
{
public:
	class UPCGComponent*                          SourceComponent;                                   // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPCGComponentInstanceData) == 0x000008, "Wrong alignment on FPCGComponentInstanceData");
static_assert(sizeof(FPCGComponentInstanceData) == 0x000070, "Wrong size on FPCGComponentInstanceData");
static_assert(offsetof(FPCGComponentInstanceData, SourceComponent) == 0x000068, "Member 'FPCGComponentInstanceData::SourceComponent' has a wrong offset!");

// ScriptStruct PCG.PCGDebugVisualizationSettings
// 0x0058 (0x0058 - 0x0000)
struct FPCGDebugVisualizationSettings final
{
public:
	float                                         PointScale;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGDebugVisScaleMethod                       ScaleMethod;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             PointMesh;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      MaterialOverride;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGDebugVisualizationSettings) == 0x000008, "Wrong alignment on FPCGDebugVisualizationSettings");
static_assert(sizeof(FPCGDebugVisualizationSettings) == 0x000058, "Wrong size on FPCGDebugVisualizationSettings");
static_assert(offsetof(FPCGDebugVisualizationSettings, PointScale) == 0x000000, "Member 'FPCGDebugVisualizationSettings::PointScale' has a wrong offset!");
static_assert(offsetof(FPCGDebugVisualizationSettings, ScaleMethod) == 0x000004, "Member 'FPCGDebugVisualizationSettings::ScaleMethod' has a wrong offset!");
static_assert(offsetof(FPCGDebugVisualizationSettings, PointMesh) == 0x000008, "Member 'FPCGDebugVisualizationSettings::PointMesh' has a wrong offset!");
static_assert(offsetof(FPCGDebugVisualizationSettings, MaterialOverride) == 0x000030, "Member 'FPCGDebugVisualizationSettings::MaterialOverride' has a wrong offset!");

// ScriptStruct PCG.PCGOverrideInstancedPropertyBag
// 0x0060 (0x0060 - 0x0000)
struct FPCGOverrideInstancedPropertyBag final
{
public:
	struct FInstancedPropertyBag                  Parameters;                                        // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            PropertiesIDsOverridden;                           // 0x0010(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGOverrideInstancedPropertyBag) == 0x000008, "Wrong alignment on FPCGOverrideInstancedPropertyBag");
static_assert(sizeof(FPCGOverrideInstancedPropertyBag) == 0x000060, "Wrong size on FPCGOverrideInstancedPropertyBag");
static_assert(offsetof(FPCGOverrideInstancedPropertyBag, Parameters) == 0x000000, "Member 'FPCGOverrideInstancedPropertyBag::Parameters' has a wrong offset!");
static_assert(offsetof(FPCGOverrideInstancedPropertyBag, PropertiesIDsOverridden) == 0x000010, "Member 'FPCGOverrideInstancedPropertyBag::PropertiesIDsOverridden' has a wrong offset!");

// ScriptStruct PCG.PCGPoint
// 0x00D0 (0x00D0 - 0x0000)
struct FPCGPoint final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Density;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundsMin;                                         // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundsMax;                                         // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Color;                                             // 0x00A0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Steepness;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MetadataEntry;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPoint) == 0x000010, "Wrong alignment on FPCGPoint");
static_assert(sizeof(FPCGPoint) == 0x0000D0, "Wrong size on FPCGPoint");
static_assert(offsetof(FPCGPoint, Transform) == 0x000000, "Member 'FPCGPoint::Transform' has a wrong offset!");
static_assert(offsetof(FPCGPoint, Density) == 0x000060, "Member 'FPCGPoint::Density' has a wrong offset!");
static_assert(offsetof(FPCGPoint, BoundsMin) == 0x000068, "Member 'FPCGPoint::BoundsMin' has a wrong offset!");
static_assert(offsetof(FPCGPoint, BoundsMax) == 0x000080, "Member 'FPCGPoint::BoundsMax' has a wrong offset!");
static_assert(offsetof(FPCGPoint, Color) == 0x0000A0, "Member 'FPCGPoint::Color' has a wrong offset!");
static_assert(offsetof(FPCGPoint, Steepness) == 0x0000C0, "Member 'FPCGPoint::Steepness' has a wrong offset!");
static_assert(offsetof(FPCGPoint, Seed) == 0x0000C4, "Member 'FPCGPoint::Seed' has a wrong offset!");
static_assert(offsetof(FPCGPoint, MetadataEntry) == 0x0000C8, "Member 'FPCGPoint::MetadataEntry' has a wrong offset!");

// ScriptStruct PCG.PCGPropertyAliases
// 0x0010 (0x0010 - 0x0000)
struct FPCGPropertyAliases final
{
public:
	TArray<class FName>                           Aliases;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPropertyAliases) == 0x000008, "Wrong alignment on FPCGPropertyAliases");
static_assert(sizeof(FPCGPropertyAliases) == 0x000010, "Wrong size on FPCGPropertyAliases");
static_assert(offsetof(FPCGPropertyAliases, Aliases) == 0x000000, "Member 'FPCGPropertyAliases::Aliases' has a wrong offset!");

// ScriptStruct PCG.PCGSettingsOverridableParam
// 0x0088 (0x0088 - 0x0000)
struct FPCGSettingsOverridableParam final
{
public:
	class FName                                   Label;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PropertiesNames;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UStruct*                                PropertyClass;                                     // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FPCGPropertyAliases>       MapOfAliases;                                      // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bHasNameClash;                                     // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x17];                                      // 0x0071(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGSettingsOverridableParam) == 0x000008, "Wrong alignment on FPCGSettingsOverridableParam");
static_assert(sizeof(FPCGSettingsOverridableParam) == 0x000088, "Wrong size on FPCGSettingsOverridableParam");
static_assert(offsetof(FPCGSettingsOverridableParam, Label) == 0x000000, "Member 'FPCGSettingsOverridableParam::Label' has a wrong offset!");
static_assert(offsetof(FPCGSettingsOverridableParam, PropertiesNames) == 0x000008, "Member 'FPCGSettingsOverridableParam::PropertiesNames' has a wrong offset!");
static_assert(offsetof(FPCGSettingsOverridableParam, PropertyClass) == 0x000018, "Member 'FPCGSettingsOverridableParam::PropertyClass' has a wrong offset!");
static_assert(offsetof(FPCGSettingsOverridableParam, MapOfAliases) == 0x000020, "Member 'FPCGSettingsOverridableParam::MapOfAliases' has a wrong offset!");
static_assert(offsetof(FPCGSettingsOverridableParam, bHasNameClash) == 0x000070, "Member 'FPCGSettingsOverridableParam::bHasNameClash' has a wrong offset!");

// ScriptStruct PCG.PCGPreConfiguredSettingsInfo
// 0x0018 (0x0018 - 0x0000)
struct FPCGPreConfiguredSettingsInfo final
{
public:
	int32                                         PreconfiguredIndex;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Label;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGPreConfiguredSettingsInfo) == 0x000008, "Wrong alignment on FPCGPreConfiguredSettingsInfo");
static_assert(sizeof(FPCGPreConfiguredSettingsInfo) == 0x000018, "Wrong size on FPCGPreConfiguredSettingsInfo");
static_assert(offsetof(FPCGPreConfiguredSettingsInfo, PreconfiguredIndex) == 0x000000, "Member 'FPCGPreConfiguredSettingsInfo::PreconfiguredIndex' has a wrong offset!");
static_assert(offsetof(FPCGPreConfiguredSettingsInfo, Label) == 0x000008, "Member 'FPCGPreConfiguredSettingsInfo::Label' has a wrong offset!");

// ScriptStruct PCG.DeterminismTestResult
// 0x0090 (0x0090 - 0x0000)
struct FDeterminismTestResult final
{
public:
	int64                                         Index;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TestResultTitle;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestResultName;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGDataType                                  DataTypesTested;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, EDeterminismLevel>          TestResults;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalDetails;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bFlagRaised;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeterminismTestResult) == 0x000008, "Wrong alignment on FDeterminismTestResult");
static_assert(sizeof(FDeterminismTestResult) == 0x000090, "Wrong size on FDeterminismTestResult");
static_assert(offsetof(FDeterminismTestResult, Index) == 0x000000, "Member 'FDeterminismTestResult::Index' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, TestResultTitle) == 0x000008, "Member 'FDeterminismTestResult::TestResultTitle' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, TestResultName) == 0x000010, "Member 'FDeterminismTestResult::TestResultName' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, Seed) == 0x000020, "Member 'FDeterminismTestResult::Seed' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, DataTypesTested) == 0x000024, "Member 'FDeterminismTestResult::DataTypesTested' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, TestResults) == 0x000028, "Member 'FDeterminismTestResult::TestResults' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, AdditionalDetails) == 0x000078, "Member 'FDeterminismTestResult::AdditionalDetails' has a wrong offset!");
static_assert(offsetof(FDeterminismTestResult, bFlagRaised) == 0x000088, "Member 'FDeterminismTestResult::bFlagRaised' has a wrong offset!");

}

