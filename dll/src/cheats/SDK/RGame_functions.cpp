#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RGame

#include "Basic.hpp"

#include "RGame_classes.hpp"
#include "RGame_parameters.hpp"


namespace SDK
{

// Function RGame.RPawnBase.GetIsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPawnBase::GetIsAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetIsAlive");

	Params::RPawnBase_GetIsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnBase.OnDamageCombatEvent
// (Final, Native, Public)
// Parameters:
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARPawnBase::OnDamageCombatEvent(const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "OnDamageCombatEvent");

	Params::RPawnBase_OnDamageCombatEvent Parms{};

	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnBase.OnRep_ServerPawnName
// (Final, Native, Private)

void ARPawnBase::OnRep_ServerPawnName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "OnRep_ServerPawnName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnBase.GetCapsuleComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCapsuleComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* ARPawnBase::GetCapsuleComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetCapsuleComponent");

	Params::RPawnBase_GetCapsuleComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnBase.GetGScriptCategory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARPawnBase::GetGScriptCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetGScriptCategory");

	Params::RPawnBase_GetGScriptCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnBase.GetGScriptComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* ARPawnBase::GetGScriptComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetGScriptComponent");

	Params::RPawnBase_GetGScriptComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnBase.GetHealthComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URHealthComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URHealthComponent* ARPawnBase::GetHealthComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetHealthComponent");

	Params::RPawnBase_GetHealthComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnBase.GetRPawnMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URPawnMovementComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URPawnMovementComponent* ARPawnBase::GetRPawnMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetRPawnMovementComponent");

	Params::RPawnBase_GetRPawnMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnBase.GetSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ARPawnBase::GetSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnBase", "GetSkeletalMeshComponent");

	Params::RPawnBase_GetSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetEquippedWeaponCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARPlayerPawn::GetEquippedWeaponCategory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerPawn", "GetEquippedWeaponCategory");

	Params::RPlayerPawn_GetEquippedWeaponCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.AddGameplayTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              NewGameplayTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddGameplayTag(const struct FGameplayTag& NewGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddGameplayTag");

	Params::RPlayerPawn_AddGameplayTag Parms{};

	Parms.NewGameplayTag = std::move(NewGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddPawnDownedWidget
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::AddPawnDownedWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddPawnDownedWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddPingInputBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddPingInputBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddPingInputBlock");

	Params::RPlayerPawn_AddPingInputBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddPostProcessMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APostProcessVolume*               Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               MaterialParent                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* ARPlayerPawn::AddPostProcessMaterial(class APostProcessVolume* Volume, class UMaterialInterface* MaterialParent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddPostProcessMaterial");

	Params::RPlayerPawn_AddPostProcessMaterial Parms{};

	Parms.Volume = Volume;
	Parms.MaterialParent = MaterialParent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.AddRecoil
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Recoil                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddRecoil(const struct FRotator& Recoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddRecoil");

	Params::RPlayerPawn_AddRecoil Parms{};

	Parms.Recoil = std::move(Recoil);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddRespawnLocationUpdateBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddRespawnLocationUpdateBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddRespawnLocationUpdateBlock");

	Params::RPlayerPawn_AddRespawnLocationUpdateBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddRoomObjectiveItemsHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddRoomObjectiveItemsHeld(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddRoomObjectiveItemsHeld");

	Params::RPlayerPawn_AddRoomObjectiveItemsHeld Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddRotationInputBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddRotationInputBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddRotationInputBlock");

	Params::RPlayerPawn_AddRotationInputBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddTemporaryInputBlockers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockControlInput                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockInputPhysics                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockDash                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockJump                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddTemporaryInputBlockers(class FName Key, bool bBlockControlInput, bool bBlockInputPhysics, bool bBlockDash, bool bBlockJump, bool bBlockRotation, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddTemporaryInputBlockers");

	Params::RPlayerPawn_AddTemporaryInputBlockers Parms{};

	Parms.Key = Key;
	Parms.bBlockControlInput = bBlockControlInput;
	Parms.bBlockInputPhysics = bBlockInputPhysics;
	Parms.bBlockDash = bBlockDash;
	Parms.bBlockJump = bBlockJump;
	Parms.bBlockRotation = bBlockRotation;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AddWeaponVisibilityBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AddWeaponVisibilityBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AddWeaponVisibilityBlock");

	Params::RPlayerPawn_AddWeaponVisibilityBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.AnimEvent_Multicast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::AnimEvent_Multicast(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "AnimEvent_Multicast");

	Params::RPlayerPawn_AnimEvent_Multicast Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.BroadcastOnPlayerBrokePot_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::BroadcastOnPlayerBrokePot_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "BroadcastOnPlayerBrokePot_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.CallOnPlayerAreaAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FHitResult>&        Hits                                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARPlayerPawn::CallOnPlayerAreaAttack(const TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "CallOnPlayerAreaAttack");

	Params::RPlayerPawn_CallOnPlayerAreaAttack Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.CallOnPlayerLesserAreaAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FHitResult>&        Hits                                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARPlayerPawn::CallOnPlayerLesserAreaAttack(const TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "CallOnPlayerLesserAreaAttack");

	Params::RPlayerPawn_CallOnPlayerLesserAreaAttack Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.CallOnPlayerPickedUpSoulFragment
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::CallOnPlayerPickedUpSoulFragment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "CallOnPlayerPickedUpSoulFragment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.CancelFadeOutTeleport
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::CancelFadeOutTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "CancelFadeOutTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ClearAllInputBlockers
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::ClearAllInputBlockers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ClearAllInputBlockers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ClearDownedState
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::ClearDownedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ClearDownedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ClearPingInputBlocks
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::ClearPingInputBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ClearPingInputBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ClearRotationInputBlocks
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::ClearRotationInputBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ClearRotationInputBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ClearWeaponVisibilityBlocks
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::ClearWeaponVisibilityBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ClearWeaponVisibilityBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.DisableActionsWhenDowned
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::DisableActionsWhenDowned(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "DisableActionsWhenDowned");

	Params::RPlayerPawn_DisableActionsWhenDowned Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.EmoteCameraZoomOutImplementation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPlayerPawn::EmoteCameraZoomOutImplementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "EmoteCameraZoomOutImplementation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPlayerPawn.EmoteMontageEnded
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPlayerPawn::EmoteMontageEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "EmoteMontageEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPlayerPawn.EnableActionsWhenRevived
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::EnableActionsWhenRevived(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "EnableActionsWhenRevived");

	Params::RPlayerPawn_EnableActionsWhenRevived Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.EnterCombat
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::EnterCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "EnterCombat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.GetCharacterMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceDynamic*> ARPlayerPawn::GetCharacterMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetCharacterMaterials");

	Params::RPlayerPawn_GetCharacterMaterials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetCrosshairWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector*                         WorldLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::GetCrosshairWorldTransform(struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetCrosshairWorldTransform");

	Params::RPlayerPawn_GetCrosshairWorldTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);
}


// Function RGame.RPlayerPawn.GetCurrentWeaponScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGWeaponScript*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGWeaponScript* ARPlayerPawn::GetCurrentWeaponScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetCurrentWeaponScript");

	Params::RPlayerPawn_GetCurrentWeaponScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetMutatorRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARPlayerPawn::GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetMutatorRank");

	Params::RPlayerPawn_GetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetMuzzleLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARPlayerPawn::GetMuzzleLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetMuzzleLocation");

	Params::RPlayerPawn_GetMuzzleLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetPawnViewTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ARPlayerPawn::GetPawnViewTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetPawnViewTransform");

	Params::RPlayerPawn_GetPawnViewTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetPawnWorldViewTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector*                         WorldLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::GetPawnWorldViewTransform(struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetPawnWorldViewTransform");

	Params::RPlayerPawn_GetPawnWorldViewTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);
}


// Function RGame.RPlayerPawn.GetPlayerColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ARPlayerPawn::GetPlayerColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetPlayerColor");

	Params::RPlayerPawn_GetPlayerColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetReviveCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARPlayerPawn::GetReviveCastTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetReviveCastTime");

	Params::RPlayerPawn_GetReviveCastTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetReviveHealthCostPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARPlayerPawn::GetReviveHealthCostPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetReviveHealthCostPercentage");

	Params::RPlayerPawn_GetReviveHealthCostPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.HandleInputMethodChanged
// (Final, Native, Private)
// Parameters:
// ECommonInputType                        NewInputType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::HandleInputMethodChanged(ECommonInputType NewInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "HandleInputMethodChanged");

	Params::RPlayerPawn_HandleInputMethodChanged Parms{};

	Parms.NewInputType = NewInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.HasGameplayTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::HasGameplayTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "HasGameplayTag");

	Params::RPlayerPawn_HasGameplayTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.InterruptEmote
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPlayerPawn::InterruptEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "InterruptEmote");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPlayerPawn.IsInEmoteState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::IsInEmoteState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "IsInEmoteState");

	Params::RPlayerPawn_IsInEmoteState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.LeaveCombat
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::LeaveCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "LeaveCombat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnAbilityActivate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnAbilityActivate(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnAbilityActivate");

	Params::RPlayerPawn_OnAbilityActivate Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnAbilityReleased
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnAbilityReleased(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnAbilityReleased");

	Params::RPlayerPawn_OnAbilityReleased Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnEnemyKilled
// (Final, Native, Protected)
// Parameters:
// class ARNPCPawnBase*                    EnemyPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnEnemyKilled(class ARNPCPawnBase* EnemyPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnEnemyKilled");

	Params::RPlayerPawn_OnEnemyKilled Parms{};

	Parms.EnemyPawn = EnemyPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnFire
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::OnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnLevelChanged
// (Final, Native, Protected)

void ARPlayerPawn::OnLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerFellOutOfWorld_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::OnPlayerFellOutOfWorld_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerFellOutOfWorld_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerPawnDowned_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::OnPlayerPawnDowned_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerPawnDowned_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerPawnKilled_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::OnPlayerPawnKilled_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerPawnKilled_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerPawnRespawned_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::OnPlayerPawnRespawned_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerPawnRespawned_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerPawnRevived_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::OnPlayerPawnRevived_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerPawnRevived_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerStartTeleport_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ARPlayerPawn::OnPlayerStartTeleport_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerStartTeleport_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerTeleported_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnPlayerTeleported_Multicast(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerTeleported_Multicast");

	Params::RPlayerPawn_OnPlayerTeleported_Multicast Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPlayerWeaponModFired
// (Final, Native, Public)
// Parameters:
// bool                                    IsPrimaryMod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnPlayerWeaponModFired(bool IsPrimaryMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPlayerWeaponModFired");

	Params::RPlayerPawn_OnPlayerWeaponModFired Parms{};

	Parms.IsPrimaryMod = IsPrimaryMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnPostProcessVolumeAssigned
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APostProcessVolume*               Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnPostProcessVolumeAssigned(class APostProcessVolume* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPostProcessVolumeAssigned");

	Params::RPlayerPawn_OnPostProcessVolumeAssigned Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.OnPreLevelChanged
// (Final, Native, Protected)

void ARPlayerPawn::OnPreLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnPreLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnReleasedReload
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::OnReleasedReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnReleasedReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnReleaseFire
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::OnReleaseFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnReleaseFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnReleaseSecondaryFire
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::OnReleaseSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnReleaseSecondaryFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnReload
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::OnReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRep_CosmeticLoadout
// (Final, Native, Private)

void ARPlayerPawn::OnRep_CosmeticLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRep_CosmeticLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRep_EquippedWeapon
// (Final, Native, Private)

void ARPlayerPawn::OnRep_EquippedWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRep_EquippedWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRep_MeshHueShift
// (Final, Native, Private)

void ARPlayerPawn::OnRep_MeshHueShift()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRep_MeshHueShift");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRevivedCastFinished_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARPlayerPawn*                     RevivingPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnRevivedCastFinished_Multicast(class ARPlayerPawn* RevivingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRevivedCastFinished_Multicast");

	Params::RPlayerPawn_OnRevivedCastFinished_Multicast Parms{};

	Parms.RevivingPlayer = RevivingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRevivedCastInterrupted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARPlayerPawn*                     RevivingPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnRevivedCastInterrupted_Multicast(class ARPlayerPawn* RevivingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRevivedCastInterrupted_Multicast");

	Params::RPlayerPawn_OnRevivedCastInterrupted_Multicast Parms{};

	Parms.RevivingPlayer = RevivingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRevivedCastStarted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARPlayerPawn*                     RevivingPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CastTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentCastTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnRevivedCastStarted_Multicast(class ARPlayerPawn* RevivingPlayer, float CastTime, float CurrentCastTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRevivedCastStarted_Multicast");

	Params::RPlayerPawn_OnRevivedCastStarted_Multicast Parms{};

	Parms.RevivingPlayer = RevivingPlayer;
	Parms.CastTime = CastTime;
	Parms.CurrentCastTime = CurrentCastTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRevivingPlayerHealthDepleted
// (Final, Native, Protected)
// Parameters:
// class URHealthComponent*                RevivingPlayerHealthComponent                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnRevivingPlayerHealthDepleted(class URHealthComponent* RevivingPlayerHealthComponent, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRevivingPlayerHealthDepleted");

	Params::RPlayerPawn_OnRevivingPlayerHealthDepleted Parms{};

	Parms.RevivingPlayerHealthComponent = RevivingPlayerHealthComponent;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRevivingPlayerMovement
// (Final, Native, Protected)
// Parameters:
// class ARPawnBase*                       Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnRevivingPlayerMovement(class ARPawnBase* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRevivingPlayerMovement");

	Params::RPlayerPawn_OnRevivingPlayerMovement Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRevivingPlayerWeaponModFired
// (Final, Native, Protected)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPrimaryFire                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnRevivingPlayerWeaponModFired(class ARPlayerPawn* Player, bool IsPrimaryFire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRevivingPlayerWeaponModFired");

	Params::RPlayerPawn_OnRevivingPlayerWeaponModFired Parms{};

	Parms.Player = Player;
	Parms.IsPrimaryFire = IsPrimaryFire;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnRunStarted
// (Final, Native, Private)

void ARPlayerPawn::OnRunStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnRunStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnSecondaryFire
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::OnSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnSecondaryFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnSegmentCompleted
// (Final, Native, Protected)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnSegmentCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnSegmentCompleted");

	Params::RPlayerPawn_OnSegmentCompleted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnSegmentStarted
// (Final, Native, Protected)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnSegmentStarted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnSegmentStarted");

	Params::RPlayerPawn_OnSegmentStarted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnWidgetPushed
// (Final, Native, Private)
// Parameters:
// class URCommonActivatableWidget*        Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::OnWidgetPushed(class URCommonActivatableWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnWidgetPushed");

	Params::RPlayerPawn_OnWidgetPushed Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.OnWidgetPushedDelayed
// (Final, Native, Private)

void ARPlayerPawn::OnWidgetPushedDelayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "OnWidgetPushedDelayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.PlayCameraShakeIfLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     ShakeClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               DecalMaterial                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   SystemTemplate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ShouldAutoPoolNiagara                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENCPoolMethod                     PoolingMethod                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::PlayCameraShakeIfLocalPlayer(TSubclassOf<class UCameraShakeBase> ShakeClass, class UMaterialInterface* DecalMaterial, class UNiagaraSystem* SystemTemplate, class USoundBase* Sound, const bool ShouldAutoPoolNiagara, const ENCPoolMethod PoolingMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayCameraShakeIfLocalPlayer");

	Params::RPlayerPawn_PlayCameraShakeIfLocalPlayer Parms{};

	Parms.ShakeClass = ShakeClass;
	Parms.DecalMaterial = DecalMaterial;
	Parms.SystemTemplate = SystemTemplate;
	Parms.Sound = Sound;
	Parms.ShouldAutoPoolNiagara = ShouldAutoPoolNiagara;
	Parms.PoolingMethod = PoolingMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.PlayDoorTeleportTimeline
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayDoorTeleportTimeline(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayDoorTeleportTimeline");

	Params::RPlayerPawn_PlayDoorTeleportTimeline Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.PlayEmote
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       EmoteName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayEmote(const class FName EmoteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayEmote");

	Params::RPlayerPawn_PlayEmote Parms{};

	Parms.EmoteName = EmoteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.PlayEmote_Multicast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// const class FName                       EmoteName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayEmote_Multicast(const class FName EmoteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayEmote_Multicast");

	Params::RPlayerPawn_PlayEmote_Multicast Parms{};

	Parms.EmoteName = EmoteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.PlayEmote_Server
// (Net, Native, Event, Public, NetServer)
// Parameters:
// const class FName                       EmoteName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayEmote_Server(const class FName EmoteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayEmote_Server");

	Params::RPlayerPawn_PlayEmote_Server Parms{};

	Parms.EmoteName = EmoteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.PlayEmoteMontage
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FName                       EmoteName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayEmoteMontage(const class FName EmoteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayEmoteMontage");

	Params::RPlayerPawn_PlayEmoteMontage Parms{};

	Parms.EmoteName = EmoteName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.PlayPostProcessDamageTaken
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayPostProcessDamageTaken(const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayPostProcessDamageTaken");

	Params::RPlayerPawn_PlayPostProcessDamageTaken Parms{};

	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.PlayVignetteTimeline
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             IntensityMultiplier                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayVignetteTimeline(const float Duration, const float IntensityMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayVignetteTimeline");

	Params::RPlayerPawn_PlayVignetteTimeline Parms{};

	Parms.Duration = Duration;
	Parms.IntensityMultiplier = IntensityMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.PlayVoiceLine
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName                       Event                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVoiceQueryDataPair>&EventData                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayVoiceLine(const class FName Event, const TArray<struct FVoiceQueryDataPair>& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayVoiceLine");

	Params::RPlayerPawn_PlayVoiceLine Parms{};

	Parms.Event = Event;
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.PlayVoiceLine_Server
// (Net, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class FName                       Event                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVoiceQueryDataPair>&EventData                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARPlayerPawn::PlayVoiceLine_Server(const class FName Event, const TArray<struct FVoiceQueryDataPair>& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "PlayVoiceLine_Server");

	Params::RPlayerPawn_PlayVoiceLine_Server Parms{};

	Parms.Event = Event;
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RemoveGameplayTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTimerHandle&              TimerHandle                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::RemoveGameplayTag(const struct FGameplayTag& GameplayTag, const struct FTimerHandle& TimerHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RemoveGameplayTag");

	Params::RPlayerPawn_RemoveGameplayTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.TimerHandle = std::move(TimerHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RemovePawnDownedWidget
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::RemovePawnDownedWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RemovePawnDownedWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RemovePingInputBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::RemovePingInputBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RemovePingInputBlock");

	Params::RPlayerPawn_RemovePingInputBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RemoveRespawnLocationUpdateBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::RemoveRespawnLocationUpdateBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RemoveRespawnLocationUpdateBlock");

	Params::RPlayerPawn_RemoveRespawnLocationUpdateBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RemoveRotationInputBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::RemoveRotationInputBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RemoveRotationInputBlock");

	Params::RPlayerPawn_RemoveRotationInputBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RemoveWeaponVisibilityBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::RemoveWeaponVisibilityBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RemoveWeaponVisibilityBlock");

	Params::RPlayerPawn_RemoveWeaponVisibilityBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ResetEnvironmentFX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Param                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ResetEnvironmentFX(const class FName ParameterName, const float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ResetEnvironmentFX");

	Params::RPlayerPawn_ResetEnvironmentFX Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ResetRoomObjectiveItemsHeld_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ARPlayerPawn::ResetRoomObjectiveItemsHeld_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ResetRoomObjectiveItemsHeld_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.RevivePlayer
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::RevivePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "RevivePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnAbilityActivate
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ServerOnAbilityActivate(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnAbilityActivate");

	Params::RPlayerPawn_ServerOnAbilityActivate Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnAbilityReleased
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ServerOnAbilityReleased(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnAbilityReleased");

	Params::RPlayerPawn_ServerOnAbilityReleased Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnFire
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ServerOnFire(int32 CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnFire");

	Params::RPlayerPawn_ServerOnFire Parms{};

	Parms.CurrentAmmo = CurrentAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnReleaseFire
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// uint32                                  LastProjectileId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ServerOnReleaseFire(uint32 LastProjectileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnReleaseFire");

	Params::RPlayerPawn_ServerOnReleaseFire Parms{};

	Parms.LastProjectileId = LastProjectileId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnReleaseSecondaryFire
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// uint32                                  LastProjectileId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ServerOnReleaseSecondaryFire(uint32 LastProjectileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnReleaseSecondaryFire");

	Params::RPlayerPawn_ServerOnReleaseSecondaryFire Parms{};

	Parms.LastProjectileId = LastProjectileId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnReload
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ARPlayerPawn::ServerOnReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ServerOnSecondaryFire
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ServerOnSecondaryFire(int32 CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ServerOnSecondaryFire");

	Params::RPlayerPawn_ServerOnSecondaryFire Parms{};

	Parms.CurrentAmmo = CurrentAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SetFOV(float FOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetFOV");

	Params::RPlayerPawn_SetFOV Parms{};

	Parms.FOV = FOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetLocationAndRotation_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARPlayerPawn::SetLocationAndRotation_Multicast(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetLocationAndRotation_Multicast");

	Params::RPlayerPawn_SetLocationAndRotation_Multicast Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetLookUpRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SetLookUpRate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetLookUpRate");

	Params::RPlayerPawn_SetLookUpRate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetMutatorRank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewRank                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 NewRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetMutatorRank");

	Params::RPlayerPawn_SetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.NewRank = NewRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetPlayerAliveRevive_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARPlayerPawn::SetPlayerAliveRevive_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetPlayerAliveRevive_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetSyringeVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ARPlayerPawn::SetSyringeVisibility(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetSyringeVisibility");

	Params::RPlayerPawn_SetSyringeVisibility Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.SetTurnRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SetTurnRate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetTurnRate");

	Params::RPlayerPawn_SetTurnRate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SetUpEventBinds
// (Final, Native, Protected)

void ARPlayerPawn::SetUpEventBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SetUpEventBinds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ShowDownedHighlighting
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bNewShow                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ShowDownedHighlighting(const bool bNewShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ShowDownedHighlighting");

	Params::RPlayerPawn_ShowDownedHighlighting Parms{};

	Parms.bNewShow = bNewShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SimulateMoveForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SimulateMoveForward(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SimulateMoveForward");

	Params::RPlayerPawn_SimulateMoveForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SpawnVoiceLine
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVoiceData&                VoiceOverData                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SpawnVoiceLine(const struct FVoiceData& VoiceOverData, const float Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SpawnVoiceLine");

	Params::RPlayerPawn_SpawnVoiceLine Parms{};

	Parms.VoiceOverData = std::move(VoiceOverData);
	Parms.Priority = Priority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.SpawnVoiceLine_Multicast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// const class FName                       Event                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             VariationsIndex                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::SpawnVoiceLine_Multicast(const class FName Event, const float Priority, const int32 VariationsIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SpawnVoiceLine_Multicast");

	Params::RPlayerPawn_SpawnVoiceLine_Multicast Parms{};

	Parms.Event = Event;
	Parms.Priority = Priority;
	Parms.VariationsIndex = VariationsIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.StartFadeOutTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::StartFadeOutTeleport(float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "StartFadeOutTeleport");

	Params::RPlayerPawn_StartFadeOutTeleport Parms{};

	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.StartVoiceLineCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::StartVoiceLineCooldown(const float Time, const float Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "StartVoiceLineCooldown");

	Params::RPlayerPawn_StartVoiceLineCooldown Parms{};

	Parms.Time = Time;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.SweepMeleeHitActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RangeOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> ARPlayerPawn::SweepMeleeHitActors(float RangeOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "SweepMeleeHitActors");

	Params::RPlayerPawn_SweepMeleeHitActors Parms{};

	Parms.RangeOverride = RangeOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.ToggleAbilityVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    AnchorVisibility                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DropShieldVisibility                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AtlanteanCubeVisibility                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ToggleAbilityVisibility(bool AnchorVisibility, bool DropShieldVisibility, bool AtlanteanCubeVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ToggleAbilityVisibility");

	Params::RPlayerPawn_ToggleAbilityVisibility Parms{};

	Parms.AnchorVisibility = AnchorVisibility;
	Parms.DropShieldVisibility = DropShieldVisibility;
	Parms.AtlanteanCubeVisibility = AtlanteanCubeVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.ToggleElementalPostProcessVisual
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ToggleElementalPostProcessVisual(const class FName ParameterName, const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ToggleElementalPostProcessVisual");

	Params::RPlayerPawn_ToggleElementalPostProcessVisual Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.TogglePayload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::TogglePayload(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "TogglePayload");

	Params::RPlayerPawn_TogglePayload Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ToggleShowPingInfo
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::ToggleShowPingInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ToggleShowPingInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ToggleUnderwaterPostProcessVisual
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bVisible                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ToggleUnderwaterPostProcessVisual(const bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ToggleUnderwaterPostProcessVisual");

	Params::RPlayerPawn_ToggleUnderwaterPostProcessVisual Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ToggleWeaponVisibilities
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNewMeleeVisibility                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWeaponVisibility                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideOnServer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ToggleWeaponVisibilities(bool bNewMeleeVisibility, bool bNewWeaponVisibility, class FName Key, bool bHideOnServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ToggleWeaponVisibilities");

	Params::RPlayerPawn_ToggleWeaponVisibilities Parms{};

	Parms.bNewMeleeVisibility = bNewMeleeVisibility;
	Parms.bNewWeaponVisibility = bNewWeaponVisibility;
	Parms.Key = Key;
	Parms.bHideOnServer = bHideOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.ToggleWeaponVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    MeleeNewVisibility                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PrimaryNewVisibility                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::ToggleWeaponVisibility(bool MeleeNewVisibility, bool PrimaryNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "ToggleWeaponVisibility");

	Params::RPlayerPawn_ToggleWeaponVisibility Parms{};

	Parms.MeleeNewVisibility = MeleeNewVisibility;
	Parms.PrimaryNewVisibility = PrimaryNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerPawn.TryUpdatePlayerResetPosition
// (Final, Native, Private)

void ARPlayerPawn::TryUpdatePlayerResetPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "TryUpdatePlayerResetPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.UndrawPingOnSelf
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPlayerPawn::UndrawPingOnSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "UndrawPingOnSelf");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPlayerPawn.UnequipWeapon
// (Native, Public, BlueprintCallable)
// Parameters:
// class ARWeapon*                         Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerPawn::UnequipWeapon(class ARWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "UnequipWeapon");

	Params::RPlayerPawn_UnequipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.UpdatePlayerMesh
// (Final, Native, Public, BlueprintCallable)

void ARPlayerPawn::UpdatePlayerMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "UpdatePlayerMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerPawn.GetArmsSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ARPlayerPawn::GetArmsSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetArmsSkeletalMeshComponent");

	Params::RPlayerPawn_GetArmsSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetDefaultArmsMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ARPlayerPawn::GetDefaultArmsMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetDefaultArmsMontage");

	Params::RPlayerPawn_GetDefaultArmsMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetDefaultArmsMontageAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ARPlayerPawn::GetDefaultArmsMontageAdditive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetDefaultArmsMontageAdditive");

	Params::RPlayerPawn_GetDefaultArmsMontageAdditive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetDefaultCharacterMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ARPlayerPawn::GetDefaultCharacterMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetDefaultCharacterMontage");

	Params::RPlayerPawn_GetDefaultCharacterMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetDefaultCharacterMontageAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ARPlayerPawn::GetDefaultCharacterMontageAdditive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetDefaultCharacterMontageAdditive");

	Params::RPlayerPawn_GetDefaultCharacterMontageAdditive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetEquippedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARWeapon* ARPlayerPawn::GetEquippedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetEquippedWeapon");

	Params::RPlayerPawn_GetEquippedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetFirstPersonCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCineCameraComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCineCameraComponent* ARPlayerPawn::GetFirstPersonCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetFirstPersonCamera");

	Params::RPlayerPawn_GetFirstPersonCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetHelmetStaticMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ARPlayerPawn::GetHelmetStaticMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetHelmetStaticMeshComponent");

	Params::RPlayerPawn_GetHelmetStaticMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.GetProximitySphereComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDMActorProximitySphereComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDMActorProximitySphereComponent* ARPlayerPawn::GetProximitySphereComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "GetProximitySphereComponent");

	Params::RPlayerPawn_GetProximitySphereComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.IsDowned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::IsDowned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "IsDowned");

	Params::RPlayerPawn_IsDowned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.IsPingInputBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::IsPingInputBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "IsPingInputBlocked");

	Params::RPlayerPawn_IsPingInputBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.IsRespawnLocationUpdateBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::IsRespawnLocationUpdateBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "IsRespawnLocationUpdateBlocked");

	Params::RPlayerPawn_IsRespawnLocationUpdateBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.IsRotationInputBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::IsRotationInputBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "IsRotationInputBlocked");

	Params::RPlayerPawn_IsRotationInputBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerPawn.IsWeaponVisibilityBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerPawn::IsWeaponVisibilityBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerPawn", "IsWeaponVisibilityBlocked");

	Params::RPlayerPawn_IsWeaponVisibilityBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RClientPredictionDebugContext.DrawClientPredictionDebugCapsule
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URClientPredictionDebugContext::DrawClientPredictionDebugCapsule(float Radius, float HalfHeight, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RClientPredictionDebugContext", "DrawClientPredictionDebugCapsule");

	Params::RClientPredictionDebugContext_DrawClientPredictionDebugCapsule Parms{};

	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RClientPredictionDebugContext.DrawClientPredictionDebugSphere
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URClientPredictionDebugContext::DrawClientPredictionDebugSphere(float Radius, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RClientPredictionDebugContext", "DrawClientPredictionDebugSphere");

	Params::RClientPredictionDebugContext_DrawClientPredictionDebugSphere Parms{};

	Parms.Radius = Radius;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RClientPredictionDebugContext.GetTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URClientPredictionDebugContext::GetTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RClientPredictionDebugContext", "GetTag");

	Params::RClientPredictionDebugContext_GetTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ClientPredictionInterface.DebugClientPredictionState
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class URClientPredictionDebugContext*   DebugContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IClientPredictionInterface::DebugClientPredictionState(class URClientPredictionDebugContext* DebugContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClientPredictionInterface", "DebugClientPredictionState");

	Params::ClientPredictionInterface_DebugClientPredictionState Parms{};

	Parms.DebugContext = DebugContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ClientPredictionInterface.OnClientPredictionChangeInput
// (Native, Event, Public, BlueprintEvent)

void IClientPredictionInterface::OnClientPredictionChangeInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClientPredictionInterface", "OnClientPredictionChangeInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ClientPredictionInterface.OnClientPredictionChangeState
// (Native, Event, Public, BlueprintEvent)

void IClientPredictionInterface::OnClientPredictionChangeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClientPredictionInterface", "OnClientPredictionChangeState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ClientPredictionInterface.OnOwningClientPredictionInputChanged
// (Native, Event, Public, BlueprintEvent)

void IClientPredictionInterface::OnOwningClientPredictionInputChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClientPredictionInterface", "OnOwningClientPredictionInputChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ClientPredictionInterface.TickPredictedObject
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IClientPredictionInterface::TickPredictedObject(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClientPredictionInterface", "TickPredictedObject");

	Params::ClientPredictionInterface_TickPredictedObject Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ClientPredictionInterface.IsOwnerOfClientPredictionInput
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IClientPredictionInterface::IsOwnerOfClientPredictionInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClientPredictionInterface", "IsOwnerOfClientPredictionInput");

	Params::ClientPredictionInterface_IsOwnerOfClientPredictionInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RObjectiveManager.GetObjectiveManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARObjectiveManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARObjectiveManager* ARObjectiveManager::GetObjectiveManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RObjectiveManager", "GetObjectiveManager");

	Params::RObjectiveManager_GetObjectiveManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RObjectiveManager.AdjustObjectsByNumPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AREnemySpawnAreaSegment*          Segment                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::AdjustObjectsByNumPlayers(class AREnemySpawnAreaSegment* Segment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "AdjustObjectsByNumPlayers");

	Params::RObjectiveManager_AdjustObjectsByNumPlayers Parms{};

	Parms.Segment = Segment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.EndObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompleted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::EndObjective(const struct FGameplayTag& ObjectiveTag, bool bCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "EndObjective");

	Params::RObjectiveManager_EndObjective Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);
	Parms.bCompleted = bCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.GetFirstObjectiveAssetByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URObjectivePrimaryDataAsset*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URObjectivePrimaryDataAsset* ARObjectiveManager::GetFirstObjectiveAssetByTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "GetFirstObjectiveAssetByTag");

	Params::RObjectiveManager_GetFirstObjectiveAssetByTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RObjectiveManager.GetObjectiveAssetsByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URObjectivePrimaryDataAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URObjectivePrimaryDataAsset*> ARObjectiveManager::GetObjectiveAssetsByTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "GetObjectiveAssetsByTag");

	Params::RObjectiveManager_GetObjectiveAssetsByTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RObjectiveManager.HandlePlayerLeft
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::HandlePlayerLeft(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "HandlePlayerLeft");

	Params::RObjectiveManager_HandlePlayerLeft Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.OnAreaChanged
// (Final, Native, Private)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::OnAreaChanged(class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "OnAreaChanged");

	Params::RObjectiveManager_OnAreaChanged Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.OnPreLevelChanged
// (Final, Native, Private)

void ARObjectiveManager::OnPreLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "OnPreLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.OnRep_LastCreatedObjectiveScript
// (Final, Native, Private)

void ARObjectiveManager::OnRep_LastCreatedObjectiveScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "OnRep_LastCreatedObjectiveScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.OnSpawnAreaSegmentCompleted
// (Final, Native, Private)
// Parameters:
// class AREnemySpawnAreaSegment*          Segment                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::OnSpawnAreaSegmentCompleted(class AREnemySpawnAreaSegment* Segment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "OnSpawnAreaSegmentCompleted");

	Params::RObjectiveManager_OnSpawnAreaSegmentCompleted Parms{};

	Parms.Segment = Segment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.StartObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRObjectiveData&           ObjectiveData                                          (Parm, NativeAccessSpecifierPublic)

void ARObjectiveManager::StartObjective(const struct FRObjectiveData& ObjectiveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "StartObjective");

	Params::RObjectiveManager_StartObjective Parms{};

	Parms.ObjectiveData = std::move(ObjectiveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.UpdateObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      UpdateInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARObjectiveManager::UpdateObjective(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "UpdateObjective");

	Params::RObjectiveManager_UpdateObjective Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);
	Parms.UpdateInfo = std::move(UpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.BroadcastObjectiveEnded_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompleted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::BroadcastObjectiveEnded_Multicast(const struct FGameplayTag& ObjectiveTag, bool bCompleted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "BroadcastObjectiveEnded_Multicast");

	Params::RObjectiveManager_BroadcastObjectiveEnded_Multicast Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);
	Parms.bCompleted = bCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.BroadcastObjectiveRemoved_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::BroadcastObjectiveRemoved_Multicast(const struct FGameplayTag& ObjectiveTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "BroadcastObjectiveRemoved_Multicast");

	Params::RObjectiveManager_BroadcastObjectiveRemoved_Multicast Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.BroadcastObjectiveUpdated_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      UpdateInfo                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARObjectiveManager::BroadcastObjectiveUpdated_Multicast(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "BroadcastObjectiveUpdated_Multicast");

	Params::RObjectiveManager_BroadcastObjectiveUpdated_Multicast Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);
	Parms.UpdateInfo = std::move(UpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.BroadcastRoomObjectiveSegmentCompleted_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)

void ARObjectiveManager::BroadcastRoomObjectiveSegmentCompleted_Multicast() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "BroadcastRoomObjectiveSegmentCompleted_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.LocalBroadcastObjectiveEnded
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompleted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARObjectiveManager::LocalBroadcastObjectiveEnded(const struct FGameplayTag& ObjectiveTag, bool bCompleted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "LocalBroadcastObjectiveEnded");

	Params::RObjectiveManager_LocalBroadcastObjectiveEnded Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);
	Parms.bCompleted = bCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectiveManager.LocalBroadcastObjectiveUpdated
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FGameplayTag&              ObjectiveTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      UpdateInfo                                             (Parm, NativeAccessSpecifierPublic)

void ARObjectiveManager::LocalBroadcastObjectiveUpdated(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectiveManager", "LocalBroadcastObjectiveUpdated");

	Params::RObjectiveManager_LocalBroadcastObjectiveUpdated Parms{};

	Parms.ObjectiveTag = std::move(ObjectiveTag);
	Parms.UpdateInfo = std::move(UpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ProximityCylinder.GetCylinderHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UProximityCylinder::GetCylinderHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProximityCylinder", "GetCylinderHeight");

	Params::ProximityCylinder_GetCylinderHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ProximityCylinder.GetUnscaledCylinderRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UProximityCylinder::GetUnscaledCylinderRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProximityCylinder", "GetUnscaledCylinderRadius");

	Params::ProximityCylinder_GetUnscaledCylinderRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.DMActorProximityCylinderComponent.GetCylinderRadiusAndHeight
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  ReturnCylinderHeight                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  ReturnCylinderRadius                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMActorProximityCylinderComponent::GetCylinderRadiusAndHeight(float* ReturnCylinderHeight, float* ReturnCylinderRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMActorProximityCylinderComponent", "GetCylinderRadiusAndHeight");

	Params::DMActorProximityCylinderComponent_GetCylinderRadiusAndHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReturnCylinderHeight != nullptr)
		*ReturnCylinderHeight = Parms.ReturnCylinderHeight;

	if (ReturnCylinderRadius != nullptr)
		*ReturnCylinderRadius = Parms.ReturnCylinderRadius;
}


// Function RGame.DMActorProximityCylinderComponent.GetProximityCylinder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UProximityCylinder*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProximityCylinder* UDMActorProximityCylinderComponent::GetProximityCylinder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMActorProximityCylinderComponent", "GetProximityCylinder");

	Params::DMActorProximityCylinderComponent_GetProximityCylinder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.DMActorProximityCylinderComponent.UpdateProximityCylinderSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   ScaleMulti                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMActorProximityCylinderComponent::UpdateProximityCylinderSize(const struct FVector& ScaleMulti)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMActorProximityCylinderComponent", "UpdateProximityCylinderSize");

	Params::DMActorProximityCylinderComponent_UpdateProximityCylinderSize Parms{};

	Parms.ScaleMulti = std::move(ScaleMulti);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeScript.OnApplicableRunStarted
// (Event, Public, BlueprintEvent)

void URChallengeScript::OnApplicableRunStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeScript", "OnApplicableRunStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RChallengeScript.OnPlayerRegistered
// (Event, Public, BlueprintEvent)

void URChallengeScript::OnPlayerRegistered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeScript", "OnPlayerRegistered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RChallengeScript.RunStarted
// (Final, Native, Public)

void URChallengeScript::RunStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeScript", "RunStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.ActivateScript
// (Native, Public)

void URGScript::ActivateScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "ActivateScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.BranchByNetRole
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EGScriptNetRole*                        Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::BranchByNetRole(EGScriptNetRole* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "BranchByNetRole");

	Params::RGScript_BranchByNetRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function RGame.RGScript.DeactivateScript
// (Native, Public)

void URGScript::DeactivateScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "DeactivateScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.FinishExecution
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   consumePriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::FinishExecution(class FName FunctionName, int32 consumePriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "FinishExecution");

	Params::RGScript_FinishExecution Parms{};

	Parms.FunctionName = FunctionName;
	Parms.consumePriority = consumePriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.K2_ActivateScript
// (Event, Public, BlueprintEvent)

void URGScript::K2_ActivateScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_ActivateScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGScript.K2_DeactivateScript
// (Event, Public, BlueprintEvent)

void URGScript::K2_DeactivateScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_DeactivateScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGScript.K2_FinishCurrentExecution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   consumePriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::K2_FinishCurrentExecution(int32 consumePriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_FinishCurrentExecution");

	Params::RGScript_K2_FinishCurrentExecution Parms{};

	Parms.consumePriority = consumePriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.K2_PreLevelTransition
// (Event, Public, BlueprintEvent)

void URGScript::K2_PreLevelTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_PreLevelTransition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGScript.K2_TickScript
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::K2_TickScript(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_TickScript");

	Params::RGScript_K2_TickScript Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGScript.OnRep_bActivated
// (Final, Native, Private)
// Parameters:
// bool                                    bPreviousValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::OnRep_bActivated(bool bPreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "OnRep_bActivated");

	Params::RGScript_OnRep_bActivated Parms{};

	Parms.bPreviousValue = bPreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.PreLevelTransition
// (Native, Public)

void URGScript::PreLevelTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "PreLevelTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.SetTickScriptEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldTickScript                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::SetTickScriptEnabled(bool bShouldTickScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "SetTickScriptEnabled");

	Params::RGScript_SetTickScriptEnabled Parms{};

	Parms.bShouldTickScript = bShouldTickScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.SetTickScriptInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TickInterval                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScript::SetTickScriptInterval(float TickInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "SetTickScriptInterval");

	Params::RGScript_SetTickScriptInterval Parms{};

	Parms.TickInterval = TickInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.ShouldSkipExecution
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGScript::ShouldSkipExecution(class FName FunctionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "ShouldSkipExecution");

	Params::RGScript_ShouldSkipExecution Parms{};

	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.TickScriptInterval_OnRep
// (Final, Native, Public)

void URGScript::TickScriptInterval_OnRep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "TickScriptInterval_OnRep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScript.GetScriptFName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGScript::GetScriptFName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "GetScriptFName");

	Params::RGScript_GetScriptFName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.GetTickScriptInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGScript::GetTickScriptInterval() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "GetTickScriptInterval");

	Params::RGScript_GetTickScriptInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_GetCurrentActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGScriptActorInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGScriptActorInfo URGScript::K2_GetCurrentActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_GetCurrentActorInfo");

	Params::RGScript_K2_GetCurrentActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_GetInstigatorController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* URGScript::K2_GetInstigatorController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_GetInstigatorController");

	Params::RGScript_K2_GetInstigatorController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_GetInstigatorPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* URGScript::K2_GetInstigatorPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_GetInstigatorPawn");

	Params::RGScript_K2_GetInstigatorPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* URGScript::K2_GetPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_GetPlayerController");

	Params::RGScript_K2_GetPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_GetRGScriptComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* URGScript::K2_GetRGScriptComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_GetRGScriptComponent");

	Params::RGScript_K2_GetRGScriptComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_GetSkeletalmesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* URGScript::K2_GetSkeletalmesh(class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_GetSkeletalmesh");

	Params::RGScript_K2_GetSkeletalmesh Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_IsInstigatorLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGScript::K2_IsInstigatorLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_IsInstigatorLocallyControlled");

	Params::RGScript_K2_IsInstigatorLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScript.K2_IsScriptLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGScript::K2_IsScriptLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScript", "K2_IsScriptLocallyControlled");

	Params::RGScript_K2_IsScriptLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatusEffectGScript.AttachStatusEffectToPawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URStatusEffectGScript>StatusEffectClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARPawnBase*                       Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               InstigatorScriptComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipDeathCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        StatusEffectInstigatorScript                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URStatusEffectGScript*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URStatusEffectGScript* URStatusEffectGScript::AttachStatusEffectToPawn(TSubclassOf<class URStatusEffectGScript> StatusEffectClass, class ARPawnBase* Pawn, bool bStack, class URGScriptComponent* InstigatorScriptComponent, bool bSkipDeathCheck, int32 Rank, class URGScript* StatusEffectInstigatorScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RStatusEffectGScript", "AttachStatusEffectToPawn");

	Params::RStatusEffectGScript_AttachStatusEffectToPawn Parms{};

	Parms.StatusEffectClass = StatusEffectClass;
	Parms.Pawn = Pawn;
	Parms.bStack = bStack;
	Parms.InstigatorScriptComponent = InstigatorScriptComponent;
	Parms.bSkipDeathCheck = bSkipDeathCheck;
	Parms.Rank = Rank;
	Parms.StatusEffectInstigatorScript = StatusEffectInstigatorScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatusEffectGScript.AilmentAdded
// (Native, Public)

void URStatusEffectGScript::AilmentAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "AilmentAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.AilmentRemoved
// (Native, Public)

void URStatusEffectGScript::AilmentRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "AilmentRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.AttachParticlesToOwnerSkeletalMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   SystemTemplate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* URStatusEffectGScript::AttachParticlesToOwnerSkeletalMesh(class UNiagaraSystem* SystemTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "AttachParticlesToOwnerSkeletalMesh");

	Params::RStatusEffectGScript_AttachParticlesToOwnerSkeletalMesh Parms{};

	Parms.SystemTemplate = SystemTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatusEffectGScript.CallDeactivateScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URStatusEffectGScript::CallDeactivateScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "CallDeactivateScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RStatusEffectGScript.CleanupAttachedParticles
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectGScript::CleanupAttachedParticles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "CleanupAttachedParticles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.DestroyStatusEffect
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectGScript::DestroyStatusEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "DestroyStatusEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.Dispel
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectGScript::Dispel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "Dispel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.Dispelled
// (Native, Protected)

void URStatusEffectGScript::Dispelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "Dispelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.EffectDuration_OnRep
// (Final, Native, Public)

void URStatusEffectGScript::EffectDuration_OnRep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "EffectDuration_OnRep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.ExtendRemainingDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URStatusEffectGScript::ExtendRemainingDuration(float DeltaDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "ExtendRemainingDuration");

	Params::RStatusEffectGScript_ExtendRemainingDuration Parms{};

	Parms.DeltaDuration = DeltaDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.K2_AilmentAdded
// (Event, Public, BlueprintEvent)

void URStatusEffectGScript::K2_AilmentAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "K2_AilmentAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RStatusEffectGScript.K2_AilmentRemoved
// (Event, Public, BlueprintEvent)

void URStatusEffectGScript::K2_AilmentRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "K2_AilmentRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RStatusEffectGScript.K2_Dispelled
// (Event, Protected, BlueprintEvent)

void URStatusEffectGScript::K2_Dispelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "K2_Dispelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RStatusEffectGScript.K2_PostHit
// (Event, Public, BlueprintEvent)

void URStatusEffectGScript::K2_PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "K2_PostHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RStatusEffectGScript.OnRep_CurrentStackCount
// (Final, Native, Private)
// Parameters:
// int32                                   PrevStackCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URStatusEffectGScript::OnRep_CurrentStackCount(int32 PrevStackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "OnRep_CurrentStackCount");

	Params::RStatusEffectGScript_OnRep_CurrentStackCount Parms{};

	Parms.PrevStackCount = PrevStackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.OnRep_ExpirationTime
// (Final, Native, Protected)

void URStatusEffectGScript::OnRep_ExpirationTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "OnRep_ExpirationTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.OnUpdateDuration_Client
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// float                                   NewDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URStatusEffectGScript::OnUpdateDuration_Client(float NewDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "OnUpdateDuration_Client");

	Params::RStatusEffectGScript_OnUpdateDuration_Client Parms{};

	Parms.NewDuration = NewDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.PauseDestroyHandle
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectGScript::PauseDestroyHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "PauseDestroyHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.PostHit
// (Native, Public)

void URStatusEffectGScript::PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "PostHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.RefreshStatusEffect
// (Native, Event, Public, BlueprintEvent)

void URStatusEffectGScript::RefreshStatusEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "RefreshStatusEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.RemoveStack
// (Native, Event, Public, BlueprintEvent)

void URStatusEffectGScript::RemoveStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "RemoveStack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.RemoveStatusEffectStack
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectGScript::RemoveStatusEffectStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "RemoveStatusEffectStack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.RemoveStatusEffectStacksOnDurationElapsed
// (Final, Native, Public)

void URStatusEffectGScript::RemoveStatusEffectStacksOnDurationElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "RemoveStatusEffectStacksOnDurationElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.ResetEffectDuration
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URStatusEffectGScript::ResetEffectDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "ResetEffectDuration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.SetCurrentStackCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _CurrentStackCount                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URStatusEffectGScript::SetCurrentStackCount(int32 _CurrentStackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "SetCurrentStackCount");

	Params::RStatusEffectGScript_SetCurrentStackCount Parms{};

	Parms._CurrentStackCount = _CurrentStackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatusEffectGScript.SetEffectDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URStatusEffectGScript::SetEffectDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "SetEffectDuration");

	Params::RStatusEffectGScript_SetEffectDuration Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.SetMaxStackCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MaxStacks                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URStatusEffectGScript::SetMaxStackCount(int32 MaxStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "SetMaxStackCount");

	Params::RStatusEffectGScript_SetMaxStackCount Parms{};

	Parms.MaxStacks = MaxStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.Stack
// (Native, Event, Public, BlueprintEvent)

void URStatusEffectGScript::Stack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "Stack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.UnpauseDestroyHandle
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectGScript::UnpauseDestroyHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "UnpauseDestroyHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatusEffectGScript.UpdateStacks
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URStatusEffectGScript::UpdateStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "UpdateStacks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RStatusEffectGScript.GetCurrentStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URStatusEffectGScript::GetCurrentStackCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "GetCurrentStackCount");

	Params::RStatusEffectGScript_GetCurrentStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatusEffectGScript.GetRemainingDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URStatusEffectGScript::GetRemainingDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectGScript", "GetRemainingDuration");

	Params::RStatusEffectGScript_GetRemainingDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatusEffectAilmentGScript.InstantlyTickAilmentOnce
// (Final, Native, Public, BlueprintCallable)

void URStatusEffectAilmentGScript::InstantlyTickAilmentOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatusEffectAilmentGScript", "InstantlyTickAilmentOnce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ProximitySphere.GetUnscaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UProximitySphere::GetUnscaledSphereRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProximitySphere", "GetUnscaledSphereRadius");

	Params::ProximitySphere_GetUnscaledSphereRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.DMActorProximitySphereComponent.GetActorsInProximitySphereAsArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UProximitySphere*                 ProximitySphere                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               OptionalType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UDMActorProximitySphereComponent::GetActorsInProximitySphereAsArray(class UProximitySphere* ProximitySphere, TSubclassOf<class AActor> OptionalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMActorProximitySphereComponent", "GetActorsInProximitySphereAsArray");

	Params::DMActorProximitySphereComponent_GetActorsInProximitySphereAsArray Parms{};

	Parms.ProximitySphere = ProximitySphere;
	Parms.OptionalType = OptionalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.DMActorProximitySphereComponent.GetClosestActorInProximitySphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UProximitySphere*                 ProximitySphere                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDMActorProximitySphereComponent::GetClosestActorInProximitySphere(class UProximitySphere* ProximitySphere)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMActorProximitySphereComponent", "GetClosestActorInProximitySphere");

	Params::DMActorProximitySphereComponent_GetClosestActorInProximitySphere Parms{};

	Parms.ProximitySphere = ProximitySphere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.DMActorProximitySphereComponent.GetProximitySphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProximitySphere*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProximitySphere* UDMActorProximitySphereComponent::GetProximitySphere(float SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMActorProximitySphereComponent", "GetProximitySphere");

	Params::DMActorProximitySphereComponent_GetProximitySphere Parms{};

	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetMutatorDescription
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGWeaponMutatorScript::GetMutatorDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetMutatorDescription");

	Params::RGWeaponMutatorScript_GetMutatorDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetMutatorRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGWeaponMutatorScript::GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetMutatorRank");

	Params::RGWeaponMutatorScript_GetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.K2_OnBeginFire
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnBeginFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnBeginFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnBeginSecondaryFire
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnBeginSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnBeginSecondaryFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnEndFire
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnEndFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnEndFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnEndSecondaryFire
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnEndSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnEndSecondaryFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnEnemyKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::K2_OnEnemyKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnEnemyKilled");

	Params::RGWeaponMutatorScript_K2_OnEnemyKilled Parms{};

	Parms.KilledActor = KilledActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGWeaponMutatorScript.K2_OnEquip
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnEquip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnModPrimaryFired
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnModPrimaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnModPrimaryFired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnModSecondaryFired
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnModSecondaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnModSecondaryFired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnProjectileSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARProjectileBase*                 SpawnedProjectile                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::K2_OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnProjectileSpawned");

	Params::RGWeaponMutatorScript_K2_OnProjectileSpawned Parms{};

	Parms.SpawnedProjectile = SpawnedProjectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGWeaponMutatorScript.K2_OnProjectileSpawnedClientDummy
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::K2_OnProjectileSpawnedClientDummy(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnProjectileSpawnedClientDummy");

	Params::RGWeaponMutatorScript_K2_OnProjectileSpawnedClientDummy Parms{};

	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGWeaponMutatorScript.K2_OnReload
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnReloadFinished
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnReloadFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnReloadFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_OnUnequip
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_OnUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_OnUnequip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_PreModPrimaryFired
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_PreModPrimaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_PreModPrimaryFired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_PreModSecondaryFired
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_PreModSecondaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_PreModSecondaryFired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.K2_PreProjectileSpawned
// (Event, Public, BlueprintEvent)

void URGWeaponMutatorScript::K2_PreProjectileSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "K2_PreProjectileSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponMutatorScript.OnBeginFire
// (Native, Public)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::OnBeginFire(int32 CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnBeginFire");

	Params::RGWeaponMutatorScript_OnBeginFire Parms{};

	Parms.CurrentAmmo = CurrentAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnBeginSecondaryFire
// (Native, Public)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::OnBeginSecondaryFire(int32 CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnBeginSecondaryFire");

	Params::RGWeaponMutatorScript_OnBeginSecondaryFire Parms{};

	Parms.CurrentAmmo = CurrentAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnEndFire
// (Native, Public)

void URGWeaponMutatorScript::OnEndFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnEndFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnEndSecondaryFire
// (Native, Public)

void URGWeaponMutatorScript::OnEndSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnEndSecondaryFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnEnemyKilled
// (Native, Public)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::OnEnemyKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnEnemyKilled");

	Params::RGWeaponMutatorScript_OnEnemyKilled Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnEquip
// (Native, Public)

void URGWeaponMutatorScript::OnEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnEquip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnModPrimaryFired
// (Native, Public)

void URGWeaponMutatorScript::OnModPrimaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnModPrimaryFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnModSecondaryFired
// (Native, Public)

void URGWeaponMutatorScript::OnModSecondaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnModSecondaryFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnProjectileSpawned
// (Native, Public)
// Parameters:
// class ARProjectileBase*                 SpawnedProjectile                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnProjectileSpawned");

	Params::RGWeaponMutatorScript_OnProjectileSpawned Parms{};

	Parms.SpawnedProjectile = SpawnedProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnProjectileSpawnedClientDummy
// (Native, Public, HasDefaults)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponMutatorScript::OnProjectileSpawnedClientDummy(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnProjectileSpawnedClientDummy");

	Params::RGWeaponMutatorScript_OnProjectileSpawnedClientDummy Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnReload
// (Native, Public)

void URGWeaponMutatorScript::OnReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnReloadFinished
// (Native, Public)

void URGWeaponMutatorScript::OnReloadFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnReloadFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.OnUnequip
// (Native, Public)

void URGWeaponMutatorScript::OnUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "OnUnequip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.PreModPrimaryFired
// (Native, Public)

void URGWeaponMutatorScript::PreModPrimaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "PreModPrimaryFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.PreModSecondaryFired
// (Native, Public)

void URGWeaponMutatorScript::PreModSecondaryFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "PreModSecondaryFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.PreProjectileSpawned
// (Native, Public)

void URGWeaponMutatorScript::PreProjectileSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "PreProjectileSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponMutatorScript.GetBaseWeaponSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBaseWeaponSettings*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBaseWeaponSettings* URGWeaponMutatorScript::GetBaseWeaponSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetBaseWeaponSettings");

	Params::RGWeaponMutatorScript_GetBaseWeaponSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetDescription
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGWeaponMutatorScript::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetDescription");

	Params::RGWeaponMutatorScript_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetFloatWeaponStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponMutatorScript::GetFloatWeaponStat(EFloatWeaponStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetFloatWeaponStat");

	Params::RGWeaponMutatorScript_GetFloatWeaponStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetGlobalWeaponModifiers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGlobalWeaponModifiers*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGlobalWeaponModifiers* URGWeaponMutatorScript::GetGlobalWeaponModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetGlobalWeaponModifiers");

	Params::RGWeaponMutatorScript_GetGlobalWeaponModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetIntegerWeaponStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGWeaponMutatorScript::GetIntegerWeaponStat(EIntegerWeaponStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetIntegerWeaponStat");

	Params::RGWeaponMutatorScript_GetIntegerWeaponStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetMutableWeaponSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URMutableWeaponSettings*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URMutableWeaponSettings* URGWeaponMutatorScript::GetMutableWeaponSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetMutableWeaponSettings");

	Params::RGWeaponMutatorScript_GetMutableWeaponSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARWeapon* URGWeaponMutatorScript::GetWeaponActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetWeaponActor");

	Params::RGWeaponMutatorScript_GetWeaponActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.GetWeaponScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGWeaponScript*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGWeaponScript* URGWeaponMutatorScript::GetWeaponScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "GetWeaponScript");

	Params::RGWeaponMutatorScript_GetWeaponScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponMutatorScript.RollProcChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Chance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponMutatorScript::RollProcChance(int32 Chance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponMutatorScript", "RollProcChance");

	Params::RGWeaponMutatorScript_RollProcChance Parms{};

	Parms.Chance = Chance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponCosmeticScript.K2_OnWeaponCosmeticEvent
// (Event, Public, BlueprintEvent)

void URGWeaponCosmeticScript::K2_OnWeaponCosmeticEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponCosmeticScript", "K2_OnWeaponCosmeticEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponCosmeticScript.OnWeaponCosmeticEvent
// (Native, Public)

void URGWeaponCosmeticScript::OnWeaponCosmeticEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponCosmeticScript", "OnWeaponCosmeticEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.DMCodingStandardActor.DoSomething_Client
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void ADMCodingStandardActor::DoSomething_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCodingStandardActor", "DoSomething_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.DMCodingStandardActor.DoSomething_Multicast
// (Final, Net, Native, Event, NetMulticast, Private)

void ADMCodingStandardActor::DoSomething_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCodingStandardActor", "DoSomething_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.DMCodingStandardActor.DoSomething_Server
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ADMCodingStandardActor::DoSomething_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCodingStandardActor", "DoSomething_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.DMCodingStandardActor.OnRep_bReplicatedRuntimeVariable
// (Final, Native, Protected)

void ADMCodingStandardActor::OnRep_bReplicatedRuntimeVariable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCodingStandardActor", "OnRep_bReplicatedRuntimeVariable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAIController.InitializeBehaviorTree
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRAISettings&              Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARAIController::InitializeBehaviorTree(class AController* Controller, const struct FRAISettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIController", "InitializeBehaviorTree");

	Params::RAIController_InitializeBehaviorTree Parms{};

	Parms.Controller = Controller;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.OnArmorUpdated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentArmor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHealCombatEvent&          HealEvent                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URHealthbarWidget::OnArmorUpdated(class URHealthComponent* Component, float CurrentArmor, float Delta, const struct FHealCombatEvent& HealEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "OnArmorUpdated");

	Params::RHealthbarWidget_OnArmorUpdated Parms{};

	Parms.Component = Component;
	Parms.CurrentArmor = CurrentArmor;
	Parms.Delta = Delta;
	Parms.HealEvent = std::move(HealEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.OnDamageTaken
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URHealthbarWidget::OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "OnDamageTaken");

	Params::RHealthbarWidget_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.OnDamageTakenServerValidated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URHealthbarWidget::OnDamageTakenServerValidated(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "OnDamageTakenServerValidated");

	Params::RHealthbarWidget_OnDamageTakenServerValidated Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.OnHealthDepleted
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URHealthbarWidget::OnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "OnHealthDepleted");

	Params::RHealthbarWidget_OnHealthDepleted Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.OnHealthUpdated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   currentHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHealCombatEvent&          HealEvent                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URHealthbarWidget::OnHealthUpdated(class URHealthComponent* Component, float currentHealth, float Delta, const struct FHealCombatEvent& HealEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "OnHealthUpdated");

	Params::RHealthbarWidget_OnHealthUpdated Parms{};

	Parms.Component = Component;
	Parms.currentHealth = currentHealth;
	Parms.Delta = Delta;
	Parms.HealEvent = std::move(HealEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.ReinitHealthbarWithNewTarget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URHealthComponent*                NewComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthbarWidget::ReinitHealthbarWithNewTarget(class URHealthComponent* NewComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "ReinitHealthbarWithNewTarget");

	Params::RHealthbarWidget_ReinitHealthbarWithNewTarget Parms{};

	Parms.NewComponent = NewComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.SetHealthbarComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthbarWidget::SetHealthbarComponent(class URHealthComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "SetHealthbarComponent");

	Params::RHealthbarWidget_SetHealthbarComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthbarWidget.SetName
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URHealthbarWidget::SetName(const class FText& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "SetName");

	Params::RHealthbarWidget_SetName Parms{};

	Parms.Name_0 = std::move(Name_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RHealthbarWidget.UpdateHealthBarVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URHealthbarWidget::UpdateHealthBarVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthbarWidget", "UpdateHealthBarVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAIHelper.FindAndCreatePatrolingPathWithClosestPoints
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARAIHelper::FindAndCreatePatrolingPathWithClosestPoints(class APawn* Pawn, class FName Tag, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "FindAndCreatePatrolingPathWithClosestPoints");

	Params::RAIHelper_FindAndCreatePatrolingPathWithClosestPoints Parms{};

	Parms.Pawn = Pawn;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.FindAndCreateSpecifiedPatrolingPath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARAIHelper::FindAndCreateSpecifiedPatrolingPath(class APawn* Pawn, class FName Tag, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "FindAndCreateSpecifiedPatrolingPath");

	Params::RAIHelper_FindAndCreateSpecifiedPatrolingPath Parms{};

	Parms.Pawn = Pawn;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.GetClosestMoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARAIHelper::GetClosestMoveToLocation(class APawn* Pawn, class FName Tag, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "GetClosestMoveToLocation");

	Params::RAIHelper_GetClosestMoveToLocation Parms{};

	Parms.Pawn = Pawn;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ARAIHelper*                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ARAIHelper* ARAIHelper::GetInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "GetInstance");

	Params::RAIHelper_GetInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.GetRandomMoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARAIHelper::GetRandomMoveToLocation(class APawn* Pawn, class FName Tag, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "GetRandomMoveToLocation");

	Params::RAIHelper_GetRandomMoveToLocation Parms{};

	Parms.Pawn = Pawn;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.GetRNavigationManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARNavigationManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARNavigationManager* ARAIHelper::GetRNavigationManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "GetRNavigationManager");

	Params::RAIHelper_GetRNavigationManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.GetRNavigationManagerForActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARNavigationManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARNavigationManager* ARAIHelper::GetRNavigationManagerForActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "GetRNavigationManagerForActor");

	Params::RAIHelper_GetRNavigationManagerForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAIHelper.GetRNavigationManagerForLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARNavigationManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARNavigationManager* ARAIHelper::GetRNavigationManagerForLocation(class UObject* WorldContextObject, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAIHelper", "GetRNavigationManagerForLocation");

	Params::RAIHelper_GetRNavigationManagerForLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAIMovementLocation.GetNextMovementLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARAIMovementLocation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAIMovementLocation* ARAIMovementLocation::GetNextMovementLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAIMovementLocation", "GetNextMovementLocation");

	Params::RAIMovementLocation_GetNextMovementLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPrimaryDataAsset.GetDescription
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URPrimaryDataAsset::GetDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPrimaryDataAsset", "GetDescription");

	Params::RPrimaryDataAsset_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAnimationNotifyListener.OnAnimationTriggerEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRAnimationNotifyListener::OnAnimationTriggerEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RAnimationNotifyListener", "OnAnimationTriggerEvent");

	Params::RAnimationNotifyListener_OnAnimationTriggerEvent Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAnimationNotifyListener.OnToggleEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bool                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRAnimationNotifyListener::OnToggleEvent(class FName Socket, bool Bool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RAnimationNotifyListener", "OnToggleEvent");

	Params::RAnimationNotifyListener_OnToggleEvent Parms{};

	Parms.Socket = Socket;
	Parms.Bool = Bool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyMutatorScript.K2_OnAttack
// (Event, Public, BlueprintEvent)

void URGEnemyMutatorScript::K2_OnAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "K2_OnAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyMutatorScript.K2_OnDamageDealt
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)

void URGEnemyMutatorScript::K2_OnDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "K2_OnDamageDealt");

	Params::RGEnemyMutatorScript_K2_OnDamageDealt Parms{};

	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGEnemyMutatorScript.K2_OnDamageTaken
// (Event, Public, BlueprintEvent)

void URGEnemyMutatorScript::K2_OnDamageTaken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "K2_OnDamageTaken");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyMutatorScript.K2_OnDeath
// (Event, Public, BlueprintEvent)

void URGEnemyMutatorScript::K2_OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "K2_OnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyMutatorScript.K2_OnPreDamageDealt
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)

void URGEnemyMutatorScript::K2_OnPreDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "K2_OnPreDamageDealt");

	Params::RGEnemyMutatorScript_K2_OnPreDamageDealt Parms{};

	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGEnemyMutatorScript.OnAttack
// (Native, Public)

void URGEnemyMutatorScript::OnAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "OnAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyMutatorScript.OnDamageDealt
// (Native, Public)
// Parameters:
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)

void URGEnemyMutatorScript::OnDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "OnDamageDealt");

	Params::RGEnemyMutatorScript_OnDamageDealt Parms{};

	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyMutatorScript.OnDamageTaken
// (Native, Public)

void URGEnemyMutatorScript::OnDamageTaken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "OnDamageTaken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyMutatorScript.OnDeath
// (Native, Public)

void URGEnemyMutatorScript::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyMutatorScript.OnPreDamageDealt
// (Native, Public)
// Parameters:
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)

void URGEnemyMutatorScript::OnPreDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyMutatorScript", "OnPreDamageDealt");

	Params::RGEnemyMutatorScript_OnPreDamageDealt Parms{};

	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAnimFunctionLibrary.GetMontageLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ARPlayerPawn*               PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       MontageSection                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Additive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URAnimFunctionLibrary::GetMontageLength(const class ARPlayerPawn* PlayerPawn, const class FName MontageSection, bool Additive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAnimFunctionLibrary", "GetMontageLength");

	Params::RAnimFunctionLibrary_GetMontageLength Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.MontageSection = MontageSection;
	Parms.Additive = Additive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAnimFunctionLibrary.PlaySynchedMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ARPlayerPawn*               PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       MontageSection                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PlayRate                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CharacterAdditive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ArmsAdditive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URAnimFunctionLibrary::PlaySynchedMontage(const class ARPlayerPawn* PlayerPawn, const class FName MontageSection, const float PlayRate, bool CharacterAdditive, bool ArmsAdditive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAnimFunctionLibrary", "PlaySynchedMontage");

	Params::RAnimFunctionLibrary_PlaySynchedMontage Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.MontageSection = MontageSection;
	Parms.PlayRate = PlayRate;
	Parms.CharacterAdditive = CharacterAdditive;
	Parms.ArmsAdditive = ArmsAdditive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.AddAreaEffectScript
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGAreaEffectScript>  AreaEffectScript                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARAreaEffect::AddAreaEffectScript(TSubclassOf<class URGAreaEffectScript> AreaEffectScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "AddAreaEffectScript");

	Params::RAreaEffect_AddAreaEffectScript Parms{};

	Parms.AreaEffectScript = AreaEffectScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.CleanupAreaEffect_Multicast
// (Final, Net, Native, Event, NetMulticast, Private)

void ARAreaEffect::CleanupAreaEffect_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "CleanupAreaEffect_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.DestroyAreaEffect
// (Final, Native, Public, BlueprintCallable)

void ARAreaEffect::DestroyAreaEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "DestroyAreaEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.GetActorsInArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARAreaEffect::GetActorsInArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "GetActorsInArea");

	Params::RAreaEffect_GetActorsInArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAreaEffect.GetGScriptComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* ARAreaEffect::GetGScriptComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "GetGScriptComponent");

	Params::RAreaEffect_GetGScriptComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAreaEffect.OnActorEnterArea
// (Final, Native, Private)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARAreaEffect::OnActorEnterArea(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "OnActorEnterArea");

	Params::RAreaEffect_OnActorEnterArea Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.OnActorExitArea
// (Final, Native, Private)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARAreaEffect::OnActorExitArea(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "OnActorExitArea");

	Params::RAreaEffect_OnActorExitArea Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.OnLifetimeExpired
// (Final, Native, Private)

void ARAreaEffect::OnLifetimeExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "OnLifetimeExpired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.OnRep_ActorsInArea
// (Final, Native, Private)

void ARAreaEffect::OnRep_ActorsInArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "OnRep_ActorsInArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.RestartAreaEffectDuration
// (Final, Native, Public, BlueprintCallable)

void ARAreaEffect::RestartAreaEffectDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "RestartAreaEffectDuration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAreaEffect.GetAreaEffectScripts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class URGAreaEffectScript*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URGAreaEffectScript*> ARAreaEffect::GetAreaEffectScripts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAreaEffect", "GetAreaEffectScripts");

	Params::RAreaEffect_GetAreaEffectScripts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.GetPoolFromDataTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGetPoolOutcome*                        Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  DesiredQueueLength                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRBossAbilitySettings>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBossAbilitySettings> URGBossScript::GetPoolFromDataTable(class UDataTable* DataTable, class FName Phase, EGetPoolOutcome* Branches, int32* DesiredQueueLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGBossScript", "GetPoolFromDataTable");

	Params::RGBossScript_GetPoolFromDataTable Parms{};

	Parms.DataTable = DataTable;
	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (DesiredQueueLength != nullptr)
		*DesiredQueueLength = Parms.DesiredQueueLength;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.ClearAbilityQueue
// (Final, Native, Public, BlueprintCallable)

void URGBossScript::ClearAbilityQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "ClearAbilityQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.ClearStatusEffects_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void URGBossScript::ClearStatusEffects_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "ClearStatusEffects_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.DequeueAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGBossAbilityScript> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class URGBossAbilityScript> URGBossScript::DequeueAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "DequeueAbility");

	Params::RGBossScript_DequeueAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.EnqueueAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGBossAbilityScript> AbilityScript                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::EnqueueAbility(TSubclassOf<class URGBossAbilityScript> AbilityScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "EnqueueAbility");

	Params::RGBossScript_EnqueueAbility Parms{};

	Parms.AbilityScript = AbilityScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.EnqueueAbilityAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGBossAbilityScript> AbilityScript                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::EnqueueAbilityAt(TSubclassOf<class URGBossAbilityScript> AbilityScript, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "EnqueueAbilityAt");

	Params::RGBossScript_EnqueueAbilityAt Parms{};

	Parms.AbilityScript = AbilityScript;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.EnterNextPhase
// (Final, Native, Public, BlueprintCallable)

void URGBossScript::EnterNextPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "EnterNextPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.ExecuteAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGBossAbilityScript> AbilityScript                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::ExecuteAbility(TSubclassOf<class URGBossAbilityScript> AbilityScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "ExecuteAbility");

	Params::RGBossScript_ExecuteAbility Parms{};

	Parms.AbilityScript = AbilityScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.ExecuteNextAbility
// (Final, Native, Public, BlueprintCallable)

void URGBossScript::ExecuteNextAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "ExecuteNextAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.GetAbilityToEnqueue
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class URGBossAbilityScript> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class URGBossAbilityScript> URGBossScript::GetAbilityToEnqueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "GetAbilityToEnqueue");

	Params::RGBossScript_GetAbilityToEnqueue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.GetCurrentPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBossPhase                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBossPhase URGBossScript::GetCurrentPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "GetCurrentPhase");

	Params::RGBossScript_GetCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.GetCurrentPhaseName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGBossScript::GetCurrentPhaseName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "GetCurrentPhaseName");

	Params::RGBossScript_GetCurrentPhaseName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.K2_OnDamageTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URGBossScript::K2_OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "K2_OnDamageTaken");

	Params::RGBossScript_K2_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGBossScript.K2_OnEnterPhase
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::K2_OnEnterPhase(class FName Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "K2_OnEnterPhase");

	Params::RGBossScript_K2_OnEnterPhase Parms{};

	Parms.Phase = Phase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGBossScript.K2_OnFinishAbilityExecution
// (Event, Public, BlueprintEvent)

void URGBossScript::K2_OnFinishAbilityExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "K2_OnFinishAbilityExecution");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGBossScript.K2_OnPreDamageTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::K2_OnPreDamageTaken(class URHealthComponent* Component, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "K2_OnPreDamageTaken");

	Params::RGBossScript_K2_OnPreDamageTaken Parms{};

	Parms.Component = Component;
	Parms.Damage = Damage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGBossScript.K2_OnPreExecuteAbility
// (Event, Public, BlueprintEvent)

void URGBossScript::K2_OnPreExecuteAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "K2_OnPreExecuteAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGBossScript.Multicast_OnEnterPhase
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::Multicast_OnEnterPhase(class FName Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "Multicast_OnEnterPhase");

	Params::RGBossScript_Multicast_OnEnterPhase Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnCinematicEnded
// (Final, Native, Private)

void URGBossScript::OnCinematicEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnCinematicEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnDamageTaken
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URGBossScript::OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnDamageTaken");

	Params::RGBossScript_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnEnterPhase
// (Native, Public)
// Parameters:
// class FName                             Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::OnEnterPhase(class FName Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnEnterPhase");

	Params::RGBossScript_OnEnterPhase Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnFinishAbilityExecution
// (Native, Public)

void URGBossScript::OnFinishAbilityExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnFinishAbilityExecution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnHealthDepleted
// (Final, Native, Private)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URGBossScript::OnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnHealthDepleted");

	Params::RGBossScript_OnHealthDepleted Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnIntroCinematicEnd
// (Final, Native, Protected, BlueprintCallable)

void URGBossScript::OnIntroCinematicEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnIntroCinematicEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnPreDamageTaken
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::OnPreDamageTaken(class URHealthComponent* Component, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnPreDamageTaken");

	Params::RGBossScript_OnPreDamageTaken Parms{};

	Parms.Component = Component;
	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnPreExecuteAbility
// (Native, Public)

void URGBossScript::OnPreExecuteAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnPreExecuteAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.OnRep_ActiveAbilityScript
// (Final, Native, Private)

void URGBossScript::OnRep_ActiveAbilityScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "OnRep_ActiveAbilityScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.PeekAbilityQueue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class URGBossAbilityScript> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class URGBossAbilityScript> URGBossScript::PeekAbilityQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "PeekAbilityQueue");

	Params::RGBossScript_PeekAbilityQueue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossScript.SetCurrentPhaseQueueLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossScript::SetCurrentPhaseQueueLength(int32 NewLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "SetCurrentPhaseQueueLength");

	Params::RGBossScript_SetCurrentPhaseQueueLength Parms{};

	Parms.NewLength = NewLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossScript.GetActiveAbilityScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGBossAbilityScript*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGBossAbilityScript* URGBossScript::GetActiveAbilityScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossScript", "GetActiveAbilityScript");

	Params::RGBossScript_GetActiveAbilityScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetLoader.GetAssetLoader
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARAssetLoader*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAssetLoader* ARAssetLoader::GetAssetLoader(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetLoader", "GetAssetLoader");

	Params::RAssetLoader_GetAssetLoader Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetLoader.LoadPrimaryGameAssets
// (Final, Native, Public)

void ARAssetLoader::LoadPrimaryGameAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetLoader", "LoadPrimaryGameAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetLoader.OnAreaChanged
// (Final, Native, Public)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARAssetLoader::OnAreaChanged(class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetLoader", "OnAreaChanged");

	Params::RAssetLoader_OnAreaChanged Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetLoader.OnPreAreaChanged
// (Final, Native, Public)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARAssetLoader::OnPreAreaChanged(class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetLoader", "OnPreAreaChanged");

	Params::RAssetLoader_OnPreAreaChanged Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetLoader.UnloadCurrentAreaAssets
// (Final, Native, Public, BlueprintCallable)

void ARAssetLoader::UnloadCurrentAreaAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetLoader", "UnloadCurrentAreaAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutatorPrimaryAsset.CopyVariableRankValues
// (Final, Native, Public)

void URMutatorPrimaryAsset::CopyVariableRankValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorPrimaryAsset", "CopyVariableRankValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutatorPrimaryAsset.SetMutatorDescription
// (Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      Description                                            (Parm, NativeAccessSpecifierPublic)

void URMutatorPrimaryAsset::SetMutatorDescription(const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorPrimaryAsset", "SetMutatorDescription");

	Params::RMutatorPrimaryAsset_SetMutatorDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutatorPrimaryAsset.GetMutatorName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URMutatorPrimaryAsset::GetMutatorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorPrimaryAsset", "GetMutatorName");

	Params::RMutatorPrimaryAsset_GetMutatorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBaseScript.AddProjectileEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGProjectileEffectScript>EffectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileBaseScript::AddProjectileEffect(TSubclassOf<class URGProjectileEffectScript> EffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "AddProjectileEffect");

	Params::RProjectileBaseScript_AddProjectileEffect Parms{};

	Parms.EffectClass = EffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBaseScript.K2_PostAddMutators
// (Event, Public, BlueprintEvent)

void URProjectileBaseScript::K2_PostAddMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "K2_PostAddMutators");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RProjectileBaseScript.K2_ProjectileDisabled
// (Event, Public, BlueprintEvent)

void URProjectileBaseScript::K2_ProjectileDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "K2_ProjectileDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RProjectileBaseScript.PostAddMutators
// (Native, Public)

void URProjectileBaseScript::PostAddMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "PostAddMutators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBaseScript.ProjectileDisabled
// (Native, Public)

void URProjectileBaseScript::ProjectileDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "ProjectileDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBaseScript.SetStatusEffectsStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileBaseScript::SetStatusEffectsStack(bool bStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "SetStatusEffectsStack");

	Params::RProjectileBaseScript_SetStatusEffectsStack Parms{};

	Parms.bStack = bStack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBaseScript.GetOwningProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARProjectileBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARProjectileBase* URProjectileBaseScript::GetOwningProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBaseScript", "GetOwningProjectile");

	Params::RProjectileBaseScript_GetOwningProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetAllDifficultyPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class URDifficultyPrimaryAsset*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URDifficultyPrimaryAsset*> URAssetManager::GetAllDifficultyPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetAllDifficultyPrimaryAssets");

	Params::RAssetManager_GetAllDifficultyPrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetAllMutatorPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowDisabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowAssignedOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URAssetManager::GetAllMutatorPrimaryAssets(bool bAllowDisabled, bool bAllowAssignedOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetAllMutatorPrimaryAssets");

	Params::RAssetManager_GetAllMutatorPrimaryAssets Parms{};

	Parms.bAllowDisabled = bAllowDisabled;
	Parms.bAllowAssignedOnly = bAllowAssignedOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetAllMutatorPrimaryAssetsRarityAndNameSorted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARLootTableManager*               LootTableManager                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowDisabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowAssignedOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URAssetManager::GetAllMutatorPrimaryAssetsRarityAndNameSorted(class ARLootTableManager* LootTableManager, bool bAllowDisabled, bool bAllowAssignedOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetAllMutatorPrimaryAssetsRarityAndNameSorted");

	Params::RAssetManager_GetAllMutatorPrimaryAssetsRarityAndNameSorted Parms{};

	Parms.LootTableManager = LootTableManager;
	Parms.bAllowDisabled = bAllowDisabled;
	Parms.bAllowAssignedOnly = bAllowAssignedOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetAllRewardTablePrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class URRewardTablePrimaryAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URRewardTablePrimaryAsset*> URAssetManager::GetAllRewardTablePrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetAllRewardTablePrimaryAssets");

	Params::RAssetManager_GetAllRewardTablePrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetAllSkillTreeCategoryPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class URSkillTreeCategoryPrimaryAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URSkillTreeCategoryPrimaryAsset*> URAssetManager::GetAllSkillTreeCategoryPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetAllSkillTreeCategoryPrimaryAssets");

	Params::RAssetManager_GetAllSkillTreeCategoryPrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetAssetManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URAssetManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URAssetManager* URAssetManager::GetAssetManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetAssetManager");

	Params::RAssetManager_GetAssetManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetCharacterMutatorPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowDisabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URCharacterMutatorPrimaryAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URCharacterMutatorPrimaryAsset*> URAssetManager::GetCharacterMutatorPrimaryAssets(bool bAllowDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetCharacterMutatorPrimaryAssets");

	Params::RAssetManager_GetCharacterMutatorPrimaryAssets Parms{};

	Parms.bAllowDisabled = bAllowDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetMutatorPreloadBlueprintData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> URAssetManager::GetMutatorPreloadBlueprintData(class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetMutatorPreloadBlueprintData");

	Params::RAssetManager_GetMutatorPreloadBlueprintData Parms{};

	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetMutatorPreloadPrimaryAssetData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> URAssetManager::GetMutatorPreloadPrimaryAssetData(class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetMutatorPreloadPrimaryAssetData");

	Params::RAssetManager_GetMutatorPreloadPrimaryAssetData Parms{};

	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetPreloadData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> URAssetManager::GetPreloadData(class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetPreloadData");

	Params::RAssetManager_GetPreloadData Parms{};

	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetPrimaryAssetsFromType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FPrimaryAssetType&         Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URPrimaryDataAsset*>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URPrimaryDataAsset*> URAssetManager::GetPrimaryAssetsFromType(const struct FPrimaryAssetType& Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetPrimaryAssetsFromType");

	Params::RAssetManager_GetPrimaryAssetsFromType Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetProjectileMutatorPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowDisabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URProjectileMutatorPrimaryAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URProjectileMutatorPrimaryAsset*> URAssetManager::GetProjectileMutatorPrimaryAssets(bool bAllowDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetProjectileMutatorPrimaryAssets");

	Params::RAssetManager_GetProjectileMutatorPrimaryAssets Parms{};

	Parms.bAllowDisabled = bAllowDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetSelectableActivatableCharacterMutatorPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class URCharacterMutatorPrimaryAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URCharacterMutatorPrimaryAsset*> URAssetManager::GetSelectableActivatableCharacterMutatorPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetSelectableActivatableCharacterMutatorPrimaryAssets");

	Params::RAssetManager_GetSelectableActivatableCharacterMutatorPrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetTotemTablePrimaryAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URTotemTablePrimaryAsset*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URTotemTablePrimaryAsset* URAssetManager::GetTotemTablePrimaryAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetTotemTablePrimaryAsset");

	Params::RAssetManager_GetTotemTablePrimaryAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetWeaponModPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class URWeaponModPrimaryAsset*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URWeaponModPrimaryAsset*> URAssetManager::GetWeaponModPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetWeaponModPrimaryAssets");

	Params::RAssetManager_GetWeaponModPrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetWeaponMutatorPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowDisabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URWeaponMutatorPrimaryAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URWeaponMutatorPrimaryAsset*> URAssetManager::GetWeaponMutatorPrimaryAssets(bool bAllowDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetWeaponMutatorPrimaryAssets");

	Params::RAssetManager_GetWeaponMutatorPrimaryAssets Parms{};

	Parms.bAllowDisabled = bAllowDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.GetWeaponPrimaryAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class URWeaponPrimaryAsset*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URWeaponPrimaryAsset*> URAssetManager::GetWeaponPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "GetWeaponPrimaryAssets");

	Params::RAssetManager_GetWeaponPrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.IsAssetLoaded
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FSoftObjectPath&           Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URAssetManager::IsAssetLoaded(const struct FSoftObjectPath& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "IsAssetLoaded");

	Params::RAssetManager_IsAssetLoaded Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.LoadClassFromSoftClassPtr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             SoftClassPtr                                           (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* URAssetManager::LoadClassFromSoftClassPtr(TSoftClassPtr<class UClass> SoftClassPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "LoadClassFromSoftClassPtr");

	Params::RAssetManager_LoadClassFromSoftClassPtr Parms{};

	Parms.SoftClassPtr = SoftClassPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.LoadObjectFromSoftObjectPtr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObjectPtr                                          (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URAssetManager::LoadObjectFromSoftObjectPtr(TSoftObjectPtr<class UObject> SoftObjectPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "LoadObjectFromSoftObjectPtr");

	Params::RAssetManager_LoadObjectFromSoftObjectPtr Parms{};

	Parms.SoftObjectPtr = SoftObjectPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAssetManager.RequestAsyncLoadAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSoftObjectPath>&   Paths                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URAssetManager::RequestAsyncLoadAssets(const TArray<struct FSoftObjectPath>& Paths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "RequestAsyncLoadAssets");

	Params::RAssetManager_RequestAsyncLoadAssets Parms{};

	Parms.Paths = std::move(Paths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetManager.RequestSyncLoadAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSoftObjectPath>&   Paths                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URAssetManager::RequestSyncLoadAssets(const TArray<struct FSoftObjectPath>& Paths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "RequestSyncLoadAssets");

	Params::RAssetManager_RequestSyncLoadAssets Parms{};

	Parms.Paths = std::move(Paths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetManager.UnloadAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSoftObjectPath>&   Paths                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URAssetManager::UnloadAssets(const TArray<struct FSoftObjectPath>& Paths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAssetManager", "UnloadAssets");

	Params::RAssetManager_UnloadAssets Parms{};

	Parms.Paths = std::move(Paths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetManager.LoadPrimaryGameAssets
// (Final, Native, Public, BlueprintCallable)

void URAssetManager::LoadPrimaryGameAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetManager", "LoadPrimaryGameAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetManager.LoadPrimaryGlobalAssets
// (Final, Native, Public, BlueprintCallable)

void URAssetManager::LoadPrimaryGlobalAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetManager", "LoadPrimaryGlobalAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetManager.UnloadPrimaryGameAssets
// (Final, Native, Public, BlueprintCallable)

void URAssetManager::UnloadPrimaryGameAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetManager", "UnloadPrimaryGameAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAssetManager.UnloadPrimaryGlobalAssets
// (Final, Native, Public, BlueprintCallable)

void URAssetManager::UnloadPrimaryGlobalAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAssetManager", "UnloadPrimaryGlobalAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RAudioMixingSubsystem.GetDefaultSFXSubmix
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundSubmix*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundSubmix* URAudioMixingSubsystem::GetDefaultSFXSubmix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAudioMixingSubsystem", "GetDefaultSFXSubmix");

	Params::RAudioMixingSubsystem_GetDefaultSFXSubmix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAudioMixingSubsystem.GetNonLocalPlayerEnemyVolumeMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const bool                              bIsLocal                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URAudioMixingSubsystem::GetNonLocalPlayerEnemyVolumeMultiplier(const bool bIsLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAudioMixingSubsystem", "GetNonLocalPlayerEnemyVolumeMultiplier");

	Params::RAudioMixingSubsystem_GetNonLocalPlayerEnemyVolumeMultiplier Parms{};

	Parms.bIsLocal = bIsLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAudioMixingSubsystem.GetNonLocalPlayerVolumeMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const bool                              bIsLocal                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URAudioMixingSubsystem::GetNonLocalPlayerVolumeMultiplier(const bool bIsLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAudioMixingSubsystem", "GetNonLocalPlayerVolumeMultiplier");

	Params::RAudioMixingSubsystem_GetNonLocalPlayerVolumeMultiplier Parms{};

	Parms.bIsLocal = bIsLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask.CancelTask
// (Native, Public, BlueprintCallable)

void URGTask::CancelTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask", "CancelTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask.FreezeTask
// (Native, Public, BlueprintCallable)

void URGTask::FreezeTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask", "FreezeTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask.UnfreezeTask
// (Native, Public, BlueprintCallable)

void URGTask::UnfreezeTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask", "UnfreezeTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_SpawnPlayerSound.SpawnPlayerSound
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_SpawnPlayerSound*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_SpawnPlayerSound* URGTask_SpawnPlayerSound::SpawnPlayerSound(class URGScript* OwningScript, class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_SpawnPlayerSound", "SpawnPlayerSound");

	Params::RGTask_SpawnPlayerSound_SpawnPlayerSound Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Sound = Sound;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAudioSettings.GetPlayer2DAttenuation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundAttenuation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundAttenuation* URAudioSettings::GetPlayer2DAttenuation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAudioSettings", "GetPlayer2DAttenuation");

	Params::RAudioSettings_GetPlayer2DAttenuation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAudioSettings.GetWeapon2DAttenuation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundAttenuation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundAttenuation* URAudioSettings::GetWeapon2DAttenuation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAudioSettings", "GetWeapon2DAttenuation");

	Params::RAudioSettings_GetWeapon2DAttenuation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAutomatedTestManager.GetTestManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARAutomatedTestManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAutomatedTestManager* ARAutomatedTestManager::GetTestManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RAutomatedTestManager", "GetTestManager");

	Params::RAutomatedTestManager_GetTestManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RAutomatedTestManager.OnTestCompleted
// (Final, Native, Private)

void ARAutomatedTestManager::OnTestCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RAutomatedTestManager", "OnTestCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.K2_OnAbilityActivate
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnAbilityActivate(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnAbilityActivate");

	Params::RGCharacterScript_K2_OnAbilityActivate Parms{};

	Parms.AbilityIndex = AbilityIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.K2_OnAbilityFired
// (Event, Public, BlueprintEvent)
// Parameters:
// class URGScript*                        AbilityScript                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnAbilityFired(class URGScript* AbilityScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnAbilityFired");

	Params::RGCharacterScript_K2_OnAbilityFired Parms{};

	Parms.AbilityScript = AbilityScript;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.K2_OnAbilityReleased
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnAbilityReleased(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnAbilityReleased");

	Params::RGCharacterScript_K2_OnAbilityReleased Parms{};

	Parms.AbilityIndex = AbilityIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.K2_OnDamageTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnDamageTaken");

	Params::RGCharacterScript_K2_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.K2_OnDeath
// (Event, Public, BlueprintEvent)

void URGCharacterScript::K2_OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterScript.K2_OnEnemyKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnEnemyKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnEnemyKilled");

	Params::RGCharacterScript_K2_OnEnemyKilled Parms{};

	Parms.KilledActor = KilledActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.K2_OnPreDamageTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSourceMask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnPreDamageTaken(class URHealthComponent* Component, float Damage, int32 DamageSourceMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnPreDamageTaken");

	Params::RGCharacterScript_K2_OnPreDamageTaken Parms{};

	Parms.Component = Component;
	Parms.Damage = Damage;
	Parms.DamageSourceMask = DamageSourceMask;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.K2_OnStatusEffectTicked
// (Event, Public, BlueprintEvent)
// Parameters:
// class URGScript*                        StatusEffectScript                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::K2_OnStatusEffectTicked(class URGScript* StatusEffectScript, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "K2_OnStatusEffectTicked");

	Params::RGCharacterScript_K2_OnStatusEffectTicked Parms{};

	Parms.StatusEffectScript = StatusEffectScript;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterScript.OnAbilityActivate
// (Native, Public)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::OnAbilityActivate(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnAbilityActivate");

	Params::RGCharacterScript_OnAbilityActivate Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnAbilityFired
// (Native, Public)
// Parameters:
// class URGScript*                        AbilityScript                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::OnAbilityFired(class URGScript* AbilityScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnAbilityFired");

	Params::RGCharacterScript_OnAbilityFired Parms{};

	Parms.AbilityScript = AbilityScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnAbilityReleased
// (Native, Public)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::OnAbilityReleased(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnAbilityReleased");

	Params::RGCharacterScript_OnAbilityReleased Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnDamageTaken
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void URGCharacterScript::OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnDamageTaken");

	Params::RGCharacterScript_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnDeath
// (Native, Public)

void URGCharacterScript::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnEnemyKilled
// (Native, Public)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::OnEnemyKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnEnemyKilled");

	Params::RGCharacterScript_OnEnemyKilled Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnPreDamageTaken
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSourceMask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharacterScript::OnPreDamageTaken(class URHealthComponent* Component, float Damage, int32 DamageSourceMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnPreDamageTaken");

	Params::RGCharacterScript_OnPreDamageTaken Parms{};

	Parms.Component = Component;
	Parms.Damage = Damage;
	Parms.DamageSourceMask = DamageSourceMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterScript.OnStatusEffectTicked
// (Native, Public)
// Parameters:
// const struct FRStatusEffectTickRecord&  StatusEffectTickRecord                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URGCharacterScript::OnStatusEffectTicked(const struct FRStatusEffectTickRecord& StatusEffectTickRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterScript", "OnStatusEffectTicked");

	Params::RGCharacterScript_OnStatusEffectTicked Parms{};

	Parms.StatusEffectTickRecord = std::move(StatusEffectTickRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.AddHealthBonus
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URGCharacterMutatorScript::AddHealthBonus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "AddHealthBonus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.ApplyStatusEffects
// (Native, Public)

void URGCharacterMutatorScript::ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "ApplyStatusEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.GetMutatorDescription
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGCharacterMutatorScript::GetMutatorDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "GetMutatorDescription");

	Params::RGCharacterMutatorScript_GetMutatorDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGCharacterMutatorScript.GetMutatorRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGCharacterMutatorScript::GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "GetMutatorRank");

	Params::RGCharacterMutatorScript_GetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGCharacterMutatorScript.K2_ApplyStatusEffects
// (Event, Public, BlueprintEvent)

void URGCharacterMutatorScript::K2_ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "K2_ApplyStatusEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.K2_OnDetonate
// (Event, Public, BlueprintEvent)

void URGCharacterMutatorScript::K2_OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "K2_OnDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.K2_OnHit
// (Event, Public, BlueprintEvent)

void URGCharacterMutatorScript::K2_OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "K2_OnHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.K2_PostDetonate
// (Event, Public, BlueprintEvent)

void URGCharacterMutatorScript::K2_PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "K2_PostDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.K2_PostHit
// (Event, Public, BlueprintEvent)

void URGCharacterMutatorScript::K2_PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "K2_PostHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.K2_PreHit
// (Event, Public, BlueprintEvent)

void URGCharacterMutatorScript::K2_PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "K2_PreHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharacterMutatorScript.OnDetonate
// (Native, Public)

void URGCharacterMutatorScript::OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "OnDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.OnHit
// (Native, Public)

void URGCharacterMutatorScript::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.PostDetonate
// (Native, Public)

void URGCharacterMutatorScript::PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "PostDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.PostHit
// (Native, Public)

void URGCharacterMutatorScript::PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "PostHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.PreHit
// (Native, Public)

void URGCharacterMutatorScript::PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "PreHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGCharacterMutatorScript.RollAbilityProcChance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float*                                  OutProcChance                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             TriggeringMutatorRank                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGCharacterMutatorScript::RollAbilityProcChance(float* OutProcChance, const int32 TriggeringMutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "RollAbilityProcChance");

	Params::RGCharacterMutatorScript_RollAbilityProcChance Parms{};

	Parms.TriggeringMutatorRank = TriggeringMutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProcChance != nullptr)
		*OutProcChance = Parms.OutProcChance;

	return Parms.ReturnValue;
}


// Function RGame.RGCharacterMutatorScript.RollChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             Chance                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGCharacterMutatorScript::RollChance(const int32 Chance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "RollChance");

	Params::RGCharacterMutatorScript_RollChance Parms{};

	Parms.Chance = Chance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGCharacterMutatorScript.RollProcChance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             Chance                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutProcChance                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGCharacterMutatorScript::RollProcChance(const int32 Chance, float* OutProcChance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "RollProcChance");

	Params::RGCharacterMutatorScript_RollProcChance Parms{};

	Parms.Chance = Chance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProcChance != nullptr)
		*OutProcChance = Parms.OutProcChance;

	return Parms.ReturnValue;
}


// Function RGame.RGCharacterMutatorScript.GetDescription
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGCharacterMutatorScript::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterMutatorScript", "GetDescription");

	Params::RGCharacterMutatorScript_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChatLogEntryWidget.SetMessage
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRChatLogMessage&          IncomingMessage                                        (Parm, NativeAccessSpecifierPublic)

void URChatLogEntryWidget::SetMessage(const struct FRChatLogMessage& IncomingMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChatLogEntryWidget", "SetMessage");

	Params::RChatLogEntryWidget_SetMessage Parms{};

	Parms.IncomingMessage = std::move(IncomingMessage);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharBehaviorMutatorScript.HasBehaviorMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            BehaviorMutatorPA                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGCharBehaviorMutatorScript::HasBehaviorMutator(class URMutatorPrimaryAsset* BehaviorMutatorPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharBehaviorMutatorScript", "HasBehaviorMutator");

	Params::RGCharBehaviorMutatorScript_HasBehaviorMutator Parms{};

	Parms.BehaviorMutatorPA = BehaviorMutatorPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGCharBehaviorMutatorScript.RunAbilityBehavior
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSourceMask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OptionalAvatarActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharBehaviorMutatorScript::RunAbilityBehavior(class AActor* TriggeringActor, int32 DamageSourceMask, float HealthDamage, class AActor* OptionalAvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharBehaviorMutatorScript", "RunAbilityBehavior");

	Params::RGCharBehaviorMutatorScript_RunAbilityBehavior Parms{};

	Parms.TriggeringActor = TriggeringActor;
	Parms.DamageSourceMask = DamageSourceMask;
	Parms.HealthDamage = HealthDamage;
	Parms.OptionalAvatarActor = OptionalAvatarActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharBehaviorMutatorScript.RunMeleeBehavior
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URGCharBehaviorMutatorScript::RunMeleeBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharBehaviorMutatorScript", "RunMeleeBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGCharBehaviorMutatorScript.RunPrimaryFireBehavior
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   HealthDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharBehaviorMutatorScript::RunPrimaryFireBehavior(float HealthDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharBehaviorMutatorScript", "RunPrimaryFireBehavior");

	Params::RGCharBehaviorMutatorScript_RunPrimaryFireBehavior Parms{};

	Parms.HealthDamage = HealthDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharBehaviorMutatorScript.RunSecondaryFireBehavior
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharBehaviorMutatorScript::RunSecondaryFireBehavior(class AActor* TriggeringActor, float HealthDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharBehaviorMutatorScript", "RunSecondaryFireBehavior");

	Params::RGCharBehaviorMutatorScript_RunSecondaryFireBehavior Parms{};

	Parms.TriggeringActor = TriggeringActor;
	Parms.HealthDamage = HealthDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBehaviorScriptBlood.NativeRunBehavior
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const float                             DrainDamage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptBlood::NativeRunBehavior(const float DrainDamage, class AActor* TriggeringActor, class AActor* AvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptBlood", "NativeRunBehavior");

	Params::RBehaviorScriptBlood_NativeRunBehavior Parms{};

	Parms.DrainDamage = DrainDamage;
	Parms.TriggeringActor = TriggeringActor;
	Parms.AvatarActor = AvatarActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptDefender.NativeRunBehavior
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             BarrierGain                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptDefender::NativeRunBehavior(class AActor* TriggeringActor, const int32 BarrierGain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptDefender", "NativeRunBehavior");

	Params::RBehaviorScriptDefender_NativeRunBehavior Parms{};

	Parms.TriggeringActor = TriggeringActor;
	Parms.BarrierGain = BarrierGain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptDefender.NativeToggleShieldFX
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bActive                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptDefender::NativeToggleShieldFX(const bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptDefender", "NativeToggleShieldFX");

	Params::RBehaviorScriptDefender_NativeToggleShieldFX Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBehaviorScriptDefender.OnRep_NativeCurrentBarrierGauge
// (Final, Native, Private)

void URBehaviorScriptDefender::OnRep_NativeCurrentBarrierGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptDefender", "OnRep_NativeCurrentBarrierGauge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_WaitLoop.WaitLoop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeBetween                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FinishImmediatelyIfCountIsZero                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_WaitLoop*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_WaitLoop* URGTask_WaitLoop::WaitLoop(class URGScript* OwningScript, float TimeBetween, int32 Count, bool FinishImmediatelyIfCountIsZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_WaitLoop", "WaitLoop");

	Params::RGTask_WaitLoop_WaitLoop Parms{};

	Parms.OwningScript = OwningScript;
	Parms.TimeBetween = TimeBetween;
	Parms.Count = Count;
	Parms.FinishImmediatelyIfCountIsZero = FinishImmediatelyIfCountIsZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_WaitLoop_Windburst.WaitLoop_Windburst
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeBetween                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARNPCPawnBase*                    TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FinishImmediatelyIfCountIsZero                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_WaitLoop_Windburst*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_WaitLoop_Windburst* URGTask_WaitLoop_Windburst::WaitLoop_Windburst(class URGScript* OwningScript, float TimeBetween, int32 Count, const struct FVector& Location, class ARNPCPawnBase* TargetActor, bool FinishImmediatelyIfCountIsZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_WaitLoop_Windburst", "WaitLoop_Windburst");

	Params::RGTask_WaitLoop_Windburst_WaitLoop_Windburst Parms{};

	Parms.OwningScript = OwningScript;
	Parms.TimeBetween = TimeBetween;
	Parms.Count = Count;
	Parms.Location = std::move(Location);
	Parms.TargetActor = TargetActor;
	Parms.FinishImmediatelyIfCountIsZero = FinishImmediatelyIfCountIsZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptFortune.CheckFortunePassive6
// (Final, Native, Protected, BlueprintCallable)

void URBehaviorScriptFortune::CheckFortunePassive6()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "CheckFortunePassive6");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptFortune.GetDamageBasedOnGold
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBehaviorScriptFortune::GetDamageBasedOnGold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "GetDamageBasedOnGold");

	Params::RBehaviorScriptFortune_GetDamageBasedOnGold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptFortune.GetFortunePassive3Multiplier
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBehaviorScriptFortune::GetFortunePassive3Multiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "GetFortunePassive3Multiplier");

	Params::RBehaviorScriptFortune_GetFortunePassive3Multiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptFortune.GetFortunePassive4Effect
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBehaviorScriptFortune::GetFortunePassive4Effect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "GetFortunePassive4Effect");

	Params::RBehaviorScriptFortune_GetFortunePassive4Effect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptFortune.NativeRunBehavior
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OriginActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptFortune::NativeRunBehavior(class AActor* TriggeringActor, class AActor* OriginActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "NativeRunBehavior");

	Params::RBehaviorScriptFortune_NativeRunBehavior Parms{};

	Parms.TriggeringActor = TriggeringActor;
	Parms.OriginActor = OriginActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptFortune.RunFortunePassive6
// (Final, Native, Protected)

void URBehaviorScriptFortune::RunFortunePassive6()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "RunFortunePassive6");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptFortune.SpawnVisuals
// (Event, Protected, BlueprintEvent)

void URBehaviorScriptFortune::SpawnVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "SpawnVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RBehaviorScriptFortune.UseSphereInsteadOfDirectHit
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBehaviorScriptFortune::UseSphereInsteadOfDirectHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFortune", "UseSphereInsteadOfDirectHit");

	Params::RBehaviorScriptFortune_UseSphereInsteadOfDirectHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptFrost.NativeRunBehavior
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             StackIncrease                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptFrost::NativeRunBehavior(class AActor* TriggeringActor, const int32 StackIncrease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptFrost", "NativeRunBehavior");

	Params::RBehaviorScriptFrost_NativeRunBehavior Parms{};

	Parms.TriggeringActor = TriggeringActor;
	Parms.StackIncrease = StackIncrease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptOcean.AddSpawnableProjectileClasses
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           SpawnedTentacleActor                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptOcean::AddSpawnableProjectileClasses(class AActor* SpawnedTentacleActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptOcean", "AddSpawnableProjectileClasses");

	Params::RBehaviorScriptOcean_AddSpawnableProjectileClasses Parms{};

	Parms.SpawnedTentacleActor = SpawnedTentacleActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptOcean.HasSpawnedNumMaxTentacles
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBehaviorScriptOcean::HasSpawnedNumMaxTentacles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptOcean", "HasSpawnedNumMaxTentacles");

	Params::RBehaviorScriptOcean_HasSpawnedNumMaxTentacles Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptOcean.NativeRunBehavior
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           TriggeringActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             TriggerDamage                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptOcean::NativeRunBehavior(class AActor* TriggeringActor, const float TriggerDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptOcean", "NativeRunBehavior");

	Params::RBehaviorScriptOcean_NativeRunBehavior Parms{};

	Parms.TriggeringActor = TriggeringActor;
	Parms.TriggerDamage = TriggerDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptOcean.PollPolarOffsetLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const float                             CurrentAngleMin                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             CurrentAngleMax                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentIteration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBehaviorScriptOcean::PollPolarOffsetLocation(const float CurrentAngleMin, const float CurrentAngleMax, int32 CurrentIteration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptOcean", "PollPolarOffsetLocation");

	Params::RBehaviorScriptOcean_PollPolarOffsetLocation Parms{};

	Parms.CurrentAngleMin = CurrentAngleMin;
	Parms.CurrentAngleMax = CurrentAngleMax;
	Parms.CurrentIteration = CurrentIteration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBehaviorScriptOcean.SpawnTentacle
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             TriggerDamage                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptOcean::SpawnTentacle(const struct FVector& Location, const float TriggerDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptOcean", "SpawnTentacle");

	Params::RBehaviorScriptOcean_SpawnTentacle Parms{};

	Parms.Location = std::move(Location);
	Parms.TriggerDamage = TriggerDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBehaviorScriptSpirit.NativeActivateSpiritSpawning
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TriggerTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TriggerDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptSpirit::NativeActivateSpiritSpawning(class AActor* TriggerTarget, float TriggerDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptSpirit", "NativeActivateSpiritSpawning");

	Params::RBehaviorScriptSpirit_NativeActivateSpiritSpawning Parms{};

	Parms.TriggerTarget = TriggerTarget;
	Parms.TriggerDamage = TriggerDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBehaviorScriptSpirit.NativeAddGaugeExternal
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             ExtraGauge                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptSpirit::NativeAddGaugeExternal(const int32 ExtraGauge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptSpirit", "NativeAddGaugeExternal");

	Params::RBehaviorScriptSpirit_NativeAddGaugeExternal Parms{};

	Parms.ExtraGauge = ExtraGauge;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBehaviorScriptSpirit.NativeRunBehavior
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OrbDamage                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBehaviorScriptSpirit::NativeRunBehavior(class AActor* TargetActor, const float OrbDamage, class AActor* AvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptSpirit", "NativeRunBehavior");

	Params::RBehaviorScriptSpirit_NativeRunBehavior Parms{};

	Parms.TargetActor = TargetActor;
	Parms.OrbDamage = OrbDamage;
	Parms.AvatarActor = AvatarActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptSpirit.NativeUpdateSpiritGaugeVisuals
// (Final, Native, Protected, BlueprintCallable)

void URBehaviorScriptSpirit::NativeUpdateSpiritGaugeVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptSpirit", "NativeUpdateSpiritGaugeVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBehaviorScriptSpirit.OnRep_NativeCurrentSpiritGauge
// (Final, Native, Private)

void URBehaviorScriptSpirit::OnRep_NativeCurrentSpiritGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBehaviorScriptSpirit", "OnRep_NativeCurrentSpiritGauge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonActivatableWidget.FocusDesiredFocusWidget
// (Final, Native, Protected, BlueprintCallable)

void URCommonActivatableWidget::FocusDesiredFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonActivatableWidget", "FocusDesiredFocusWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonActivatableWidget.GetExcludedActionWidgets
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UCommonActionWidget*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UCommonActionWidget*> URCommonActivatableWidget::GetExcludedActionWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonActivatableWidget", "GetExcludedActionWidgets");

	Params::RCommonActivatableWidget_GetExcludedActionWidgets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RCommonActivatableWidget.OnWidgetPopped
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URCommonActivatableWidget::OnWidgetPopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonActivatableWidget", "OnWidgetPopped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RCommonActivatableWidget.OnWidgetPoppedCustomBehaviour
// (Event, Public, BlueprintEvent)

void URCommonActivatableWidget::OnWidgetPoppedCustomBehaviour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonActivatableWidget", "OnWidgetPoppedCustomBehaviour");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RCommonActivatableWidget.PopWidget
// (Final, Native, Public, BlueprintCallable)

void URCommonActivatableWidget::PopWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonActivatableWidget", "PopWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonLootSelectScreen.ShowLootOptions
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URCommonLootSelectScreen::ShowLootOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonLootSelectScreen", "ShowLootOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RNPCPawnBase.ApplyCachedOverlayMaterial
// (Final, Native, Public, BlueprintCallable)

void ARNPCPawnBase::ApplyCachedOverlayMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ApplyCachedOverlayMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.CacheCurrentOverlayMaterial
// (Final, Native, Public, BlueprintCallable)

void ARNPCPawnBase::CacheCurrentOverlayMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "CacheCurrentOverlayMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.EvaluateThreatTargets
// (Native, Protected, BlueprintCallable)

void ARNPCPawnBase::EvaluateThreatTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "EvaluateThreatTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ForceKillNPC
// (Final, Native, Public, BlueprintCallable)

void ARNPCPawnBase::ForceKillNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ForceKillNPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.GetMeleeExecutaionPercentageRange
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARNPCPawnBase::GetMeleeExecutaionPercentageRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "GetMeleeExecutaionPercentageRange");

	Params::RNPCPawnBase_GetMeleeExecutaionPercentageRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNPCPawnBase.OnDamageDealt
// (Native, Public)
// Parameters:
// class ARPawnBase*                       Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnDamageDealt(class ARPawnBase* Pawn, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnDamageDealt");

	Params::RNPCPawnBase_OnDamageDealt Parms{};

	Parms.Pawn = Pawn;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnDamageTaken
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEvent                                            (Parm, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnDamageTaken");

	Params::RNPCPawnBase_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageEvent = std::move(DamageEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnDeath
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnDeath(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnDeath");

	Params::RNPCPawnBase_OnDeath Parms{};

	Parms.Component = Component;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnFinishedRunningScriptFunction
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName&                      Category                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Function                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnFinishedRunningScriptFunction(const class FName& Category, const class FName& Function)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnFinishedRunningScriptFunction");

	Params::RNPCPawnBase_OnFinishedRunningScriptFunction Parms{};

	Parms.Category = Category;
	Parms.Function = Function;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnPlayerLeftGame
// (Final, Native, Public)
// Parameters:
// class APlayerState*                     LeavingPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnPlayerLeftGame(class APlayerState* LeavingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnPlayerLeftGame");

	Params::RNPCPawnBase_OnPlayerLeftGame Parms{};

	Parms.LeavingPlayerState = LeavingPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnPreDamageDealt
// (Native, Public)
// Parameters:
// class ARPawnBase*                       Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasCritical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSourceMask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnPreDamageDealt(class ARPawnBase* Pawn, class AActor* DamagedActor, bool bWasCritical, int32 DamageSourceMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnPreDamageDealt");

	Params::RNPCPawnBase_OnPreDamageDealt Parms{};

	Parms.Pawn = Pawn;
	Parms.DamagedActor = DamagedActor;
	Parms.bWasCritical = bWasCritical;
	Parms.DamageSourceMask = DamageSourceMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnPreDamageTaken
// (Native, Public)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSourceMask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::OnPreDamageTaken(class URHealthComponent* Component, float Damage, int32 DamageSourceMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnPreDamageTaken");

	Params::RNPCPawnBase_OnPreDamageTaken Parms{};

	Parms.Component = Component;
	Parms.Damage = Damage;
	Parms.DamageSourceMask = DamageSourceMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.OnRep_NPCScript
// (Final, Native, Private)

void ARNPCPawnBase::OnRep_NPCScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "OnRep_NPCScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.PostNPCScriptAdded
// (Native, Public)

void ARNPCPawnBase::PostNPCScriptAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "PostNPCScriptAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ReceiveOnDamageDealt
// (Native, Event, Public, BlueprintEvent)

void ARNPCPawnBase::ReceiveOnDamageDealt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ReceiveOnDamageDealt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ReceiveOnDamageTaken
// (Native, Event, Public, BlueprintEvent)

void ARNPCPawnBase::ReceiveOnDamageTaken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ReceiveOnDamageTaken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ReceiveOnDeath
// (Native, Event, Public, BlueprintEvent)

void ARNPCPawnBase::ReceiveOnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ReceiveOnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ReceiveOnPreDamageDealt
// (Native, Event, Public, BlueprintEvent)

void ARNPCPawnBase::ReceiveOnPreDamageDealt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ReceiveOnPreDamageDealt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ReceiveOnPreDamageTaken
// (Native, Event, Public, BlueprintEvent)

void ARNPCPawnBase::ReceiveOnPreDamageTaken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ReceiveOnPreDamageTaken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.ReceivePostNPCScriptAdded
// (Native, Event, Public, BlueprintEvent)

void ARNPCPawnBase::ReceivePostNPCScriptAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "ReceivePostNPCScriptAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.SetEvaluateThreatAfterAllActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::SetEvaluateThreatAfterAllActions(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "SetEvaluateThreatAfterAllActions");

	Params::RNPCPawnBase_SetEvaluateThreatAfterAllActions Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.SetEvaluateThreatTargetsBetweenAttacks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::SetEvaluateThreatTargetsBetweenAttacks(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "SetEvaluateThreatTargetsBetweenAttacks");

	Params::RNPCPawnBase_SetEvaluateThreatTargetsBetweenAttacks Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.SetEvaluateThreatTargetsBetweenSpecials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::SetEvaluateThreatTargetsBetweenSpecials(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "SetEvaluateThreatTargetsBetweenSpecials");

	Params::RNPCPawnBase_SetEvaluateThreatTargetsBetweenSpecials Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.SpawnLoot
// (Native, Public, BlueprintCallable)

void ARNPCPawnBase::SpawnLoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "SpawnLoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.TryAddThreatTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNPCPawnBase::TryAddThreatTarget(class APlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "TryAddThreatTarget");

	Params::RNPCPawnBase_TryAddThreatTarget Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNPCPawnBase.GetMaxHealthCoefficient
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARNPCPawnBase::GetMaxHealthCoefficient() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnBase", "GetMaxHealthCoefficient");

	Params::RNPCPawnBase_GetMaxHealthCoefficient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileScript.ApplyStatusEffects
// (Native, Public)

void URGProjectileScript::ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "ApplyStatusEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileScript.K2_ApplyStatusEffects
// (Event, Public, BlueprintEvent)

void URGProjectileScript::K2_ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "K2_ApplyStatusEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileScript.K2_OnHit
// (Event, Public, BlueprintEvent)

void URGProjectileScript::K2_OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "K2_OnHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileScript.K2_PostHit
// (Event, Public, BlueprintEvent)

void URGProjectileScript::K2_PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "K2_PostHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileScript.K2_PreHit
// (Event, Public, BlueprintEvent)

void URGProjectileScript::K2_PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "K2_PreHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileScript.OnHit
// (Native, Public)

void URGProjectileScript::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileScript.PostHit
// (Native, Public)

void URGProjectileScript::PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "PostHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileScript.PreHit
// (Native, Public)

void URGProjectileScript::PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileScript", "PreHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGRocketScript.K2_OnDetonate
// (Event, Public, BlueprintEvent)

void URGRocketScript::K2_OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "K2_OnDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGRocketScript.K2_PostDetonate
// (Event, Public, BlueprintEvent)

void URGRocketScript::K2_PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "K2_PostDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGRocketScript.K2_PreDetonate
// (Event, Public, BlueprintEvent)

void URGRocketScript::K2_PreDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "K2_PreDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGRocketScript.OnDetonate
// (Native, Public)

void URGRocketScript::OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "OnDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGRocketScript.PostDetonate
// (Native, Public)

void URGRocketScript::PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "PostDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGRocketScript.PreDetonate
// (Native, Public)

void URGRocketScript::PreDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "PreDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGRocketScript.GetOwningRocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARRocket*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARRocket* URGRocketScript::GetOwningRocket() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGRocketScript", "GetOwningRocket");

	Params::RGRocketScript_GetOwningRocket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBossPawnBase.OnAllPlayersDead
// (Final, Native, Private)

void ARBossPawnBase::OnAllPlayersDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "OnAllPlayersDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawnBase.OnCombatActivatedUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARBossPawnBase::OnCombatActivatedUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "OnCombatActivatedUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RBossPawnBase.OnCurrentTargetDowned
// (Final, Native, Private)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawnBase::OnCurrentTargetDowned(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "OnCurrentTargetDowned");

	Params::RBossPawnBase_OnCurrentTargetDowned Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawnBase.OnCurrentTargetKilled
// (Final, Native, Private)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawnBase::OnCurrentTargetKilled(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "OnCurrentTargetKilled");

	Params::RBossPawnBase_OnCurrentTargetKilled Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawnBase.OnRep_CombatActivated
// (Final, Native, Private)

void ARBossPawnBase::OnRep_CombatActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "OnRep_CombatActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawnBase.PushHealthBarWidget_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ARBossPawnBase::PushHealthBarWidget_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "PushHealthBarWidget_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawnBase.SetNewPlayerTarget_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipRotationClear                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawnBase::SetNewPlayerTarget_Multicast(class ARPlayerPawn* NewTarget, bool bSkipRotationClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "SetNewPlayerTarget_Multicast");

	Params::RBossPawnBase_SetNewPlayerTarget_Multicast Parms{};

	Parms.NewTarget = NewTarget;
	Parms.bSkipRotationClear = bSkipRotationClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawnBase.SkipToTorakaSecretPhase
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARBossPawnBase::SkipToTorakaSecretPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawnBase", "SkipToTorakaSecretPhase");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RBossPawn_Golemancer.GetRandomPlatforms
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const int32                             MinimumFreePlatformsRequired                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumberOfPlatformsToChoose                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARBossPawn_Golemancer::GetRandomPlatforms(const int32 MinimumFreePlatformsRequired, const int32 NumberOfPlatformsToChoose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "GetRandomPlatforms");

	Params::RBossPawn_Golemancer_GetRandomPlatforms Parms{};

	Parms.MinimumFreePlatformsRequired = MinimumFreePlatformsRequired;
	Parms.NumberOfPlatformsToChoose = NumberOfPlatformsToChoose;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RBossPawn_Golemancer.PlayCoreOverloadTimeline
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             From                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             To                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::PlayCoreOverloadTimeline(const float From, const float To, const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "PlayCoreOverloadTimeline");

	Params::RBossPawn_Golemancer_PlayCoreOverloadTimeline Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Golemancer.SetRandomTarget
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARBossPawn_Golemancer::SetRandomTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "SetRandomTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RBossPawn_Golemancer.ToggleBodyDamageEmissive
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             EncounterPhase                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::ToggleBodyDamageEmissive(const int32 EncounterPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "ToggleBodyDamageEmissive");

	Params::RBossPawn_Golemancer_ToggleBodyDamageEmissive Parms{};

	Parms.EncounterPhase = EncounterPhase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Golemancer.ToggleHammerTrailVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bNewVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::ToggleHammerTrailVisibility(const bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "ToggleHammerTrailVisibility");

	Params::RBossPawn_Golemancer_ToggleHammerTrailVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Golemancer.ToggleHandGlow
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bIsRighthand                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bNewVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::ToggleHandGlow(const bool bIsRighthand, const bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "ToggleHandGlow");

	Params::RBossPawn_Golemancer_ToggleHandGlow Parms{};

	Parms.bIsRighthand = bIsRighthand;
	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Golemancer.ToggleImmunityShieldVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bNewVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::ToggleImmunityShieldVisibility(const bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "ToggleImmunityShieldVisibility");

	Params::RBossPawn_Golemancer_ToggleImmunityShieldVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Golemancer.ToggleSocketFXVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bNewVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::ToggleSocketFXVisibility(const bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "ToggleSocketFXVisibility");

	Params::RBossPawn_Golemancer_ToggleSocketFXVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Golemancer.ToggleWhirlwindVisuals
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bNewVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBossPawn_Golemancer::ToggleWhirlwindVisuals(const bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Golemancer", "ToggleWhirlwindVisuals");

	Params::RBossPawn_Golemancer_ToggleWhirlwindVisuals Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBTTask_MoveTo.Pathfinding_OnDynamicCollisionAlert
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRNavigationDynamicCollisionPayload&Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBTTask_MoveTo::Pathfinding_OnDynamicCollisionAlert(const struct FRNavigationDynamicCollisionPayload& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTTask_MoveTo", "Pathfinding_OnDynamicCollisionAlert");

	Params::RBTTask_MoveTo_Pathfinding_OnDynamicCollisionAlert Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBTTask_MoveTo.Pathfinding_OnFinish
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRNavigationQueryData&     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBTTask_MoveTo::Pathfinding_OnFinish(const struct FRNavigationQueryData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTTask_MoveTo", "Pathfinding_OnFinish");

	Params::RBTTask_MoveTo_Pathfinding_OnFinish Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.GetRGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARGameState*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARGameState* ARGameState::GetRGameState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameState", "GetRGameState");

	Params::RGameState_GetRGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.AddGoldToPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Delta                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::AddGoldToPlayer(class APlayerController* PlayerController, const int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "AddGoldToPlayer");

	Params::RGameState_AddGoldToPlayer Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.AddPortalChoiceNodeId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             NodeID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::AddPortalChoiceNodeId(const int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "AddPortalChoiceNodeId");

	Params::RGameState_AddPortalChoiceNodeId Parms{};

	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.ApplyPlayerCosmetics
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerCosmeticOption&     CosmeticOptionData                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    RWeaponCosmeticPath                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::ApplyPlayerCosmetics(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const class FString& RWeaponCosmeticPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "ApplyPlayerCosmetics");

	Params::RGameState_ApplyPlayerCosmetics Parms{};

	Parms.RPlayerPawn = RPlayerPawn;
	Parms.CosmeticOptionData = std::move(CosmeticOptionData);
	Parms.RWeaponCosmeticPath = std::move(RWeaponCosmeticPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.ApplyPlayerCosmetics_Multicast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerCosmeticOption&     CosmeticOptionData                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    RWeaponCosmeticPath                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::ApplyPlayerCosmetics_Multicast(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const class FString& RWeaponCosmeticPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "ApplyPlayerCosmetics_Multicast");

	Params::RGameState_ApplyPlayerCosmetics_Multicast Parms{};

	Parms.RPlayerPawn = RPlayerPawn;
	Parms.CosmeticOptionData = std::move(CosmeticOptionData);
	Parms.RWeaponCosmeticPath = std::move(RWeaponCosmeticPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.BroadcastOnFinalBossKilled
// (Final, Native, Public, BlueprintCallable)

void ARGameState::BroadcastOnFinalBossKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "BroadcastOnFinalBossKilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.BroadcastOnKeyUsed_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorUsedOn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::BroadcastOnKeyUsed_Multicast(class AActor* ActorUsedOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "BroadcastOnKeyUsed_Multicast");

	Params::RGameState_BroadcastOnKeyUsed_Multicast Parms{};

	Parms.ActorUsedOn = ActorUsedOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.BroadcastOnLoadingScreenPushed
// (Final, Native, Public, BlueprintCallable)

void ARGameState::BroadcastOnLoadingScreenPushed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "BroadcastOnLoadingScreenPushed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.BroadcastOnMidRunLoadingScreenPopped_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const int32                             CurrentNodeId                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::BroadcastOnMidRunLoadingScreenPopped_Multicast(const int32 CurrentNodeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "BroadcastOnMidRunLoadingScreenPopped_Multicast");

	Params::RGameState_BroadcastOnMidRunLoadingScreenPopped_Multicast Parms{};

	Parms.CurrentNodeId = CurrentNodeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.BroadcastOnMidRunLoadingScreenPopped_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const int32                             CurrentNodeId                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::BroadcastOnMidRunLoadingScreenPopped_Server(const int32 CurrentNodeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "BroadcastOnMidRunLoadingScreenPopped_Server");

	Params::RGameState_BroadcastOnMidRunLoadingScreenPopped_Server Parms{};

	Parms.CurrentNodeId = CurrentNodeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.Debug_SetRoomDifficulty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SetLevelsCompleted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::Debug_SetRoomDifficulty(int32 SetLevelsCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "Debug_SetRoomDifficulty");

	Params::RGameState_Debug_SetRoomDifficulty Parms{};

	Parms.SetLevelsCompleted = SetLevelsCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableBossHealAltarModified
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableBossHealAltarModified(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableBossHealAltarModified");

	Params::RGameState_EnableBossHealAltarModified Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableBossModifiedMoveKit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableBossModifiedMoveKit(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableBossModifiedMoveKit");

	Params::RGameState_EnableBossModifiedMoveKit Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableEnemyMeleeKillOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableEnemyMeleeKillOnly(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableEnemyMeleeKillOnly");

	Params::RGameState_EnableEnemyMeleeKillOnly Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableGoldGainForPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableGoldGainForPlayer(class APlayerController* PlayerController, bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableGoldGainForPlayer");

	Params::RGameState_EnableGoldGainForPlayer Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableHealAltarSyringesModified
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableHealAltarSyringesModified(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableHealAltarSyringesModified");

	Params::RGameState_EnableHealAltarSyringesModified Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableKillAllElites
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableKillAllElites(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableKillAllElites");

	Params::RGameState_EnableKillAllElites Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.EnableLastEnemyModified
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::EnableLastEnemyModified(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "EnableLastEnemyModified");

	Params::RGameState_EnableLastEnemyModified Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.GetDifficultySettingFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARGameState::GetDifficultySettingFactor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetDifficultySettingFactor");

	Params::RGameState_GetDifficultySettingFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetDifficultyTreeAssignedPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARGameState::GetDifficultyTreeAssignedPoints(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetDifficultyTreeAssignedPoints");

	Params::RGameState_GetDifficultyTreeAssignedPoints Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetGlobalScriptComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* ARGameState::GetGlobalScriptComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetGlobalScriptComponent");

	Params::RGameState_GetGlobalScriptComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetHealthPerNodeAtValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARGameState::GetHealthPerNodeAtValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetHealthPerNodeAtValue");

	Params::RGameState_GetHealthPerNodeAtValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetHealthPerPlayerAtValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARGameState::GetHealthPerPlayerAtValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetHealthPerPlayerAtValue");

	Params::RGameState_GetHealthPerPlayerAtValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetHueShift
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 ARGameState::GetHueShift(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetHueShift");

	Params::RGameState_GetHueShift Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetNumDifficultyTreeAssignedPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARGameState::GetNumDifficultyTreeAssignedPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetNumDifficultyTreeAssignedPoints");

	Params::RGameState_GetNumDifficultyTreeAssignedPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetNumDisconnectedPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARGameState::GetNumDisconnectedPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetNumDisconnectedPlayers");

	Params::RGameState_GetNumDisconnectedPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetPlayerGold
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARGameState::GetPlayerGold(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetPlayerGold");

	Params::RGameState_GetPlayerGold Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetPlayerPawns
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARPlayerPawn*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARPlayerPawn*> ARGameState::GetPlayerPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetPlayerPawns");

	Params::RGameState_GetPlayerPawns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetRoomDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARGameState::GetRoomDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetRoomDifficulty");

	Params::RGameState_GetRoomDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.GetRunStats
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRRunStats                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRRunStats ARGameState::GetRunStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "GetRunStats");

	Params::RGameState_GetRunStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameState.OnFinishRun_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    RunFailed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::OnFinishRun_Multicast(bool RunFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnFinishRun_Multicast");

	Params::RGameState_OnFinishRun_Multicast Parms{};

	Parms.RunFailed = RunFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.OnLevelCompleted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARGameState::OnLevelCompleted_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnLevelCompleted_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.OnRep_CharacterSlots
// (Final, Native, Protected)

void ARGameState::OnRep_CharacterSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnRep_CharacterSlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.OnSegmentCompleted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARGameState::OnSegmentCompleted_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnSegmentCompleted_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.OnSessionUserInviteAcceptedEOS
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FBlueprintSessionResult&   Session                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccesful                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::OnSessionUserInviteAcceptedEOS(const struct FBlueprintSessionResult& Session, bool bWasSuccesful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnSessionUserInviteAcceptedEOS");

	Params::RGameState_OnSessionUserInviteAcceptedEOS Parms{};

	Parms.Session = std::move(Session);
	Parms.bWasSuccesful = bWasSuccesful;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGameState.OnSessionUserInviteAcceptedSteam
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    SessionId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::OnSessionUserInviteAcceptedSteam(const class FString& SessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnSessionUserInviteAcceptedSteam");

	Params::RGameState_OnSessionUserInviteAcceptedSteam Parms{};

	Parms.SessionId = std::move(SessionId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGameState.OnStartRun_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARGameState::OnStartRun_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "OnStartRun_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.PlayerFinishMidRunLoading
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::PlayerFinishMidRunLoading(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "PlayerFinishMidRunLoading");

	Params::RGameState_PlayerFinishMidRunLoading Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGameState.PlayerJoined_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Message                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARGameState::PlayerJoined_Multicast(class APlayerState* PlayerState, const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "PlayerJoined_Multicast");

	Params::RGameState_PlayerJoined_Multicast Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.PlayerLeft_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::PlayerLeft_Multicast(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "PlayerLeft_Multicast");

	Params::RGameState_PlayerLeft_Multicast Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.PushMidRunLoadingScreen
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARGameState::PushMidRunLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "PushMidRunLoadingScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGameState.PushMidRunLoadingScreen_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ARGameState::PushMidRunLoadingScreen_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "PushMidRunLoadingScreen_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.ResetPlayerRunStats
// (Final, Native, Private)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::ResetPlayerRunStats(class ARPlayerPawn* RPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "ResetPlayerRunStats");

	Params::RGameState_ResetPlayerRunStats Parms{};

	Parms.RPlayerPawn = RPlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.ResetStats
// (Final, Native, Public, BlueprintCallable)

void ARGameState::ResetStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "ResetStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.SendChatMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const struct FRChatLogMessage&          NewMessage                                             (Parm, NativeAccessSpecifierPublic)

void ARGameState::SendChatMessage(const struct FRChatLogMessage& NewMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "SendChatMessage");

	Params::RGameState_SendChatMessage Parms{};

	Parms.NewMessage = std::move(NewMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.SetDifficultyTreeAssignedPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              SaveToSaveGame                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::SetDifficultyTreeAssignedPoints(class FName Key, int32 Points, const bool SaveToSaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "SetDifficultyTreeAssignedPoints");

	Params::RGameState_SetDifficultyTreeAssignedPoints Parms{};

	Parms.Key = Key;
	Parms.Points = Points;
	Parms.SaveToSaveGame = SaveToSaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.SetIsInRun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsInRun                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::SetIsInRun(bool IsInRun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "SetIsInRun");

	Params::RGameState_SetIsInRun Parms{};

	Parms.IsInRun = IsInRun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameState.UpdatePlayerClothes
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      NewHeadMesh                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector4&                  Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGameState::UpdatePlayerClothes(class ARPlayerPawn* RPlayerPawn, class UStaticMesh* NewHeadMesh, const struct FVector4& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "UpdatePlayerClothes");

	Params::RGameState_UpdatePlayerClothes Parms{};

	Parms.RPlayerPawn = RPlayerPawn;
	Parms.NewHeadMesh = NewHeadMesh;
	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGameState.UpdatePlayerCosmetics
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerCosmeticOption&     CosmeticOptionData                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARGameState::UpdatePlayerCosmetics(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameState", "UpdatePlayerCosmetics");

	Params::RGameState_UpdatePlayerCosmetics Parms{};

	Parms.RPlayerPawn = RPlayerPawn;
	Parms.CosmeticOptionData = std::move(CosmeticOptionData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RBossPawn_Unglu.GetClosestChargeBlastLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARAIMovementLocation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAIMovementLocation* ARBossPawn_Unglu::GetClosestChargeBlastLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Unglu", "GetClosestChargeBlastLocation");

	Params::RBossPawn_Unglu_GetClosestChargeBlastLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBossPawn_Unglu.GetClosestStationaryBeamLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARAIMovementLocation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAIMovementLocation* ARBossPawn_Unglu::GetClosestStationaryBeamLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Unglu", "GetClosestStationaryBeamLocation");

	Params::RBossPawn_Unglu_GetClosestStationaryBeamLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBossPawn_Unglu.GetRandomStationaryBeamCloneLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARAIMovementLocation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAIMovementLocation* ARBossPawn_Unglu::GetRandomStationaryBeamCloneLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Unglu", "GetRandomStationaryBeamCloneLocation");

	Params::RBossPawn_Unglu_GetRandomStationaryBeamCloneLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBossPawn_Unglu.SetRandomTarget
// (Final, Native, Public, BlueprintCallable)

void ARBossPawn_Unglu::SetRandomTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Unglu", "SetRandomTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawn_Unglu.SetRandomTarget_Multicast
// (Final, Net, Native, Event, NetMulticast, Private)

void ARBossPawn_Unglu::SetRandomTarget_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Unglu", "SetRandomTarget_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBossPawn_Unglu.TriggerEnemySpawning
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARBossPawn_Unglu::TriggerEnemySpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBossPawn_Unglu", "TriggerEnemySpawning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RBoxVisualizerComponent.SetBoxCenter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewCenter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBoxVisualizerComponent::SetBoxCenter(const struct FVector& NewCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBoxVisualizerComponent", "SetBoxCenter");

	Params::RBoxVisualizerComponent_SetBoxCenter Parms{};

	Parms.NewCenter = std::move(NewCenter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBoxVisualizerComponent.SetBoxExtents
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FBox&                      NewExtents                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBoxVisualizerComponent::SetBoxExtents(const struct FBox& NewExtents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBoxVisualizerComponent", "SetBoxExtents");

	Params::RBoxVisualizerComponent_SetBoxExtents Parms{};

	Parms.NewExtents = std::move(NewExtents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBoxVisualizerComponent.GetBox
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox URBoxVisualizerComponent::GetBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBoxVisualizerComponent", "GetBox");

	Params::RBoxVisualizerComponent_GetBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBoxVisualizerComponent.GetBoxCenter
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBoxVisualizerComponent::GetBoxCenter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBoxVisualizerComponent", "GetBoxCenter");

	Params::RBoxVisualizerComponent_GetBoxCenter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_CanFire.CanFire
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_CanFire*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_CanFire* URGTask_CanFire::CanFire(class URGScript* OwningScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_CanFire", "CanFire");

	Params::RGTask_CanFire_CanFire Parms{};

	Parms.OwningScript = OwningScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBreakableActor.DestroyMesh
// (Final, Native, Protected)
// Parameters:
// class URHealthComponent*                AffectedHealthComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARBreakableActor::DestroyMesh(class URHealthComponent* AffectedHealthComponent, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBreakableActor", "DestroyMesh");

	Params::RBreakableActor_DestroyMesh Parms{};

	Parms.AffectedHealthComponent = AffectedHealthComponent;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBreakableActor.OnComponentHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBreakableActor::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBreakableActor", "OnComponentHit");

	Params::RBreakableActor_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RBreakableActor.OnFragmentSleep
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBreakableActor::OnFragmentSleep(class UPrimitiveComponent* InComp, class FName InBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBreakableActor", "OnFragmentSleep");

	Params::RBreakableActor_OnFragmentSleep Parms{};

	Parms.InComp = InComp;
	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.GetChallengeManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARChallengeManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARChallengeManager* ARChallengeManager::GetChallengeManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RChallengeManager", "GetChallengeManager");

	Params::RChallengeManager_GetChallengeManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.ParseChallengeDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ChallengeId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARChallengeManager::ParseChallengeDescription(const class UObject* WorldContextObject, const class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RChallengeManager", "ParseChallengeDescription");

	Params::RChallengeManager_ParseChallengeDescription Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.ChallengeExists
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARChallengeManager::ChallengeExists(class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "ChallengeExists");

	Params::RChallengeManager_ChallengeExists Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.CreateChallengeGridItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRChallenge&               Challenge                                              (ConstParm, Parm, NativeAccessSpecifierPublic)
// class URChallengeGridItem*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URChallengeGridItem* ARChallengeManager::CreateChallengeGridItem(const struct FRChallenge& Challenge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "CreateChallengeGridItem");

	Params::RChallengeManager_CreateChallengeGridItem Parms{};

	Parms.Challenge = std::move(Challenge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetAllChallenges
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FRChallenge>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRChallenge> ARChallengeManager::GetAllChallenges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetAllChallenges");

	Params::RChallengeManager_GetAllChallenges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeByChallengeScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class URChallengeScript*          ChallengeScript                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRChallenge                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRChallenge ARChallengeManager::GetChallengeByChallengeScript(const class URChallengeScript* ChallengeScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeByChallengeScript");

	Params::RChallengeManager_GetChallengeByChallengeScript Parms{};

	Parms.ChallengeScript = ChallengeScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeCompletionCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARChallengeManager::GetChallengeCompletionCount(class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeCompletionCount");

	Params::RChallengeManager_GetChallengeCompletionCount Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeGridItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bExcludeCompleted                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CompletionRatioThreshold                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URChallengeGridItem*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URChallengeGridItem*> ARChallengeManager::GetChallengeGridItems(bool bExcludeCompleted, float CompletionRatioThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeGridItems");

	Params::RChallengeManager_GetChallengeGridItems Parms{};

	Parms.bExcludeCompleted = bExcludeCompleted;
	Parms.CompletionRatioThreshold = CompletionRatioThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeRewardAssets
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URPrimaryDataAsset**              OutReward                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutSoulFragmentsReward                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARChallengeManager::GetChallengeRewardAssets(class FName ChallengeId, class URPrimaryDataAsset** OutReward, int32* OutSoulFragmentsReward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeRewardAssets");

	Params::RChallengeManager_GetChallengeRewardAssets Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutReward != nullptr)
		*OutReward = Parms.OutReward;

	if (OutSoulFragmentsReward != nullptr)
		*OutSoulFragmentsReward = Parms.OutSoulFragmentsReward;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeWithMutatorRewardCompletionCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorPrimaryAsset                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  CurrentCompletionCount                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  MaxCompletionCount                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARChallengeManager::GetChallengeWithMutatorRewardCompletionCount(class URMutatorPrimaryAsset* MutatorPrimaryAsset, int32* CurrentCompletionCount, int32* MaxCompletionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeWithMutatorRewardCompletionCount");

	Params::RChallengeManager_GetChallengeWithMutatorRewardCompletionCount Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentCompletionCount != nullptr)
		*CurrentCompletionCount = Parms.CurrentCompletionCount;

	if (MaxCompletionCount != nullptr)
		*MaxCompletionCount = Parms.MaxCompletionCount;
}


// Function RGame.RChallengeManager.GetChallengeWithMutatorRewardDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorPrimaryAsset                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARChallengeManager::GetChallengeWithMutatorRewardDescription(class URMutatorPrimaryAsset* MutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeWithMutatorRewardDescription");

	Params::RChallengeManager_GetChallengeWithMutatorRewardDescription Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeWithMutatorRewardName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorPrimaryAsset                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARChallengeManager::GetChallengeWithMutatorRewardName(class URMutatorPrimaryAsset* MutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeWithMutatorRewardName");

	Params::RChallengeManager_GetChallengeWithMutatorRewardName Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.IsChallengeCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARChallengeManager::IsChallengeCompleted(class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "IsChallengeCompleted");

	Params::RChallengeManager_IsChallengeCompleted Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.IsChallengeWithMutatorRewardCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorPrimaryAsset                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARChallengeManager::IsChallengeWithMutatorRewardCompleted(class URMutatorPrimaryAsset* MutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "IsChallengeWithMutatorRewardCompleted");

	Params::RChallengeManager_IsChallengeWithMutatorRewardCompleted Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.OnChallengeCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ChallengeId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARChallengeManager::OnChallengeCompleted(const class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "OnChallengeCompleted");

	Params::RChallengeManager_OnChallengeCompleted Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.ProgressChallenge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceFullCompletion                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ProgressAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipLobbyCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipDeathCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARChallengeManager::ProgressChallenge(class FName ChallengeId, bool ForceFullCompletion, int32 ProgressAmount, bool bSkipLobbyCheck, bool bSkipDeathCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "ProgressChallenge");

	Params::RChallengeManager_ProgressChallenge Parms{};

	Parms.ChallengeId = ChallengeId;
	Parms.ForceFullCompletion = ForceFullCompletion;
	Parms.ProgressAmount = ProgressAmount;
	Parms.bSkipLobbyCheck = bSkipLobbyCheck;
	Parms.bSkipDeathCheck = bSkipDeathCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.RegisterPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARPlayerController*               InPlayerController                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARChallengeManager::RegisterPlayer(class ARPlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "RegisterPlayer");

	Params::RChallengeManager_RegisterPlayer Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.ResetChallenge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ChallengeId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARChallengeManager::ResetChallenge(const class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "ResetChallenge");

	Params::RChallengeManager_ResetChallenge Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.ResetSteamAchievements
// (Final, Native, Public, BlueprintCallable)

void ARChallengeManager::ResetSteamAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "ResetSteamAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.SetChallengeCompletionCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CompletionCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARChallengeManager::SetChallengeCompletionCount(class FName ChallengeId, int32 CompletionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "SetChallengeCompletionCount");

	Params::RChallengeManager_SetChallengeCompletionCount Parms{};

	Parms.ChallengeId = ChallengeId;
	Parms.CompletionCount = CompletionCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.SimulateAllMutatorsUnlocked
// (Final, Native, Public, BlueprintCallable)

void ARChallengeManager::SimulateAllMutatorsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "SimulateAllMutatorsUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChallengeManager.FindChallengeById
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    ChallengeId                                            (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRChallenge                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRChallenge ARChallengeManager::FindChallengeById(const class FString& ChallengeId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "FindChallengeById");

	Params::RChallengeManager_FindChallengeById Parms{};

	Parms.ChallengeId = std::move(ChallengeId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeByRewardAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URPrimaryDataAsset*         RPrimaryDataAsset                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRChallenge                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRChallenge ARChallengeManager::GetChallengeByRewardAsset(const class URPrimaryDataAsset* RPrimaryDataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeByRewardAsset");

	Params::RChallengeManager_GetChallengeByRewardAsset Parms{};

	Parms.RPrimaryDataAsset = RPrimaryDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RChallengeManager.GetChallengeByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              ChallengeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRChallenge                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRChallenge ARChallengeManager::GetChallengeByTag(const struct FGameplayTag& ChallengeTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChallengeManager", "GetChallengeByTag");

	Params::RChallengeManager_GetChallengeByTag Parms{};

	Parms.ChallengeTag = std::move(ChallengeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBreakablesManager.GetBreakablesManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBreakablesManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBreakablesManager* ARBreakablesManager::GetBreakablesManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBreakablesManager", "GetBreakablesManager");

	Params::RBreakablesManager_GetBreakablesManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RBreakablesManager.GetActorsInPool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBreakablesManager::GetActorsInPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBreakablesManager", "GetActorsInPool");

	Params::RBreakablesManager_GetActorsInPool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDecalManger.GetDecalManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARDecalManger*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARDecalManger* ARDecalManger::GetDecalManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RDecalManger", "GetDecalManager");

	Params::RDecalManger_GetDecalManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDecalManger.RegisterDecal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDecalComponent*                  NewDecal                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDecalManger::RegisterDecal(class UDecalComponent* NewDecal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDecalManger", "RegisterDecal");

	Params::RDecalManger_RegisterDecal Parms{};

	Parms.NewDecal = NewDecal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDecalManger.RegisterNiagaraDecal
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Forward                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDecalManger::RegisterNiagaraDecal(const class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDecalManger", "RegisterNiagaraDecal");

	Params::RDecalManger_RegisterNiagaraDecal Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.Forward = std::move(Forward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChatLog.AddChatLogEntryToLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRChatLogMessage&          Message                                                (Parm, NativeAccessSpecifierPublic)

void URChatLog::AddChatLogEntryToLocalPlayer(class APlayerController* PlayerController, const struct FRChatLogMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RChatLog", "AddChatLogEntryToLocalPlayer");

	Params::RChatLog_AddChatLogEntryToLocalPlayer Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RChatLog.AddChatLogEntry
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRChatLogMessage&          IncomingMessage                                        (Parm, NativeAccessSpecifierPublic)

void URChatLog::AddChatLogEntry(const struct FRChatLogMessage& IncomingMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RChatLog", "AddChatLogEntry");

	Params::RChatLog_AddChatLogEntry Parms{};

	Parms.IncomingMessage = std::move(IncomingMessage);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.ROceanGodTentacle.AddSpawnableProjectileClass
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           NewProjectileClass                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROceanGodTentacle::AddSpawnableProjectileClass(class UClass* NewProjectileClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROceanGodTentacle", "AddSpawnableProjectileClass");

	Params::ROceanGodTentacle_AddSpawnableProjectileClass Parms{};

	Parms.NewProjectileClass = NewProjectileClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterStatCharmScript.GetStatCharmDescription
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGCharacterStatCharmScript::GetStatCharmDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterStatCharmScript", "GetStatCharmDescription");

	Params::RGCharacterStatCharmScript_GetStatCharmDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGCharacterStatCharmScript.SwapStatCharm
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class ARPickupableItem*                 OldStatCharmActorRef                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERewardRarity                           NewRarity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FStatCharmStat>&    NewMutatorStats                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URGCharacterStatCharmScript::SwapStatCharm(class ARPickupableItem* OldStatCharmActorRef, const struct FTransform& SpawnTransform, ERewardRarity NewRarity, const TArray<struct FStatCharmStat>& NewMutatorStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterStatCharmScript", "SwapStatCharm");

	Params::RGCharacterStatCharmScript_SwapStatCharm Parms{};

	Parms.OldStatCharmActorRef = OldStatCharmActorRef;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.NewRarity = NewRarity;
	Parms.NewMutatorStats = std::move(NewMutatorStats);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGCharacterStatCharmScript.SwapStatCharm_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ARPickupableItem*                 OldStatCharmActorRef                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERewardRarity                           NewRarity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FStatCharmStat>&    NewMutatorStats                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URGCharacterStatCharmScript::SwapStatCharm_Multicast(class ARPickupableItem* OldStatCharmActorRef, const struct FTransform& SpawnTransform, ERewardRarity NewRarity, const TArray<struct FStatCharmStat>& NewMutatorStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharacterStatCharmScript", "SwapStatCharm_Multicast");

	Params::RGCharacterStatCharmScript_SwapStatCharm_Multicast Parms{};

	Parms.OldStatCharmActorRef = OldStatCharmActorRef;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.NewRarity = NewRarity;
	Parms.NewMutatorStats = std::move(NewMutatorStats);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_SpawnExplosion.SpawnExplosion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRunHitSequenceOnExplode                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExplosionTracesForObstacles                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCriticalOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARProjectileBase*                 OptionalProjectile                                     (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeakspotOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceFullServerAuth                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_SpawnExplosion*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_SpawnExplosion* URGTask_SpawnExplosion::SpawnExplosion(class URGScript* OwningScript, const struct FVector& Origin, float Radius, const TArray<class AActor*>& IgnoreActors, float BaseDamage, int32 DamageSources, bool bRunHitSequenceOnExplode, bool bExplosionTracesForObstacles, bool bIsCriticalOverride, class ARProjectileBase* OptionalProjectile, bool bWeakspotOverride, bool bForceFullServerAuth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_SpawnExplosion", "SpawnExplosion");

	Params::RGTask_SpawnExplosion_SpawnExplosion Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.BaseDamage = BaseDamage;
	Parms.DamageSources = DamageSources;
	Parms.bRunHitSequenceOnExplode = bRunHitSequenceOnExplode;
	Parms.bExplosionTracesForObstacles = bExplosionTracesForObstacles;
	Parms.bIsCriticalOverride = bIsCriticalOverride;
	Parms.OptionalProjectile = OptionalProjectile;
	Parms.bWeakspotOverride = bWeakspotOverride;
	Parms.bForceFullServerAuth = bForceFullServerAuth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RCinematicPlayer.OnActorEnterArea
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARCinematicPlayer::OnActorEnterArea(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCinematicPlayer", "OnActorEnterArea");

	Params::RCinematicPlayer_OnActorEnterArea Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCinematicPlayer.OnCinematicFinished
// (Final, Native, Protected)

void ARCinematicPlayer::OnCinematicFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCinematicPlayer", "OnCinematicFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCinematicPlayer.OnRep_bIsConsumed
// (Final, Native, Protected)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARCinematicPlayer::OnRep_bIsConsumed(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCinematicPlayer", "OnRep_bIsConsumed");

	Params::RCinematicPlayer_OnRep_bIsConsumed Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCinematicPlayer.PlayCinematic_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlockPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideHud                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bHidePlayerWeapon                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bHideEntirePlayer                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARCinematicPlayer::PlayCinematic_Multicast(bool bBlockPlayer, bool bHideHud, const bool bHidePlayerWeapon, const bool bHideEntirePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCinematicPlayer", "PlayCinematic_Multicast");

	Params::RCinematicPlayer_PlayCinematic_Multicast Parms{};

	Parms.bBlockPlayer = bBlockPlayer;
	Parms.bHideHud = bHideHud;
	Parms.bHidePlayerWeapon = bHidePlayerWeapon;
	Parms.bHideEntirePlayer = bHideEntirePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RClientPredictionTestPawn.ServerDash
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// uint32                                  EventId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARClientPredictionTestPawn::ServerDash(uint32 EventId, float Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RClientPredictionTestPawn", "ServerDash");

	Params::RClientPredictionTestPawn_ServerDash Parms{};

	Parms.EventId = EventId;
	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RClientPredictionTestPawn.ServerSetInput
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// const struct FRTestPawnMovementInput&   NewInput                                               (Parm, NativeAccessSpecifierPublic)

void ARClientPredictionTestPawn::ServerSetInput(const struct FRTestPawnMovementInput& NewInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RClientPredictionTestPawn", "ServerSetInput");

	Params::RClientPredictionTestPawn_ServerSetInput Parms{};

	Parms.NewInput = std::move(NewInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCombatEventManager.GetCombatEventManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARCombatEventManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARCombatEventManager* ARCombatEventManager::GetCombatEventManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RCombatEventManager", "GetCombatEventManager");

	Params::RCombatEventManager_GetCombatEventManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RCombatEventManager.IsDamageClientPredictionActiveForLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARCombatEventManager::IsDamageClientPredictionActiveForLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RCombatEventManager", "IsDamageClientPredictionActiveForLocalPlayer");

	Params::RCombatEventManager_IsDamageClientPredictionActiveForLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RCombatEventManager.IsDamageClientPredictionActiveForPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARCombatEventManager::IsDamageClientPredictionActiveForPlayer(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RCombatEventManager", "IsDamageClientPredictionActiveForPlayer");

	Params::RCombatEventManager_IsDamageClientPredictionActiveForPlayer Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RCombatEventManager.ProcessCombatEvents_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<struct FCombatEventReplication>&Events                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARCombatEventManager::ProcessCombatEvents_Multicast(const TArray<struct FCombatEventReplication>& Events)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCombatEventManager", "ProcessCombatEvents_Multicast");

	Params::RCombatEventManager_ProcessCombatEvents_Multicast Parms{};

	Parms.Events = std::move(Events);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonHUDWidget.ClearWidgetStack
// (Final, Native, Public, BlueprintCallable)

void URCommonHUDWidget::ClearWidgetStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonHUDWidget", "ClearWidgetStack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonHUDWidget.GetWidgetStack
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UCommonActivatableWidgetStack*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonActivatableWidgetStack* URCommonHUDWidget::GetWidgetStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonHUDWidget", "GetWidgetStack");

	Params::RCommonHUDWidget_GetWidgetStack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RCommonHUDWidget.IsWidgetStackEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const bool                              bExcludeNonInputWidgets                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URCommonHUDWidget::IsWidgetStackEmpty(const bool bExcludeNonInputWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonHUDWidget", "IsWidgetStackEmpty");

	Params::RCommonHUDWidget_IsWidgetStackEmpty Parms{};

	Parms.bExcludeNonInputWidgets = bExcludeNonInputWidgets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RCommonRoomObjectiveWidget.OnRoomObjectiveCompleted
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URCommonRoomObjectiveWidget::OnRoomObjectiveCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonRoomObjectiveWidget", "OnRoomObjectiveCompleted");

	Params::RCommonRoomObjectiveWidget_OnRoomObjectiveCompleted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonRoomObjectiveWidget.OnRoomObjectiveCompletedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URCommonRoomObjectiveWidget::OnRoomObjectiveCompletedEvent(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonRoomObjectiveWidget", "OnRoomObjectiveCompletedEvent");

	Params::RCommonRoomObjectiveWidget_OnRoomObjectiveCompletedEvent Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RCommonRoomObjectiveWidget.OnRoomObjectiveSpawnAreaSegmentCompleted
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          Segment                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URCommonRoomObjectiveWidget::OnRoomObjectiveSpawnAreaSegmentCompleted(class AREnemySpawnAreaSegment* Segment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonRoomObjectiveWidget", "OnRoomObjectiveSpawnAreaSegmentCompleted");

	Params::RCommonRoomObjectiveWidget_OnRoomObjectiveSpawnAreaSegmentCompleted Parms{};

	Parms.Segment = Segment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonRoomObjectiveWidget.OnRoomObjectiveUpdated
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountRequired                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URCommonRoomObjectiveWidget::OnRoomObjectiveUpdated(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment, float AmountCompleted, float AmountRequired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonRoomObjectiveWidget", "OnRoomObjectiveUpdated");

	Params::RCommonRoomObjectiveWidget_OnRoomObjectiveUpdated Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;
	Parms.AmountCompleted = AmountCompleted;
	Parms.AmountRequired = AmountRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RCommonRoomObjectiveWidget.OnRoomObjectiveUpdatedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountRequired                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URCommonRoomObjectiveWidget::OnRoomObjectiveUpdatedEvent(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment, float AmountCompleted, float AmountRequired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCommonRoomObjectiveWidget", "OnRoomObjectiveUpdatedEvent");

	Params::RCommonRoomObjectiveWidget_OnRoomObjectiveUpdatedEvent Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;
	Parms.AmountCompleted = AmountCompleted;
	Parms.AmountRequired = AmountRequired;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RCrosshair.AddSubCrosshair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URSubCrosshair>       SubCrosshairClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URSubCrosshair*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URSubCrosshair* URCrosshair::AddSubCrosshair(class APlayerController* WorldContextObject, TSubclassOf<class URSubCrosshair> SubCrosshairClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RCrosshair", "AddSubCrosshair");

	Params::RCrosshair_AddSubCrosshair Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SubCrosshairClass = SubCrosshairClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDangerZoneManager.GetDangerZoneManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARDangerZoneManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARDangerZoneManager* ARDangerZoneManager::GetDangerZoneManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RDangerZoneManager", "GetDangerZoneManager");

	Params::RDangerZoneManager_GetDangerZoneManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDangerZoneManager.RegisterDangerousActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DangerousActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CloseDangerRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalDanger                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDangerZoneManager::RegisterDangerousActor(class AActor* DangerousActor, float Radius, float CloseDangerRadius, bool bCriticalDanger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDangerZoneManager", "RegisterDangerousActor");

	Params::RDangerZoneManager_RegisterDangerousActor Parms{};

	Parms.DangerousActor = DangerousActor;
	Parms.Radius = Radius;
	Parms.CloseDangerRadius = CloseDangerRadius;
	Parms.bCriticalDanger = bCriticalDanger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDangerZoneManager.RegisterDangerousLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   DangerousLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CloseDangerRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalDanger                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDangerZoneManager::RegisterDangerousLocation(const struct FVector& DangerousLocation, float Radius, float CloseDangerRadius, bool bCriticalDanger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDangerZoneManager", "RegisterDangerousLocation");

	Params::RDangerZoneManager_RegisterDangerousLocation Parms{};

	Parms.DangerousLocation = std::move(DangerousLocation);
	Parms.Radius = Radius;
	Parms.CloseDangerRadius = CloseDangerRadius;
	Parms.bCriticalDanger = bCriticalDanger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDangerZoneManager.SetCriticalDangerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalDanger                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDangerZoneManager::SetCriticalDangerActor(class AActor* Actor, bool bCriticalDanger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDangerZoneManager", "SetCriticalDangerActor");

	Params::RDangerZoneManager_SetCriticalDangerActor Parms{};

	Parms.Actor = Actor;
	Parms.bCriticalDanger = bCriticalDanger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDangerZoneManager.UnRegisterDangerousActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToUnRegister                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDangerZoneManager::UnRegisterDangerousActor(class AActor* ActorToUnRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDangerZoneManager", "UnRegisterDangerousActor");

	Params::RDangerZoneManager_UnRegisterDangerousActor Parms{};

	Parms.ActorToUnRegister = ActorToUnRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDangerZoneManager.UnRegisterDangerousLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   DangerousLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDangerZoneManager::UnRegisterDangerousLocation(const struct FVector& DangerousLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDangerZoneManager", "UnRegisterDangerousLocation");

	Params::RDangerZoneManager_UnRegisterDangerousLocation Parms{};

	Parms.DangerousLocation = std::move(DangerousLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDebugFunctionLibrary.BlueprintDrawDebugBoxTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHit                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        OutHits                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URDebugFunctionLibrary::BlueprintDrawDebugBoxTraceMulti(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, EDrawDebugTrace DrawDebugType, bool bHit, const TArray<struct FHitResult>& OutHits, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RDebugFunctionLibrary", "BlueprintDrawDebugBoxTraceMulti");

	Params::RDebugFunctionLibrary_BlueprintDrawDebugBoxTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bHit = bHit;
	Parms.OutHits = std::move(OutHits);
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDebugFunctionLibrary.LogGScriptsForAllPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URDebugFunctionLibrary::LogGScriptsForAllPlayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RDebugFunctionLibrary", "LogGScriptsForAllPlayers");

	Params::RDebugFunctionLibrary_LogGScriptsForAllPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDebugFunctionLibrary.LogMovementSpeedModifierCoefficientsForAllPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URDebugFunctionLibrary::LogMovementSpeedModifierCoefficientsForAllPlayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RDebugFunctionLibrary", "LogMovementSpeedModifierCoefficientsForAllPlayers");

	Params::RDebugFunctionLibrary_LogMovementSpeedModifierCoefficientsForAllPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDifficultyPrimaryAsset.GetNumTiers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URDifficultyPrimaryAsset::GetNumTiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDifficultyPrimaryAsset", "GetNumTiers");

	Params::RDifficultyPrimaryAsset_GetNumTiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDifficultyPrimaryAsset.ParseDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Tier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URDifficultyPrimaryAsset::ParseDescription(int32 Tier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDifficultyPrimaryAsset", "ParseDescription");

	Params::RDifficultyPrimaryAsset_ParseDescription Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDifficultyPrimaryAsset.ParseExtraDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Tier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URDifficultyPrimaryAsset::ParseExtraDescription(int32 Tier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDifficultyPrimaryAsset", "ParseExtraDescription");

	Params::RDifficultyPrimaryAsset_ParseExtraDescription Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDoor.CallDoorOpened
// (Final, Native, Protected, BlueprintCallable)

void ARDoor::CallDoorOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "CallDoorOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDoor.OnIsClosedUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARDoor::OnIsClosedUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "OnIsClosedUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RDoor.OnNextLevelsFinishedShowing
// (Final, Native, Private)

void ARDoor::OnNextLevelsFinishedShowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "OnNextLevelsFinishedShowing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDoor.OnRep_IsClosed
// (Final, Native, Private)

void ARDoor::OnRep_IsClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "OnRep_IsClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDoor.OnRep_RequireKey
// (Final, Native, Private)

void ARDoor::OnRep_RequireKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "OnRep_RequireKey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDoor.OnRequiredKeyUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARDoor::OnRequiredKeyUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "OnRequiredKeyUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RDoor.StartClosing
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARDoor::StartClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "StartClosing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RDoor.StartOpening
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARDoor::StartOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "StartOpening");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RDoor.DoorFinishedClosing
// (Final, Native, Protected, BlueprintCallable, Const)

void ARDoor::DoorFinishedClosing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "DoorFinishedClosing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDoor.GetBlueprintVariables
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FRDoorBlueprintVariables*        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARDoor::GetBlueprintVariables(struct FRDoorBlueprintVariables* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDoor", "GetBlueprintVariables");

	Params::RDoor_GetBlueprintVariables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function RGame.RDrawDebugBoxComponent.GetBoxCenter
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URDrawDebugBoxComponent::GetBoxCenter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDrawDebugBoxComponent", "GetBoxCenter");

	Params::RDrawDebugBoxComponent_GetBoxCenter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDrawDebugBoxComponent.GetBoxExtents
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URDrawDebugBoxComponent::GetBoxExtents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDrawDebugBoxComponent", "GetBoxExtents");

	Params::RDrawDebugBoxComponent_GetBoxExtents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDummy.GetCapsuleComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCapsuleComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* ARDummy::GetCapsuleComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDummy", "GetCapsuleComponent");

	Params::RDummy_GetCapsuleComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDummy.GetHealthComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URHealthComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URHealthComponent* ARDummy::GetHealthComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDummy", "GetHealthComponent");

	Params::RDummy_GetHealthComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameMode.InitPingBeacon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARGameMode::InitPingBeacon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameMode", "InitPingBeacon");

	Params::RGameMode_InitPingBeacon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameGameMode.ReevaluateDifficultyCoefficient
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARGameGameMode::ReevaluateDifficultyCoefficient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameGameMode", "ReevaluateDifficultyCoefficient");

	Params::RGameGameMode_ReevaluateDifficultyCoefficient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameGameMode.GetAliveControllersArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class APlayerController*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class APlayerController*> ARGameGameMode::GetAliveControllersArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameGameMode", "GetAliveControllersArray");

	Params::RGameGameMode_GetAliveControllersArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameGameMode.GetDeadControllersArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class APlayerController*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class APlayerController*> ARGameGameMode::GetDeadControllersArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameGameMode", "GetDeadControllersArray");

	Params::RGameGameMode_GetDeadControllersArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameGameMode.GetDownedControllersArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class APlayerController*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class APlayerController*> ARGameGameMode::GetDownedControllersArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameGameMode", "GetDownedControllersArray");

	Params::RGameGameMode_GetDownedControllersArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDungeonGameMode.GetRDungeonGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARDungeonGameMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARDungeonGameMode* ARDungeonGameMode::GetRDungeonGameMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RDungeonGameMode", "GetRDungeonGameMode");

	Params::RDungeonGameMode_GetRDungeonGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RDungeonGameMode.ClearVoteTimer
// (Event, Public, BlueprintEvent)

void ARDungeonGameMode::ClearVoteTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "ClearVoteTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RDungeonGameMode.FinishWaitingForPlayers
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ARDungeonGameMode::FinishWaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "FinishWaitingForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.OnAllSegmentsCompleted
// (Final, Native, Private)

void ARDungeonGameMode::OnAllSegmentsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "OnAllSegmentsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.OnFinalBossKilled
// (Final, Native, Private)

void ARDungeonGameMode::OnFinalBossKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "OnFinalBossKilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.OnSegmentCompleted_Internal
// (Final, Native, Private)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDungeonGameMode::OnSegmentCompleted_Internal(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "OnSegmentCompleted_Internal");

	Params::RDungeonGameMode_OnSegmentCompleted_Internal Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.ReturnToLobby
// (Final, Native, Public, BlueprintCallable)

void ARDungeonGameMode::ReturnToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "ReturnToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.StartWaitingForPlayers
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARGamePlayerController*           GamePlayerController                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDungeonGameMode::StartWaitingForPlayers(class ARGamePlayerController* GamePlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "StartWaitingForPlayers");

	Params::RDungeonGameMode_StartWaitingForPlayers Parms{};

	Parms.GamePlayerController = GamePlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.StopWaitingForPlayer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARGamePlayerController*           GamePlayerController                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDungeonGameMode::StopWaitingForPlayer(class ARGamePlayerController* GamePlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "StopWaitingForPlayer");

	Params::RDungeonGameMode_StopWaitingForPlayer Parms{};

	Parms.GamePlayerController = GamePlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.TravelToLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              LevelId                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             LightingLevelId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              ConnectorLevels                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bBlockingLoading                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetPlayerStartTag                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDungeonGameMode::TravelToLevel(const TArray<class FName>& LevelId, class FName LightingLevelId, const TArray<class FName>& ConnectorLevels, bool bBlockingLoading, class FName TargetPlayerStartTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "TravelToLevel");

	Params::RDungeonGameMode_TravelToLevel Parms{};

	Parms.LevelId = std::move(LevelId);
	Parms.LightingLevelId = LightingLevelId;
	Parms.ConnectorLevels = std::move(ConnectorLevels);
	Parms.bBlockingLoading = bBlockingLoading;
	Parms.TargetPlayerStartTag = TargetPlayerStartTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.TravelToLobby
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TargetPlayerStartTag                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDungeonGameMode::TravelToLobby(class FName TargetPlayerStartTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "TravelToLobby");

	Params::RDungeonGameMode_TravelToLobby Parms{};

	Parms.TargetPlayerStartTag = TargetPlayerStartTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.TravelToNextLevel
// (Final, Exec, Native, Public, BlueprintCallable)

void ARDungeonGameMode::TravelToNextLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "TravelToNextLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.TravelToSameLevel
// (Final, Exec, Native, Public, BlueprintCallable)

void ARDungeonGameMode::TravelToSameLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "TravelToSameLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.VoteToProceedPortal
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARDungeonGameMode::VoteToProceedPortal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "VoteToProceedPortal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RDungeonGameMode.VoteToProceedShortcut
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARGamePlayerController*           VotingPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARDungeonGameMode::VoteToProceedShortcut(class ARGamePlayerController* VotingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "VoteToProceedShortcut");

	Params::RDungeonGameMode_VoteToProceedShortcut Parms{};

	Parms.VotingPlayer = VotingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RDungeonGameMode.StartLobbyElevatorSequence
// (Final, Native, Public, BlueprintCallable, Const)

void ARDungeonGameMode::StartLobbyElevatorSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "StartLobbyElevatorSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RDungeonGameMode.StartUngluTeleportSequence
// (Final, Native, Public, BlueprintCallable, Const)

void ARDungeonGameMode::StartUngluTeleportSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RDungeonGameMode", "StartUngluTeleportSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.DestroyOrReleaseNiagaraSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::DestroyOrReleaseNiagaraSystem(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "DestroyOrReleaseNiagaraSystem");

	Params::REffectsManager_DestroyOrReleaseNiagaraSystem Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.GetIsNiagaraPoolingEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREffectsManager::GetIsNiagaraPoolingEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "GetIsNiagaraPoolingEnabled");

	Params::REffectsManager_GetIsNiagaraPoolingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REffectsManager.GetShouldAutoPoolNiagara
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENCPoolMethod                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENCPoolMethod AREffectsManager::GetShouldAutoPoolNiagara()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "GetShouldAutoPoolNiagara");

	Params::REffectsManager_GetShouldAutoPoolNiagara Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REffectsManager.GetShouldManualReleaseNiagara
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENCPoolMethod                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENCPoolMethod AREffectsManager::GetShouldManualReleaseNiagara()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "GetShouldManualReleaseNiagara");

	Params::REffectsManager_GetShouldManualReleaseNiagara Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REffectsManager.PlayReplicatedNiagara
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   SystemTemplate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FNiagaraFloatParam>&FloatParams                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FVector&                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreCullCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::PlayReplicatedNiagara(const class UObject* WorldContextObject, class UNiagaraSystem* SystemTemplate, const TArray<struct FNiagaraFloatParam>& FloatParams, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bPreCullCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "PlayReplicatedNiagara");

	Params::REffectsManager_PlayReplicatedNiagara Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SystemTemplate = SystemTemplate;
	Parms.FloatParams = std::move(FloatParams);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.bPreCullCheck = bPreCullCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.PlayReplicatedNiagaraAtActorLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   SystemTemplate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FNiagaraFloatParam>&FloatParams                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FVector&                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreCullCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::PlayReplicatedNiagaraAtActorLocation(const class UObject* WorldContextObject, class UNiagaraSystem* SystemTemplate, const TArray<struct FNiagaraFloatParam>& FloatParams, class AActor* Actor, const struct FRotator& Rotation, const struct FVector& Scale, bool bPreCullCheck, const struct FVector& LocationOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "PlayReplicatedNiagaraAtActorLocation");

	Params::REffectsManager_PlayReplicatedNiagaraAtActorLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SystemTemplate = SystemTemplate;
	Parms.FloatParams = std::move(FloatParams);
	Parms.Actor = Actor;
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.bPreCullCheck = bPreCullCheck;
	Parms.LocationOffset = std::move(LocationOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.PlayReplicatedSound2D
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FAudioParameter>&   AudioParams                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::PlayReplicatedSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, const TArray<struct FAudioParameter>& AudioParams, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "PlayReplicatedSound2D");

	Params::REffectsManager_PlayReplicatedSound2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.AudioParams = std::move(AudioParams);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.PlayReplicatedSoundAtActorLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FAudioParameter>&   AudioParams                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::PlayReplicatedSoundAtActorLocation(const class UObject* WorldContextObject, class USoundBase* Sound, class AActor* Actor, const TArray<struct FAudioParameter>& AudioParams, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, const struct FVector& LocationOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "PlayReplicatedSoundAtActorLocation");

	Params::REffectsManager_PlayReplicatedSoundAtActorLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Actor = Actor;
	Parms.AudioParams = std::move(AudioParams);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.LocationOffset = std::move(LocationOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.PlayReplicatedSoundAtLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FAudioParameter>&   AudioParams                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::PlayReplicatedSoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const TArray<struct FAudioParameter>& AudioParams, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "PlayReplicatedSoundAtLocation");

	Params::REffectsManager_PlayReplicatedSoundAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Location = std::move(Location);
	Parms.AudioParams = std::move(AudioParams);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.TrackNiagaraComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREffectsManager::TrackNiagaraComponent(const class UObject* WorldContextObject, class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REffectsManager", "TrackNiagaraComponent");

	Params::REffectsManager_TrackNiagaraComponent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REffectsManager.PlayBatchedEffects_Multicast
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<struct FNiagaraSpawnRequest>&Niagara                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FSoundSpawnRequest>&Sounds                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FSound2DSpawnRequest>&Sounds2D                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AREffectsManager::PlayBatchedEffects_Multicast(const TArray<struct FNiagaraSpawnRequest>& Niagara, const TArray<struct FSoundSpawnRequest>& Sounds, const TArray<struct FSound2DSpawnRequest>& Sounds2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REffectsManager", "PlayBatchedEffects_Multicast");

	Params::REffectsManager_PlayBatchedEffects_Multicast Parms{};

	Parms.Niagara = std::move(Niagara);
	Parms.Sounds = std::move(Sounds);
	Parms.Sounds2D = std::move(Sounds2D);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.ActivateMutators
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::ActivateMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "ActivateMutators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.AddAndActivateMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGEnemyMutatorScript>NewMutator                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::AddAndActivateMutator(TSubclassOf<class URGEnemyMutatorScript> NewMutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "AddAndActivateMutator");

	Params::REnemyPawnBase_AddAndActivateMutator Parms{};

	Parms.NewMutator = NewMutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.AddFlyingCollisionException
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::AddFlyingCollisionException()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "AddFlyingCollisionException");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.AddMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URGEnemyMutatorScript>NewMutator                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::AddMutator(TSubclassOf<class URGEnemyMutatorScript> NewMutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "AddMutator");

	Params::REnemyPawnBase_AddMutator Parms{};

	Parms.NewMutator = NewMutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.CheckValidMontageSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::CheckValidMontageSection(class UAnimMontage* Montage, class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "CheckValidMontageSection");

	Params::REnemyPawnBase_CheckValidMontageSection Parms{};

	Parms.Montage = Montage;
	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.CurrentCombatTarget_OnRep
// (Final, Native, Protected)

void AREnemyPawnBase::CurrentCombatTarget_OnRep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "CurrentCombatTarget_OnRep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.DoSpecial
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::DoSpecial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "DoSpecial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.EnterCombat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::EnterCombat(class AController* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "EnterCombat");

	Params::REnemyPawnBase_EnterCombat Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.EnterSearchingState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PreDeterminedTarget                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::EnterSearchingState(class APlayerController* PreDeterminedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "EnterSearchingState");

	Params::REnemyPawnBase_EnterSearchingState Parms{};

	Parms.PreDeterminedTarget = PreDeterminedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.FireProjectileAtTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARProjectileBase>     ProjectileClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FireFromLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotatorOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectileLifeSpan                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutTargetLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        OutTargetRotation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           CustomTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   CustomTargetLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseRandomSpread                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsePrediction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARProjectileBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARProjectileBase*> AREnemyPawnBase::FireProjectileAtTarget(TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FVector& FireFromLocation, const struct FRotator& RotatorOffset, float Damage, float ProjectileLifeSpan, struct FVector* OutTargetLocation, struct FRotator* OutTargetRotation, class AActor* CustomTarget, const struct FVector& CustomTargetLocation, bool bUseRandomSpread, bool bUsePrediction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "FireProjectileAtTarget");

	Params::REnemyPawnBase_FireProjectileAtTarget Parms{};

	Parms.ProjectileClass = ProjectileClass;
	Parms.FireFromLocation = std::move(FireFromLocation);
	Parms.RotatorOffset = std::move(RotatorOffset);
	Parms.Damage = Damage;
	Parms.ProjectileLifeSpan = ProjectileLifeSpan;
	Parms.CustomTarget = CustomTarget;
	Parms.CustomTargetLocation = std::move(CustomTargetLocation);
	Parms.bUseRandomSpread = bUseRandomSpread;
	Parms.bUsePrediction = bUsePrediction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetLocation != nullptr)
		*OutTargetLocation = std::move(Parms.OutTargetLocation);

	if (OutTargetRotation != nullptr)
		*OutTargetRotation = std::move(Parms.OutTargetRotation);

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.FrozenReset_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void AREnemyPawnBase::FrozenReset_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "FrozenReset_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.GetAISettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRAISettings                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRAISettings AREnemyPawnBase::GetAISettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetAISettings");

	Params::REnemyPawnBase_GetAISettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetAIState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAIState                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIState AREnemyPawnBase::GetAIState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetAIState");

	Params::REnemyPawnBase_GetAIState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetAttackSpeedModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRMutableFloat                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRMutableFloat AREnemyPawnBase::GetAttackSpeedModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetAttackSpeedModifier");

	Params::REnemyPawnBase_GetAttackSpeedModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetCachedLineOfSightBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AREnemyPawnBase::GetCachedLineOfSightBone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetCachedLineOfSightBone");

	Params::REnemyPawnBase_GetCachedLineOfSightBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetCurrentCombatTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARPawnBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARPawnBase* AREnemyPawnBase::GetCurrentCombatTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetCurrentCombatTarget");

	Params::REnemyPawnBase_GetCurrentCombatTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetDefaultCharacterMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* AREnemyPawnBase::GetDefaultCharacterMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetDefaultCharacterMontage");

	Params::REnemyPawnBase_GetDefaultCharacterMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetIsCurrentlyCCd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::GetIsCurrentlyCCd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetIsCurrentlyCCd");

	Params::REnemyPawnBase_GetIsCurrentlyCCd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetIsCurrentlyFrozen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::GetIsCurrentlyFrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetIsCurrentlyFrozen");

	Params::REnemyPawnBase_GetIsCurrentlyFrozen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetIsElite
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::GetIsElite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetIsElite");

	Params::REnemyPawnBase_GetIsElite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetIsFlying
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::GetIsFlying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetIsFlying");

	Params::REnemyPawnBase_GetIsFlying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetIsFriendly
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::GetIsFriendly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetIsFriendly");

	Params::REnemyPawnBase_GetIsFriendly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetIsGhost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::GetIsGhost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetIsGhost");

	Params::REnemyPawnBase_GetIsGhost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetMutators
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<TSubclassOf<class URGEnemyMutatorScript>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class URGEnemyMutatorScript>> AREnemyPawnBase::GetMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetMutators");

	Params::REnemyPawnBase_GetMutators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetRandomUsableAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipLimitations                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGEnemyAttackScript*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGEnemyAttackScript* AREnemyPawnBase::GetRandomUsableAttack(bool bSkipLimitations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetRandomUsableAttack");

	Params::REnemyPawnBase_GetRandomUsableAttack Parms{};

	Parms.bSkipLimitations = bSkipLimitations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.GetRangedTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AREnemyPawnBase::GetRangedTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "GetRangedTargetLocation");

	Params::REnemyPawnBase_GetRangedTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.HasLoS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDebugDraw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CustomTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::HasLoS(bool bDebugDraw, class AActor* CustomTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "HasLoS");

	Params::REnemyPawnBase_HasLoS Parms{};

	Parms.bDebugDraw = bDebugDraw;
	Parms.CustomTarget = CustomTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.HasUsableAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::HasUsableAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "HasUsableAttack");

	Params::REnemyPawnBase_HasUsableAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.IsBelowExecutionHealthThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             ThresholdModifier                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::IsBelowExecutionHealthThreshold(const float ThresholdModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "IsBelowExecutionHealthThreshold");

	Params::REnemyPawnBase_IsBelowExecutionHealthThreshold Parms{};

	Parms.ThresholdModifier = ThresholdModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.OnCurrentEnemyTargetKilled
// (Final, Native, Private)
// Parameters:
// class AREnemyPawnBase*                  Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::OnCurrentEnemyTargetKilled(class AREnemyPawnBase* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnCurrentEnemyTargetKilled");

	Params::REnemyPawnBase_OnCurrentEnemyTargetKilled Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OnCurrentPlayerTargetKilled
// (Final, Native, Private)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::OnCurrentPlayerTargetKilled(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnCurrentPlayerTargetKilled");

	Params::REnemyPawnBase_OnCurrentPlayerTargetKilled Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OnCurrentTargetDowned
// (Final, Native, Private)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::OnCurrentTargetDowned(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnCurrentTargetDowned");

	Params::REnemyPawnBase_OnCurrentTargetDowned Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OnJumped_Multicast
// (Net, Native, Event, NetMulticast, Public, BlueprintCallable)

void AREnemyPawnBase::OnJumped_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnJumped_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OnKnockbacked
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::OnKnockbacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnKnockbacked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OnKnockbackEnded
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::OnKnockbackEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnKnockbackEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OnLandedOnGround
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::OnLandedOnGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OnLandedOnGround");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.OverrideAISettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRAISettings&              NewAISettings                                          (Parm, NativeAccessSpecifierPublic)

void AREnemyPawnBase::OverrideAISettings(const struct FRAISettings& NewAISettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "OverrideAISettings");

	Params::REnemyPawnBase_OverrideAISettings Parms{};

	Parms.NewAISettings = std::move(NewAISettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.PerformAreaAttack
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AREnemyPawnBase::PerformAreaAttack(const TArray<class AActor*>& IgnoredActors, const struct FVector& TargetLocation, float Damage, float AttackRadius, int32 DamageSources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "PerformAreaAttack");

	Params::REnemyPawnBase_PerformAreaAttack Parms{};

	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Damage = Damage;
	Parms.AttackRadius = AttackRadius;
	Parms.DamageSources = DamageSources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.PerformConeAttack
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackHalfAngle                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AREnemyPawnBase::PerformConeAttack(const TArray<class AActor*>& IgnoredActors, const struct FVector& TargetLocation, const struct FVector& TargetDirection, float Damage, float AttackRadius, float AttackHalfAngle, int32 DamageSources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "PerformConeAttack");

	Params::REnemyPawnBase_PerformConeAttack Parms{};

	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.TargetDirection = std::move(TargetDirection);
	Parms.Damage = Damage;
	Parms.AttackRadius = AttackRadius;
	Parms.AttackHalfAngle = AttackHalfAngle;
	Parms.DamageSources = DamageSources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyPawnBase.PerformDodge_Multicast
// (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::PerformDodge_Multicast(float Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "PerformDodge_Multicast");

	Params::REnemyPawnBase_PerformDodge_Multicast Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.PlayMontage_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::PlayMontage_Multicast(class UAnimMontage* Montage, class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "PlayMontage_Multicast");

	Params::REnemyPawnBase_PlayMontage_Multicast Parms{};

	Parms.Montage = Montage;
	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.ReceiveDoSpecial
// (Native, Event, Public, BlueprintEvent)

void AREnemyPawnBase::ReceiveDoSpecial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "ReceiveDoSpecial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.ReceiveOnEnterCombat
// (Native, Event, Public, BlueprintEvent)

void AREnemyPawnBase::ReceiveOnEnterCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "ReceiveOnEnterCombat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.ReceiveOnSilenceStarted
// (Native, Event, Public, BlueprintEvent)

void AREnemyPawnBase::ReceiveOnSilenceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "ReceiveOnSilenceStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.ReceiveOnSilenceStopped
// (Native, Event, Public, BlueprintEvent)

void AREnemyPawnBase::ReceiveOnSilenceStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "ReceiveOnSilenceStopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.RemoveFlyingCollisionException
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::RemoveFlyingCollisionException()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "RemoveFlyingCollisionException");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetAIFrozen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   freezeDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetAIFrozen(float freezeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetAIFrozen");

	Params::REnemyPawnBase_SetAIFrozen Parms{};

	Parms.freezeDuration = freezeDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetAIRooted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   rootDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetAIRooted(float rootDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetAIRooted");

	Params::REnemyPawnBase_SetAIRooted Parms{};

	Parms.rootDuration = rootDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetAISilenced
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   silenceDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetAISilenced(float silenceDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetAISilenced");

	Params::REnemyPawnBase_SetAISilenced Parms{};

	Parms.silenceDuration = silenceDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetAIState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAIState                                NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetAIState(EAIState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetAIState");

	Params::REnemyPawnBase_SetAIState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetAIStunned
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   stunDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  actualStunDuration                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShorterDurationOverrides                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStunImmunity                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetAIStunned(float stunDuration, float* actualStunDuration, bool bShorterDurationOverrides, bool bIgnoreStunImmunity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetAIStunned");

	Params::REnemyPawnBase_SetAIStunned Parms{};

	Parms.stunDuration = stunDuration;
	Parms.bShorterDurationOverrides = bShorterDurationOverrides;
	Parms.bIgnoreStunImmunity = bIgnoreStunImmunity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (actualStunDuration != nullptr)
		*actualStunDuration = Parms.actualStunDuration;
}


// Function RGame.REnemyPawnBase.SetAllAttacksBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetAllAttacksBlocked(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetAllAttacksBlocked");

	Params::REnemyPawnBase_SetAllAttacksBlocked Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetCachedLineOfSightBonee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       NewCachedLineOfSightBone                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetCachedLineOfSightBonee(const class FName NewCachedLineOfSightBone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetCachedLineOfSightBonee");

	Params::REnemyPawnBase_SetCachedLineOfSightBonee Parms{};

	Parms.NewCachedLineOfSightBone = NewCachedLineOfSightBone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetCCImmune
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetCCImmune(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetCCImmune");

	Params::REnemyPawnBase_SetCCImmune Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetCurrentCombatTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetCurrentCombatTarget(class APawn* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetCurrentCombatTarget");

	Params::REnemyPawnBase_SetCurrentCombatTarget Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetCurrentCombatTargetLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLock                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetCurrentCombatTargetLocked(bool bNewLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetCurrentCombatTargetLocked");

	Params::REnemyPawnBase_SetCurrentCombatTargetLocked Parms{};

	Parms.bNewLock = bNewLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetForcedSpawnMovementLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   ForcedSpawnMovementLocation                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetForcedSpawnMovementLocation(const struct FVector& ForcedSpawnMovementLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetForcedSpawnMovementLocation");

	Params::REnemyPawnBase_SetForcedSpawnMovementLocation Parms{};

	Parms.ForcedSpawnMovementLocation = std::move(ForcedSpawnMovementLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetIsElite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIsElite                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetIsElite(bool bNewIsElite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetIsElite");

	Params::REnemyPawnBase_SetIsElite Parms{};

	Parms.bNewIsElite = bNewIsElite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetIsFriendly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewFriendlyStatus                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FriendlyEnemyDamageMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetIsFriendly(bool bNewFriendlyStatus, float FriendlyEnemyDamageMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetIsFriendly");

	Params::REnemyPawnBase_SetIsFriendly Parms{};

	Parms.bNewFriendlyStatus = bNewFriendlyStatus;
	Parms.FriendlyEnemyDamageMultiplier = FriendlyEnemyDamageMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetIsGhost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewGhostStatus                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetIsGhost(bool bNewGhostStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetIsGhost");

	Params::REnemyPawnBase_SetIsGhost Parms{};

	Parms.bNewGhostStatus = bNewGhostStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetMaxSpeed_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetMaxSpeed_Multicast(float NewMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetMaxSpeed_Multicast");

	Params::REnemyPawnBase_SetMaxSpeed_Multicast Parms{};

	Parms.NewMaxSpeed = NewMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetMutators
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class URGEnemyMutatorScript>>&NewMutators                                            (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetMutators(const TArray<TSubclassOf<class URGEnemyMutatorScript>>& NewMutators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetMutators");

	Params::REnemyPawnBase_SetMutators Parms{};

	Parms.NewMutators = std::move(NewMutators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetOnLandedAnimationBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewBlock                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetOnLandedAnimationBlocked(bool bNewBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetOnLandedAnimationBlocked");

	Params::REnemyPawnBase_SetOnLandedAnimationBlocked Parms{};

	Parms.bNewBlock = bNewBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetRuntimePhysicsAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPhysicsAsset*                    NewPhysicsAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReInit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetRuntimePhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetRuntimePhysicsAsset");

	Params::REnemyPawnBase_SetRuntimePhysicsAsset Parms{};

	Parms.NewPhysicsAsset = NewPhysicsAsset;
	Parms.bForceReInit = bForceReInit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetSpawnedByAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewSpawnedByOtherAI                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetSpawnedByAI(bool bNewSpawnedByOtherAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetSpawnedByAI");

	Params::REnemyPawnBase_SetSpawnedByAI Parms{};

	Parms.bNewSpawnedByOtherAI = bNewSpawnedByOtherAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetStunImmune
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetStunImmune(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetStunImmune");

	Params::REnemyPawnBase_SetStunImmune Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.SetupLocationChecker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AREnemySpawnAreaSegment*          Segment                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::SetupLocationChecker(class AREnemySpawnAreaSegment* Segment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "SetupLocationChecker");

	Params::REnemyPawnBase_SetupLocationChecker Parms{};

	Parms.Segment = Segment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.StartFlying
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::StartFlying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "StartFlying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.StartJump_Multicast
// (Net, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::StartJump_Multicast(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "StartJump_Multicast");

	Params::REnemyPawnBase_StartJump_Multicast Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.StartLerp_Multicast
// (Net, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyPawnBase::StartLerp_Multicast(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "StartLerp_Multicast");

	Params::REnemyPawnBase_StartLerp_Multicast Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.StopFlying
// (Final, Native, Public, BlueprintCallable)

void AREnemyPawnBase::StopFlying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "StopFlying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyPawnBase.ValidateResourceCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URGEnemyAttackScript*             Script                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyPawnBase::ValidateResourceCondition(class URGEnemyAttackScript* Script)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyPawnBase", "ValidateResourceCondition");

	Params::REnemyPawnBase_ValidateResourceCondition Parms{};

	Parms.Script = Script;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.HitSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               ROwningScriptComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARProjectileBase*                 OptionalProjectile                                     (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallHitEvents                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreClientAuthFlow                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamageClientPrediction                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeakspotOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::HitSequence(class URGScriptComponent* ROwningScriptComponent, const struct FHitResult& Hit, float Damage, int32 DamageSources, class ARProjectileBase* OptionalProjectile, bool bCriticalOverride, bool bCallHitEvents, bool bIgnoreClientAuthFlow, bool bDamageClientPrediction, bool bWeakspotOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RProjectileBase", "HitSequence");

	Params::RProjectileBase_HitSequence Parms{};

	Parms.ROwningScriptComponent = ROwningScriptComponent;
	Parms.Hit = std::move(Hit);
	Parms.Damage = Damage;
	Parms.DamageSources = DamageSources;
	Parms.OptionalProjectile = OptionalProjectile;
	Parms.bCriticalOverride = bCriticalOverride;
	Parms.bCallHitEvents = bCallHitEvents;
	Parms.bIgnoreClientAuthFlow = bIgnoreClientAuthFlow;
	Parms.bDamageClientPrediction = bDamageClientPrediction;
	Parms.bWeakspotOverride = bWeakspotOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.CacheHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARProjectileBase::CacheHitResult(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "CacheHitResult");

	Params::RProjectileBase_CacheHitResult Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.CacheHitResults
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FHitResult>&        Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARProjectileBase::CacheHitResults(const TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "CacheHitResults");

	Params::RProjectileBase_CacheHitResults Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.DestroyProjectile
// (Native, Public, BlueprintCallable)

void ARProjectileBase::DestroyProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "DestroyProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.DisableProjectile
// (Native, Public, BlueprintCallable)

void ARProjectileBase::DisableProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "DisableProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.IgnoreCollisionWithActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockTwoWay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::IgnoreCollisionWithActor(class AActor* Actor, bool bBlockTwoWay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "IgnoreCollisionWithActor");

	Params::RProjectileBase_IgnoreCollisionWithActor Parms{};

	Parms.Actor = Actor;
	Parms.bBlockTwoWay = bBlockTwoWay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARProjectileBase::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "OnComponentBeginOverlap");

	Params::RProjectileBase_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.OnComponentHit
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARProjectileBase::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "OnComponentHit");

	Params::RProjectileBase_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.OnProjectileHasBeenActivated
// (Native, Event, Public, BlueprintEvent)

void ARProjectileBase::OnProjectileHasBeenActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "OnProjectileHasBeenActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.OnRep_bActive
// (Final, Native, Protected)

void ARProjectileBase::OnRep_bActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "OnRep_bActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.OnRep_OwningWeapon
// (Final, Native, Private)

void ARProjectileBase::OnRep_OwningWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "OnRep_OwningWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.ResetCollisionsToIgnore
// (Final, Native, Public, BlueprintCallable)

void ARProjectileBase::ResetCollisionsToIgnore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "ResetCollisionsToIgnore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.ResetIgnoreCollisionWithActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetTwoWay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::ResetIgnoreCollisionWithActor(class AActor* Actor, bool bResetTwoWay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "ResetIgnoreCollisionWithActor");

	Params::RProjectileBase_ResetIgnoreCollisionWithActor Parms{};

	Parms.Actor = Actor;
	Parms.bResetTwoWay = bResetTwoWay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.SetAvatarActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewAvatarActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::SetAvatarActor(class AActor* NewAvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "SetAvatarActor");

	Params::RProjectileBase_SetAvatarActor Parms{};

	Parms.NewAvatarActor = NewAvatarActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.SetBaseCriticalMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newBaseCriticalMultiplier                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::SetBaseCriticalMultiplier(float newBaseCriticalMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "SetBaseCriticalMultiplier");

	Params::RProjectileBase_SetBaseCriticalMultiplier Parms{};

	Parms.newBaseCriticalMultiplier = newBaseCriticalMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.SetBaseDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newBaseDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::SetBaseDamage(float newBaseDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "SetBaseDamage");

	Params::RProjectileBase_SetBaseDamage Parms{};

	Parms.newBaseDamage = newBaseDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.SetBaseEffectiveRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newBaseEffectiveRange                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::SetBaseEffectiveRange(float newBaseEffectiveRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "SetBaseEffectiveRange");

	Params::RProjectileBase_SetBaseEffectiveRange Parms{};

	Parms.newBaseEffectiveRange = newBaseEffectiveRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.SetProjectileSpawnerType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EProjectileSpawnerType                  NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::SetProjectileSpawnerType(EProjectileSpawnerType NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "SetProjectileSpawnerType");

	Params::RProjectileBase_SetProjectileSpawnerType Parms{};

	Parms.NewType = NewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.SetVisualStartLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectileBase::SetVisualStartLocation(const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "SetVisualStartLocation");

	Params::RProjectileBase_SetVisualStartLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileBase.GetAvatarActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARProjectileBase::GetAvatarActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetAvatarActor");

	Params::RProjectileBase_GetAvatarActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetCachedHitResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FHitResult ARProjectileBase::GetCachedHitResult() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetCachedHitResult");

	Params::RProjectileBase_GetCachedHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetOnHitDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bWasCritical                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARProjectileBase::GetOnHitDamage(bool* bWasCritical) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetOnHitDamage");

	Params::RProjectileBase_GetOnHitDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bWasCritical != nullptr)
		*bWasCritical = Parms.bWasCritical;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetOnHitDamageWithMultipliers
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bWasCritical                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARProjectileBase::GetOnHitDamageWithMultipliers(bool* bWasCritical) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetOnHitDamageWithMultipliers");

	Params::RProjectileBase_GetOnHitDamageWithMultipliers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bWasCritical != nullptr)
		*bWasCritical = Parms.bWasCritical;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetOwningGScriptComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* ARProjectileBase::GetOwningGScriptComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetOwningGScriptComponent");

	Params::RProjectileBase_GetOwningGScriptComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetOwningPawn
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARPawnBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARPawnBase* ARProjectileBase::GetOwningPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetOwningPawn");

	Params::RProjectileBase_GetOwningPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetProjectileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARProjectileBase::GetProjectileName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetProjectileName");

	Params::RProjectileBase_GetProjectileName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetProjectileScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URProjectileBaseScript*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URProjectileBaseScript* ARProjectileBase::GetProjectileScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetProjectileScript");

	Params::RProjectileBase_GetProjectileScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileBase.GetProjectileSpawnerType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProjectileSpawnerType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProjectileSpawnerType ARProjectileBase::GetProjectileSpawnerType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileBase", "GetProjectileSpawnerType");

	Params::RProjectileBase_GetProjectileSpawnerType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectile.PredictProjectileMovementCurve
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARProjectile>         InProjectileClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FProjectileSimulationResult>*outResults                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector*                         outImpactLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  StartRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   iterationTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARProjectile::PredictProjectileMovementCurve(const class UObject* WorldContextObject, TSubclassOf<class ARProjectile> InProjectileClass, TArray<struct FProjectileSimulationResult>* outResults, struct FVector* outImpactLocation, const struct FVector& StartLocation, const struct FRotator& StartRotation, float iterationTime, int32 MaxIterations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RProjectile", "PredictProjectileMovementCurve");

	Params::RProjectile_PredictProjectileMovementCurve Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InProjectileClass = InProjectileClass;
	Parms.StartLocation = std::move(StartLocation);
	Parms.StartRotation = std::move(StartRotation);
	Parms.iterationTime = iterationTime;
	Parms.MaxIterations = MaxIterations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outResults != nullptr)
		*outResults = std::move(Parms.outResults);

	if (outImpactLocation != nullptr)
		*outImpactLocation = std::move(Parms.outImpactLocation);
}


// Function RGame.REnemyResourceManager.GetEnemyResourceManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AREnemyResourceManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AREnemyResourceManager* AREnemyResourceManager::GetEnemyResourceManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REnemyResourceManager", "GetEnemyResourceManager");

	Params::REnemyResourceManager_GetEnemyResourceManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyResourceManager.AttackGroupHasEnoughResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              AttackGroupTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemyResourceManager::AttackGroupHasEnoughResources(const struct FGameplayTag& AttackGroupTag, float Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "AttackGroupHasEnoughResources");

	Params::REnemyResourceManager_AttackGroupHasEnoughResources Parms{};

	Parms.AttackGroupTag = std::move(AttackGroupTag);
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyResourceManager.GetClosestPylonActorToLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPylonActor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPylonActor AREnemyResourceManager::GetClosestPylonActorToLocation(const struct FVector& Location, float MaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "GetClosestPylonActorToLocation");

	Params::REnemyResourceManager_GetClosestPylonActorToLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.MaxDistance = MaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyResourceManager.GetExecutableEnemies
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARNPCPawnBase*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARNPCPawnBase*> AREnemyResourceManager::GetExecutableEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "GetExecutableEnemies");

	Params::REnemyResourceManager_GetExecutableEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemyResourceManager.OnRunStarted
// (Final, Native, Private)

void AREnemyResourceManager::OnRunStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "OnRunStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyResourceManager.RegenAttackGroups
// (Final, Native, Private)

void AREnemyResourceManager::RegenAttackGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "RegenAttackGroups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyResourceManager.RegisterExecutableEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARNPCPawnBase*                    Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyResourceManager::RegisterExecutableEnemy(class ARNPCPawnBase* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "RegisterExecutableEnemy");

	Params::REnemyResourceManager_RegisterExecutableEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyResourceManager.RegisterPylonActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PylonActorToRegister                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyResourceManager::RegisterPylonActor(class AActor* PylonActorToRegister, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "RegisterPylonActor");

	Params::REnemyResourceManager_RegisterPylonActor Parms{};

	Parms.PylonActorToRegister = PylonActorToRegister;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyResourceManager.UnregisterExecutableEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARNPCPawnBase*                    Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyResourceManager::UnregisterExecutableEnemy(class ARNPCPawnBase* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "UnregisterExecutableEnemy");

	Params::REnemyResourceManager_UnregisterExecutableEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyResourceManager.UnregisterPylonActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PylonActorToUnRegister                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyResourceManager::UnregisterPylonActor(class AActor* PylonActorToUnRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "UnregisterPylonActor");

	Params::REnemyResourceManager_UnregisterPylonActor Parms{};

	Parms.PylonActorToUnRegister = PylonActorToUnRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemyResourceManager.UseAttackGroupResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              AttackGroupTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemyResourceManager::UseAttackGroupResources(const struct FGameplayTag& AttackGroupTag, float Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemyResourceManager", "UseAttackGroupResources");

	Params::REnemyResourceManager_UseAttackGroupResources Parms{};

	Parms.AttackGroupTag = std::move(AttackGroupTag);
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.AddCurrentSpawnAreaSegment_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void AREnemySpawnAreaSegment::AddCurrentSpawnAreaSegment_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "AddCurrentSpawnAreaSegment_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.ForceCompleteSegment
// (Final, Native, Public, BlueprintCallable)

void AREnemySpawnAreaSegment::ForceCompleteSegment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "ForceCompleteSegment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.GetAllEnemiesDefeated
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnAreaSegment::GetAllEnemiesDefeated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "GetAllEnemiesDefeated");

	Params::REnemySpawnAreaSegment_GetAllEnemiesDefeated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnAreaSegment.GetEnemies
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARNPCPawnBase*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARNPCPawnBase*> AREnemySpawnAreaSegment::GetEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "GetEnemies");

	Params::REnemySpawnAreaSegment_GetEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnAreaSegment.GetPlayersInArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APlayerController*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerController*> AREnemySpawnAreaSegment::GetPlayersInArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "GetPlayersInArea");

	Params::REnemySpawnAreaSegment_GetPlayersInArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnAreaSegment.HasSegmentObjectiveEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnAreaSegment::HasSegmentObjectiveEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "HasSegmentObjectiveEnded");

	Params::REnemySpawnAreaSegment_HasSegmentObjectiveEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnAreaSegment.OnActorEnterArea
// (Final, Native, Private)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnAreaSegment::OnActorEnterArea(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "OnActorEnterArea");

	Params::REnemySpawnAreaSegment_OnActorEnterArea Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.OnEntryDoorFinishedClosing
// (Final, Native, Private)

void AREnemySpawnAreaSegment::OnEntryDoorFinishedClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "OnEntryDoorFinishedClosing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.OnFinishRun
// (Final, Native, Private)
// Parameters:
// bool                                    RunFailed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnAreaSegment::OnFinishRun(bool RunFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "OnFinishRun");

	Params::REnemySpawnAreaSegment_OnFinishRun Parms{};

	Parms.RunFailed = RunFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.OnNextLevelsFinishedShowing
// (Final, Native, Private)

void AREnemySpawnAreaSegment::OnNextLevelsFinishedShowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "OnNextLevelsFinishedShowing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.OnPreLevelChanged
// (Final, Native, Private)

void AREnemySpawnAreaSegment::OnPreLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "OnPreLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.OnStarted_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void AREnemySpawnAreaSegment::OnStarted_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "OnStarted_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.SpawnRoomObjectiveEnemyWave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   WaveSizeOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnAreaSegment::SpawnRoomObjectiveEnemyWave(int32 WaveSizeOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "SpawnRoomObjectiveEnemyWave");

	Params::REnemySpawnAreaSegment_SpawnRoomObjectiveEnemyWave Parms{};

	Parms.WaveSizeOverride = WaveSizeOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.StartSegment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnAreaSegment::StartSegment(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "StartSegment");

	Params::REnemySpawnAreaSegment_StartSegment Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.StopSpawning
// (Final, Native, Public, BlueprintCallable)

void AREnemySpawnAreaSegment::StopSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "StopSpawning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnAreaSegment.GetRoomObjectiveType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERoomObjectiveType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERoomObjectiveType AREnemySpawnAreaSegment::GetRoomObjectiveType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnAreaSegment", "GetRoomObjectiveType");

	Params::REnemySpawnAreaSegment_GetRoomObjectiveType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.AddToGloballySpawnedTargets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToAdd                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::AddToGloballySpawnedTargets(class AActor* ActorToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REnemySpawnManager", "AddToGloballySpawnedTargets");

	Params::REnemySpawnManager_AddToGloballySpawnedTargets Parms{};

	Parms.ActorToAdd = ActorToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.GetSpawnManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AREnemySpawnManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AREnemySpawnManager* AREnemySpawnManager::GetSpawnManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REnemySpawnManager", "GetSpawnManager");

	Params::REnemySpawnManager_GetSpawnManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.RemoveFromGloballySpawnedTargets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToRemove                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::RemoveFromGloballySpawnedTargets(class AActor* ActorToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("REnemySpawnManager", "RemoveFromGloballySpawnedTargets");

	Params::REnemySpawnManager_RemoveFromGloballySpawnedTargets Parms{};

	Parms.ActorToRemove = ActorToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.AllSegmentsInCurrentNodeCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnManager::AllSegmentsInCurrentNodeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "AllSegmentsInCurrentNodeCompleted");

	Params::REnemySpawnManager_AllSegmentsInCurrentNodeCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.AllSegmentsInCurrentRoomCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnManager::AllSegmentsInCurrentRoomCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "AllSegmentsInCurrentRoomCompleted");

	Params::REnemySpawnManager_AllSegmentsInCurrentRoomCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.AnySegmentInCurrentNodeCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnManager::AnySegmentInCurrentNodeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "AnySegmentInCurrentNodeCompleted");

	Params::REnemySpawnManager_AnySegmentInCurrentNodeCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.BroadcastOnCurrentSegmentsCompleted
// (Final, Native, Public, BlueprintCallable)

void AREnemySpawnManager::BroadcastOnCurrentSegmentsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "BroadcastOnCurrentSegmentsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.BroadcastOnEliteEnemyKilled
// (Final, Native, Public)

void AREnemySpawnManager::BroadcastOnEliteEnemyKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "BroadcastOnEliteEnemyKilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.BroadcastOnEliteEnemySpawned
// (Final, Native, Public)

void AREnemySpawnManager::BroadcastOnEliteEnemySpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "BroadcastOnEliteEnemySpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.BroadcastOnEnemyKilled_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ARNPCPawnBase*                    EnemyPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::BroadcastOnEnemyKilled_Multicast(class ARNPCPawnBase* EnemyPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "BroadcastOnEnemyKilled_Multicast");

	Params::REnemySpawnManager_BroadcastOnEnemyKilled_Multicast Parms{};

	Parms.EnemyPawn = EnemyPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.GetCurrentAliveEnemies
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIncludePostRegisteredEnemies                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AREnemySpawnManager::GetCurrentAliveEnemies(bool bIncludePostRegisteredEnemies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetCurrentAliveEnemies");

	Params::REnemySpawnManager_GetCurrentAliveEnemies Parms{};

	Parms.bIncludePostRegisteredEnemies = bIncludePostRegisteredEnemies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetCurrentSpawnAreaSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AREnemySpawnAreaSegment*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AREnemySpawnAreaSegment* AREnemySpawnManager::GetCurrentSpawnAreaSegment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetCurrentSpawnAreaSegment");

	Params::REnemySpawnManager_GetCurrentSpawnAreaSegment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetCurrentSpawnAreaSegments
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AREnemySpawnAreaSegment*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AREnemySpawnAreaSegment*> AREnemySpawnManager::GetCurrentSpawnAreaSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetCurrentSpawnAreaSegments");

	Params::REnemySpawnManager_GetCurrentSpawnAreaSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetEnemyMutatorSetByEnemyMutatorClass
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class URGEnemyMutatorScript>EnemyMutatorClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FREnemyMutatorSet                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FREnemyMutatorSet AREnemySpawnManager::GetEnemyMutatorSetByEnemyMutatorClass(TSubclassOf<class URGEnemyMutatorScript> EnemyMutatorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetEnemyMutatorSetByEnemyMutatorClass");

	Params::REnemySpawnManager_GetEnemyMutatorSetByEnemyMutatorClass Parms{};

	Parms.EnemyMutatorClass = EnemyMutatorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetRandomEnemyMutatorSets
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   NumMutatorSets                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FREnemyMutatorSet>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FREnemyMutatorSet> AREnemySpawnManager::GetRandomEnemyMutatorSets(int32 NumMutatorSets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetRandomEnemyMutatorSets");

	Params::REnemySpawnManager_GetRandomEnemyMutatorSets Parms{};

	Parms.NumMutatorSets = NumMutatorSets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetRandomUsableMutatorSetsForEnemy
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AREnemyPawnBase*                  Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumMutatorSets                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FREnemyMutatorSet>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FREnemyMutatorSet> AREnemySpawnManager::GetRandomUsableMutatorSetsForEnemy(class AREnemyPawnBase* Enemy, const int32 NumMutatorSets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetRandomUsableMutatorSetsForEnemy");

	Params::REnemySpawnManager_GetRandomUsableMutatorSetsForEnemy Parms{};

	Parms.Enemy = Enemy;
	Parms.NumMutatorSets = NumMutatorSets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetRandomValidLocationInBoundingSpawnArea
// (Final, Native, Private, HasDefaults)
// Parameters:
// class AREnemySpawnArea*                 SpawnArea                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBoxComponent*                    SpawnAreaBox                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentAttempts                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FullRetryAttempts                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AREnemyPawnBase>      EnemyToSpawn                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowFailsafeCenterSpawn                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AREnemySpawnManager::GetRandomValidLocationInBoundingSpawnArea(class AREnemySpawnArea* SpawnArea, class UBoxComponent* SpawnAreaBox, int32 CurrentAttempts, int32 FullRetryAttempts, TSubclassOf<class AREnemyPawnBase> EnemyToSpawn, bool bAllowFailsafeCenterSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetRandomValidLocationInBoundingSpawnArea");

	Params::REnemySpawnManager_GetRandomValidLocationInBoundingSpawnArea Parms{};

	Parms.SpawnArea = SpawnArea;
	Parms.SpawnAreaBox = SpawnAreaBox;
	Parms.CurrentAttempts = CurrentAttempts;
	Parms.FullRetryAttempts = FullRetryAttempts;
	Parms.EnemyToSpawn = EnemyToSpawn;
	Parms.bAllowFailsafeCenterSpawn = bAllowFailsafeCenterSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetRemainingEnemies
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AREnemySpawnManager::GetRemainingEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetRemainingEnemies");

	Params::REnemySpawnManager_GetRemainingEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.GetRemainingEnemiesToSpawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AREnemySpawnManager::GetRemainingEnemiesToSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "GetRemainingEnemiesToSpawn");

	Params::REnemySpawnManager_GetRemainingEnemiesToSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.HandleSpawnFailure
// (Final, Native, Public)
// Parameters:
// const TArray<class AREnemySpawnAreaSegment*>&CurrentSegments                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsElite                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::HandleSpawnFailure(const TArray<class AREnemySpawnAreaSegment*>& CurrentSegments, bool bIsElite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "HandleSpawnFailure");

	Params::REnemySpawnManager_HandleSpawnFailure Parms{};

	Parms.CurrentSegments = std::move(CurrentSegments);
	Parms.bIsElite = bIsElite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.IsAnyEncounterActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnManager::IsAnyEncounterActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "IsAnyEncounterActive");

	Params::REnemySpawnManager_IsAnyEncounterActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.IsEnemyMutatorSetUsableForEnemy
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FREnemyMutatorSet&         EnemyMutatorSet                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AREnemyPawnBase*                  Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnManager::IsEnemyMutatorSetUsableForEnemy(const struct FREnemyMutatorSet& EnemyMutatorSet, class AREnemyPawnBase* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "IsEnemyMutatorSetUsableForEnemy");

	Params::REnemySpawnManager_IsEnemyMutatorSetUsableForEnemy Parms{};

	Parms.EnemyMutatorSet = std::move(EnemyMutatorSet);
	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.OnEnemySpawnEffects_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           EnemyClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpawnDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::OnEnemySpawnEffects_Multicast(const class UObject* WorldContextObject, class UClass* EnemyClass, float SpawnDuration, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "OnEnemySpawnEffects_Multicast");

	Params::REnemySpawnManager_OnEnemySpawnEffects_Multicast Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EnemyClass = EnemyClass;
	Parms.SpawnDuration = SpawnDuration;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.OnFinalBossKilled
// (Final, Native, Private)

void AREnemySpawnManager::OnFinalBossKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "OnFinalBossKilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.OnFinishRun
// (Final, Native, Private)
// Parameters:
// bool                                    RunFailed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::OnFinishRun(bool RunFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "OnFinishRun");

	Params::REnemySpawnManager_OnFinishRun Parms{};

	Parms.RunFailed = RunFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.OnLastSegmentInNodeCompleted_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void AREnemySpawnManager::OnLastSegmentInNodeCompleted_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "OnLastSegmentInNodeCompleted_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.OnPreLevelChanged
// (Final, Native, Private)

void AREnemySpawnManager::OnPreLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "OnPreLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.ReceiveOnEnemySpawnPrimed
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class UClass*                           EnemyClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpawnDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::ReceiveOnEnemySpawnPrimed(class UClass* EnemyClass, float SpawnDuration, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "ReceiveOnEnemySpawnPrimed");

	Params::REnemySpawnManager_ReceiveOnEnemySpawnPrimed Parms{};

	Parms.EnemyClass = EnemyClass;
	Parms.SpawnDuration = SpawnDuration;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.RegisterSpawnedEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARNPCPawnBase*                    EnemyPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::RegisterSpawnedEnemy(class ARNPCPawnBase* EnemyPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "RegisterSpawnedEnemy");

	Params::REnemySpawnManager_RegisterSpawnedEnemy Parms{};

	Parms.EnemyPawn = EnemyPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.SegmentCompleted
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::SegmentCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "SegmentCompleted");

	Params::REnemySpawnManager_SegmentCompleted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.SegmentStarted
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::SegmentStarted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "SegmentStarted");

	Params::REnemySpawnManager_SegmentStarted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.StartSpawningEnemyWithEffects
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             EnemySpawnTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AREnemySpawnArea*                 SpawnArea                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TWeakObjectPtr<class ARNPCPawnBase>>*SpawnedEnemiesList                                     (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    bIsElite                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RetryAttempts                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowFailsafeCenterSpawn                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AREnemySpawnManager::StartSpawningEnemyWithEffects(class FName EnemySpawnTag, class AREnemySpawnArea* SpawnArea, TArray<TWeakObjectPtr<class ARNPCPawnBase>>* SpawnedEnemiesList, bool bIsElite, int32 RetryAttempts, bool bAllowFailsafeCenterSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "StartSpawningEnemyWithEffects");

	Params::REnemySpawnManager_StartSpawningEnemyWithEffects Parms{};

	Parms.EnemySpawnTag = EnemySpawnTag;
	Parms.SpawnArea = SpawnArea;
	Parms.bIsElite = bIsElite;
	Parms.RetryAttempts = RetryAttempts;
	Parms.bAllowFailsafeCenterSpawn = bAllowFailsafeCenterSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedEnemiesList != nullptr)
		*SpawnedEnemiesList = std::move(Parms.SpawnedEnemiesList);

	return Parms.ReturnValue;
}


// Function RGame.REnemySpawnManager.TryForceSpawningEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EnemySpawnTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AREnemySpawnArea*                 SpawnArea                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AREnemySpawnAreaSegment*          SpawnAreaSegment                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::TryForceSpawningEnemy(class FName EnemySpawnTag, class AREnemySpawnArea* SpawnArea, class AREnemySpawnAreaSegment* SpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "TryForceSpawningEnemy");

	Params::REnemySpawnManager_TryForceSpawningEnemy Parms{};

	Parms.EnemySpawnTag = EnemySpawnTag;
	Parms.SpawnArea = SpawnArea;
	Parms.SpawnAreaSegment = SpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.REnemySpawnManager.TryForceSpawningEnemyCurrentSegment
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EnemySpawnTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistanceForSpawn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AREnemySpawnManager::TryForceSpawningEnemyCurrentSegment(class FName EnemySpawnTag, const struct FVector& Location, float MaxDistanceForSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("REnemySpawnManager", "TryForceSpawningEnemyCurrentSegment");

	Params::REnemySpawnManager_TryForceSpawningEnemyCurrentSegment Parms{};

	Parms.EnemySpawnTag = EnemySpawnTag;
	Parms.Location = std::move(Location);
	Parms.MaxDistanceForSpawn = MaxDistanceForSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.K2_OnApplyTransientfields
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   FieldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             FieldRadius                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARFieldSystemActor::K2_OnApplyTransientfields(const struct FVector& FieldLocation, const float FieldRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "K2_OnApplyTransientfields");

	Params::RFieldSystemActor_K2_OnApplyTransientfields Parms{};

	Parms.FieldLocation = std::move(FieldLocation);
	Parms.FieldRadius = FieldRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RFieldSystemActor.TriggerTransientFields_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   FieldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             FieldRadius                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFields_Multicast(const struct FVector& FieldLocation, const float FieldRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFields_Multicast");

	Params::RFieldSystemActor_TriggerTransientFields_Multicast Parms{};

	Parms.FieldLocation = std::move(FieldLocation);
	Parms.FieldRadius = FieldRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.TriggerTransientFieldsActorHitDelegateWrapper
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFieldsActorHitDelegateWrapper(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFieldsActorHitDelegateWrapper");

	Params::RFieldSystemActor_TriggerTransientFieldsActorHitDelegateWrapper Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.TriggerTransientFieldsEnemyAreaAttackDelegateWrapper
// (Final, Native, Public, HasDefaults)
// Parameters:
// const TArray<class AActor*>&            HitActors                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AREnemyPawnBase*                  Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFieldsEnemyAreaAttackDelegateWrapper(const TArray<class AActor*>& HitActors, class AREnemyPawnBase* Enemy, const struct FVector& Location, float AttackRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFieldsEnemyAreaAttackDelegateWrapper");

	Params::RFieldSystemActor_TriggerTransientFieldsEnemyAreaAttackDelegateWrapper Parms{};

	Parms.HitActors = std::move(HitActors);
	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);
	Parms.AttackRadius = AttackRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.TriggerTransientFieldsEnemyProjectileDelegateWrapper
// (Final, Native, Public)
// Parameters:
// class AREnemyPawnBase*                  EnemyPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARProjectileBase*                 ProjectileActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFieldsEnemyProjectileDelegateWrapper(class AREnemyPawnBase* EnemyPawn, class AActor* HitActor, class ARProjectileBase* ProjectileActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFieldsEnemyProjectileDelegateWrapper");

	Params::RFieldSystemActor_TriggerTransientFieldsEnemyProjectileDelegateWrapper Parms{};

	Parms.EnemyPawn = EnemyPawn;
	Parms.HitActor = HitActor;
	Parms.ProjectileActor = ProjectileActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.TriggerTransientFieldsPlayerAreaAttackDelegateWrapper
// (Final, Native, Public)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        Hits                                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFieldsPlayerAreaAttackDelegateWrapper(class ARPlayerPawn* Player, const TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFieldsPlayerAreaAttackDelegateWrapper");

	Params::RFieldSystemActor_TriggerTransientFieldsPlayerAreaAttackDelegateWrapper Parms{};

	Parms.Player = Player;
	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.TriggerTransientFieldsPlayerLesserAreaAttackDelegateWrapper
// (Final, Native, Public)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        Hits                                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFieldsPlayerLesserAreaAttackDelegateWrapper(class ARPlayerPawn* Player, const TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFieldsPlayerLesserAreaAttackDelegateWrapper");

	Params::RFieldSystemActor_TriggerTransientFieldsPlayerLesserAreaAttackDelegateWrapper Parms{};

	Parms.Player = Player;
	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFieldSystemActor.TriggerTransientFieldsPlayerProjectileDelegateWrapper
// (Final, Native, Public)
// Parameters:
// class ARPlayerPawn*                     PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARProjectileBase*                 ProjectileActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARFieldSystemActor::TriggerTransientFieldsPlayerProjectileDelegateWrapper(class ARPlayerPawn* PlayerPawn, class AActor* HitActor, class ARProjectileBase* ProjectileActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFieldSystemActor", "TriggerTransientFieldsPlayerProjectileDelegateWrapper");

	Params::RFieldSystemActor_TriggerTransientFieldsPlayerProjectileDelegateWrapper Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.HitActor = HitActor;
	Parms.ProjectileActor = ProjectileActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFloatingTextManager.GetFloatingTextManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARFloatingTextManager*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARFloatingTextManager* ARFloatingTextManager::GetFloatingTextManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RFloatingTextManager", "GetFloatingTextManager");

	Params::RFloatingTextManager_GetFloatingTextManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RFloatingTextManager.RemoveFloatingTextByType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URFloatingTextWidget*             FloatingText                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARFloatingTextManager::RemoveFloatingTextByType(class URFloatingTextWidget* FloatingText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFloatingTextManager", "RemoveFloatingTextByType");

	Params::RFloatingTextManager_RemoveFloatingTextByType Parms{};

	Parms.FloatingText = FloatingText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFloatingTextWidget.PushFloatingTextAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ERFloatingTextType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URFloatingTextWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URFloatingTextWidget* URFloatingTextWidget::PushFloatingTextAtLocation(class UObject* WorldContextObject, const struct FVector& Location, const class FText& Text, ERFloatingTextType Type, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RFloatingTextWidget", "PushFloatingTextAtLocation");

	Params::RFloatingTextWidget_PushFloatingTextAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.Text = std::move(Text);
	Parms.Type = Type;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RFloatingTextWidget.QueueFloatingText
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ERFloatingTextType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URFloatingTextWidget::QueueFloatingText(class UObject* WorldContextObject, const struct FVector& Location, const class FText& Text, ERFloatingTextType Type, bool bSkipDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RFloatingTextWidget", "QueueFloatingText");

	Params::RFloatingTextWidget_QueueFloatingText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.Text = std::move(Text);
	Parms.Type = Type;
	Parms.bSkipDelay = bSkipDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RFloatingTextWidget.RefreshText
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const class FText&                      NewText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   NewWorldPosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URFloatingTextWidget::RefreshText(const class FText& NewText, const struct FVector& NewWorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFloatingTextWidget", "RefreshText");

	Params::RFloatingTextWidget_RefreshText Parms{};

	Parms.NewText = std::move(NewText);
	Parms.NewWorldPosition = std::move(NewWorldPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RFloatingTextWidget.SetAnimationDuration
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URFloatingTextWidget::SetAnimationDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RFloatingTextWidget", "SetAnimationDuration");

	Params::RFloatingTextWidget_SetAnimationDuration Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGAbilityCharacterMutatorScript.AddAbilityBlocker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::AddAbilityBlocker(const class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "AddAbilityBlocker");

	Params::RGAbilityCharacterMutatorScript_AddAbilityBlocker Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.BPCanFireAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGAbilityCharacterMutatorScript::BPCanFireAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "BPCanFireAbility");

	Params::RGAbilityCharacterMutatorScript_BPCanFireAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAbilityCharacterMutatorScript.BroadcastOnCooldownFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::BroadcastOnCooldownFinished(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "BroadcastOnCooldownFinished");

	Params::RGAbilityCharacterMutatorScript_BroadcastOnCooldownFinished Parms{};

	Parms.RGAbilityCharacterMutatorScript = RGAbilityCharacterMutatorScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.BroadcastOnCooldownFinished_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::BroadcastOnCooldownFinished_Server(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "BroadcastOnCooldownFinished_Server");

	Params::RGAbilityCharacterMutatorScript_BroadcastOnCooldownFinished_Server Parms{};

	Parms.RGAbilityCharacterMutatorScript = RGAbilityCharacterMutatorScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.BroadcastOnStacksUpdated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumStacksRemaining                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::BroadcastOnStacksUpdated(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, const int32 NumStacksRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "BroadcastOnStacksUpdated");

	Params::RGAbilityCharacterMutatorScript_BroadcastOnStacksUpdated Parms{};

	Parms.RGAbilityCharacterMutatorScript = RGAbilityCharacterMutatorScript;
	Parms.NumStacksRemaining = NumStacksRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.BroadcastOnStackUpdated_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumStacksRemaining                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::BroadcastOnStackUpdated_Multicast(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, const int32 NumStacksRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "BroadcastOnStackUpdated_Multicast");

	Params::RGAbilityCharacterMutatorScript_BroadcastOnStackUpdated_Multicast Parms{};

	Parms.RGAbilityCharacterMutatorScript = RGAbilityCharacterMutatorScript;
	Parms.NumStacksRemaining = NumStacksRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.BroadcastOnStackUpdated_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumStacksRemaining                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::BroadcastOnStackUpdated_Server(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, const int32 NumStacksRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "BroadcastOnStackUpdated_Server");

	Params::RGAbilityCharacterMutatorScript_BroadcastOnStackUpdated_Server Parms{};

	Parms.RGAbilityCharacterMutatorScript = RGAbilityCharacterMutatorScript;
	Parms.NumStacksRemaining = NumStacksRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.CanFireAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InputAbilityIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGAbilityCharacterMutatorScript::CanFireAbility(int32 InputAbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "CanFireAbility");

	Params::RGAbilityCharacterMutatorScript_CanFireAbility Parms{};

	Parms.InputAbilityIndex = InputAbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAbilityCharacterMutatorScript.ClearAbilityBlockers
// (Final, Native, Public, BlueprintCallable)

void URGAbilityCharacterMutatorScript::ClearAbilityBlockers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "ClearAbilityBlockers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.FireAbility
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URGAbilityCharacterMutatorScript::FireAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "FireAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGAbilityCharacterMutatorScript.FireAbility_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void URGAbilityCharacterMutatorScript::FireAbility_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "FireAbility_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.FireAbility_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void URGAbilityCharacterMutatorScript::FireAbility_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "FireAbility_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.GetChargePercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGAbilityCharacterMutatorScript::GetChargePercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "GetChargePercentage");

	Params::RGAbilityCharacterMutatorScript_GetChargePercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAbilityCharacterMutatorScript.IsAbilityEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGAbilityCharacterMutatorScript::IsAbilityEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "IsAbilityEnabled");

	Params::RGAbilityCharacterMutatorScript_IsAbilityEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAbilityCharacterMutatorScript.IsInputCooldownReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGAbilityCharacterMutatorScript::IsInputCooldownReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "IsInputCooldownReady");

	Params::RGAbilityCharacterMutatorScript_IsInputCooldownReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAbilityCharacterMutatorScript.IsInSweetSpotInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGAbilityCharacterMutatorScript::IsInSweetSpotInterval()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "IsInSweetSpotInterval");

	Params::RGAbilityCharacterMutatorScript_IsInSweetSpotInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAbilityCharacterMutatorScript.OnAbilityDisabled
// (Event, Public, BlueprintEvent)

void URGAbilityCharacterMutatorScript::OnAbilityDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "OnAbilityDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGAbilityCharacterMutatorScript.OnAbilityEnabled
// (Event, Public, BlueprintEvent)

void URGAbilityCharacterMutatorScript::OnAbilityEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "OnAbilityEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGAbilityCharacterMutatorScript.RemoveAbilityBlocker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAbilityCharacterMutatorScript::RemoveAbilityBlocker(const class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "RemoveAbilityBlocker");

	Params::RGAbilityCharacterMutatorScript_RemoveAbilityBlocker Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAbilityCharacterMutatorScript.GetWeaponScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGWeaponScript*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGWeaponScript* URGAbilityCharacterMutatorScript::GetWeaponScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAbilityCharacterMutatorScript", "GetWeaponScript");

	Params::RGAbilityCharacterMutatorScript_GetWeaponScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ActorHasAnyStatusEffectFromInstigator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               InstigatorScriptComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::ActorHasAnyStatusEffectFromInstigator(class AActor* Actor, class URGScriptComponent* InstigatorScriptComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ActorHasAnyStatusEffectFromInstigator");

	Params::RGameFunctionLibrary_ActorHasAnyStatusEffectFromInstigator Parms{};

	Parms.Actor = Actor;
	Parms.InstigatorScriptComponent = InstigatorScriptComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ActorHasStatusEffect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             StatusEffectClass                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::ActorHasStatusEffect(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ActorHasStatusEffect");

	Params::RGameFunctionLibrary_ActorHasStatusEffect Parms{};

	Parms.Actor = Actor;
	Parms.StatusEffectClass = StatusEffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ActorHasStatusEffectFromInstigator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             StatusEffectClass                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               InstigatorScriptComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::ActorHasStatusEffectFromInstigator(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass, class URGScriptComponent* InstigatorScriptComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ActorHasStatusEffectFromInstigator");

	Params::RGameFunctionLibrary_ActorHasStatusEffectFromInstigator Parms{};

	Parms.Actor = Actor;
	Parms.StatusEffectClass = StatusEffectClass;
	Parms.InstigatorScriptComponent = InstigatorScriptComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.AddHighlightToTextWithKeywords
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    Text                                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    HighlightStyle                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::AddHighlightToTextWithKeywords(const class FString& Text, const class FString& HighlightStyle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddHighlightToTextWithKeywords");

	Params::RGameFunctionLibrary_AddHighlightToTextWithKeywords Parms{};

	Parms.Text = std::move(Text);
	Parms.HighlightStyle = std::move(HighlightStyle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.AddMutableFloatCoefficient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::AddMutableFloatCoefficient(struct FRMutableFloat& MutableFloat, class FName Key, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddMutableFloatCoefficient");

	Params::RGameFunctionLibrary_AddMutableFloatCoefficient Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.AddMutableFloatPostAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::AddMutableFloatPostAdditive(struct FRMutableFloat& MutableFloat, class FName Key, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddMutableFloatPostAdditive");

	Params::RGameFunctionLibrary_AddMutableFloatPostAdditive Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.AddMutableFloatPreAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::AddMutableFloatPreAdditive(struct FRMutableFloat& MutableFloat, class FName Key, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddMutableFloatPreAdditive");

	Params::RGameFunctionLibrary_AddMutableFloatPreAdditive Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.AddMutableIntegerCoefficient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::AddMutableIntegerCoefficient(struct FRMutableInteger& MutableInteger, class FName Key, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddMutableIntegerCoefficient");

	Params::RGameFunctionLibrary_AddMutableIntegerCoefficient Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.AddMutableIntegerPostAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::AddMutableIntegerPostAdditive(struct FRMutableInteger& MutableInteger, class FName Key, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddMutableIntegerPostAdditive");

	Params::RGameFunctionLibrary_AddMutableIntegerPostAdditive Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.AddMutableIntegerPreAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::AddMutableIntegerPreAdditive(struct FRMutableInteger& MutableInteger, class FName Key, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AddMutableIntegerPreAdditive");

	Params::RGameFunctionLibrary_AddMutableIntegerPreAdditive Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.AnalyzeFocusEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFocusEvent&               FocusEvent                                             (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::AnalyzeFocusEvent(const struct FFocusEvent& FocusEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AnalyzeFocusEvent");

	Params::RGameFunctionLibrary_AnalyzeFocusEvent Parms{};

	Parms.FocusEvent = std::move(FocusEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.AnalyzeGeometry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGeometry&                 Geometry                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::AnalyzeGeometry(const struct FGeometry& Geometry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AnalyzeGeometry");

	Params::RGameFunctionLibrary_AnalyzeGeometry Parms{};

	Parms.Geometry = std::move(Geometry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ApplyLightningEffectDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LightingBouncesLeft                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OriginActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   LightningNiagaraSystem                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       LightningHitSound                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               AffectedActorClasses                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LightningDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageFalloffPerBounce                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BounceDelay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               InstigatorScriptComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRLightningDamageCombatEventData&LightningDamageCombatEventData                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bDamageClientPrediction                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URGameFunctionLibrary::ApplyLightningEffectDamage(const class UObject* WorldContextObject, int32 LightingBouncesLeft, class AActor* OriginActor, class AActor* DamageCauser, class AController* InstigatedByController, const TArray<class AActor*>& IgnoreActors, class UNiagaraSystem* LightningNiagaraSystem, class USoundBase* LightningHitSound, TSubclassOf<class AActor> AffectedActorClasses, float LightningDamage, float DamageRadius, float DamageFalloffPerBounce, float BounceDelay, class URGScriptComponent* InstigatorScriptComponent, const struct FRLightningDamageCombatEventData& LightningDamageCombatEventData, bool bDamageClientPrediction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ApplyLightningEffectDamage");

	Params::RGameFunctionLibrary_ApplyLightningEffectDamage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LightingBouncesLeft = LightingBouncesLeft;
	Parms.OriginActor = OriginActor;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.LightningNiagaraSystem = LightningNiagaraSystem;
	Parms.LightningHitSound = LightningHitSound;
	Parms.AffectedActorClasses = AffectedActorClasses;
	Parms.LightningDamage = LightningDamage;
	Parms.DamageRadius = DamageRadius;
	Parms.DamageFalloffPerBounce = DamageFalloffPerBounce;
	Parms.BounceDelay = BounceDelay;
	Parms.InstigatorScriptComponent = InstigatorScriptComponent;
	Parms.LightningDamageCombatEventData = std::move(LightningDamageCombatEventData);
	Parms.bDamageClientPrediction = bDamageClientPrediction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ApplyRadialDamage
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               AffectedActorClasses                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceForObstacles                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamageClientPrediction                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::ApplyRadialDamage(const class UObject* WorldContextObject, const struct FVector& Origin, class AActor* DamageCauser, class AController* InstigatedByController, const TArray<class AActor*>& IgnoreActors, TSubclassOf<class AActor> AffectedActorClasses, float BaseDamage, float DamageRadius, bool bTraceForObstacles, int32 DamageSources, bool bDamageClientPrediction, class AActor* AvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ApplyRadialDamage");

	Params::RGameFunctionLibrary_ApplyRadialDamage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.AffectedActorClasses = AffectedActorClasses;
	Parms.BaseDamage = BaseDamage;
	Parms.DamageRadius = DamageRadius;
	Parms.bTraceForObstacles = bTraceForObstacles;
	Parms.DamageSources = DamageSources;
	Parms.bDamageClientPrediction = bDamageClientPrediction;
	Parms.AvatarActor = AvatarActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.AreObjectsInSameRoom
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     FirstObject                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     SecondObject                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      LevelGenerationSettingsBox                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::AreObjectsInSameRoom(const class AActor* FirstObject, const class AActor* SecondObject, const struct FBox& LevelGenerationSettingsBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "AreObjectsInSameRoom");

	Params::RGameFunctionLibrary_AreObjectsInSameRoom Parms{};

	Parms.FirstObject = FirstObject;
	Parms.SecondObject = SecondObject;
	Parms.LevelGenerationSettingsBox = std::move(LevelGenerationSettingsBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.Array_Random_Cached
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<int32>&                    TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  OutItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::Array_Random_Cached(const TArray<int32>& TargetArray, int32* OutItem, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "Array_Random_Cached");

	Params::RGameFunctionLibrary_Array_Random_Cached Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItem != nullptr)
		*OutItem = Parms.OutItem;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;
}


// Function RGame.RGameFunctionLibrary.CheckDamageSource
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageSource                           DamageSource                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::CheckDamageSource(int32 BitMask, EDamageSource DamageSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "CheckDamageSource");

	Params::RGameFunctionLibrary_CheckDamageSource Parms{};

	Parms.BitMask = BitMask;
	Parms.DamageSource = DamageSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.CombineRotatorWithEuler
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRotator&                  Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Euler                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URGameFunctionLibrary::CombineRotatorWithEuler(const struct FRotator& Rotator, const struct FVector& Euler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "CombineRotatorWithEuler");

	Params::RGameFunctionLibrary_CombineRotatorWithEuler Parms{};

	Parms.Rotator = std::move(Rotator);
	Parms.Euler = std::move(Euler);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ConvertFNameToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::ConvertFNameToFloat(const class FName Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ConvertFNameToFloat");

	Params::RGameFunctionLibrary_ConvertFNameToFloat Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.CreateBlueprintAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Parent                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PackagePath                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URGameFunctionLibrary::CreateBlueprintAsset(class UClass* Parent, const class FString& Name_0, const class FString& PackagePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "CreateBlueprintAsset");

	Params::RGameFunctionLibrary_CreateBlueprintAsset Parms{};

	Parms.Parent = Parent;
	Parms.Name_0 = std::move(Name_0);
	Parms.PackagePath = std::move(PackagePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.DamageSourceMaskHasFlag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FlagsToCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::DamageSourceMaskHasFlag(int32 Mask, int32 FlagsToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "DamageSourceMaskHasFlag");

	Params::RGameFunctionLibrary_DamageSourceMaskHasFlag Parms{};

	Parms.Mask = Mask;
	Parms.FlagsToCheck = FlagsToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.DumpMutableFloatToLog
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::DumpMutableFloatToLog(const class UObject* WorldContextObject, struct FRMutableFloat& MutableFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "DumpMutableFloatToLog");

	Params::RGameFunctionLibrary_DumpMutableFloatToLog Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MutableFloat = std::move(MutableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.FadeInWithoutRestart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             FadeInDuration                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             FadeVolumeLevel                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EAudioFaderCurve                  FadeCurve                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::FadeInWithoutRestart(class UAudioComponent* AudioComponent, const float FadeInDuration, const float FadeVolumeLevel, const EAudioFaderCurve FadeCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "FadeInWithoutRestart");

	Params::RGameFunctionLibrary_FadeInWithoutRestart Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;
	Parms.FadeCurve = FadeCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.FilterForAliveAndVulnerableActorsFromActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>&                  ActorsToFilter                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::FilterForAliveAndVulnerableActorsFromActors(TArray<class AActor*>& ActorsToFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "FilterForAliveAndVulnerableActorsFromActors");

	Params::RGameFunctionLibrary_FilterForAliveAndVulnerableActorsFromActors Parms{};

	Parms.ActorsToFilter = std::move(ActorsToFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ActorsToFilter = std::move(Parms.ActorsToFilter);
}


// Function RGame.RGameFunctionLibrary.FindDefaultComponentByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TSubclassOf<class AActor>         InActorClass                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class UActorComponent>InComponentClass                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* URGameFunctionLibrary::FindDefaultComponentByClass(const TSubclassOf<class AActor> InActorClass, const TSubclassOf<class UActorComponent> InComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "FindDefaultComponentByClass");

	Params::RGameFunctionLibrary_FindDefaultComponentByClass Parms{};

	Parms.InActorClass = InActorClass;
	Parms.InComponentClass = InComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GamepadLostFocusByMouseEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFocusEvent&               FocusEvent                                             (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::GamepadLostFocusByMouseEvent(class APlayerController* PlayerController, const struct FFocusEvent& FocusEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GamepadLostFocusByMouseEvent");

	Params::RGameFunctionLibrary_GamepadLostFocusByMouseEvent Parms{};

	Parms.PlayerController = PlayerController;
	Parms.FocusEvent = std::move(FocusEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetActivatableAbilityKeybindName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::GetActivatableAbilityKeybindName(int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetActivatableAbilityKeybindName");

	Params::RGameFunctionLibrary_GetActivatableAbilityKeybindName Parms{};

	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetActorGameplayTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer URGameFunctionLibrary::GetActorGameplayTags(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetActorGameplayTags");

	Params::RGameFunctionLibrary_GetActorGameplayTags Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetActorsOfClassInsideRadius
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetActorsOfClassInsideRadius(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetActorsOfClassInsideRadius");

	Params::RGameFunctionLibrary_GetActorsOfClassInsideRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetActorStatusEffect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             StatusEffectClass                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URStatusEffectGScript*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URStatusEffectGScript* URGameFunctionLibrary::GetActorStatusEffect(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetActorStatusEffect");

	Params::RGameFunctionLibrary_GetActorStatusEffect Parms{};

	Parms.Actor = Actor;
	Parms.StatusEffectClass = StatusEffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetActorStatusEffectAmount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             StatusEffectClass                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetActorStatusEffectAmount(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetActorStatusEffectAmount");

	Params::RGameFunctionLibrary_GetActorStatusEffectAmount Parms{};

	Parms.Actor = Actor;
	Parms.StatusEffectClass = StatusEffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetActorStatusEffectFromInstigator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             StatusEffectClass                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               InstigatorScriptComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URStatusEffectGScript*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URStatusEffectGScript* URGameFunctionLibrary::GetActorStatusEffectFromInstigator(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass, class URGScriptComponent* InstigatorScriptComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetActorStatusEffectFromInstigator");

	Params::RGameFunctionLibrary_GetActorStatusEffectFromInstigator Parms{};

	Parms.Actor = Actor;
	Parms.StatusEffectClass = StatusEffectClass;
	Parms.InstigatorScriptComponent = InstigatorScriptComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAliveActorsFromActors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>&            ActorsToFilter                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetAliveActorsFromActors(const TArray<class AActor*>& ActorsToFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAliveActorsFromActors");

	Params::RGameFunctionLibrary_GetAliveActorsFromActors Parms{};

	Parms.ActorsToFilter = std::move(ActorsToFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAliveAndVulnerableActorsFromActors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>&            ActorsToFilter                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetAliveAndVulnerableActorsFromActors(const TArray<class AActor*>& ActorsToFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAliveAndVulnerableActorsFromActors");

	Params::RGameFunctionLibrary_GetAliveAndVulnerableActorsFromActors Parms{};

	Parms.ActorsToFilter = std::move(ActorsToFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllAliveEnemyPawnsInLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ARNPCPawnBase*>&     IgnoredEnemies                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bExcludeBosses                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDummys                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGlobalTargets                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGeometryCollections                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetAllAliveEnemyPawnsInLevel(const class UObject* WorldContextObject, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllAliveEnemyPawnsInLevel");

	Params::RGameFunctionLibrary_GetAllAliveEnemyPawnsInLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IgnoredEnemies = std::move(IgnoredEnemies);
	Parms.bExcludeBosses = bExcludeBosses;
	Parms.bIncludeDummys = bIncludeDummys;
	Parms.bIncludeGlobalTargets = bIncludeGlobalTargets;
	Parms.bIncludeGeometryCollections = bIncludeGeometryCollections;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllAliveEnemyPawnsInLevelSortedByDistanceFromLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescendingSort                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ARNPCPawnBase*>&     IgnoredEnemies                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bExcludeBosses                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDummys                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGlobalTargets                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGeometryCollections                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetAllAliveEnemyPawnsInLevelSortedByDistanceFromLocation(const class UObject* WorldContextObject, const struct FVector& Location, bool bDescendingSort, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllAliveEnemyPawnsInLevelSortedByDistanceFromLocation");

	Params::RGameFunctionLibrary_GetAllAliveEnemyPawnsInLevelSortedByDistanceFromLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.bDescendingSort = bDescendingSort;
	Parms.IgnoredEnemies = std::move(IgnoredEnemies);
	Parms.bExcludeBosses = bExcludeBosses;
	Parms.bIncludeDummys = bIncludeDummys;
	Parms.bIncludeGlobalTargets = bIncludeGlobalTargets;
	Parms.bIncludeGeometryCollections = bIncludeGeometryCollections;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllAliveEnemyPawnsInRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ARNPCPawnBase*>&     IgnoredEnemies                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExcludeBosses                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDummys                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGlobalTargets                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGeometryCollections                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetAllAliveEnemyPawnsInRadius(const class UObject* WorldContextObject, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, const struct FVector& Location, float Radius, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllAliveEnemyPawnsInRadius");

	Params::RGameFunctionLibrary_GetAllAliveEnemyPawnsInRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IgnoredEnemies = std::move(IgnoredEnemies);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.bExcludeBosses = bExcludeBosses;
	Parms.bIncludeDummys = bIncludeDummys;
	Parms.bIncludeGlobalTargets = bIncludeGlobalTargets;
	Parms.bIncludeGeometryCollections = bIncludeGeometryCollections;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllHitsInRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     OriginActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TSubclassOf<class AActor>         AffectedActorClass                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceForObstacles                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> URGameFunctionLibrary::GetAllHitsInRadius(const class UObject* WorldContextObject, const struct FVector& Origin, const class AActor* OriginActor, const TArray<class AActor*>& IgnoreActors, const TSubclassOf<class AActor> AffectedActorClass, float Radius, bool bTraceForObstacles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllHitsInRadius");

	Params::RGameFunctionLibrary_GetAllHitsInRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.OriginActor = OriginActor;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.AffectedActorClass = AffectedActorClass;
	Parms.Radius = Radius;
	Parms.bTraceForObstacles = bTraceForObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllKeywords
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const bool                              bAllowVariants                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> URGameFunctionLibrary::GetAllKeywords(const bool bAllowVariants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllKeywords");

	Params::RGameFunctionLibrary_GetAllKeywords Parms{};

	Parms.bAllowVariants = bAllowVariants;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllPawnsInRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     OriginActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceForObstacles                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARPawnBase*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARPawnBase*> URGameFunctionLibrary::GetAllPawnsInRadius(const class UObject* WorldContextObject, const struct FVector& Origin, const class AActor* OriginActor, const TArray<class AActor*>& IgnoreActors, float Radius, bool bTraceForObstacles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllPawnsInRadius");

	Params::RGameFunctionLibrary_GetAllPawnsInRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.OriginActor = OriginActor;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Radius = Radius;
	Parms.bTraceForObstacles = bTraceForObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetAllPlayerPawnsInLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARPlayerPawn*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARPlayerPawn*> URGameFunctionLibrary::GetAllPlayerPawnsInLevel(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetAllPlayerPawnsInLevel");

	Params::RGameFunctionLibrary_GetAllPlayerPawnsInLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetChanceBasedOnGold
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             GoldEquivalentToMaxChance                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetChanceBasedOnGold(class AController* Controller, const float GoldEquivalentToMaxChance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetChanceBasedOnGold");

	Params::RGameFunctionLibrary_GetChanceBasedOnGold Parms{};

	Parms.Controller = Controller;
	Parms.GoldEquivalentToMaxChance = GoldEquivalentToMaxChance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetChargeValueFromPlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>&            PlayerActors                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetChargeValueFromPlayers(const TArray<class AActor*>& PlayerActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetChargeValueFromPlayers");

	Params::RGameFunctionLibrary_GetChargeValueFromPlayers Parms{};

	Parms.PlayerActors = std::move(PlayerActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetClosestActorToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float*                                  OutDistance                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URGameFunctionLibrary::GetClosestActorToLocation(const struct FVector& Location, const TArray<class AActor*>& Actors, float* OutDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetClosestActorToLocation");

	Params::RGameFunctionLibrary_GetClosestActorToLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDistance != nullptr)
		*OutDistance = Parms.OutDistance;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetClosestPointOnSkeletalMeshToWorldLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            HitBone                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequireVisibleSkelMesh                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReturnActorBoundsIfNoSkelMesh                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URGameFunctionLibrary::GetClosestPointOnSkeletalMeshToWorldLocation(const class AActor* Target, const struct FVector& Location, class FName* HitBone, bool bRequireVisibleSkelMesh, bool bReturnActorBoundsIfNoSkelMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetClosestPointOnSkeletalMeshToWorldLocation");

	Params::RGameFunctionLibrary_GetClosestPointOnSkeletalMeshToWorldLocation Parms{};

	Parms.Target = Target;
	Parms.Location = std::move(Location);
	Parms.bRequireVisibleSkelMesh = bRequireVisibleSkelMesh;
	Parms.bReturnActorBoundsIfNoSkelMesh = bReturnActorBoundsIfNoSkelMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitBone != nullptr)
		*HitBone = Parms.HitBone;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetCoefficientsValueByKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetCoefficientsValueByKey(struct FRMutableFloat& MutableFloat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetCoefficientsValueByKey");

	Params::RGameFunctionLibrary_GetCoefficientsValueByKey Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetCommonInputKeyBrush
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush URGameFunctionLibrary::GetCommonInputKeyBrush(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetCommonInputKeyBrush");

	Params::RGameFunctionLibrary_GetCommonInputKeyBrush Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetCurrentLookAtTargetForPlayerController
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARGamePlayerController*           PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   TraceRadiusSize                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::GetCurrentLookAtTargetForPlayerController(const class UObject* WorldContextObject, class ARGamePlayerController* PlayerController, const TArray<EObjectTypeQuery>& ObjectTypes, struct FHitResult* OutHit, float TraceRadiusSize, float TraceLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetCurrentLookAtTargetForPlayerController");

	Params::RGameFunctionLibrary_GetCurrentLookAtTargetForPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerController = PlayerController;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.TraceRadiusSize = TraceRadiusSize;
	Parms.TraceLength = TraceLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);
}


// Function RGame.RGameFunctionLibrary.GetDashedLinePoints
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector2D&                 PointA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 PointB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DashLength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> URGameFunctionLibrary::GetDashedLinePoints(const struct FVector2D& PointA, const struct FVector2D& PointB, float DashLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetDashedLinePoints");

	Params::RGameFunctionLibrary_GetDashedLinePoints Parms{};

	Parms.PointA = std::move(PointA);
	Parms.PointB = std::move(PointB);
	Parms.DashLength = DashLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetDifficultyValueByArrayIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URDifficultyPrimaryAsset*         RDifficultyPrimaryAsset                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Tier                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ArrayIndex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetDifficultyValueByArrayIndex(const class UObject* WorldContextObject, class URDifficultyPrimaryAsset* RDifficultyPrimaryAsset, const int32 Tier, const int32 ArrayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetDifficultyValueByArrayIndex");

	Params::RGameFunctionLibrary_GetDifficultyValueByArrayIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RDifficultyPrimaryAsset = RDifficultyPrimaryAsset;
	Parms.Tier = Tier;
	Parms.ArrayIndex = ArrayIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetDirectDamageBitmask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetDirectDamageBitmask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetDirectDamageBitmask");

	Params::RGameFunctionLibrary_GetDirectDamageBitmask Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetEmoteDataTableRowByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmoteDataTableRow               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEmoteDataTableRow URGameFunctionLibrary::GetEmoteDataTableRowByTag(class UDataTable* Table, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetEmoteDataTableRowByTag");

	Params::RGameFunctionLibrary_GetEmoteDataTableRowByTag Parms{};

	Parms.Table = Table;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetEnemyInfoById
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EnemyId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FREnemyTableRow                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FREnemyTableRow URGameFunctionLibrary::GetEnemyInfoById(const class UObject* WorldContextObject, class FName EnemyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetEnemyInfoById");

	Params::RGameFunctionLibrary_GetEnemyInfoById Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EnemyId = EnemyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetFirstLocalGamePlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARGamePlayerController*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARGamePlayerController* URGameFunctionLibrary::GetFirstLocalGamePlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetFirstLocalGamePlayerController");

	Params::RGameFunctionLibrary_GetFirstLocalGamePlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetFloatingTextTypeFromDamageBitMask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERFloatingTextType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERFloatingTextType URGameFunctionLibrary::GetFloatingTextTypeFromDamageBitMask(int32 Mask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetFloatingTextTypeFromDamageBitMask");

	Params::RGameFunctionLibrary_GetFloatingTextTypeFromDamageBitMask Parms{};

	Parms.Mask = Mask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetFName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGameFunctionLibrary::GetFName(const class UObject* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetFName");

	Params::RGameFunctionLibrary_GetFName Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetFocusCause
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFocusEvent&               FocusEvent                                             (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag URGameFunctionLibrary::GetFocusCause(const struct FFocusEvent& FocusEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetFocusCause");

	Params::RGameFunctionLibrary_GetFocusCause Parms{};

	Parms.FocusEvent = std::move(FocusEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetFromSoftObjectPtr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObjectPtr                                          (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URGameFunctionLibrary::GetFromSoftObjectPtr(TSoftObjectPtr<class UObject> SoftObjectPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetFromSoftObjectPtr");

	Params::RGameFunctionLibrary_GetFromSoftObjectPtr Parms{};

	Parms.SoftObjectPtr = SoftObjectPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetFXFromSurfaceTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UDataTable*                 SurfaceFXTable                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPhysicalSurface                  SurfaceType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   RowFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSurfaceTypeFX                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSurfaceTypeFX URGameFunctionLibrary::GetFXFromSurfaceTable(const class UDataTable* SurfaceFXTable, const EPhysicalSurface SurfaceType, bool* RowFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetFXFromSurfaceTable");

	Params::RGameFunctionLibrary_GetFXFromSurfaceTable Parms{};

	Parms.SurfaceFXTable = SurfaceFXTable;
	Parms.SurfaceType = SurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RowFound != nullptr)
		*RowFound = Parms.RowFound;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetGlobalScriptComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* URGameFunctionLibrary::GetGlobalScriptComponent(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetGlobalScriptComponent");

	Params::RGameFunctionLibrary_GetGlobalScriptComponent Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetGScriptCategoryFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGameFunctionLibrary::GetGScriptCategoryFromActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetGScriptCategoryFromActor");

	Params::RGameFunctionLibrary_GetGScriptCategoryFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetGScriptComponentFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* URGameFunctionLibrary::GetGScriptComponentFromActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetGScriptComponentFromActor");

	Params::RGameFunctionLibrary_GetGScriptComponentFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetKeyboardLayoutInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRKeyboardLayoutRow              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRKeyboardLayoutRow URGameFunctionLibrary::GetKeyboardLayoutInfo(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetKeyboardLayoutInfo");

	Params::RGameFunctionLibrary_GetKeyboardLayoutInfo Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetKeywordInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    Keyword                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::GetKeywordInfo(const class FString& Keyword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetKeywordInfo");

	Params::RGameFunctionLibrary_GetKeywordInfo Parms{};

	Parms.Keyword = std::move(Keyword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetKeywordsInfoText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bAllowKeywordVariants                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::GetKeywordsInfoText(const class FString& InText, const bool bAllowKeywordVariants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetKeywordsInfoText");

	Params::RGameFunctionLibrary_GetKeywordsInfoText Parms{};

	Parms.InText = std::move(InText);
	Parms.bAllowKeywordVariants = bAllowKeywordVariants;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetLightSettingsDataTableRowByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLightSettingsRow                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLightSettingsRow URGameFunctionLibrary::GetLightSettingsDataTableRowByTag(class UDataTable* Table, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetLightSettingsDataTableRowByTag");

	Params::RGameFunctionLibrary_GetLightSettingsDataTableRowByTag Parms{};

	Parms.Table = Table;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutableFloatBaseValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetMutableFloatBaseValue(struct FRMutableFloat& MutableFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutableFloatBaseValue");

	Params::RGameFunctionLibrary_GetMutableFloatBaseValue Parms{};

	Parms.MutableFloat = std::move(MutableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutableFloatCurrentValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetMutableFloatCurrentValue(struct FRMutableFloat& MutableFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutableFloatCurrentValue");

	Params::RGameFunctionLibrary_GetMutableFloatCurrentValue Parms{};

	Parms.MutableFloat = std::move(MutableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutableFloatValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::GetMutableFloatValue(struct FRMutableFloat& MutableFloat, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutableFloatValue");

	Params::RGameFunctionLibrary_GetMutableFloatValue Parms{};

	Parms.MutableFloat = std::move(MutableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function RGame.RGameFunctionLibrary.GetMutableIntegerBaseValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetMutableIntegerBaseValue(struct FRMutableInteger& MutableInteger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutableIntegerBaseValue");

	Params::RGameFunctionLibrary_GetMutableIntegerBaseValue Parms{};

	Parms.MutableInteger = std::move(MutableInteger);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutableIntegerCurrentValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetMutableIntegerCurrentValue(struct FRMutableInteger& MutableInteger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutableIntegerCurrentValue");

	Params::RGameFunctionLibrary_GetMutableIntegerCurrentValue Parms{};

	Parms.MutableInteger = std::move(MutableInteger);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutatorValueByArrayIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Rank                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ArrayIndex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetMutatorValueByArrayIndex(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 Rank, const int32 ArrayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutatorValueByArrayIndex");

	Params::RGameFunctionLibrary_GetMutatorValueByArrayIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.Rank = Rank;
	Parms.ArrayIndex = ArrayIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutatorValueByVariableName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URMutatorPrimaryAsset*      RMutatorPrimaryAsset                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    VariableName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Rank                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetMutatorValueByVariableName(const class UObject* WorldContextObject, const class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const class FString& VariableName, const int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutatorValueByVariableName");

	Params::RGameFunctionLibrary_GetMutatorValueByVariableName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.VariableName = std::move(VariableName);
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutatorValueFromActorInfoInstigatorScriptComponent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGScriptActorInfo&         GScriptActorInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             MutatorDescriptionVariableArrayIndex                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetMutatorValueFromActorInfoInstigatorScriptComponent(const struct FGScriptActorInfo& GScriptActorInfo, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 MutatorDescriptionVariableArrayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutatorValueFromActorInfoInstigatorScriptComponent");

	Params::RGameFunctionLibrary_GetMutatorValueFromActorInfoInstigatorScriptComponent Parms{};

	Parms.GScriptActorInfo = std::move(GScriptActorInfo);
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.MutatorDescriptionVariableArrayIndex = MutatorDescriptionVariableArrayIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutatorVariables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorDescriptionVariables>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorDescriptionVariables> URGameFunctionLibrary::GetMutatorVariables(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutatorVariables");

	Params::RGameFunctionLibrary_GetMutatorVariables Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetMutatorVariablesByVariableName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMutatorDescriptionVariables     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMutatorDescriptionVariables URGameFunctionLibrary::GetMutatorVariablesByVariableName(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetMutatorVariablesByVariableName");

	Params::RGameFunctionLibrary_GetMutatorVariablesByVariableName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.VariableName = std::move(VariableName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetNameWithHighestValueFromMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<class FName, int32>&         Map                                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   DefaultHighestValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DefaultName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGameFunctionLibrary::GetNameWithHighestValueFromMap(const TMap<class FName, int32>& Map, int32 DefaultHighestValue, class FName DefaultName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetNameWithHighestValueFromMap");

	Params::RGameFunctionLibrary_GetNameWithHighestValueFromMap Parms{};

	Parms.Map = std::move(Map);
	Parms.DefaultHighestValue = DefaultHighestValue;
	Parms.DefaultName = DefaultName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetNormalizedRandom
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetNormalizedRandom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetNormalizedRandom");

	Params::RGameFunctionLibrary_GetNormalizedRandom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetNumCompletedOverworldNodesInCurrentArea
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetNumCompletedOverworldNodesInCurrentArea(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetNumCompletedOverworldNodesInCurrentArea");

	Params::RGameFunctionLibrary_GetNumCompletedOverworldNodesInCurrentArea Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetNumEquippedMutatorsInGodCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               RGScriptComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              GodCategoryTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetNumEquippedMutatorsInGodCategory(class URGScriptComponent* RGScriptComponent, const struct FGameplayTag& GodCategoryTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetNumEquippedMutatorsInGodCategory");

	Params::RGameFunctionLibrary_GetNumEquippedMutatorsInGodCategory Parms{};

	Parms.RGScriptComponent = RGScriptComponent;
	Parms.GodCategoryTag = std::move(GodCategoryTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetObjectFromClassReference
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URGameFunctionLibrary::GetObjectFromClassReference(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetObjectFromClassReference");

	Params::RGameFunctionLibrary_GetObjectFromClassReference Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetPlayerAbilityProcChance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Rank                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetPlayerAbilityProcChance(class APawn* PlayerPawn, const int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetPlayerAbilityProcChance");

	Params::RGameFunctionLibrary_GetPlayerAbilityProcChance Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetPlayerEquippedMutatorsSorted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URGameFunctionLibrary::GetPlayerEquippedMutatorsSorted(class ARPlayerPawn* RPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetPlayerEquippedMutatorsSorted");

	Params::RGameFunctionLibrary_GetPlayerEquippedMutatorsSorted Parms{};

	Parms.RPlayerPawn = RPlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetPostAdditivesValueByKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::GetPostAdditivesValueByKey(struct FRMutableFloat& MutableFloat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetPostAdditivesValueByKey");

	Params::RGameFunctionLibrary_GetPostAdditivesValueByKey Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetPostAdditivesValueByKeyInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetPostAdditivesValueByKeyInteger(struct FRMutableInteger& MutableInteger, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetPostAdditivesValueByKeyInteger");

	Params::RGameFunctionLibrary_GetPostAdditivesValueByKeyInteger Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetProjectVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::GetProjectVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetProjectVersion");

	Params::RGameFunctionLibrary_GetProjectVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetRandomAliveEnemyPawnInLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ARNPCPawnBase*>&     IgnoredEnemies                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bExcludeBosses                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDummys                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGlobalTargets                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGeometryCollections                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URGameFunctionLibrary::GetRandomAliveEnemyPawnInLevel(const class UObject* WorldContextObject, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetRandomAliveEnemyPawnInLevel");

	Params::RGameFunctionLibrary_GetRandomAliveEnemyPawnInLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IgnoredEnemies = std::move(IgnoredEnemies);
	Parms.bExcludeBosses = bExcludeBosses;
	Parms.bIncludeDummys = bIncludeDummys;
	Parms.bIncludeGlobalTargets = bIncludeGlobalTargets;
	Parms.bIncludeGeometryCollections = bIncludeGeometryCollections;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetRandomAlivePlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* URGameFunctionLibrary::GetRandomAlivePlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetRandomAlivePlayerController");

	Params::RGameFunctionLibrary_GetRandomAlivePlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetRandomIntWithWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<int32, float>&               IntegersAndWeightMap                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::GetRandomIntWithWeight(const TMap<int32, float>& IntegersAndWeightMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetRandomIntWithWeight");

	Params::RGameFunctionLibrary_GetRandomIntWithWeight Parms{};

	Parms.IntegersAndWeightMap = std::move(IntegersAndWeightMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetRandomPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* URGameFunctionLibrary::GetRandomPlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetRandomPlayerController");

	Params::RGameFunctionLibrary_GetRandomPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetRandomUpgradeableMutatorOptions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FRLootSelectionOption>&PrevLootOptions                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumOptions                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRLootSelectionOption>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRLootSelectionOption> URGameFunctionLibrary::GetRandomUpgradeableMutatorOptions(const TArray<struct FRLootSelectionOption>& PrevLootOptions, class APlayerController* PlayerController, const int32 NumOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetRandomUpgradeableMutatorOptions");

	Params::RGameFunctionLibrary_GetRandomUpgradeableMutatorOptions Parms{};

	Parms.PrevLootOptions = std::move(PrevLootOptions);
	Parms.PlayerController = PlayerController;
	Parms.NumOptions = NumOptions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetRenderMatrix
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPrimitiveComponent*        Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix URGameFunctionLibrary::GetRenderMatrix(const class UObject* WorldContextObject, const class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetRenderMatrix");

	Params::RGameFunctionLibrary_GetRenderMatrix Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetSafeNormalAndMagnitude
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             Tolerance                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  MagnitudeOut                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URGameFunctionLibrary::GetSafeNormalAndMagnitude(const float Tolerance, const struct FVector& Vector, float* MagnitudeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetSafeNormalAndMagnitude");

	Params::RGameFunctionLibrary_GetSafeNormalAndMagnitude Parms{};

	Parms.Tolerance = Tolerance;
	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MagnitudeOut != nullptr)
		*MagnitudeOut = Parms.MagnitudeOut;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetSFXFromSurfaceTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UDataTable*                 SurfaceSFXTable                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPhysicalSurface                  SurfaceType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   RowFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSurfaceTypeSFX                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSurfaceTypeSFX URGameFunctionLibrary::GetSFXFromSurfaceTable(const class UDataTable* SurfaceSFXTable, const EPhysicalSurface SurfaceType, bool* RowFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetSFXFromSurfaceTable");

	Params::RGameFunctionLibrary_GetSFXFromSurfaceTable Parms{};

	Parms.SurfaceSFXTable = SurfaceSFXTable;
	Parms.SurfaceType = SurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RowFound != nullptr)
		*RowFound = Parms.RowFound;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetVisibilityAsString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UWidget*                    Widget                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameFunctionLibrary::GetVisibilityAsString(const class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetVisibilityAsString");

	Params::RGameFunctionLibrary_GetVisibilityAsString Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetVoiceOverDataTableRowByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoiceOverTableRow               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoiceOverTableRow URGameFunctionLibrary::GetVoiceOverDataTableRowByTag(class UDataTable* Table, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetVoiceOverDataTableRowByTag");

	Params::RGameFunctionLibrary_GetVoiceOverDataTableRowByTag Parms{};

	Parms.Table = Table;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.GetVulnerableActorsFromActors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>&            ActorsToFilter                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGameFunctionLibrary::GetVulnerableActorsFromActors(const TArray<class AActor*>& ActorsToFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "GetVulnerableActorsFromActors");

	Params::RGameFunctionLibrary_GetVulnerableActorsFromActors Parms{};

	Parms.ActorsToFilter = std::move(ActorsToFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.HasPlayerEverCompletedCurrentArea
// (Final, Native, Static, Public)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::HasPlayerEverCompletedCurrentArea(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "HasPlayerEverCompletedCurrentArea");

	Params::RGameFunctionLibrary_HasPlayerEverCompletedCurrentArea Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.HueShift
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HueShiftPercentage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor URGameFunctionLibrary::HueShift(const struct FLinearColor& Color, float HueShiftPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "HueShift");

	Params::RGameFunctionLibrary_HueShift Parms{};

	Parms.Color = std::move(Color);
	Parms.HueShiftPercentage = HueShiftPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsActorAnEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsActorAnEnemy(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsActorAnEnemy");

	Params::RGameFunctionLibrary_IsActorAnEnemy Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsDirectDamage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsDirectDamage(int32 Mask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsDirectDamage");

	Params::RGameFunctionLibrary_IsDirectDamage Parms{};

	Parms.Mask = Mask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsHitResultWeakspotHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsHitResultWeakspotHit(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsHitResultWeakspotHit");

	Params::RGameFunctionLibrary_IsHitResultWeakspotHit Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsInLastOverworldArea
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsInLastOverworldArea(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsInLastOverworldArea");

	Params::RGameFunctionLibrary_IsInLastOverworldArea Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsInsideOrOnBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBox&                      Box                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsInsideOrOnBox(const struct FBox& Box, const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsInsideOrOnBox");

	Params::RGameFunctionLibrary_IsInsideOrOnBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsLocalControllerWithNullCheck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsLocalControllerWithNullCheck(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsLocalControllerWithNullCheck");

	Params::RGameFunctionLibrary_IsLocalControllerWithNullCheck Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsLocallyControlledPawnWithNullCheck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsLocallyControlledPawnWithNullCheck(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsLocallyControlledPawnWithNullCheck");

	Params::RGameFunctionLibrary_IsLocallyControlledPawnWithNullCheck Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsMoviePlayerRunning
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsMoviePlayerRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsMoviePlayerRunning");

	Params::RGameFunctionLibrary_IsMoviePlayerRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsMutatorVariablePercentValueInText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsMutatorVariablePercentValueInText(const class UObject* WorldContextObject, const class FString& VariableName, const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsMutatorVariablePercentValueInText");

	Params::RGameFunctionLibrary_IsMutatorVariablePercentValueInText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.VariableName = std::move(VariableName);
	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsObjectInSameRoomAsPlayer
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Object                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      LevelGenerationSettingsBox                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsObjectInSameRoomAsPlayer(const class AActor* Object, const class APlayerController* PlayerController, const struct FBox& LevelGenerationSettingsBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsObjectInSameRoomAsPlayer");

	Params::RGameFunctionLibrary_IsObjectInSameRoomAsPlayer Parms{};

	Parms.Object = Object;
	Parms.PlayerController = PlayerController;
	Parms.LevelGenerationSettingsBox = std::move(LevelGenerationSettingsBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsOverworldNodeCompleted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NodeID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsOverworldNodeCompleted(const class UObject* WorldContextObject, const int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsOverworldNodeCompleted");

	Params::RGameFunctionLibrary_IsOverworldNodeCompleted Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsSingleplayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsSingleplayer(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsSingleplayer");

	Params::RGameFunctionLibrary_IsSingleplayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsTargetWithinCone
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   ConeOrigin                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ConeDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsTargetWithinCone(const struct FVector& ConeOrigin, const struct FVector& ConeDirection, float ConeHalfAngle, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsTargetWithinCone");

	Params::RGameFunctionLibrary_IsTargetWithinCone Parms{};

	Parms.ConeOrigin = std::move(ConeOrigin);
	Parms.ConeDirection = std::move(ConeDirection);
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsTearingDownWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsTearingDownWorld(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsTearingDownWorld");

	Params::RGameFunctionLibrary_IsTearingDownWorld Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsVectorInsideFrustum
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMatrix&                   Sides                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Vector                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Radius                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsVectorInsideFrustum(const struct FMatrix& Sides, const struct FVector& Vector, const float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsVectorInsideFrustum");

	Params::RGameFunctionLibrary_IsVectorInsideFrustum Parms{};

	Parms.Sides = std::move(Sides);
	Parms.Vector = std::move(Vector);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.IsWithEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::IsWithEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "IsWithEditor");

	Params::RGameFunctionLibrary_IsWithEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.LineTraceAndSpawnDecal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LineTraceStart                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LineTraceEnd                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               DecalMaterial                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DecalSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 DecalMinMaxLifetime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DecalFadeoutTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   LineTraceHit                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UDecalComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* URGameFunctionLibrary::LineTraceAndSpawnDecal(const class UObject* WorldContextObject, const struct FVector& LineTraceStart, const struct FVector& LineTraceEnd, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector2D& DecalMinMaxLifetime, float DecalFadeoutTime, bool* LineTraceHit, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "LineTraceAndSpawnDecal");

	Params::RGameFunctionLibrary_LineTraceAndSpawnDecal Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LineTraceStart = std::move(LineTraceStart);
	Parms.LineTraceEnd = std::move(LineTraceEnd);
	Parms.DecalMaterial = DecalMaterial;
	Parms.DecalSize = std::move(DecalSize);
	Parms.DecalMinMaxLifetime = std::move(DecalMinMaxLifetime);
	Parms.DecalFadeoutTime = DecalFadeoutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LineTraceHit != nullptr)
		*LineTraceHit = Parms.LineTraceHit;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.MakeDamageSourceBitMask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::MakeDamageSourceBitMask(int32 Mask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "MakeDamageSourceBitMask");

	Params::RGameFunctionLibrary_MakeDamageSourceBitMask Parms{};

	Parms.Mask = Mask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.MutateFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::MutateFloat(struct FRMutableFloat& MutableFloat, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "MutateFloat");

	Params::RGameFunctionLibrary_MutateFloat Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.NegativeModuloFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   M                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameFunctionLibrary::NegativeModuloFloat(float X, float M)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "NegativeModuloFloat");

	Params::RGameFunctionLibrary_NegativeModuloFloat Parms{};

	Parms.X = X;
	Parms.M = M;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.NegativeModuloInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   M                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameFunctionLibrary::NegativeModuloInt(int32 X, int32 M)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "NegativeModuloInt");

	Params::RGameFunctionLibrary_NegativeModuloInt Parms{};

	Parms.X = X;
	Parms.M = M;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.OpenConsole
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::OpenConsole(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "OpenConsole");

	Params::RGameFunctionLibrary_OpenConsole Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.ParseMutatorDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bUseAdvancedDescription                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGameFunctionLibrary::ParseMutatorDescription(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 MutatorRank, const bool bUseAdvancedDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ParseMutatorDescription");

	Params::RGameFunctionLibrary_ParseMutatorDescription Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.MutatorRank = MutatorRank;
	Parms.bUseAdvancedDescription = bUseAdvancedDescription;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.PointWithPolarOffset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URGameFunctionLibrary::PointWithPolarOffset(const struct FVector& Origin, float Distance, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "PointWithPolarOffset");

	Params::RGameFunctionLibrary_PointWithPolarOffset Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Distance = Distance;
	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.RecreatePhysicsStateOnSkeletalMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RecreatePhysicsStateOnSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RecreatePhysicsStateOnSkeletalMesh");

	Params::RGameFunctionLibrary_RecreatePhysicsStateOnSkeletalMesh Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.RemoveMutableFloatCoefficient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RemoveMutableFloatCoefficient(struct FRMutableFloat& MutableFloat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RemoveMutableFloatCoefficient");

	Params::RGameFunctionLibrary_RemoveMutableFloatCoefficient Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.RemoveMutableFloatPostAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RemoveMutableFloatPostAdditive(struct FRMutableFloat& MutableFloat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RemoveMutableFloatPostAdditive");

	Params::RGameFunctionLibrary_RemoveMutableFloatPostAdditive Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.RemoveMutableFloatPreAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RemoveMutableFloatPreAdditive(struct FRMutableFloat& MutableFloat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RemoveMutableFloatPreAdditive");

	Params::RGameFunctionLibrary_RemoveMutableFloatPreAdditive Parms{};

	Parms.MutableFloat = std::move(MutableFloat);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.RemoveMutableIntegerCoefficient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RemoveMutableIntegerCoefficient(struct FRMutableInteger& MutableInteger, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RemoveMutableIntegerCoefficient");

	Params::RGameFunctionLibrary_RemoveMutableIntegerCoefficient Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.RemoveMutableIntegerPostAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RemoveMutableIntegerPostAdditive(struct FRMutableInteger& MutableInteger, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RemoveMutableIntegerPostAdditive");

	Params::RGameFunctionLibrary_RemoveMutableIntegerPostAdditive Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.RemoveMutableIntegerPreAdditive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::RemoveMutableIntegerPreAdditive(struct FRMutableInteger& MutableInteger, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RemoveMutableIntegerPreAdditive");

	Params::RGameFunctionLibrary_RemoveMutableIntegerPreAdditive Parms{};

	Parms.MutableInteger = std::move(MutableInteger);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.ResetMeshToDefaultMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::ResetMeshToDefaultMaterials(class UPrimitiveComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ResetMeshToDefaultMaterials");

	Params::RGameFunctionLibrary_ResetMeshToDefaultMaterials Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.ResetMutableFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableFloat&                  MutableFloat                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::ResetMutableFloat(struct FRMutableFloat& MutableFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ResetMutableFloat");

	Params::RGameFunctionLibrary_ResetMutableFloat Parms{};

	Parms.MutableFloat = std::move(MutableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableFloat = std::move(Parms.MutableFloat);
}


// Function RGame.RGameFunctionLibrary.ResetMutableInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRMutableInteger&                MutableInteger                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::ResetMutableInteger(struct FRMutableInteger& MutableInteger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ResetMutableInteger");

	Params::RGameFunctionLibrary_ResetMutableInteger Parms{};

	Parms.MutableInteger = std::move(MutableInteger);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MutableInteger = std::move(Parms.MutableInteger);
}


// Function RGame.RGameFunctionLibrary.RInterpToShortestPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRotator&                  Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConstantSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseShortestPath                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URGameFunctionLibrary::RInterpToShortestPath(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed, bool bConstantSpeed, bool bUseShortestPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "RInterpToShortestPath");

	Params::RGameFunctionLibrary_RInterpToShortestPath Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;
	Parms.bConstantSpeed = bConstantSpeed;
	Parms.bUseShortestPath = bUseShortestPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.SetActorIsEditorOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsEditorOnly                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SetActorIsEditorOnly(class AActor* Actor, bool bIsEditorOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetActorIsEditorOnly");

	Params::RGameFunctionLibrary_SetActorIsEditorOnly Parms{};

	Parms.Actor = Actor;
	Parms.bIsEditorOnly = bIsEditorOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SetAudioComponentSettingsMultiplayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AController*                OptionalController                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class APawn*                      OptionalPlayerPawn                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsPlayerSound                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* URGameFunctionLibrary::SetAudioComponentSettingsMultiplayer(const class UObject* WorldContextObject, class UAudioComponent* AudioComponent, const class AController* OptionalController, const class APawn* OptionalPlayerPawn, const bool bIsPlayerSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetAudioComponentSettingsMultiplayer");

	Params::RGameFunctionLibrary_SetAudioComponentSettingsMultiplayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AudioComponent = AudioComponent;
	Parms.OptionalController = OptionalController;
	Parms.OptionalPlayerPawn = OptionalPlayerPawn;
	Parms.bIsPlayerSound = bIsPlayerSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.SetCosmeticMaterialParameters
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UMeshComponent*>&    MeshComponents                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UMaterialInstance*                NewMI                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SetCosmeticMaterialParameters(const class UObject* WorldContextObject, const TArray<class UMeshComponent*>& MeshComponents, class UMaterialInstance* NewMI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetCosmeticMaterialParameters");

	Params::RGameFunctionLibrary_SetCosmeticMaterialParameters Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MeshComponents = std::move(MeshComponents);
	Parms.NewMI = NewMI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SetLightPropertiesByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LightActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SetLightPropertiesByTag(const struct FGameplayTag& Tag, class AActor* LightActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetLightPropertiesByTag");

	Params::RGameFunctionLibrary_SetLightPropertiesByTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.LightActor = LightActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SetOneOffTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle URGameFunctionLibrary::SetOneOffTimer(TDelegate<void()> Delegate, float Time, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetOneOffTimer");

	Params::RGameFunctionLibrary_SetOneOffTimer Parms{};

	Parms.Delegate = Delegate;
	Parms.Time = Time;
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.SetSoundWaveSettingsFromOtherSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundWave*                       SoundWave                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USoundWave*                 TemplateSound                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SetSoundWaveSettingsFromOtherSound(class USoundWave* SoundWave, const class USoundWave* TemplateSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetSoundWaveSettingsFromOtherSound");

	Params::RGameFunctionLibrary_SetSoundWaveSettingsFromOtherSound Parms{};

	Parms.SoundWave = SoundWave;
	Parms.TemplateSound = TemplateSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SetSoundWaveSettingsFromTemplate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundWave*                       NewMetaSoundWave                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USoundCue*                  TemplateSoundCue                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SetSoundWaveSettingsFromTemplate(class USoundWave* NewMetaSoundWave, const class USoundCue* TemplateSoundCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetSoundWaveSettingsFromTemplate");

	Params::RGameFunctionLibrary_SetSoundWaveSettingsFromTemplate Parms{};

	Parms.NewMetaSoundWave = NewMetaSoundWave;
	Parms.TemplateSoundCue = TemplateSoundCue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SetStencilMask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    renderDepth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   stencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SetStencilMask(class UPrimitiveComponent* Component, bool renderDepth, int32 stencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SetStencilMask");

	Params::RGameFunctionLibrary_SetStencilMask Parms{};

	Parms.Component = Component;
	Parms.renderDepth = renderDepth;
	Parms.stencilValue = stencilValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.ShouldExcludeComponentFromRenderMatrix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ARGamePlayerController*     PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPrimitiveComponent*        Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::ShouldExcludeComponentFromRenderMatrix(const class ARGamePlayerController* PlayerController, const class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ShouldExcludeComponentFromRenderMatrix");

	Params::RGameFunctionLibrary_ShouldExcludeComponentFromRenderMatrix Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.ShouldShowExtendedInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ShowExtendedInfoTag                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameFunctionLibrary::ShouldShowExtendedInfo(class APawn* Pawn, const struct FGameplayTag& ShowExtendedInfoTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "ShouldShowExtendedInfo");

	Params::RGameFunctionLibrary_ShouldShowExtendedInfo Parms{};

	Parms.Pawn = Pawn;
	Parms.ShowExtendedInfoTag = std::move(ShowExtendedInfoTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.SortAbilitiesByIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class URGAbilityCharacterMutatorScript*>&Abilities                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SortAbilitiesByIndex(TArray<class URGAbilityCharacterMutatorScript*>& Abilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SortAbilitiesByIndex");

	Params::RGameFunctionLibrary_SortAbilitiesByIndex Parms{};

	Parms.Abilities = std::move(Abilities);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Abilities = std::move(Parms.Abilities);
}


// Function RGame.RGameFunctionLibrary.SortActorsByDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>&                  Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SortActorsByDistance(TArray<class AActor*>& Actors, const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SortActorsByDistance");

	Params::RGameFunctionLibrary_SortActorsByDistance Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);
}


// Function RGame.RGameFunctionLibrary.SortAndReapplyActivatableAbilities
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         PlayerGScriptComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SortAndReapplyActivatableAbilities(class URPlayerGScriptComponent* PlayerGScriptComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SortAndReapplyActivatableAbilities");

	Params::RGameFunctionLibrary_SortAndReapplyActivatableAbilities Parms{};

	Parms.PlayerGScriptComponent = PlayerGScriptComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SortHitsByDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FHitResult>&              Hits                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SortHitsByDistance(TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SortHitsByDistance");

	Params::RGameFunctionLibrary_SortHitsByDistance Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Hits = std::move(Parms.Hits);
}


// Function RGame.RGameFunctionLibrary.SpawnDecalFromHitResult
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UMaterialInterface*               DecalMaterial                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DecalSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 DecalMinMaxLifetime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DecalFadeoutTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* URGameFunctionLibrary::SpawnDecalFromHitResult(const class UObject* WorldContextObject, const struct FHitResult& HitResult, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector2D& DecalMinMaxLifetime, float DecalFadeoutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SpawnDecalFromHitResult");

	Params::RGameFunctionLibrary_SpawnDecalFromHitResult Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.HitResult = std::move(HitResult);
	Parms.DecalMaterial = DecalMaterial;
	Parms.DecalSize = std::move(DecalSize);
	Parms.DecalMinMaxLifetime = std::move(DecalMinMaxLifetime);
	Parms.DecalFadeoutTime = DecalFadeoutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.SpawnGold
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FractionValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SpawnGold(const class UObject* WorldContextObject, int32 TotalValue, const struct FVector& Location, int32 FractionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SpawnGold");

	Params::RGameFunctionLibrary_SpawnGold Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TotalValue = TotalValue;
	Parms.Location = std::move(Location);
	Parms.FractionValue = FractionValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SpawnHitEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class AController*                Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 SurfaceFXTableOverride                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 SurfaceSFXTableOverride                                (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SpawnHitEffect(const class UObject* WorldContextObject, const struct FHitResult& HitResult, const class AController* Controller, const class UDataTable* SurfaceFXTableOverride, const class UDataTable* SurfaceSFXTableOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SpawnHitEffect");

	Params::RGameFunctionLibrary_SpawnHitEffect Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.HitResult = std::move(HitResult);
	Parms.Controller = Controller;
	Parms.SurfaceFXTableOverride = SurfaceFXTableOverride;
	Parms.SurfaceSFXTableOverride = SurfaceSFXTableOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SpawnHitEffectsOnPawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VFXTag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    WasCritical                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::SpawnHitEffectsOnPawn(const class UObject* WorldContextObject, class FName VFXTag, const struct FHitResult& HitResult, bool WasCritical)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SpawnHitEffectsOnPawn");

	Params::RGameFunctionLibrary_SpawnHitEffectsOnPawn Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.VFXTag = VFXTag;
	Parms.HitResult = std::move(HitResult);
	Parms.WasCritical = WasCritical;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.SpawnSystemAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class URNiagaraComponent>   RNiagaraComponentClass                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENCPoolMethod                           PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreCullCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* URGameFunctionLibrary::SpawnSystemAttached(TSubclassOf<class URNiagaraComponent> RNiagaraComponentClass, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, ENCPoolMethod PoolingMethod, bool bAutoDestroy, bool bAutoActivate, bool bPreCullCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "SpawnSystemAttached");

	Params::RGameFunctionLibrary_SpawnSystemAttached Parms{};

	Parms.RNiagaraComponentClass = RNiagaraComponentClass;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.LocationType = LocationType;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.bAutoActivate = bAutoActivate;
	Parms.bPreCullCheck = bPreCullCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameFunctionLibrary.StartLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bPlayUntilStopped                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::StartLoadingScreen(bool bPlayUntilStopped, float PlayTime, bool bForceStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "StartLoadingScreen");

	Params::RGameFunctionLibrary_StartLoadingScreen Parms{};

	Parms.bPlayUntilStopped = bPlayUntilStopped;
	Parms.PlayTime = PlayTime;
	Parms.bForceStart = bForceStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.StopLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable)

void URGameFunctionLibrary::StopLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "StopLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.UnlockAllAbilities
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::UnlockAllAbilities(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "UnlockAllAbilities");

	Params::RGameFunctionLibrary_UnlockAllAbilities Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.UnlockAllLockedContent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::UnlockAllLockedContent(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "UnlockAllLockedContent");

	Params::RGameFunctionLibrary_UnlockAllLockedContent Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.UnlockAllMutators
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::UnlockAllMutators(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "UnlockAllMutators");

	Params::RGameFunctionLibrary_UnlockAllMutators Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.UnlockAllWeaponMods
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::UnlockAllWeaponMods(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "UnlockAllWeaponMods");

	Params::RGameFunctionLibrary_UnlockAllWeaponMods Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameFunctionLibrary.WriteRunStatsToTextFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRPlayerStats&             Stats                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             RunIndex                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PlayerName                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameFunctionLibrary::WriteRunStatsToTextFile(const struct FRPlayerStats& Stats, const int32 RunIndex, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameFunctionLibrary", "WriteRunStatsToTextFile");

	Params::RGameFunctionLibrary_WriteRunStatsToTextFile Parms{};

	Parms.Stats = std::move(Stats);
	Parms.RunIndex = RunIndex;
	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.GetChatLogWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URChatLog*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URChatLog* URGameHud::GetChatLogWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "GetChatLogWidget");

	Params::RGameHud_GetChatLogWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameHud.GetWaitingForPlayersWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* URGameHud::GetWaitingForPlayersWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "GetWaitingForPlayersWidget");

	Params::RGameHud_GetWaitingForPlayersWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameHud.IsWaitingForPlayersWidgetVisible
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameHud::IsWaitingForPlayersWidgetVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "IsWaitingForPlayersWidgetVisible");

	Params::RGameHud_IsWaitingForPlayersWidgetVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameHud.ReinitBossHealthWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBossPawnBase*                   BossPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::ReinitBossHealthWidget(class ARBossPawnBase* BossPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "ReinitBossHealthWidget");

	Params::RGameHud_ReinitBossHealthWidget Parms{};

	Parms.BossPawn = BossPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetBarrierGaugeBlocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGameHud::SetBarrierGaugeBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetBarrierGaugeBlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetBarrierGaugeMaxReached
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGameHud::SetBarrierGaugeMaxReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetBarrierGaugeMaxReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetBarrierGaugeReset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGameHud::SetBarrierGaugeReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetBarrierGaugeReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetBarrierGaugeVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        BarrierGaugeVisibility                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetBarrierGaugeVisibility(ESlateVisibility BarrierGaugeVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetBarrierGaugeVisibility");

	Params::RGameHud_SetBarrierGaugeVisibility Parms{};

	Parms.BarrierGaugeVisibility = BarrierGaugeVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetChargeUpBarVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        ChargeUpBarVilibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetChargeUpBarVisibility(ESlateVisibility ChargeUpBarVilibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetChargeUpBarVisibility");

	Params::RGameHud_SetChargeUpBarVisibility Parms{};

	Parms.ChargeUpBarVilibility = ChargeUpBarVilibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetCrosshairCooldownIndicatorVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        CrosshairIndicatorVisibility                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetCrosshairCooldownIndicatorVisibility(ESlateVisibility CrosshairIndicatorVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetCrosshairCooldownIndicatorVisibility");

	Params::RGameHud_SetCrosshairCooldownIndicatorVisibility Parms{};

	Parms.CrosshairIndicatorVisibility = CrosshairIndicatorVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetOverheatBarVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        OverheatBarVilibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetOverheatBarVisibility(ESlateVisibility OverheatBarVilibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetOverheatBarVisibility");

	Params::RGameHud_SetOverheatBarVisibility Parms{};

	Parms.OverheatBarVilibility = OverheatBarVilibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetPreventBossHealthbarRemovalOnDeath
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldPrevent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetPreventBossHealthbarRemovalOnDeath(bool bShouldPrevent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetPreventBossHealthbarRemovalOnDeath");

	Params::RGameHud_SetPreventBossHealthbarRemovalOnDeath Parms{};

	Parms.bShouldPrevent = bShouldPrevent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetReviveAvailabilityVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetReviveAvailabilityVisibility(ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetReviveAvailabilityVisibility");

	Params::RGameHud_SetReviveAvailabilityVisibility Parms{};

	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetSpiritGaugeMaxReached
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGameHud::SetSpiritGaugeMaxReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetSpiritGaugeMaxReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetSpiritGaugeReset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGameHud::SetSpiritGaugeReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetSpiritGaugeReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetSpiritGaugeVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        SpiritGaugeVisibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetSpiritGaugeVisibility(ESlateVisibility SpiritGaugeVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetSpiritGaugeVisibility");

	Params::RGameHud_SetSpiritGaugeVisibility Parms{};

	Parms.SpiritGaugeVisibility = SpiritGaugeVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.SetTimerBarVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::SetTimerBarVisibility(ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "SetTimerBarVisibility");

	Params::RGameHud_SetTimerBarVisibility Parms{};

	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.UpdateBarrierGaugePercent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::UpdateBarrierGaugePercent(float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "UpdateBarrierGaugePercent");

	Params::RGameHud_UpdateBarrierGaugePercent Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.UpdateBossHealthWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBossPawnBase*                   BossPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        BossHealthVisibility                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::UpdateBossHealthWidget(class ARBossPawnBase* BossPawn, ESlateVisibility BossHealthVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "UpdateBossHealthWidget");

	Params::RGameHud_UpdateBossHealthWidget Parms{};

	Parms.BossPawn = BossPawn;
	Parms.BossHealthVisibility = BossHealthVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.UpdateChargeUpProgressBarPercent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::UpdateChargeUpProgressBarPercent(float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "UpdateChargeUpProgressBarPercent");

	Params::RGameHud_UpdateChargeUpProgressBarPercent Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.UpdateReviveAvailability
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isConsumed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::UpdateReviveAvailability(bool isConsumed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "UpdateReviveAvailability");

	Params::RGameHud_UpdateReviveAvailability Parms{};

	Parms.isConsumed = isConsumed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.UpdateSpiritGaugePercent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::UpdateSpiritGaugePercent(float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "UpdateSpiritGaugePercent");

	Params::RGameHud_UpdateSpiritGaugePercent Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameHud.UpdateTimerBarPercentage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   PercentageLeft                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameHud::UpdateTimerBarPercentage(float PercentageLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameHud", "UpdateTimerBarPercentage");

	Params::RGameHud_UpdateTimerBarPercentage Parms{};

	Parms.PercentageLeft = PercentageLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameInstance.GetEOSStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            StatNames                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void URGameInstance::GetEOSStats(const TArray<class FString>& StatNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameInstance", "GetEOSStats");

	Params::RGameInstance_GetEOSStats Parms{};

	Parms.StatNames = std::move(StatNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameInstance.SetJoinablePresence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bJoinable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameInstance::SetJoinablePresence(bool bJoinable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameInstance", "SetJoinablePresence");

	Params::RGameInstance_SetJoinablePresence Parms{};

	Parms.bJoinable = bJoinable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameInstance.UpdateEOSStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameInstance::UpdateEOSStats(const class FString& StatName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameInstance", "UpdateEOSStats");

	Params::RGameInstance_UpdateEOSStats Parms{};

	Parms.StatName = std::move(StatName);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.BroadcastOnPlayerDroppedMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARPlayerController*               RPlayerController                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Rank                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerController::BroadcastOnPlayerDroppedMutator(class ARPlayerController* RPlayerController, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "BroadcastOnPlayerDroppedMutator");

	Params::RPlayerController_BroadcastOnPlayerDroppedMutator Parms{};

	Parms.RPlayerController = RPlayerController;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.BroadcastOnPlayerPickedUpItem
// (Final, Native, Public, BlueprintCallable)

void ARPlayerController::BroadcastOnPlayerPickedUpItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "BroadcastOnPlayerPickedUpItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.GamepadIconSchemeUpdated
// (Final, Native, Private)
// Parameters:
// EGamepadIconScheme                      NewIconScheme                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerController::GamepadIconSchemeUpdated(EGamepadIconScheme NewIconScheme)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "GamepadIconSchemeUpdated");

	Params::RPlayerController_GamepadIconSchemeUpdated Parms{};

	Parms.NewIconScheme = NewIconScheme;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.GetHUDWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URCommonHUDWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URCommonHUDWidget* ARPlayerController::GetHUDWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "GetHUDWidget");

	Params::RPlayerController_GetHUDWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerController.SetClientControlRotation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Rotator                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARPlayerController::SetClientControlRotation(const struct FRotator& Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "SetClientControlRotation");

	Params::RPlayerController_SetClientControlRotation Parms{};

	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.UpdatePostProcessGamma
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerController::UpdatePostProcessGamma(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "UpdatePostProcessGamma");

	Params::RPlayerController_UpdatePostProcessGamma Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.UpdatePostProcessSettings
// (Final, Native, Private)

void ARPlayerController::UpdatePostProcessSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "UpdatePostProcessSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerController.BroadcastOnPlayerSkillTreeUpdated
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const int32                             NumPointsAssigned                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumMaxPoints                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerController::BroadcastOnPlayerSkillTreeUpdated(const int32 NumPointsAssigned, const int32 NumMaxPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerController", "BroadcastOnPlayerSkillTreeUpdated");

	Params::RPlayerController_BroadcastOnPlayerSkillTreeUpdated Parms{};

	Parms.NumPointsAssigned = NumPointsAssigned;
	Parms.NumMaxPoints = NumMaxPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.AddCrosshair
// (Final, Native, Public)
// Parameters:
// class ARWeapon*                         Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::AddCrosshair(class ARWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "AddCrosshair");

	Params::RGamePlayerController_AddCrosshair Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.AddHealthBonus_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         GScriptComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URCharacterMutatorPrimaryAsset*HealthBonusMutatorPA                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::AddHealthBonus_Server(class URPlayerGScriptComponent* GScriptComponent, const class URCharacterMutatorPrimaryAsset* HealthBonusMutatorPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "AddHealthBonus_Server");

	Params::RGamePlayerController_AddHealthBonus_Server Parms{};

	Parms.GScriptComponent = GScriptComponent;
	Parms.HealthBonusMutatorPA = HealthBonusMutatorPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ApplyCorruptedNodeDifficultyEffect_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARGamePlayerController::ApplyCorruptedNodeDifficultyEffect_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ApplyCorruptedNodeDifficultyEffect_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ApplyPlayerCosmetics
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerCosmeticOption&     CosmeticOptionData                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             EmoteSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URWeaponCosmeticPrimaryAsset*RWeaponCosmeticPA                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ApplyPlayerCosmetics(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const int32 EmoteSlot, const class URWeaponCosmeticPrimaryAsset* RWeaponCosmeticPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ApplyPlayerCosmetics");

	Params::RGamePlayerController_ApplyPlayerCosmetics Parms{};

	Parms.RPlayerPawn = RPlayerPawn;
	Parms.CosmeticOptionData = std::move(CosmeticOptionData);
	Parms.EmoteSlot = EmoteSlot;
	Parms.RWeaponCosmeticPA = RWeaponCosmeticPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ApplyPlayerCosmetics_Server
// (Net, Native, Event, Public, NetServer)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerCosmeticOption&     CosmeticOptionData                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    RWeaponCosmeticPath                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ApplyPlayerCosmetics_Server(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const class FString& RWeaponCosmeticPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ApplyPlayerCosmetics_Server");

	Params::RGamePlayerController_ApplyPlayerCosmetics_Server Parms{};

	Parms.RPlayerPawn = RPlayerPawn;
	Parms.CosmeticOptionData = std::move(CosmeticOptionData);
	Parms.RWeaponCosmeticPath = std::move(RWeaponCosmeticPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.AttachWeaponToController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URWeaponPrimaryAsset*             WeaponClass                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class URWeaponModPrimaryAsset*>&WeaponMods                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const bool                              bSaveToLoadout                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::AttachWeaponToController(class URWeaponPrimaryAsset* WeaponClass, const TArray<class URWeaponModPrimaryAsset*>& WeaponMods, const bool bSaveToLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "AttachWeaponToController");

	Params::RGamePlayerController_AttachWeaponToController Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.WeaponMods = std::move(WeaponMods);
	Parms.bSaveToLoadout = bSaveToLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnCloseLogbook
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnCloseLogbook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnCloseLogbook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnEnemyExecutionActivate
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnEnemyExecutionActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnEnemyExecutionActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnExitWorkbench
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnExitWorkbench()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnExitWorkbench");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnFinishedWaitingForPlayers
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnFinishedWaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnFinishedWaitingForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnHealUsed
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnHealUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnHealUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnHeldWidgetRemoved
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnHeldWidgetRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnHeldWidgetRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnHeldWidgetShown
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnHeldWidgetShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnHeldWidgetShown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnOpenLogbook
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnOpenLogbook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnOpenLogbook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnPlayerChoseGodCategoryMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ChosenGodCategoryName                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            DiscardedGodCategoryNames                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    ChosenGodMutatorName                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            DiscardedGodMutatorNames                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARGamePlayerController::BroadcastOnPlayerChoseGodCategoryMutator(const class FString& ChosenGodCategoryName, const TArray<class FString>& DiscardedGodCategoryNames, const class FString& ChosenGodMutatorName, const TArray<class FString>& DiscardedGodMutatorNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnPlayerChoseGodCategoryMutator");

	Params::RGamePlayerController_BroadcastOnPlayerChoseGodCategoryMutator Parms{};

	Parms.ChosenGodCategoryName = std::move(ChosenGodCategoryName);
	Parms.DiscardedGodCategoryNames = std::move(DiscardedGodCategoryNames);
	Parms.ChosenGodMutatorName = std::move(ChosenGodMutatorName);
	Parms.DiscardedGodMutatorNames = std::move(DiscardedGodMutatorNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnPlayerPurchaseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    PurchasedItemName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PurchasedItemCost                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            NotPurchasedItems                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARGamePlayerController::BroadcastOnPlayerPurchaseItem(const class FString& PurchasedItemName, int32 PurchasedItemCost, const TArray<class AActor*>& NotPurchasedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnPlayerPurchaseItem");

	Params::RGamePlayerController_BroadcastOnPlayerPurchaseItem Parms{};

	Parms.PurchasedItemName = std::move(PurchasedItemName);
	Parms.PurchasedItemCost = PurchasedItemCost;
	Parms.NotPurchasedItems = std::move(NotPurchasedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnStopWaitingForPlayers
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::BroadcastOnStopWaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnStopWaitingForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ClientPushFloatingTextAtLocation
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERFloatingTextType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ClientPushFloatingTextAtLocation(const struct FVector& Location, ERFloatingTextType Type, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ClientPushFloatingTextAtLocation");

	Params::RGamePlayerController_ClientPushFloatingTextAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Type = Type;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ClientQueueFloatingTextAtLocation
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERFloatingTextType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ClientQueueFloatingTextAtLocation(const struct FVector& Location, ERFloatingTextType Type, int32 Value, bool bSkipDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ClientQueueFloatingTextAtLocation");

	Params::RGamePlayerController_ClientQueueFloatingTextAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Type = Type;
	Parms.Value = Value;
	Parms.bSkipDelay = bSkipDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.EquipStartLoadout
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const bool                              bIsRespawning                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::EquipStartLoadout(const bool bIsRespawning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "EquipStartLoadout");

	Params::RGamePlayerController_EquipStartLoadout Parms{};

	Parms.bIsRespawning = bIsRespawning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.FinishedMidRunLoading_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ARGamePlayerController::FinishedMidRunLoading_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "FinishedMidRunLoading_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.FinishWaitingForPlayer_Client
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ARGamePlayerController::FinishWaitingForPlayer_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "FinishWaitingForPlayer_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.HealActor_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class URHealthComponent*                HealthComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _Instigator                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorToHeal                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealType                               HealType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::HealActor_Server(class URHealthComponent* HealthComp, class AActor* _Instigator, class AActor* ActorToHeal, EHealType HealType, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "HealActor_Server");

	Params::RGamePlayerController_HealActor_Server Parms{};

	Parms.HealthComp = HealthComp;
	Parms._Instigator = _Instigator;
	Parms.ActorToHeal = ActorToHeal;
	Parms.HealType = HealType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.HeartbeatPing_Server
// (Net, Native, Event, Public, NetServer)

void ARGamePlayerController::HeartbeatPing_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "HeartbeatPing_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.HeartbeatPong_Client
// (Net, Native, Event, Public, NetClient)

void ARGamePlayerController::HeartbeatPong_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "HeartbeatPong_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.K2_OnPawnHealthDepleted
// (Event, Public, BlueprintEvent)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::K2_OnPawnHealthDepleted(class URHealthComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "K2_OnPawnHealthDepleted");

	Params::RGamePlayerController_K2_OnPawnHealthDepleted Parms{};

	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGamePlayerController.K2_PushGameOverScreen
// (Event, Public, BlueprintEvent)

void ARGamePlayerController::K2_PushGameOverScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "K2_PushGameOverScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.KeyUsed_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           ActorUsedOn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::KeyUsed_Server(class AActor* ActorUsedOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "KeyUsed_Server");

	Params::RGamePlayerController_KeyUsed_Server Parms{};

	Parms.ActorUsedOn = ActorUsedOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.KillPawn
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::KillPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "KillPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnCastFinished_Client
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARGamePlayerController::OnCastFinished_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnCastFinished_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnCastInterrupted_Client
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARGamePlayerController::OnCastInterrupted_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnCastInterrupted_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnCastStarted_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   CastTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentCastTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnCastStarted_Client(float CastTime, float CurrentCastTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnCastStarted_Client");

	Params::RGamePlayerController_OnCastStarted_Client Parms{};

	Parms.CastTime = CastTime;
	Parms.CurrentCastTime = CurrentCastTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnCommonInputTypeChanged
// (Final, Native, Private)
// Parameters:
// ECommonInputType                        InputType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnCommonInputTypeChanged(ECommonInputType InputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnCommonInputTypeChanged");

	Params::RGamePlayerController_OnCommonInputTypeChanged Parms{};

	Parms.InputType = InputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnCrosshairAlignmentChanged
// (Final, Native, Private)
// Parameters:
// ECrosshairAlignmentOption               NewOption                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnCrosshairAlignmentChanged(ECrosshairAlignmentOption NewOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnCrosshairAlignmentChanged");

	Params::RGamePlayerController_OnCrosshairAlignmentChanged Parms{};

	Parms.NewOption = NewOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnGameEnded_Client
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                                    GameWon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnGameEnded_Client(bool GameWon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnGameEnded_Client");

	Params::RGamePlayerController_OnGameEnded_Client Parms{};

	Parms.GameWon = GameWon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnGameEnded_Server
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    GameWon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnGameEnded_Server(bool GameWon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnGameEnded_Server");

	Params::RGamePlayerController_OnGameEnded_Server Parms{};

	Parms.GameWon = GameWon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnInteract_Server
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ARGamePlayerController::OnInteract_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnInteract_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnPawnHealthDepleted
// (Final, Native, Private)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnPawnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnPawnHealthDepleted");

	Params::RGamePlayerController_OnPawnHealthDepleted Parms{};

	Parms.Component = Component;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnPlayerJoined
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     JoiningPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnPlayerJoined(class APlayerState* JoiningPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnPlayerJoined");

	Params::RGamePlayerController_OnPlayerJoined Parms{};

	Parms.JoiningPlayerState = JoiningPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnPlayerRespawned_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ARGamePlayerController::OnPlayerRespawned_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnPlayerRespawned_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnPushDeathScreen
// (Event, Public, BlueprintEvent)

void ARGamePlayerController::OnPushDeathScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnPushDeathScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.OnRespawnPlayer
// (Final, Native, Private)

void ARGamePlayerController::OnRespawnPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnRespawnPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.OnTabKeyDown
// (Event, Public, BlueprintEvent)

void ARGamePlayerController::OnTabKeyDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnTabKeyDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.OnTabKeyUp
// (Event, Public, BlueprintEvent)

void ARGamePlayerController::OnTabKeyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnTabKeyUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.OnUserInputDeviceChange
// (Final, Native, Private)
// Parameters:
// EInputDeviceConnectionState             NewConnectionState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlatformUserId&           PlatformUserId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputDeviceId&            InputDeviceId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::OnUserInputDeviceChange(EInputDeviceConnectionState NewConnectionState, const struct FPlatformUserId& PlatformUserId, const struct FInputDeviceId& InputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "OnUserInputDeviceChange");

	Params::RGamePlayerController_OnUserInputDeviceChange Parms{};

	Parms.NewConnectionState = NewConnectionState;
	Parms.PlatformUserId = std::move(PlatformUserId);
	Parms.InputDeviceId = std::move(InputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.PlayEmoteSong
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class USoundBase*                 EmoteSong                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::PlayEmoteSong(const class USoundBase* EmoteSong)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "PlayEmoteSong");

	Params::RGamePlayerController_PlayEmoteSong Parms{};

	Parms.EmoteSong = EmoteSong;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.PlayEmoteSong_Server
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// const class USoundBase*                 EmoteSong                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::PlayEmoteSong_Server(const class USoundBase* EmoteSong)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "PlayEmoteSong_Server");

	Params::RGamePlayerController_PlayEmoteSong_Server Parms{};

	Parms.EmoteSong = EmoteSong;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.PlayEmoteSongImplementation
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class USoundBase*                 EmoteSong                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::PlayEmoteSongImplementation(const class USoundBase* EmoteSong)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "PlayEmoteSongImplementation");

	Params::RGamePlayerController_PlayEmoteSongImplementation Parms{};

	Parms.EmoteSong = EmoteSong;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGamePlayerController.PlayerJoined_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARGameState*                      RGameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     InPlayerState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Message                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARGamePlayerController::PlayerJoined_Server(class ARGameState* RGameState, class APlayerState* InPlayerState, const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "PlayerJoined_Server");

	Params::RGamePlayerController_PlayerJoined_Server Parms{};

	Parms.RGameState = RGameState;
	Parms.InPlayerState = InPlayerState;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ProceedFromDeathScreen
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::ProceedFromDeathScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ProceedFromDeathScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ProceedFromDeathScreen_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARGamePlayerController::ProceedFromDeathScreen_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ProceedFromDeathScreen_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ProceedFromEndOfRunScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bRunFailed                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ProceedFromEndOfRunScreen(const bool bRunFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ProceedFromEndOfRunScreen");

	Params::RGamePlayerController_ProceedFromEndOfRunScreen Parms{};

	Parms.bRunFailed = bRunFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ProceedFromEndOfRunScreen_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const bool                              bRunFailed                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ProceedFromEndOfRunScreen_Server(const bool bRunFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ProceedFromEndOfRunScreen_Server");

	Params::RGamePlayerController_ProceedFromEndOfRunScreen_Server Parms{};

	Parms.bRunFailed = bRunFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.PushDeathScreen_Client
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARGamePlayerController::PushDeathScreen_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "PushDeathScreen_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ReconnectDone_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARGamePlayerController::ReconnectDone_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ReconnectDone_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ReconnectPlayerStateSync_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<struct FRPlayerStateSync>& SyncData                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARGamePlayerController::ReconnectPlayerStateSync_Client(const TArray<struct FRPlayerStateSync>& SyncData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ReconnectPlayerStateSync_Client");

	Params::RGamePlayerController_ReconnectPlayerStateSync_Client Parms{};

	Parms.SyncData = std::move(SyncData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.RemoveDownedScreen
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::RemoveDownedScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RemoveDownedScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.RestartCosmeticsTempTimer
// (Event, Public, BlueprintEvent)

void ARGamePlayerController::RestartCosmeticsTempTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RestartCosmeticsTempTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.RevivePawn
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::RevivePawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RevivePawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.RunPauseBehavior
// (Event, Protected, BlueprintEvent)

void ARGamePlayerController::RunPauseBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RunPauseBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.RunRoutedObjectBehaviour_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class UObject*                          RoutedObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::RunRoutedObjectBehaviour_Server(class UObject* RoutedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RunRoutedObjectBehaviour_Server");

	Params::RGamePlayerController_RunRoutedObjectBehaviour_Server Parms{};

	Parms.RoutedObject = RoutedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.RunRoutedObjectBehaviourByName_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class UObject*                          RoutedObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BehaviourName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::RunRoutedObjectBehaviourByName_Server(class UObject* RoutedObject, class FName BehaviourName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RunRoutedObjectBehaviourByName_Server");

	Params::RGamePlayerController_RunRoutedObjectBehaviourByName_Server Parms{};

	Parms.RoutedObject = RoutedObject;
	Parms.BehaviourName = BehaviourName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.RunRoutedObjectBehaviourWithData_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class UObject*                          RoutedObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRoutedObjectData&         RoutedData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARGamePlayerController::RunRoutedObjectBehaviourWithData_Server(class UObject* RoutedObject, const struct FRoutedObjectData& RoutedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "RunRoutedObjectBehaviourWithData_Server");

	Params::RGamePlayerController_RunRoutedObjectBehaviourWithData_Server Parms{};

	Parms.RoutedObject = RoutedObject;
	Parms.RoutedData = std::move(RoutedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SelectOverworldNode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             PlayerId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SelectedNodeId                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SelectOverworldNode(const int32 PlayerId, const int32 SelectedNodeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SelectOverworldNode");

	Params::RGamePlayerController_SelectOverworldNode Parms{};

	Parms.PlayerId = PlayerId;
	Parms.SelectedNodeId = SelectedNodeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SelectOverworldNode_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const int32                             PlayerId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SelectedNodeId                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SelectOverworldNode_Server(const int32 PlayerId, const int32 SelectedNodeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SelectOverworldNode_Server");

	Params::RGamePlayerController_SelectOverworldNode_Server Parms{};

	Parms.PlayerId = PlayerId;
	Parms.SelectedNodeId = SelectedNodeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ServerAttachWeaponToController
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URWeaponPrimaryAsset*             WeaponClass                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class URWeaponModPrimaryAsset*>&WeaponMods                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARGamePlayerController::ServerAttachWeaponToController(class URWeaponPrimaryAsset* WeaponClass, const TArray<class URWeaponModPrimaryAsset*>& WeaponMods)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ServerAttachWeaponToController");

	Params::RGamePlayerController_ServerAttachWeaponToController Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.WeaponMods = std::move(WeaponMods);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ServerDestroyCharm
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARPickupableCharm*                CharmToDestroy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ServerDestroyCharm(class ARPickupableCharm* CharmToDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ServerDestroyCharm");

	Params::RGamePlayerController_ServerDestroyCharm Parms{};

	Parms.CharmToDestroy = CharmToDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ServerSendChatMessage
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FRChatLogMessage&          MessageToSend                                          (Parm, NativeAccessSpecifierPublic)

void ARGamePlayerController::ServerSendChatMessage(const struct FRChatLogMessage& MessageToSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ServerSendChatMessage");

	Params::RGamePlayerController_ServerSendChatMessage Parms{};

	Parms.MessageToSend = std::move(MessageToSend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ServerSetCrosshairDirectionAndOffset
// (Net, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   CrosshairDirection                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalOffset                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::ServerSetCrosshairDirectionAndOffset(const struct FVector& CrosshairDirection, const struct FVector& LocalOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ServerSetCrosshairDirectionAndOffset");

	Params::RGamePlayerController_ServerSetCrosshairDirectionAndOffset Parms{};

	Parms.CrosshairDirection = std::move(CrosshairDirection);
	Parms.LocalOffset = std::move(LocalOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetChestState_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARLootableContainer*              Chest                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EChestState                             ChestState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetChestState_Server(class ARLootableContainer* Chest, EChestState ChestState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetChestState_Server");

	Params::RGamePlayerController_SetChestState_Server Parms{};

	Parms.Chest = Chest;
	Parms.ChestState = ChestState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetCurrentHealth_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URHealthComponent*                HealthComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetCurrentHealth_Server(class URHealthComponent* HealthComp, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetCurrentHealth_Server");

	Params::RGamePlayerController_SetCurrentHealth_Server Parms{};

	Parms.HealthComp = HealthComp;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetDamageEventReward_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class URGObjectiveScript*               ObjectiveScript                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessful                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetDamageEventReward_Server(class URGObjectiveScript* ObjectiveScript, bool bSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetDamageEventReward_Server");

	Params::RGamePlayerController_SetDamageEventReward_Server Parms{};

	Parms.ObjectiveScript = ObjectiveScript;
	Parms.bSuccessful = bSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetEquippedLoadout_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FRLoadout&                 Loadout                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetEquippedLoadout_Server(const struct FRLoadout& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetEquippedLoadout_Server");

	Params::RGamePlayerController_SetEquippedLoadout_Server Parms{};

	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetHealAltarSelection_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARHealAltar*                      HealAltar                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsumed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetHealAltarSelection_Server(class ARHealAltar* HealAltar, bool bConsumed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetHealAltarSelection_Server");

	Params::RGamePlayerController_SetHealAltarSelection_Server Parms{};

	Parms.HealAltar = HealAltar;
	Parms.bConsumed = bConsumed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetLootOptionOnLootableContainer_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARLootableContainer*              LootableContainer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRLootSelectionOption>&LootOption                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bHasChosenLoot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetLootOptionOnLootableContainer_Server(class ARLootableContainer* LootableContainer, const TArray<struct FRLootSelectionOption>& LootOption, bool bHasChosenLoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetLootOptionOnLootableContainer_Server");

	Params::RGamePlayerController_SetLootOptionOnLootableContainer_Server Parms{};

	Parms.LootableContainer = LootableContainer;
	Parms.LootOption = std::move(LootOption);
	Parms.bHasChosenLoot = bHasChosenLoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetMerchantPlinthOption_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARMerchantPlinth*                 MerchantPlinth                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRLootSelectionOption>&MutatorLootSelection                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPlinthRewardType                       RewardType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            PrimaryAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorRewardCategoryDataAsset* GodCategory                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlinth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetMerchantPlinthOption_Server(class ARMerchantPlinth* MerchantPlinth, const TArray<struct FRLootSelectionOption>& MutatorLootSelection, EPlinthRewardType RewardType, class URMutatorPrimaryAsset* PrimaryAsset, bool bLooted, class URMutatorRewardCategoryDataAsset* GodCategory, bool bClearPlinth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetMerchantPlinthOption_Server");

	Params::RGamePlayerController_SetMerchantPlinthOption_Server Parms{};

	Parms.MerchantPlinth = MerchantPlinth;
	Parms.MutatorLootSelection = std::move(MutatorLootSelection);
	Parms.RewardType = RewardType;
	Parms.PrimaryAsset = PrimaryAsset;
	Parms.bLooted = bLooted;
	Parms.GodCategory = GodCategory;
	Parms.bClearPlinth = bClearPlinth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetNodeSpawnPointCharmReward_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARNodeRewardSpawnPoint*           NodeRewardSpawnPoint                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            CharmPrimaryAsset                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCharmPickedUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetNodeSpawnPointCharmReward_Server(class ARNodeRewardSpawnPoint* NodeRewardSpawnPoint, class URMutatorPrimaryAsset* CharmPrimaryAsset, bool bCharmPickedUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetNodeSpawnPointCharmReward_Server");

	Params::RGamePlayerController_SetNodeSpawnPointCharmReward_Server Parms{};

	Parms.NodeRewardSpawnPoint = NodeRewardSpawnPoint;
	Parms.CharmPrimaryAsset = CharmPrimaryAsset;
	Parms.bCharmPickedUp = bCharmPickedUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetPlayerCorruptedNodeChoiceVote_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class APlayerState*                     InPlayerState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URNodeChoicePrimaryAsset*         VotedNodeChoicePA                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URNodeChoicePrimaryAsset*         VotedNodeChoiceRewardPA                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetPlayerCorruptedNodeChoiceVote_Server(class APlayerState* InPlayerState, class URNodeChoicePrimaryAsset* VotedNodeChoicePA, class URNodeChoicePrimaryAsset* VotedNodeChoiceRewardPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetPlayerCorruptedNodeChoiceVote_Server");

	Params::RGamePlayerController_SetPlayerCorruptedNodeChoiceVote_Server Parms{};

	Parms.InPlayerState = InPlayerState;
	Parms.VotedNodeChoicePA = VotedNodeChoicePA;
	Parms.VotedNodeChoiceRewardPA = VotedNodeChoiceRewardPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetPlayerEmote
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EmoteTag                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetPlayerEmote(const int32 Slot, const struct FGameplayTag& EmoteTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetPlayerEmote");

	Params::RGamePlayerController_SetPlayerEmote Parms{};

	Parms.Slot = Slot;
	Parms.EmoteTag = std::move(EmoteTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetSacrificeAltarInteractionCost_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARLootableContainer*              SacrificeAltar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InteractionCost                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetSacrificeAltarInteractionCost_Server(class ARLootableContainer* SacrificeAltar, int32 InteractionCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetSacrificeAltarInteractionCost_Server");

	Params::RGamePlayerController_SetSacrificeAltarInteractionCost_Server Parms{};

	Parms.SacrificeAltar = SacrificeAltar;
	Parms.InteractionCost = InteractionCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SetWishingWellInteractionCost_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARLootableContainer*              WishingWell                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InteractionCost                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UsesLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SetWishingWellInteractionCost_Server(class ARLootableContainer* WishingWell, int32 InteractionCost, int32 UsesLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SetWishingWellInteractionCost_Server");

	Params::RGamePlayerController_SetWishingWellInteractionCost_Server Parms{};

	Parms.WishingWell = WishingWell;
	Parms.InteractionCost = InteractionCost;
	Parms.UsesLeft = UsesLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.ShowDownedScreen
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::ShowDownedScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "ShowDownedScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SpawnAndPossessSpectatorPawn
// (Final, Native, Public, BlueprintCallable)

void ARGamePlayerController::SpawnAndPossessSpectatorPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SpawnAndPossessSpectatorPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.StartWaitingForPlayer_Client
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARGamePlayerController::StartWaitingForPlayer_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "StartWaitingForPlayer_Client");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.StartWaitingForPlayers
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARGamePlayerController::StartWaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "StartWaitingForPlayers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.StartWaitingForPlayersLobby
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARGamePlayerController::StartWaitingForPlayersLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "StartWaitingForPlayersLobby");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.StopWaitingForMe
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARGamePlayerController::StopWaitingForMe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "StopWaitingForMe");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGamePlayerController.SwapHudVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShowSpectateHud                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SwapHudVisibility(bool bShowSpectateHud)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SwapHudVisibility");

	Params::RGamePlayerController_SwapHudVisibility Parms{};

	Parms.bShowSpectateHud = bShowSpectateHud;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SwapPickupableCharm
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARPickupableMutator*              PickupableMutator                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::SwapPickupableCharm(class URMutatorPrimaryAsset* MutatorAsset, int32 MutatorRank, class ARPickupableMutator* PickupableMutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SwapPickupableCharm");

	Params::RGamePlayerController_SwapPickupableCharm Parms{};

	Parms.MutatorAsset = MutatorAsset;
	Parms.MutatorRank = MutatorRank;
	Parms.PickupableMutator = PickupableMutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SwapPickupableMutator
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARPickupableMutator*              PickupableMutator                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMutatorContainer&         AttachedMutators                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void ARGamePlayerController::SwapPickupableMutator(class URMutatorPrimaryAsset* MutatorAsset, int32 MutatorRank, class ARPickupableMutator* PickupableMutator, const struct FMutatorContainer& AttachedMutators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SwapPickupableMutator");

	Params::RGamePlayerController_SwapPickupableMutator Parms{};

	Parms.MutatorAsset = MutatorAsset;
	Parms.MutatorRank = MutatorRank;
	Parms.PickupableMutator = PickupableMutator;
	Parms.AttachedMutators = std::move(AttachedMutators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.SwapStatCharmMutator
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URGCharacterStatCharmScript*      StatCharmMutator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARPickupableItem*                 OldStatCharmActor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERewardRarity                           NewRarity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FStatCharmStat>&    NewMutatorStats                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARGamePlayerController::SwapStatCharmMutator(class URGCharacterStatCharmScript* StatCharmMutator, class ARPickupableItem* OldStatCharmActor, const struct FTransform& SpawnTransform, ERewardRarity NewRarity, const TArray<struct FStatCharmStat>& NewMutatorStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "SwapStatCharmMutator");

	Params::RGamePlayerController_SwapStatCharmMutator Parms{};

	Parms.StatCharmMutator = StatCharmMutator;
	Parms.OldStatCharmActor = OldStatCharmActor;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.NewRarity = NewRarity;
	Parms.NewMutatorStats = std::move(NewMutatorStats);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.TriggerHit_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGWeaponScript*                  WeaponScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ProjectileId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCriticalOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallHitEvents                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamageClientPrediction                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        NonWeaponContext                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeakspotOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   HitSequenceFlags                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::TriggerHit_Server(const struct FHitResult& Hit, float BaseDamage, int32 DamageSources, class URGWeaponScript* WeaponScript, uint32 ProjectileId, bool bIsCriticalOverride, bool bCallHitEvents, bool bDamageClientPrediction, class URGScript* NonWeaponContext, bool bWeakspotOverride, uint8 HitSequenceFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "TriggerHit_Server");

	Params::RGamePlayerController_TriggerHit_Server Parms{};

	Parms.Hit = std::move(Hit);
	Parms.BaseDamage = BaseDamage;
	Parms.DamageSources = DamageSources;
	Parms.WeaponScript = WeaponScript;
	Parms.ProjectileId = ProjectileId;
	Parms.bIsCriticalOverride = bIsCriticalOverride;
	Parms.bCallHitEvents = bCallHitEvents;
	Parms.bDamageClientPrediction = bDamageClientPrediction;
	Parms.NonWeaponContext = NonWeaponContext;
	Parms.bWeakspotOverride = bWeakspotOverride;
	Parms.HitSequenceFlags = HitSequenceFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnVoteToProceed
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const int32                             NumVotes                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumPlayers                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             TimeLeft                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::BroadcastOnVoteToProceed(const int32 NumVotes, const int32 NumPlayers, const int32 TimeLeft) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnVoteToProceed");

	Params::RGamePlayerController_BroadcastOnVoteToProceed Parms{};

	Parms.NumVotes = NumVotes;
	Parms.NumPlayers = NumPlayers;
	Parms.TimeLeft = TimeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnVoteToProceed_Client
// (Net, NetReliable, Native, Event, Public, NetClient, Const)
// Parameters:
// const int32                             NumVotes                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumPlayers                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             TimeLeft                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::BroadcastOnVoteToProceed_Client(const int32 NumVotes, const int32 NumPlayers, const int32 TimeLeft) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnVoteToProceed_Client");

	Params::RGamePlayerController_BroadcastOnVoteToProceed_Client Parms{};

	Parms.NumVotes = NumVotes;
	Parms.NumPlayers = NumPlayers;
	Parms.TimeLeft = TimeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnVoteToProceedTick_Client
// (Net, NetReliable, Native, Event, Public, NetClient, Const)
// Parameters:
// const int32                             TimeLeft                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::BroadcastOnVoteToProceedTick_Client(const int32 TimeLeft) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnVoteToProceedTick_Client");

	Params::RGamePlayerController_BroadcastOnVoteToProceedTick_Client Parms{};

	Parms.TimeLeft = TimeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.BroadcastOnVoteToProceedTimerTick
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const int32                             TimeLeft                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGamePlayerController::BroadcastOnVoteToProceedTimerTick(const int32 TimeLeft) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "BroadcastOnVoteToProceedTimerTick");

	Params::RGamePlayerController_BroadcastOnVoteToProceedTimerTick Parms{};

	Parms.TimeLeft = TimeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGamePlayerController.GetControlledPlayerPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ARGamePlayerController::GetControlledPlayerPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetControlledPlayerPawn");

	Params::RGamePlayerController_GetControlledPlayerPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetCurrentlyEquippedOveriddingWeaponScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGWeaponScript*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGWeaponScript* ARGamePlayerController::GetCurrentlyEquippedOveriddingWeaponScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetCurrentlyEquippedOveriddingWeaponScript");

	Params::RGamePlayerController_GetCurrentlyEquippedOveriddingWeaponScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetCurrentPlayerEmotes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<int32, struct FGameplayTag>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, struct FGameplayTag> ARGamePlayerController::GetCurrentPlayerEmotes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetCurrentPlayerEmotes");

	Params::RGamePlayerController_GetCurrentPlayerEmotes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetGameHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGameHud*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGameHud* ARGamePlayerController::GetGameHud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetGameHud");

	Params::RGamePlayerController_GetGameHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetGameplayTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer ARGamePlayerController::GetGameplayTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetGameplayTags");

	Params::RGamePlayerController_GetGameplayTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetNumMaxMutatorCategories
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARGamePlayerController::GetNumMaxMutatorCategories() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetNumMaxMutatorCategories");

	Params::RGamePlayerController_GetNumMaxMutatorCategories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetSpectateHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URSpectateHud*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URSpectateHud* ARGamePlayerController::GetSpectateHud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetSpectateHud");

	Params::RGamePlayerController_GetSpectateHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGamePlayerController.GetWeaponOverridingWeaponScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARWeapon*                         Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGWeaponScript*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGWeaponScript* ARGamePlayerController::GetWeaponOverridingWeaponScript(class ARWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGamePlayerController", "GetWeaponOverridingWeaponScript");

	Params::RGamePlayerController_GetWeaponOverridingWeaponScript Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameplayTagAssetInterface.AddGameplayTag
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRGameplayTagAssetInterface::AddGameplayTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RGameplayTagAssetInterface", "AddGameplayTag");

	Params::RGameplayTagAssetInterface_AddGameplayTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameplayTagRelationshipMapping.HasTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     ActiveTags                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameplayTagRelationshipMapping::HasTag(const struct FGameplayTag& Tag, const struct FGameplayTagContainer& ActiveTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameplayTagRelationshipMapping", "HasTag");

	Params::RGameplayTagRelationshipMapping_HasTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ActiveTags = std::move(ActiveTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetRGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGameUserSettings*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGameUserSettings* URGameUserSettings::GetRGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGameUserSettings", "GetRGameUserSettings");

	Params::RGameUserSettings_GetRGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.BroadcastOnCultureChanged
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::BroadcastOnCultureChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "BroadcastOnCultureChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.BroadcastOnGraphicsSettingsChanged
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::BroadcastOnGraphicsSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "BroadcastOnGraphicsSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.GetAimAssistStrength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetAimAssistStrength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetAimAssistStrength");

	Params::RGameUserSettings_GetAimAssistStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetHasShownTelemetryConsentScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetHasShownTelemetryConsentScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetHasShownTelemetryConsentScreen");

	Params::RGameUserSettings_GetHasShownTelemetryConsentScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.OpenComboBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UComboBoxString*                  ComboBox                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::OpenComboBox(class UComboBoxString* ComboBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "OpenComboBox");

	Params::RGameUserSettings_OpenComboBox Parms{};

	Parms.ComboBox = ComboBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.ResetDisplaySettings
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::ResetDisplaySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "ResetDisplaySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.ResetGameplaySettings
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::ResetGameplaySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "ResetGameplaySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.ResetGraphicsSettings
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::ResetGraphicsSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "ResetGraphicsSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.ResetSettings
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::ResetSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "ResetSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.ResetSoundSettings
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::ResetSoundSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "ResetSoundSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetAAMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetAAMethod(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetAAMethod");

	Params::RGameUserSettings_SetAAMethod Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetAimAssistStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             NewStrength                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetAimAssistStrength(const float NewStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetAimAssistStrength");

	Params::RGameUserSettings_SetAimAssistStrength Parms{};

	Parms.NewStrength = NewStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetAimSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetAimSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetAimSensitivity");

	Params::RGameUserSettings_SetAimSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetAllowTelemetryDataCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewAllow                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetAllowTelemetryDataCollection(const bool bNewAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetAllowTelemetryDataCollection");

	Params::RGameUserSettings_SetAllowTelemetryDataCollection Parms{};

	Parms.bNewAllow = bNewAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetAlternateMusicList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetAlternateMusicList(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetAlternateMusicList");

	Params::RGameUserSettings_SetAlternateMusicList Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetBackgroundMaxFramerate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetBackgroundMaxFramerate(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetBackgroundMaxFramerate");

	Params::RGameUserSettings_SetBackgroundMaxFramerate Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetBinauralAudio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetBinauralAudio(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetBinauralAudio");

	Params::RGameUserSettings_SetBinauralAudio Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetControllerScopedXSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetControllerScopedXSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetControllerScopedXSensitivity");

	Params::RGameUserSettings_SetControllerScopedXSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetControllerScopedYSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetControllerScopedYSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetControllerScopedYSensitivity");

	Params::RGameUserSettings_SetControllerScopedYSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetControllerVibrationEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetControllerVibrationEnabled(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetControllerVibrationEnabled");

	Params::RGameUserSettings_SetControllerVibrationEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetControllerXSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetControllerXSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetControllerXSensitivity");

	Params::RGameUserSettings_SetControllerXSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetControllerYSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetControllerYSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetControllerYSensitivity");

	Params::RGameUserSettings_SetControllerYSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetCrosshairAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrosshairAlignmentOption               NewCrosshairAlignmentOption                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetCrosshairAlignment(ECrosshairAlignmentOption NewCrosshairAlignmentOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetCrosshairAlignment");

	Params::RGameUserSettings_SetCrosshairAlignment Parms{};

	Parms.NewCrosshairAlignmentOption = NewCrosshairAlignmentOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetDepthOfFieldEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetOnlyConfigValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetDepthOfFieldEnabled(bool bNewValue, bool bSetOnlyConfigValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetDepthOfFieldEnabled");

	Params::RGameUserSettings_SetDepthOfFieldEnabled Parms{};

	Parms.bNewValue = bNewValue;
	Parms.bSetOnlyConfigValue = bSetOnlyConfigValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetDisableLanguageFiltering
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewDisabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetDisableLanguageFiltering(bool bNewDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetDisableLanguageFiltering");

	Params::RGameUserSettings_SetDisableLanguageFiltering Parms{};

	Parms.bNewDisabled = bNewDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetFieldOfView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetFieldOfView(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetFieldOfView");

	Params::RGameUserSettings_SetFieldOfView Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetForegroundMaxFramerate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetForegroundMaxFramerate(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetForegroundMaxFramerate");

	Params::RGameUserSettings_SetForegroundMaxFramerate Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetGameLanguage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    NewValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetGameLanguage(const class FString& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetGameLanguage");

	Params::RGameUserSettings_SetGameLanguage Parms{};

	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetGamepadIconScheme
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGamepadIconScheme                      NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetGamepadIconScheme(EGamepadIconScheme NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetGamepadIconScheme");

	Params::RGameUserSettings_SetGamepadIconScheme Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetGamma
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetGamma(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetGamma");

	Params::RGameUserSettings_SetGamma Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetGlobalIlluminationMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetGlobalIlluminationMethod(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetGlobalIlluminationMethod");

	Params::RGameUserSettings_SetGlobalIlluminationMethod Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetHasShownTelemetryConsentScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewHasShown                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetHasShownTelemetryConsentScreen(const bool bNewHasShown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetHasShownTelemetryConsentScreen");

	Params::RGameUserSettings_SetHasShownTelemetryConsentScreen Parms{};

	Parms.bNewHasShown = bNewHasShown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetHoldToScope
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetHoldToScope(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetHoldToScope");

	Params::RGameUserSettings_SetHoldToScope Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetInvertedXAxisAiming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetInvertedXAxisAiming(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetInvertedXAxisAiming");

	Params::RGameUserSettings_SetInvertedXAxisAiming Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetInvertedYAxisAiming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetInvertedYAxisAiming(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetInvertedYAxisAiming");

	Params::RGameUserSettings_SetInvertedYAxisAiming Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetLockForegroundMaxFramerate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetLockForegroundMaxFramerate(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetLockForegroundMaxFramerate");

	Params::RGameUserSettings_SetLockForegroundMaxFramerate Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetMasterVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetMasterVolume(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetMasterVolume");

	Params::RGameUserSettings_SetMasterVolume Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetMotionBlurEnabled(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetMotionBlurEnabled");

	Params::RGameUserSettings_SetMotionBlurEnabled Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetMusicVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetMusicVolume(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetMusicVolume");

	Params::RGameUserSettings_SetMusicVolume Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetMuteWhenUnfocused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetMuteWhenUnfocused(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetMuteWhenUnfocused");

	Params::RGameUserSettings_SetMuteWhenUnfocused Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetPerformCameraShakes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetPerformCameraShakes(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetPerformCameraShakes");

	Params::RGameUserSettings_SetPerformCameraShakes Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetScopedAimSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetScopedAimSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetScopedAimSensitivity");

	Params::RGameUserSettings_SetScopedAimSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetScreenPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetScreenPercentage(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetScreenPercentage");

	Params::RGameUserSettings_SetScreenPercentage Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetSFXVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetSFXVolume(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetSFXVolume");

	Params::RGameUserSettings_SetSFXVolume Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowCrosshair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowCrosshair(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowCrosshair");

	Params::RGameUserSettings_SetShowCrosshair Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowDamageNumbers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageNumbersOption                    NewDamageNumbersOption                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowDamageNumbers(EDamageNumbersOption NewDamageNumbersOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowDamageNumbers");

	Params::RGameUserSettings_SetShowDamageNumbers Parms{};

	Parms.NewDamageNumbersOption = NewDamageNumbersOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowDashIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowDashIndicator(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowDashIndicator");

	Params::RGameUserSettings_SetShowDashIndicator Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowEnemyHealthNumbers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowEnemyHealthNumbers(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowEnemyHealthNumbers");

	Params::RGameUserSettings_SetShowEnemyHealthNumbers Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowHealthBars
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowHealthBars(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowHealthBars");

	Params::RGameUserSettings_SetShowHealthBars Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowPlayerHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowPlayerHUD(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowPlayerHUD");

	Params::RGameUserSettings_SetShowPlayerHUD Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowPlayerNames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowPlayerNames(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowPlayerNames");

	Params::RGameUserSettings_SetShowPlayerNames Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetShowSubtitles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetShowSubtitles(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetShowSubtitles");

	Params::RGameUserSettings_SetShowSubtitles Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.SetVoiceVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::SetVoiceVolume(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "SetVoiceVolume");

	Params::RGameUserSettings_SetVoiceVolume Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.UpdateScalabilityQualityLevels
// (Final, Native, Public, BlueprintCallable)

void URGameUserSettings::UpdateScalabilityQualityLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "UpdateScalabilityQualityLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.UpdateScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FIntPoint&                 NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGameUserSettings::UpdateScreenResolution(const struct FIntPoint& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "UpdateScreenResolution");

	Params::RGameUserSettings_UpdateScreenResolution Parms{};

	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGameUserSettings.GetAAType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameUserSettings::GetAAType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetAAType");

	Params::RGameUserSettings_GetAAType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetAimSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetAimSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetAimSensitivity");

	Params::RGameUserSettings_GetAimSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetAllowTelemetryDataCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetAllowTelemetryDataCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetAllowTelemetryDataCollection");

	Params::RGameUserSettings_GetAllowTelemetryDataCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetBackgroundMaxFramerate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetBackgroundMaxFramerate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetBackgroundMaxFramerate");

	Params::RGameUserSettings_GetBackgroundMaxFramerate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetBinauralAudio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetBinauralAudio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetBinauralAudio");

	Params::RGameUserSettings_GetBinauralAudio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetControllerScopedXSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetControllerScopedXSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetControllerScopedXSensitivity");

	Params::RGameUserSettings_GetControllerScopedXSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetControllerScopedYSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetControllerScopedYSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetControllerScopedYSensitivity");

	Params::RGameUserSettings_GetControllerScopedYSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetControllerXSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetControllerXSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetControllerXSensitivity");

	Params::RGameUserSettings_GetControllerXSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetControllerYSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetControllerYSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetControllerYSensitivity");

	Params::RGameUserSettings_GetControllerYSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetCrosshairAlignmentOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrosshairAlignmentOption               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrosshairAlignmentOption URGameUserSettings::GetCrosshairAlignmentOption() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetCrosshairAlignmentOption");

	Params::RGameUserSettings_GetCrosshairAlignmentOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetDepthOfFieldEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetDepthOfFieldEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetDepthOfFieldEnabled");

	Params::RGameUserSettings_GetDepthOfFieldEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetDisableLanguageFiltering
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetDisableLanguageFiltering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetDisableLanguageFiltering");

	Params::RGameUserSettings_GetDisableLanguageFiltering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetFieldOfView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetFieldOfView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetFieldOfView");

	Params::RGameUserSettings_GetFieldOfView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetForegroundMaxFramerate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetForegroundMaxFramerate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetForegroundMaxFramerate");

	Params::RGameUserSettings_GetForegroundMaxFramerate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetGameLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URGameUserSettings::GetGameLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetGameLanguage");

	Params::RGameUserSettings_GetGameLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetGamepadIconScheme
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGamepadIconScheme                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGamepadIconScheme URGameUserSettings::GetGamepadIconScheme() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetGamepadIconScheme");

	Params::RGameUserSettings_GetGamepadIconScheme Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetGamma
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetGamma() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetGamma");

	Params::RGameUserSettings_GetGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetGIType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGameUserSettings::GetGIType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetGIType");

	Params::RGameUserSettings_GetGIType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetHoldToScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetHoldToScope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetHoldToScope");

	Params::RGameUserSettings_GetHoldToScope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetInvertXAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetInvertXAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetInvertXAxis");

	Params::RGameUserSettings_GetInvertXAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetInvertYAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetInvertYAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetInvertYAxis");

	Params::RGameUserSettings_GetInvertYAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetIsControllerVibrationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetIsControllerVibrationEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetIsControllerVibrationEnabled");

	Params::RGameUserSettings_GetIsControllerVibrationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetLockForegroundMaxFramerate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetLockForegroundMaxFramerate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetLockForegroundMaxFramerate");

	Params::RGameUserSettings_GetLockForegroundMaxFramerate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetMasterAudioVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetMasterAudioVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetMasterAudioVolume");

	Params::RGameUserSettings_GetMasterAudioVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetMotionBlurEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetMotionBlurEnabled");

	Params::RGameUserSettings_GetMotionBlurEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetMusicAudioVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetMusicAudioVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetMusicAudioVolume");

	Params::RGameUserSettings_GetMusicAudioVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetMuteWhenUnfocused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetMuteWhenUnfocused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetMuteWhenUnfocused");

	Params::RGameUserSettings_GetMuteWhenUnfocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetPerformCameraShakes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetPerformCameraShakes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetPerformCameraShakes");

	Params::RGameUserSettings_GetPerformCameraShakes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetScopedAimSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetScopedAimSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetScopedAimSensitivity");

	Params::RGameUserSettings_GetScopedAimSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetScreenPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetScreenPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetScreenPercentage");

	Params::RGameUserSettings_GetScreenPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetSFXAudioVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetSFXAudioVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetSFXAudioVolume");

	Params::RGameUserSettings_GetSFXAudioVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowCrosshair
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowCrosshair() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowCrosshair");

	Params::RGameUserSettings_GetShowCrosshair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowDamageNumbers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageNumbersOption                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDamageNumbersOption URGameUserSettings::GetShowDamageNumbers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowDamageNumbers");

	Params::RGameUserSettings_GetShowDamageNumbers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowDashIndicator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowDashIndicator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowDashIndicator");

	Params::RGameUserSettings_GetShowDashIndicator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowEnemyHealthNumbers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowEnemyHealthNumbers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowEnemyHealthNumbers");

	Params::RGameUserSettings_GetShowEnemyHealthNumbers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowHealthBars
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowHealthBars() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowHealthBars");

	Params::RGameUserSettings_GetShowHealthBars Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowPlayerHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowPlayerHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowPlayerHUD");

	Params::RGameUserSettings_GetShowPlayerHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowPlayerNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowPlayerNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowPlayerNames");

	Params::RGameUserSettings_GetShowPlayerNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetShowSubtitles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetShowSubtitles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetShowSubtitles");

	Params::RGameUserSettings_GetShowSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetUseAlternateMusicList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGameUserSettings::GetUseAlternateMusicList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetUseAlternateMusicList");

	Params::RGameUserSettings_GetUseAlternateMusicList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGameUserSettings.GetVoiceAudioVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGameUserSettings::GetVoiceAudioVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGameUserSettings", "GetVoiceAudioVolume");

	Params::RGameUserSettings_GetVoiceAudioVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAreaEffectScript.GetActorsInArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGAreaEffectScript::GetActorsInArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "GetActorsInArea");

	Params::RGAreaEffectScript_GetActorsInArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAreaEffectScript.GetAliveNPCPawnsInArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARNPCPawnBase*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARNPCPawnBase*> URGAreaEffectScript::GetAliveNPCPawnsInArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "GetAliveNPCPawnsInArea");

	Params::RGAreaEffectScript_GetAliveNPCPawnsInArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAreaEffectScript.GetAlivePawnsInArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARPawnBase*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARPawnBase*> URGAreaEffectScript::GetAlivePawnsInArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "GetAlivePawnsInArea");

	Params::RGAreaEffectScript_GetAlivePawnsInArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGAreaEffectScript.K2_OnEnter
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAreaEffectScript::K2_OnEnter(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "K2_OnEnter");

	Params::RGAreaEffectScript_K2_OnEnter Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGAreaEffectScript.K2_OnExit
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAreaEffectScript::K2_OnExit(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "K2_OnExit");

	Params::RGAreaEffectScript_K2_OnExit Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGAreaEffectScript.OnActorsInAreaChanged
// (Final, Native, Protected)

void URGAreaEffectScript::OnActorsInAreaChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "OnActorsInAreaChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAreaEffectScript.OnEnter
// (Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAreaEffectScript::OnEnter(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "OnEnter");

	Params::RGAreaEffectScript_OnEnter Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAreaEffectScript.OnExit
// (Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGAreaEffectScript::OnExit(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "OnExit");

	Params::RGAreaEffectScript_OnExit Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGAreaEffectScript.GetOwningAreaEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARAreaEffect*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARAreaEffect* URGAreaEffectScript::GetOwningAreaEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGAreaEffectScript", "GetOwningAreaEffect");

	Params::RGAreaEffectScript_GetOwningAreaEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossAbilityScript.CancelAbilityExecution
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGBossAbilityScript::CancelAbilityExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "CancelAbilityExecution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossAbilityScript.EnterNextPhase
// (Final, Native, Public, BlueprintCallable)

void URGBossAbilityScript::EnterNextPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "EnterNextPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossAbilityScript.FinishAbilityExecution
// (Final, Native, Public, BlueprintCallable)

void URGBossAbilityScript::FinishAbilityExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "FinishAbilityExecution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossAbilityScript.IsMainAbilityScript
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGBossAbilityScript::IsMainAbilityScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "IsMainAbilityScript");

	Params::RGBossAbilityScript_IsMainAbilityScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGBossAbilityScript.K2_OnAnimationTriggerEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossAbilityScript::K2_OnAnimationTriggerEvent(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "K2_OnAnimationTriggerEvent");

	Params::RGBossAbilityScript_K2_OnAnimationTriggerEvent Parms{};

	Parms.Event = Event;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGBossAbilityScript.Multicast_CancelAbilityExecution
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void URGBossAbilityScript::Multicast_CancelAbilityExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "Multicast_CancelAbilityExecution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBossAbilityScript.OnAnimationTriggerEvent
// (Final, Native, Public)
// Parameters:
// class FName                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGBossAbilityScript::OnAnimationTriggerEvent(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBossAbilityScript", "OnAnimationTriggerEvent");

	Params::RGBossAbilityScript_OnAnimationTriggerEvent Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGBurningAilment.GetFirePassive1SpreadTargets
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URGBurningAilment::GetFirePassive1SpreadTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGBurningAilment", "GetFirePassive1SpreadTargets");

	Params::RGBurningAilment_GetFirePassive1SpreadTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGCharSkillTreeMutatorScript.RefreshSkillTreeMutator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             MutatorRank                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGCharSkillTreeMutatorScript::RefreshSkillTreeMutator(const int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGCharSkillTreeMutatorScript", "RefreshSkillTreeMutator");

	Params::RGCharSkillTreeMutatorScript_RefreshSkillTreeMutator Parms{};

	Parms.MutatorRank = MutatorRank;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGEnemyAttackScript.ForceFinishAttackExecution
// (Final, Native, Public, BlueprintCallable)

void URGEnemyAttackScript::ForceFinishAttackExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "ForceFinishAttackExecution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.GetCategoryName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGEnemyAttackScript::GetCategoryName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "GetCategoryName");

	Params::RGEnemyAttackScript_GetCategoryName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGEnemyAttackScript.K2_OnAttack
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnCombatTargetChanged
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnCombatTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnCombatTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnDeath
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnFrozen
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnFrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnFrozen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnInterrupted
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnInterrupted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnStunned
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnStunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnStunned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnUnfrozen
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnUnfrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnUnfrozen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.K2_OnUnstunned
// (Event, Public, BlueprintEvent)

void URGEnemyAttackScript::K2_OnUnstunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "K2_OnUnstunned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyAttackScript.OnAttack
// (Native, Public)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGEnemyAttackScript::OnAttack(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnAttack");

	Params::RGEnemyAttackScript_OnAttack Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnCombatTargetChanged
// (Native, Public)

void URGEnemyAttackScript::OnCombatTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnCombatTargetChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnDeath
// (Native, Public)

void URGEnemyAttackScript::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnFrozen
// (Native, Public)

void URGEnemyAttackScript::OnFrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnFrozen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnInterrupted
// (Native, Public)

void URGEnemyAttackScript::OnInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnStunned
// (Native, Public)

void URGEnemyAttackScript::OnStunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnStunned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnUnfrozen
// (Native, Public)

void URGEnemyAttackScript::OnUnfrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnUnfrozen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.OnUnstunned
// (Native, Public)

void URGEnemyAttackScript::OnUnstunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "OnUnstunned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyAttackScript.StartCooldown
// (Final, Native, Public, BlueprintCallable)

void URGEnemyAttackScript::StartCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyAttackScript", "StartCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.K2_OnAttack
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnCombatTargetChanged
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnCombatTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnCombatTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnDeath
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnFrozen
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnFrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnFrozen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnInterrupted
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnInterrupted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnSpecial
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnSpecial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnSpecial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnStunned
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnStunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnStunned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnUnfrozen
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnUnfrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnUnfrozen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.K2_OnUnstunned
// (Event, Public, BlueprintEvent)

void URGEnemyScript::K2_OnUnstunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "K2_OnUnstunned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGEnemyScript.OnAttack
// (Native, Public)

void URGEnemyScript::OnAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnCombatTargetChanged
// (Native, Public)

void URGEnemyScript::OnCombatTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnCombatTargetChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnDeath
// (Native, Public)

void URGEnemyScript::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnFrozen
// (Native, Public)

void URGEnemyScript::OnFrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnFrozen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnInterrupted
// (Native, Public)

void URGEnemyScript::OnInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnSpecial
// (Native, Public)

void URGEnemyScript::OnSpecial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnSpecial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnStunned
// (Native, Public)

void URGEnemyScript::OnStunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnStunned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnUnfrozen
// (Native, Public)

void URGEnemyScript::OnUnfrozen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnUnfrozen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGEnemyScript.OnUnstunned
// (Native, Public)

void URGEnemyScript::OnUnstunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGEnemyScript", "OnUnstunned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGeometryCollectionActor.GetHasBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARGeometryCollectionActor::GetHasBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGeometryCollectionActor", "GetHasBroken");

	Params::RGeometryCollectionActor_GetHasBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGeometryCollectionActor.HandleBreakEvent
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FChaosBreakEvent&          BreakEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARGeometryCollectionActor::HandleBreakEvent(const struct FChaosBreakEvent& BreakEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGeometryCollectionActor", "HandleBreakEvent");

	Params::RGeometryCollectionActor_HandleBreakEvent Parms{};

	Parms.BreakEvent = std::move(BreakEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGeometryCollectionActor.K2_OnMeshBroken
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FChaosBreakEvent&          BreakEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARGeometryCollectionActor::K2_OnMeshBroken(const struct FChaosBreakEvent& BreakEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGeometryCollectionActor", "K2_OnMeshBroken");

	Params::RGeometryCollectionActor_K2_OnMeshBroken Parms{};

	Parms.BreakEvent = std::move(BreakEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGeometryCollectionActor.OnComponentHit
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARGeometryCollectionActor::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGeometryCollectionActor", "OnComponentHit");

	Params::RGeometryCollectionActor_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGFrostPassive3CharacterMutator.GetFrostPassive3Multiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGFrostPassive3CharacterMutator::GetFrostPassive3Multiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGFrostPassive3CharacterMutator", "GetFrostPassive3Multiplier");

	Params::RGFrostPassive3CharacterMutator_GetFrostPassive3Multiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGFrozenSlipperyStatusEffect.DoAoeSlam
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class URStatusEffectGScript*>&Instigators                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutMaxRadius                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGFrozenSlipperyStatusEffect::DoAoeSlam(const TArray<class URStatusEffectGScript*>& Instigators, const struct FVector& Origin, float* OutMaxRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGFrozenSlipperyStatusEffect", "DoAoeSlam");

	Params::RGFrozenSlipperyStatusEffect_DoAoeSlam Parms{};

	Parms.Instigators = std::move(Instigators);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMaxRadius != nullptr)
		*OutMaxRadius = Parms.OutMaxRadius;
}


// Function RGame.RGGrenadeScript.K2_OnBounce
// (Event, Public, BlueprintEvent)

void URGGrenadeScript::K2_OnBounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "K2_OnBounce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGGrenadeScript.K2_OnDetonate
// (Event, Public, BlueprintEvent)

void URGGrenadeScript::K2_OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "K2_OnDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGGrenadeScript.K2_PostDetonate
// (Event, Public, BlueprintEvent)

void URGGrenadeScript::K2_PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "K2_PostDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGGrenadeScript.K2_PreDetonate
// (Event, Public, BlueprintEvent)

void URGGrenadeScript::K2_PreDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "K2_PreDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGGrenadeScript.OnBounce
// (Native, Public)

void URGGrenadeScript::OnBounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "OnBounce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGGrenadeScript.OnDetonate
// (Native, Public)

void URGGrenadeScript::OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "OnDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGGrenadeScript.PostDetonate
// (Native, Public)

void URGGrenadeScript::PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "PostDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGGrenadeScript.PreDetonate
// (Native, Public)

void URGGrenadeScript::PreDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "PreDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGGrenadeScript.GetOwningGrenade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARGrenade*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARGrenade* URGGrenadeScript::GetOwningGrenade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGGrenadeScript", "GetOwningGrenade");

	Params::RGGrenadeScript_GetOwningGrenade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGObjectiveScript.EndObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCompleted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGObjectiveScript::EndObjective(bool bCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGObjectiveScript", "EndObjective");

	Params::RGObjectiveScript_EndObjective Parms{};

	Parms.bCompleted = bCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGObjectiveScript.SetHasObjectiveEnded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHasEnded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGObjectiveScript::SetHasObjectiveEnded(bool bNewHasEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGObjectiveScript", "SetHasObjectiveEnded");

	Params::RGObjectiveScript_SetHasObjectiveEnded Parms{};

	Parms.bNewHasEnded = bNewHasEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGObjectiveScript.SetResultForController
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSuccesful                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGObjectiveScript::SetResultForController(bool bSuccesful, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGObjectiveScript", "SetResultForController");

	Params::RGObjectiveScript_SetResultForController Parms{};

	Parms.bSuccesful = bSuccesful;
	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGObjectiveScript.UpdateObjective
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      UpdateInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URGObjectiveScript::UpdateObjective(const class FText& UpdateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGObjectiveScript", "UpdateObjective");

	Params::RGObjectiveScript_UpdateObjective Parms{};

	Parms.UpdateInfo = std::move(UpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGObjectiveScript.GetProgressionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGObjectiveScript::GetProgressionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGObjectiveScript", "GetProgressionText");

	Params::RGObjectiveScript_GetProgressionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGObjectiveScript.HasObjectiveEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGObjectiveScript::HasObjectiveEnded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGObjectiveScript", "HasObjectiveEnded");

	Params::RGObjectiveScript_HasObjectiveEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGoldManager.GetGoldManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARGoldManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARGoldManager* ARGoldManager::GetGoldManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGoldManager", "GetGoldManager");

	Params::RGoldManager_GetGoldManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGoldManager.OnPreLevelChanged
// (Final, Native, Private)

void ARGoldManager::OnPreLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGoldManager", "OnPreLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGoldManager.SpawnGold
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBurst                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGoldManager::SpawnGold(class APawn* Player, bool bBurst, int32 Amount, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGoldManager", "SpawnGold");

	Params::RGoldManager_SpawnGold Parms{};

	Parms.Player = Player;
	Parms.bBurst = bBurst;
	Parms.Amount = Amount;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGolemancerPlatform.FlipTile
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARGolemancerPlatform*             FlipSourceActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGolemancerPlatform::FlipTile(class ARGolemancerPlatform* FlipSourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPlatform", "FlipTile");

	Params::RGolemancerPlatform_FlipTile Parms{};

	Parms.FlipSourceActor = FlipSourceActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGolemancerPlatform.GetPlatformMesh
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ARGolemancerPlatform::GetPlatformMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPlatform", "GetPlatformMesh");

	Params::RGolemancerPlatform_GetPlatformMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RGolemancerPlatform.PrimeTileExplosion
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGolemancerPlatform::PrimeTileExplosion(const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPlatform", "PrimeTileExplosion");

	Params::RGolemancerPlatform_PrimeTileExplosion Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGolemancerPlatform.SetOnFire
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARGolemancerPlatform::SetOnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPlatform", "SetOnFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGolemancerPylon.ActivationChanged
// (Event, Protected, BlueprintEvent)

void ARGolemancerPylon::ActivationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPylon", "ActivationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGolemancerPylon.OnRep_bIsActive
// (Final, Native, Private)

void ARGolemancerPylon::OnRep_bIsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPylon", "OnRep_bIsActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGolemancerPylon.SetIsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewIsActive                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGolemancerPylon::SetIsActive(const bool bNewIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPylon", "SetIsActive");

	Params::RGolemancerPylon_SetIsActive Parms{};

	Parms.bNewIsActive = bNewIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGolemancerPylon.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARGolemancerPylon::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGolemancerPylon", "IsActive");

	Params::RGolemancerPylon_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileEffectScript.ApplyStatusEffects
// (Native, Protected)

void URGProjectileEffectScript::ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "ApplyStatusEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.K2_ApplyStatusEffects
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_ApplyStatusEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_OnBounce
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_OnBounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_OnBounce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_OnDetonate
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_OnDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_OnHit
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_OnHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_PostAddMutators
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_PostAddMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_PostAddMutators");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_PostDetonate
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_PostDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_PostHit
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_PostHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_PreHit
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_PreHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.K2_ProjectileDisabled
// (Event, Protected, BlueprintEvent)

void URGProjectileEffectScript::K2_ProjectileDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "K2_ProjectileDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileEffectScript.OnBounce
// (Native, Protected)

void URGProjectileEffectScript::OnBounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "OnBounce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.OnDetonate
// (Native, Protected)

void URGProjectileEffectScript::OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "OnDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.OnHit
// (Native, Protected)

void URGProjectileEffectScript::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.PostAddMutators
// (Native, Protected)

void URGProjectileEffectScript::PostAddMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "PostAddMutators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.PostDetonate
// (Native, Protected)

void URGProjectileEffectScript::PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "PostDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.PostHit
// (Native, Protected)

void URGProjectileEffectScript::PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "PostHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.PreHit
// (Native, Protected)

void URGProjectileEffectScript::PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "PreHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.ProjectileDisabled
// (Native, Protected)

void URGProjectileEffectScript::ProjectileDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "ProjectileDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileEffectScript.GetOwningProjectile
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARProjectileBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARProjectileBase* URGProjectileEffectScript::GetOwningProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "GetOwningProjectile");

	Params::RGProjectileEffectScript_GetOwningProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileEffectScript.GetProjectileScript
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URProjectileBaseScript*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URProjectileBaseScript* URGProjectileEffectScript::GetProjectileScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileEffectScript", "GetProjectileScript");

	Params::RGProjectileEffectScript_GetProjectileScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileMutatorScript.ApplyStatusEffects
// (Native, Public)

void URGProjectileMutatorScript::ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "ApplyStatusEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.GetMutatorDescription
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGProjectileMutatorScript::GetMutatorDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "GetMutatorDescription");

	Params::RGProjectileMutatorScript_GetMutatorDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileMutatorScript.GetMutatorRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGProjectileMutatorScript::GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "GetMutatorRank");

	Params::RGProjectileMutatorScript_GetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileMutatorScript.K2_ApplyStatusEffects
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_ApplyStatusEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_ApplyStatusEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.K2_OnDetonate
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_OnDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.K2_OnHit
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_OnHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.K2_PostDetonate
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_PostDetonate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.K2_PostHit
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_PostHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.K2_PreHit
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_PreHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.K2_ProjectileDisabled
// (Event, Public, BlueprintEvent)

void URGProjectileMutatorScript::K2_ProjectileDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "K2_ProjectileDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGProjectileMutatorScript.OnDetonate
// (Native, Public)

void URGProjectileMutatorScript::OnDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "OnDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.OnHit
// (Native, Public)

void URGProjectileMutatorScript::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.PostDetonate
// (Native, Public)

void URGProjectileMutatorScript::PostDetonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "PostDetonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.PostHit
// (Native, Public)

void URGProjectileMutatorScript::PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "PostHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.PreHit
// (Native, Public)

void URGProjectileMutatorScript::PreHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "PreHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.ProjectileDisabled
// (Native, Public)

void URGProjectileMutatorScript::ProjectileDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "ProjectileDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGProjectileMutatorScript.GetDescription
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URGProjectileMutatorScript::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "GetDescription");

	Params::RGProjectileMutatorScript_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileMutatorScript.GetOwningProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARProjectileBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARProjectileBase* URGProjectileMutatorScript::GetOwningProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "GetOwningProjectile");

	Params::RGProjectileMutatorScript_GetOwningProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileMutatorScript.GetProjectileScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URProjectileBaseScript*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URProjectileBaseScript* URGProjectileMutatorScript::GetProjectileScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "GetProjectileScript");

	Params::RGProjectileMutatorScript_GetProjectileScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGProjectileMutatorScript.RollProcChance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Chance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGProjectileMutatorScript::RollProcChance(int32 Chance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGProjectileMutatorScript", "RollProcChance");

	Params::RGProjectileMutatorScript_RollProcChance Parms{};

	Parms.Chance = Chance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGrenade.Detonate
// (Final, Native, Public, BlueprintCallable)

void ARGrenade::Detonate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGrenade", "Detonate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGrenade.FetchHitResults
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> ARGrenade::FetchHitResults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGrenade", "FetchHitResults");

	Params::RGrenade_FetchHitResults Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGrenade.ResetDetonateTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTimeToDetonate                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGrenade::ResetDetonateTimer(float NewTimeToDetonate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGrenade", "ResetDetonateTimer");

	Params::RGrenade_ResetDetonateTimer Parms{};

	Parms.NewTimeToDetonate = NewTimeToDetonate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGrenade.SetBaseAreaOfEffectSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newBaseAreaOfEffectRadius                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARGrenade::SetBaseAreaOfEffectSize(float newBaseAreaOfEffectRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGrenade", "SetBaseAreaOfEffectSize");

	Params::RGrenade_SetBaseAreaOfEffectSize Parms{};

	Parms.newBaseAreaOfEffectRadius = newBaseAreaOfEffectRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.AddOrExecuteScriptFunction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URGScript>            ScriptClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScript* URGScriptComponent::AddOrExecuteScriptFunction(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, TSubclassOf<class URGScript> ScriptClass, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "AddOrExecuteScriptFunction");

	Params::RGScriptComponent_AddOrExecuteScriptFunction Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.ScriptClass = ScriptClass;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.AddScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URGScript>            ScriptClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoRep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        InstigatorScript                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScript* URGScriptComponent::AddScript(class URGScriptComponent* OwningComponent, class FName Category, TSubclassOf<class URGScript> ScriptClass, int32 Priority, bool bNoRep, class URGScript* InstigatorScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "AddScript");

	Params::RGScriptComponent_AddScript Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.ScriptClass = ScriptClass;
	Parms.Priority = Priority;
	Parms.bNoRep = bNoRep;
	Parms.InstigatorScript = InstigatorScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.AddScriptNoActivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URGScript>            ScriptClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoRep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScript* URGScriptComponent::AddScriptNoActivate(class URGScriptComponent* OwningComponent, class FName Category, TSubclassOf<class URGScript> ScriptClass, int32 Priority, bool bNoRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "AddScriptNoActivate");

	Params::RGScriptComponent_AddScriptNoActivate Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.ScriptClass = ScriptClass;
	Parms.Priority = Priority;
	Parms.bNoRep = bNoRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.BindOnFinishScriptExecutionByCategory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Function                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const class FName& Category, const class FName& Function)>&Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::BindOnFinishScriptExecutionByCategory(class URGScriptComponent* OwningComponent, class FName Category, class FName Function, const TDelegate<void(const class FName& Category, const class FName& Function)>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "BindOnFinishScriptExecutionByCategory");

	Params::RGScriptComponent_BindOnFinishScriptExecutionByCategory Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.Function = Function;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ClearScripts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ClearScripts(class URGScriptComponent* OwningComponent, class FName Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ClearScripts");

	Params::RGScriptComponent_ClearScripts Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunction(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunction");

	Params::RGScriptComponent_ExecuteGenericScriptFunction Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunctionForAllCategories
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunctionForAllCategories(class URGScriptComponent* OwningComponent, ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunctionForAllCategories");

	Params::RGScriptComponent_ExecuteGenericScriptFunctionForAllCategories Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.FunctionName = FunctionName;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunctionWithActorRef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunctionWithActorRef(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, class AActor* Actor, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunctionWithActorRef");

	Params::RGScriptComponent_ExecuteGenericScriptFunctionWithActorRef Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Actor = Actor;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunctionWithDamageEventRef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunctionWithDamageEventRef(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, const struct FDamageCombatEvent& DamageCombatEvent, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunctionWithDamageEventRef");

	Params::RGScriptComponent_ExecuteGenericScriptFunctionWithDamageEventRef Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.DamageCombatEvent = std::move(DamageCombatEvent);
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunctionWithGScriptRef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        GScript                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunctionWithGScriptRef(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, class URGScript* GScript, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunctionWithGScriptRef");

	Params::RGScriptComponent_ExecuteGenericScriptFunctionWithGScriptRef Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.GScript = GScript;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunctionWithInt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunctionWithInt(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, int32 Value, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunctionWithInt");

	Params::RGScriptComponent_ExecuteGenericScriptFunctionWithInt Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Value = Value;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.ExecuteGenericScriptFunctionWithVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::ExecuteGenericScriptFunctionWithVector(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, const struct FVector& Value, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "ExecuteGenericScriptFunctionWithVector");

	Params::RGScriptComponent_ExecuteGenericScriptFunctionWithVector Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Value = std::move(Value);
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.GetAllAilmentScripts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URStatusEffectAilmentGScript*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URStatusEffectAilmentGScript*> URGScriptComponent::GetAllAilmentScripts(class URGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetAllAilmentScripts");

	Params::RGScriptComponent_GetAllAilmentScripts Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetAllEnemyAttackScripts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URGEnemyAttackScript*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URGEnemyAttackScript*> URGScriptComponent::GetAllEnemyAttackScripts(class URGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetAllEnemyAttackScripts");

	Params::RGScriptComponent_GetAllEnemyAttackScripts Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetAllScriptChildrenOfType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             parentType                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URGScript*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URGScript*> URGScriptComponent::GetAllScriptChildrenOfType(class URGScriptComponent* OwningComponent, TSoftClassPtr<class UClass> parentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetAllScriptChildrenOfType");

	Params::RGScriptComponent_GetAllScriptChildrenOfType Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.parentType = parentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetAllScriptsOfType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             scriptType                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URGScript*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URGScript*> URGScriptComponent::GetAllScriptsOfType(class URGScriptComponent* OwningComponent, TSoftClassPtr<class UClass> scriptType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetAllScriptsOfType");

	Params::RGScriptComponent_GetAllScriptsOfType Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.scriptType = scriptType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetAllStatusEffectScripts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URStatusEffectGScript*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URStatusEffectGScript*> URGScriptComponent::GetAllStatusEffectScripts(class URGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetAllStatusEffectScripts");

	Params::RGScriptComponent_GetAllStatusEffectScripts Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetFirstScriptOfType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             scriptType                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScript* URGScriptComponent::GetFirstScriptOfType(class URGScriptComponent* OwningComponent, TSoftClassPtr<class UClass> scriptType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetFirstScriptOfType");

	Params::RGScriptComponent_GetFirstScriptOfType Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.scriptType = scriptType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetGScriptContext
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGScriptActorInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGScriptActorInfo URGScriptComponent::GetGScriptContext(class URGScriptComponent* OwningComponent, class FName Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetGScriptContext");

	Params::RGScriptComponent_GetGScriptContext Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetRGScriptComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                OwningPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScriptComponent* URGScriptComponent::GetRGScriptComponent(class APlayerController* OwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetRGScriptComponent");

	Params::RGScriptComponent_GetRGScriptComponent Parms{};

	Parms.OwningPlayer = OwningPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.GetScriptInCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             scriptType                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGScript* URGScriptComponent::GetScriptInCategory(class URGScriptComponent* OwningComponent, class FName Category, TSoftClassPtr<class UClass> scriptType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "GetScriptInCategory");

	Params::RGScriptComponent_GetScriptInCategory Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.scriptType = scriptType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.K2_ExecuteGenericScriptFunctionWithParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32&                            Params_0                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllCategories                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::K2_ExecuteGenericScriptFunctionWithParams(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, const int32& Params_0, EGScriptFunctionReplication Replication, bool bAllCategories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "K2_ExecuteGenericScriptFunctionWithParams");

	Params::RGScriptComponent_K2_ExecuteGenericScriptFunctionWithParams Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Params_0 = Params_0;
	Parms.Replication = Replication;
	Parms.bAllCategories = bAllCategories;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.RemoveScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        Script                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::RemoveScript(class URGScriptComponent* OwningComponent, class FName Category, class URGScript* Script)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "RemoveScript");

	Params::RGScriptComponent_RemoveScript Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.Script = Script;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.RemoveScriptContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::RemoveScriptContext(class URGScriptComponent* OwningComponent, class FName Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "RemoveScriptContext");

	Params::RGScriptComponent_RemoveScriptContext Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.SetGScriptContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScriptComponent*               InstigatorScriptComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoRep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGScriptActorInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGScriptActorInfo URGScriptComponent::SetGScriptContext(class URGScriptComponent* OwningComponent, class FName Category, class AActor* Owner, class AActor* AvatarActor, class AController* Controller, class URGScriptComponent* InstigatorScriptComponent, bool bNoRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGScriptComponent", "SetGScriptContext");

	Params::RGScriptComponent_SetGScriptContext Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.Owner = Owner;
	Parms.AvatarActor = AvatarActor;
	Parms.Controller = Controller;
	Parms.InstigatorScriptComponent = InstigatorScriptComponent;
	Parms.bNoRep = bNoRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGScriptComponent.CacheHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URGScriptComponent::CacheHitResult(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "CacheHitResult");

	Params::RGScriptComponent_CacheHitResult Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.CancelAllTasks
// (Final, Native, Public, BlueprintCallable)

void URGScriptComponent::CancelAllTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "CancelAllTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.FreezeAllTasks
// (Final, Native, Public, BlueprintCallable)

void URGScriptComponent::FreezeAllTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "FreezeAllTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRGscriptFunctionParams&   Params_0                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunction(class FName Category, ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication, const struct FRGscriptFunctionParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunction");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunction Parms{};

	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Replication = Replication;
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunctionForAllCategories
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRGscriptFunctionParams&   Params_0                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunctionForAllCategories(ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication, const struct FRGscriptFunctionParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunctionForAllCategories");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunctionForAllCategories Parms{};

	Parms.FunctionName = FunctionName;
	Parms.Replication = Replication;
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunctionWithActorRef
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunctionWithActorRef(class FName Category, ERGScriptFunction FunctionName, class AActor* Actor, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunctionWithActorRef");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunctionWithActorRef Parms{};

	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Actor = Actor;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunctionWithDamageEventRef
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunctionWithDamageEventRef(class FName Category, ERGScriptFunction FunctionName, const struct FDamageCombatEvent& DamageCombatEvent, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunctionWithDamageEventRef");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunctionWithDamageEventRef Parms{};

	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.DamageCombatEvent = std::move(DamageCombatEvent);
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunctionWithGScriptRef
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGScript*                        GScript                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunctionWithGScriptRef(class FName Category, ERGScriptFunction FunctionName, class URGScript* GScript, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunctionWithGScriptRef");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunctionWithGScriptRef Parms{};

	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.GScript = GScript;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunctionWithInt
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunctionWithInt(class FName Category, ERGScriptFunction FunctionName, int32 Value, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunctionWithInt");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunctionWithInt Parms{};

	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Value = Value;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.MulticastExecuteGenericScriptFunctionWithVector
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::MulticastExecuteGenericScriptFunctionWithVector(class FName Category, ERGScriptFunction FunctionName, const struct FVector& Value, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "MulticastExecuteGenericScriptFunctionWithVector");

	Params::RGScriptComponent_MulticastExecuteGenericScriptFunctionWithVector Parms{};

	Parms.Category = Category;
	Parms.FunctionName = FunctionName;
	Parms.Value = std::move(Value);
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.OnRep_ScriptContainers
// (Final, Native, Private)
// Parameters:
// const TArray<struct FGScriptContainer>& PreviousValue                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void URGScriptComponent::OnRep_ScriptContainers(const TArray<struct FGScriptContainer>& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "OnRep_ScriptContainers");

	Params::RGScriptComponent_OnRep_ScriptContainers Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.OnScriptFinishedExecution
// (Final, Native, Public)
// Parameters:
// class URGScript*                        Script                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ExecutionParam                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   consumePriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGScriptComponent::OnScriptFinishedExecution(class URGScript* Script, class FName Category, class FName ExecutionParam, int32 consumePriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "OnScriptFinishedExecution");

	Params::RGScriptComponent_OnScriptFinishedExecution Parms{};

	Parms.Script = Script;
	Parms.Category = Category;
	Parms.ExecutionParam = ExecutionParam;
	Parms.consumePriority = consumePriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.OverridePreHitDamageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FPreHitDamageData&         NewPreHitDamageData                                    (Parm, NativeAccessSpecifierPublic)

void URGScriptComponent::OverridePreHitDamageData(const struct FPreHitDamageData& NewPreHitDamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "OverridePreHitDamageData");

	Params::RGScriptComponent_OverridePreHitDamageData Parms{};

	Parms.NewPreHitDamageData = std::move(NewPreHitDamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.UnfreezeAllTasks
// (Final, Native, Public, BlueprintCallable)

void URGScriptComponent::UnfreezeAllTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "UnfreezeAllTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGScriptComponent.GetCachedHitResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FHitResult URGScriptComponent::GetCachedHitResult() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGScriptComponent", "GetCachedHitResult");

	Params::RGScriptComponent_GetCachedHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGSlowStatusEffect.AddEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGSlowStatusEffect::AddEntry(class FName Key, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGSlowStatusEffect", "AddEntry");

	Params::RGSlowStatusEffect_AddEntry Parms{};

	Parms.Key = Key;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGSlowStatusEffect.K2_OnAddEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGSlowStatusEffect::K2_OnAddEntry(class FName Key, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGSlowStatusEffect", "K2_OnAddEntry");

	Params::RGSlowStatusEffect_K2_OnAddEntry Parms{};

	Parms.Key = Key;
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGSlowStatusEffect.K2_OnRemoveEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGSlowStatusEffect::K2_OnRemoveEntry(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGSlowStatusEffect", "K2_OnRemoveEntry");

	Params::RGSlowStatusEffect_K2_OnRemoveEntry Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGSlowStatusEffect.RefreshEntriesWithDuration
// (Final, Native, Protected)

void URGSlowStatusEffect::RefreshEntriesWithDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGSlowStatusEffect", "RefreshEntriesWithDuration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGSlowStatusEffect.RemoveEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRefreshEntriesWithDuration                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGSlowStatusEffect::RemoveEntry(class FName Key, bool bRefreshEntriesWithDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGSlowStatusEffect", "RemoveEntry");

	Params::RGSlowStatusEffect_RemoveEntry Parms{};

	Parms.Key = Key;
	Parms.bRefreshEntriesWithDuration = bRefreshEntriesWithDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_AddRecoil.AddRecoil
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RecoilAnimOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CooldownOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_AddRecoil*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_AddRecoil* URGTask_AddRecoil::AddRecoil(class URGScript* OwningScript, class FName RecoilAnimOverride, float CooldownOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_AddRecoil", "AddRecoil");

	Params::RGTask_AddRecoil_AddRecoil Parms{};

	Parms.OwningScript = OwningScript;
	Parms.RecoilAnimOverride = RecoilAnimOverride;
	Parms.CooldownOverride = CooldownOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_DelayedWhile.DelayedWhile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            TimeBetweenTicks_0                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool* RetValue)>         Predicate                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_DelayedWhile*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_DelayedWhile* URGTask_DelayedWhile::DelayedWhile(class URGScript* OwningScript, const float& TimeBetweenTicks_0, TDelegate<void(bool* RetValue)> Predicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_DelayedWhile", "DelayedWhile");

	Params::RGTask_DelayedWhile_DelayedWhile Parms{};

	Parms.OwningScript = OwningScript;
	Parms.TimeBetweenTicks_0 = TimeBetweenTicks_0;
	Parms.Predicate = Predicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_PlayAnimation.CreatePlayMontageAndWaitProxy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay_0                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_PlayAnimation*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_PlayAnimation* URGTask_PlayAnimation::CreatePlayMontageAndWaitProxy(class URGScript* OwningScript, class UAnimMontage* MontageToPlay_0, class FName SectionName_0, float PlayRate_0, bool bStopWhenAbilityEnds_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_PlayAnimation", "CreatePlayMontageAndWaitProxy");

	Params::RGTask_PlayAnimation_CreatePlayMontageAndWaitProxy Parms{};

	Parms.OwningScript = OwningScript;
	Parms.MontageToPlay_0 = MontageToPlay_0;
	Parms.SectionName_0 = SectionName_0;
	Parms.PlayRate_0 = PlayRate_0;
	Parms.bStopWhenAbilityEnds_0 = bStopWhenAbilityEnds_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_PlayAnimation.OnMontageBlendingOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGTask_PlayAnimation::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask_PlayAnimation", "OnMontageBlendingOut");

	Params::RGTask_PlayAnimation_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_PlayAnimation.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGTask_PlayAnimation::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask_PlayAnimation", "OnMontageEnded");

	Params::RGTask_PlayAnimation_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_PlayAnimation.OnMontageInterrupted
// (Final, Native, Public)

void URGTask_PlayAnimation::OnMontageInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask_PlayAnimation", "OnMontageInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGTask_PlayPlayerSound.PlayPlayerSound
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_PlayPlayerSound*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_PlayPlayerSound* URGTask_PlayPlayerSound::PlayPlayerSound(class URGScript* OwningScript, class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_PlayPlayerSound", "PlayPlayerSound");

	Params::RGTask_PlayPlayerSound_PlayPlayerSound Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Sound = Sound;
	Parms.Location = std::move(Location);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_PredicateCheck.PredicateCheck
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool* RetValue)>         Predicate                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_PredicateCheck*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_PredicateCheck* URGTask_PredicateCheck::PredicateCheck(class URGScript* OwningScript, TDelegate<void(bool* RetValue)> Predicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_PredicateCheck", "PredicateCheck");

	Params::RGTask_PredicateCheck_PredicateCheck Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Predicate = Predicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_ReloadWeapon.ReloadWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_ReloadWeapon*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_ReloadWeapon* URGTask_ReloadWeapon::ReloadWeapon(class URGScript* OwningScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_ReloadWeapon", "ReloadWeapon");

	Params::RGTask_ReloadWeapon_ReloadWeapon Parms{};

	Parms.OwningScript = OwningScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_ScopeWeapon.ScopeWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScopeIn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_ScopeWeapon*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_ScopeWeapon* URGTask_ScopeWeapon::ScopeWeapon(class URGScript* OwningScript, bool bScopeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_ScopeWeapon", "ScopeWeapon");

	Params::RGTask_ScopeWeapon_ScopeWeapon Parms{};

	Parms.OwningScript = OwningScript;
	Parms.bScopeIn = bScopeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_SpawnAreaEffect.SpawnAreaEffect
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARAreaEffect>         InAreaEffectClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InSpawnTransform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLifetime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalOwningActor                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            InOptionalInstigator                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_SpawnAreaEffect*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_SpawnAreaEffect* URGTask_SpawnAreaEffect::SpawnAreaEffect(class URGScript* OwningScript, TSubclassOf<class ARAreaEffect> InAreaEffectClass, const struct FTransform& InSpawnTransform, float InLifetime, class AActor* InOptionalOwningActor, class APawn* InOptionalInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_SpawnAreaEffect", "SpawnAreaEffect");

	Params::RGTask_SpawnAreaEffect_SpawnAreaEffect Parms{};

	Parms.OwningScript = OwningScript;
	Parms.InAreaEffectClass = InAreaEffectClass;
	Parms.InSpawnTransform = std::move(InSpawnTransform);
	Parms.InLifetime = InLifetime;
	Parms.InOptionalOwningActor = InOptionalOwningActor;
	Parms.InOptionalInstigator = InOptionalInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_SpawnNonWeaponProjectile.SpawnNonWeaponProjectile
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARProjectileBase>     ProjectileClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                ProjectileSpawnTransform                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseCriticalMultiplier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseEffectiveRange                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_SpawnNonWeaponProjectile* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_SpawnNonWeaponProjectile* URGTask_SpawnNonWeaponProjectile::SpawnNonWeaponProjectile(class URGScript* OwningScript, TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FTransform& ProjectileSpawnTransform, float BaseDamage, float BaseCriticalMultiplier, float BaseEffectiveRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_SpawnNonWeaponProjectile", "SpawnNonWeaponProjectile");

	Params::RGTask_SpawnNonWeaponProjectile_SpawnNonWeaponProjectile Parms{};

	Parms.OwningScript = OwningScript;
	Parms.ProjectileClass = ProjectileClass;
	Parms.ProjectileSpawnTransform = std::move(ProjectileSpawnTransform);
	Parms.BaseDamage = BaseDamage;
	Parms.BaseCriticalMultiplier = BaseCriticalMultiplier;
	Parms.BaseEffectiveRange = BaseEffectiveRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_SpawnProjectile.SpawnProjectile
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARProjectileBase>     ProjectileClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   projectileSpawnOffset                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  OffsetRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    OverrideSpawnDirection                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SpawnDirectionOverride                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useWeaponDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGWeaponModScript*               WeaponScriptSpawner                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RegisterLastTimeFired                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreSpread                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerPrimaryFireFX                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_SpawnProjectile*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_SpawnProjectile* URGTask_SpawnProjectile::SpawnProjectile(class URGScript* OwningScript, TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FVector& projectileSpawnOffset, const struct FRotator& OffsetRotation, bool OverrideSpawnDirection, const struct FVector& SpawnDirectionOverride, bool useWeaponDamage, class URGWeaponModScript* WeaponScriptSpawner, bool RegisterLastTimeFired, bool IgnoreSpread, bool TriggerPrimaryFireFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_SpawnProjectile", "SpawnProjectile");

	Params::RGTask_SpawnProjectile_SpawnProjectile Parms{};

	Parms.OwningScript = OwningScript;
	Parms.ProjectileClass = ProjectileClass;
	Parms.projectileSpawnOffset = std::move(projectileSpawnOffset);
	Parms.OffsetRotation = std::move(OffsetRotation);
	Parms.OverrideSpawnDirection = OverrideSpawnDirection;
	Parms.SpawnDirectionOverride = std::move(SpawnDirectionOverride);
	Parms.useWeaponDamage = useWeaponDamage;
	Parms.WeaponScriptSpawner = WeaponScriptSpawner;
	Parms.RegisterLastTimeFired = RegisterLastTimeFired;
	Parms.IgnoreSpread = IgnoreSpread;
	Parms.TriggerPrimaryFireFX = TriggerPrimaryFireFX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_SpawnProjectileHitEffects.SpawnProjectileHitEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OverrideTag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_SpawnProjectileHitEffects*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_SpawnProjectileHitEffects* URGTask_SpawnProjectileHitEffects::SpawnProjectileHitEffect(class URGScript* OwningScript, class FName OverrideTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_SpawnProjectileHitEffects", "SpawnProjectileHitEffect");

	Params::RGTask_SpawnProjectileHitEffects_SpawnProjectileHitEffect Parms{};

	Parms.OwningScript = OwningScript;
	Parms.OverrideTag = OverrideTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_TimeLoop.TimeLoop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_TimeLoop*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_TimeLoop* URGTask_TimeLoop::TimeLoop(class URGScript* OwningScript, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_TimeLoop", "TimeLoop");

	Params::RGTask_TimeLoop_TimeLoop Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_TurnAndWait.TurnAndWait
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor_0                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurningDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_TurnAndWait*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_TurnAndWait* URGTask_TurnAndWait::TurnAndWait(class URGScript* OwningScript, class AActor* TargetActor_0, float TurningDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_TurnAndWait", "TurnAndWait");

	Params::RGTask_TurnAndWait_TurnAndWait Parms{};

	Parms.OwningScript = OwningScript;
	Parms.TargetActor_0 = TargetActor_0;
	Parms.TurningDuration = TurningDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_UpdateAmmoInClip.UpdateAmmoInClip
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OptionalOwningScript                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_UpdateAmmoInClip*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_UpdateAmmoInClip* URGTask_UpdateAmmoInClip::UpdateAmmoInClip(class URGScript* OptionalOwningScript, int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_UpdateAmmoInClip", "UpdateAmmoInClip");

	Params::RGTask_UpdateAmmoInClip_UpdateAmmoInClip Parms{};

	Parms.OptionalOwningScript = OptionalOwningScript;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_WaitDelay.WaitDelay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGTask_WaitDelay*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGTask_WaitDelay* URGTask_WaitDelay::WaitDelay(class URGScript* OwningScript, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RGTask_WaitDelay", "WaitDelay");

	Params::RGTask_WaitDelay_WaitDelay Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGTask_WaitDelay.IncreaseTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URGScript*                        OwningScript                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGTask_WaitDelay::IncreaseTimer(class URGScript* OwningScript, float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGTask_WaitDelay", "IncreaseTimer");

	Params::RGTask_WaitDelay_IncreaseTimer Parms{};

	Parms.OwningScript = OwningScript;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.AlterRemainingCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::AlterRemainingCooldown(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "AlterRemainingCooldown");

	Params::RGWeaponModScript_AlterRemainingCooldown Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.ApplyFireSettings
// (Final, Native, Public)
// Parameters:
// class URBaseWeaponSettings*             FireSettings                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::ApplyFireSettings(class URBaseWeaponSettings* FireSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "ApplyFireSettings");

	Params::RGWeaponModScript_ApplyFireSettings Parms{};

	Parms.FireSettings = FireSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.ApplyThisFireSettings
// (Final, Native, Public, BlueprintCallable)

void URGWeaponModScript::ApplyThisFireSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "ApplyThisFireSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.FanFire
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRotator&                  RotationOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URGWeaponModScript::FanFire(const struct FRotator& RotationOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "FanFire");

	Params::RGWeaponModScript_FanFire Parms{};

	Parms.RotationOffset = std::move(RotationOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.FinishFire
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGWeaponModScript::FinishFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "FinishFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.Fire
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGWeaponModScript::Fire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "Fire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.FireProjectile
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AmmoCost                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BarrelIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARProjectileBase>     ProjectileClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SpawnOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUseWeaponDamage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ROFOverride                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipRecoil                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRunFanFireBehavior                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::FireProjectile(int32 AmmoCost, int32 BarrelIndex, TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FVector& SpawnOffset, const struct FRotator& RotationOffset, bool bUseWeaponDamage, float ROFOverride, bool bSkipRecoil, bool bRunFanFireBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "FireProjectile");

	Params::RGWeaponModScript_FireProjectile Parms{};

	Parms.AmmoCost = AmmoCost;
	Parms.BarrelIndex = BarrelIndex;
	Parms.ProjectileClass = ProjectileClass;
	Parms.SpawnOffset = std::move(SpawnOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.bUseWeaponDamage = bUseWeaponDamage;
	Parms.ROFOverride = ROFOverride;
	Parms.bSkipRecoil = bSkipRecoil;
	Parms.bRunFanFireBehavior = bRunFanFireBehavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.InterruptFireSequence
// (Final, Native, Public, BlueprintCallable)

void URGWeaponModScript::InterruptFireSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "InterruptFireSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.NativeSpawnBulletline
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Forward                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::NativeSpawnBulletline(const struct FVector& Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "NativeSpawnBulletline");

	Params::RGWeaponModScript_NativeSpawnBulletline Parms{};

	Parms.Forward = std::move(Forward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.PostFire
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGWeaponModScript::PostFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "PostFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.PreFire
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URGWeaponModScript::PreFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "PreFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.RetryFire
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipFireSequenceCheck                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::RetryFire(bool bSkipFireSequenceCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "RetryFire");

	Params::RGWeaponModScript_RetryFire Parms{};

	Parms.bSkipFireSequenceCheck = bSkipFireSequenceCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.SetModScriptLastTimeFired
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   LastTimeFired                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::SetModScriptLastTimeFired(float LastTimeFired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "SetModScriptLastTimeFired");

	Params::RGWeaponModScript_SetModScriptLastTimeFired Parms{};

	Parms.LastTimeFired = LastTimeFired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.SpawnFX
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class URNiagaraComponent>   RNiagaraComponent                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       SoundTemplate                                          (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCameraShakeBase>     CameraShakeTemplate                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::SpawnFX(TSubclassOf<class URNiagaraComponent> RNiagaraComponent, class USoundBase* SoundTemplate, TSubclassOf<class UCameraShakeBase> CameraShakeTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "SpawnFX");

	Params::RGWeaponModScript_SpawnFX Parms{};

	Parms.RNiagaraComponent = RNiagaraComponent;
	Parms.SoundTemplate = SoundTemplate;
	Parms.CameraShakeTemplate = CameraShakeTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.SpawnWeaponFireCameraShake
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     CameraShakeTemplate                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::SpawnWeaponFireCameraShake(TSubclassOf<class UCameraShakeBase> CameraShakeTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "SpawnWeaponFireCameraShake");

	Params::RGWeaponModScript_SpawnWeaponFireCameraShake Parms{};

	Parms.CameraShakeTemplate = CameraShakeTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.SpawnWeaponFireFX
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class URNiagaraComponent>   RNiagaraComponent                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::SpawnWeaponFireFX(TSubclassOf<class URNiagaraComponent> RNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "SpawnWeaponFireFX");

	Params::RGWeaponModScript_SpawnWeaponFireFX Parms{};

	Parms.RNiagaraComponent = RNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.SpawnWeaponFireSFX
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                       SoundTemplate                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponModScript::SpawnWeaponFireSFX(class USoundBase* SoundTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "SpawnWeaponFireSFX");

	Params::RGWeaponModScript_SpawnWeaponFireSFX Parms{};

	Parms.SoundTemplate = SoundTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.TriggerReload
// (Final, Native, Public)

void URGWeaponModScript::TriggerReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "TriggerReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.TryFire
// (Final, Native, Public)

void URGWeaponModScript::TryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "TryFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponModScript.GetFloatWeaponModCurrentStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponModScript::GetFloatWeaponModCurrentStat(EFloatWeaponStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "GetFloatWeaponModCurrentStat");

	Params::RGWeaponModScript_GetFloatWeaponModCurrentStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponModScript.GetRemainingCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponModScript::GetRemainingCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "GetRemainingCooldown");

	Params::RGWeaponModScript_GetRemainingCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponModScript.GetRemainingCooldownPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponModScript::GetRemainingCooldownPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "GetRemainingCooldownPercentage");

	Params::RGWeaponModScript_GetRemainingCooldownPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponModScript.IsPrimaryFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponModScript::IsPrimaryFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "IsPrimaryFire");

	Params::RGWeaponModScript_IsPrimaryFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponModScript.IsSecondaryFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponModScript::IsSecondaryFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "IsSecondaryFire");

	Params::RGWeaponModScript_IsSecondaryFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponModScript.IsWeaponHoldingFire
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponModScript::IsWeaponHoldingFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponModScript", "IsWeaponHoldingFire");

	Params::RGWeaponModScript_IsWeaponHoldingFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.ClientReloaded
// (Net, NetReliable, Native, Event, Protected, NetClient)

void URGWeaponScript::ClientReloaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ClientReloaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.ExecuteWeaponScriptFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::ExecuteWeaponScriptFunction(ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ExecuteWeaponScriptFunction");

	Params::RGWeaponScript_ExecuteWeaponScriptFunction Parms{};

	Parms.FunctionName = FunctionName;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.ExecuteWeaponScriptFunctionWithActorRef
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::ExecuteWeaponScriptFunctionWithActorRef(ERGScriptFunction FunctionName, class AActor* Actor, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ExecuteWeaponScriptFunctionWithActorRef");

	Params::RGWeaponScript_ExecuteWeaponScriptFunctionWithActorRef Parms{};

	Parms.FunctionName = FunctionName;
	Parms.Actor = Actor;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.ExecuteWeaponScriptFunctionWithInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::ExecuteWeaponScriptFunctionWithInt(ERGScriptFunction FunctionName, int32 Value, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ExecuteWeaponScriptFunctionWithInt");

	Params::RGWeaponScript_ExecuteWeaponScriptFunctionWithInt Parms{};

	Parms.FunctionName = FunctionName;
	Parms.Value = Value;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.ExecuteWeaponScriptFunctionWithVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ERGScriptFunction                       FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGScriptFunctionReplication             Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::ExecuteWeaponScriptFunctionWithVector(ERGScriptFunction FunctionName, const struct FVector& Value, EGScriptFunctionReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ExecuteWeaponScriptFunctionWithVector");

	Params::RGWeaponScript_ExecuteWeaponScriptFunctionWithVector Parms{};

	Parms.FunctionName = FunctionName;
	Parms.Value = std::move(Value);
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.FinishReload
// (Final, Native, Public, BlueprintCallable)

void URGWeaponScript::FinishReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "FinishReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.GetIsScoped
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponScript::GetIsScoped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetIsScoped");

	Params::RGWeaponScript_GetIsScoped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.InterruptReload
// (Final, Native, Public, BlueprintCallable)

void URGWeaponScript::InterruptReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "InterruptReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.K2_OnBeginFire
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnBeginFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnBeginFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnBeginSecondaryFire
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnBeginSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnBeginSecondaryFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnEndFire
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnEndFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnEndFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnEndSecondaryFire
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnEndSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnEndSecondaryFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnEnemyKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::K2_OnEnemyKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnEnemyKilled");

	Params::RGWeaponScript_K2_OnEnemyKilled Parms{};

	Parms.KilledActor = KilledActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGWeaponScript.K2_OnEquip
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnEquip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnProjectileSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARProjectileBase*                 SpawnedProjectile                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::K2_OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnProjectileSpawned");

	Params::RGWeaponScript_K2_OnProjectileSpawned Parms{};

	Parms.SpawnedProjectile = SpawnedProjectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGWeaponScript.K2_OnProjectileSpawnedClientDummy
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::K2_OnProjectileSpawnedClientDummy(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnProjectileSpawnedClientDummy");

	Params::RGWeaponScript_K2_OnProjectileSpawnedClientDummy Parms{};

	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RGWeaponScript.K2_OnReload
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnReloadFinished
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnReloadFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnReloadFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.K2_OnUnequip
// (Event, Public, BlueprintEvent)

void URGWeaponScript::K2_OnUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "K2_OnUnequip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponScript.MulticastSetAmmoInClip
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   NewAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::MulticastSetAmmoInClip(int32 NewAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "MulticastSetAmmoInClip");

	Params::RGWeaponScript_MulticastSetAmmoInClip Parms{};

	Parms.NewAmmo = NewAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnBeginFire
// (Native, Public)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::OnBeginFire(int32 CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnBeginFire");

	Params::RGWeaponScript_OnBeginFire Parms{};

	Parms.CurrentAmmo = CurrentAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnBeginSecondaryFire
// (Native, Public)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::OnBeginSecondaryFire(int32 CurrentAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnBeginSecondaryFire");

	Params::RGWeaponScript_OnBeginSecondaryFire Parms{};

	Parms.CurrentAmmo = CurrentAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnEndFire
// (Native, Public)

void URGWeaponScript::OnEndFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnEndFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnEndSecondaryFire
// (Native, Public)

void URGWeaponScript::OnEndSecondaryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnEndSecondaryFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnEnemyKilled
// (Native, Public)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::OnEnemyKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnEnemyKilled");

	Params::RGWeaponScript_OnEnemyKilled Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnEquip
// (Native, Public)

void URGWeaponScript::OnEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnEquip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnProjectileSpawned
// (Native, Public)
// Parameters:
// class ARProjectileBase*                 SpawnedProjectile                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnProjectileSpawned");

	Params::RGWeaponScript_OnProjectileSpawned Parms{};

	Parms.SpawnedProjectile = SpawnedProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnProjectileSpawnedClientDummy
// (Native, Public, HasDefaults)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::OnProjectileSpawnedClientDummy(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnProjectileSpawnedClientDummy");

	Params::RGWeaponScript_OnProjectileSpawnedClientDummy Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnReload
// (Native, Public)

void URGWeaponScript::OnReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnReloadFinished
// (Native, Public)

void URGWeaponScript::OnReloadFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnReloadFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnRep_AmmoInClip
// (Final, Native, Private)

void URGWeaponScript::OnRep_AmmoInClip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnRep_AmmoInClip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.OnUnequip
// (Native, Public)

void URGWeaponScript::OnUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "OnUnequip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.ReloadAmmo
// (Final, Native, Public, BlueprintCallable)

void URGWeaponScript::ReloadAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ReloadAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.ServerRequestReload
// (Net, NetReliable, Native, Event, Public, NetServer)

void URGWeaponScript::ServerRequestReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "ServerRequestReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.SetBaseWeaponSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBaseWeaponSettings*             BaseSettings                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::SetBaseWeaponSettings(class URBaseWeaponSettings* BaseSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "SetBaseWeaponSettings");

	Params::RGWeaponScript_SetBaseWeaponSettings Parms{};

	Parms.BaseSettings = BaseSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.SetHasSingleShotReload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSingleShotReload                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::SetHasSingleShotReload(bool bSingleShotReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "SetHasSingleShotReload");

	Params::RGWeaponScript_SetHasSingleShotReload Parms{};

	Parms.bSingleShotReload = bSingleShotReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.SetIsAiming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bAiming                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::SetIsAiming(const bool bAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "SetIsAiming");

	Params::RGWeaponScript_SetIsAiming Parms{};

	Parms.bAiming = bAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.SetIsScoped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bScoped                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponScript::SetIsScoped(bool bScoped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "SetIsScoped");

	Params::RGWeaponScript_SetIsScoped Parms{};

	Parms.bScoped = bScoped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.SetLastTimeFired
// (Final, Native, Public, BlueprintCallable)

void URGWeaponScript::SetLastTimeFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "SetLastTimeFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.TryReload
// (Final, Native, Public)

void URGWeaponScript::TryReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "TryReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponScript.CalculateAilmentProcChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFloatWeaponStat                        ChanceStat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::CalculateAilmentProcChance(EFloatWeaponStat ChanceStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "CalculateAilmentProcChance");

	Params::RGWeaponScript_CalculateAilmentProcChance Parms{};

	Parms.ChanceStat = ChanceStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.CalculateProcChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::CalculateProcChance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "CalculateProcChance");

	Params::RGWeaponScript_CalculateProcChance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetAmmoInClip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGWeaponScript::GetAmmoInClip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetAmmoInClip");

	Params::RGWeaponScript_GetAmmoInClip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetBaseWeaponSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBaseWeaponSettings*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBaseWeaponSettings* URGWeaponScript::GetBaseWeaponSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetBaseWeaponSettings");

	Params::RGWeaponScript_GetBaseWeaponSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetFloatWeaponStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetFloatWeaponStat(EFloatWeaponStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetFloatWeaponStat");

	Params::RGWeaponScript_GetFloatWeaponStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetGlobalWeaponModifiers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGlobalWeaponModifiers*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGlobalWeaponModifiers* URGWeaponScript::GetGlobalWeaponModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetGlobalWeaponModifiers");

	Params::RGWeaponScript_GetGlobalWeaponModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetInputHoldingFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponScript::GetInputHoldingFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetInputHoldingFire");

	Params::RGWeaponScript_GetInputHoldingFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetInputHoldingSecondaryFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponScript::GetInputHoldingSecondaryFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetInputHoldingSecondaryFire");

	Params::RGWeaponScript_GetInputHoldingSecondaryFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetIntegerWeaponStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URGWeaponScript::GetIntegerWeaponStat(EIntegerWeaponStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetIntegerWeaponStat");

	Params::RGWeaponScript_GetIntegerWeaponStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetLastTimeFired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetLastTimeFired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetLastTimeFired");

	Params::RGWeaponScript_GetLastTimeFired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetMutableWeaponSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URMutableWeaponSettings*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URMutableWeaponSettings* URGWeaponScript::GetMutableWeaponSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetMutableWeaponSettings");

	Params::RGWeaponScript_GetMutableWeaponSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetMuzzleSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URGWeaponScript::GetMuzzleSocketName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetMuzzleSocketName");

	Params::RGWeaponScript_GetMuzzleSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetProjectileClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ARProjectileBase>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ARProjectileBase> URGWeaponScript::GetProjectileClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetProjectileClass");

	Params::RGWeaponScript_GetProjectileClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetProjectileDummyClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AActor>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> URGWeaponScript::GetProjectileDummyClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetProjectileDummyClass");

	Params::RGWeaponScript_GetProjectileDummyClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetRandomSpreadNormalDistribution
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D*                       SpreadError                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetRandomSpreadNormalDistribution(struct FVector2D* SpreadError) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetRandomSpreadNormalDistribution");

	Params::RGWeaponScript_GetRandomSpreadNormalDistribution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpreadError != nullptr)
		*SpreadError = std::move(Parms.SpreadError);

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetROFTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetROFTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetROFTime");

	Params::RGWeaponScript_GetROFTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetROFWaitTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetROFWaitTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetROFWaitTime");

	Params::RGWeaponScript_GetROFWaitTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetSpread
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetSpread() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetSpread");

	Params::RGWeaponScript_GetSpread Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetSpreadMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::GetSpreadMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetSpreadMultiplier");

	Params::RGWeaponScript_GetSpreadMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.GetWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARWeapon* URGWeaponScript::GetWeaponActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "GetWeaponActor");

	Params::RGWeaponScript_GetWeaponActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.RollAilmentProcChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFloatWeaponStat                        ChanceStat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGWeaponScript::RollAilmentProcChance(EFloatWeaponStat ChanceStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "RollAilmentProcChance");

	Params::RGWeaponScript_RollAilmentProcChance Parms{};

	Parms.ChanceStat = ChanceStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponScript.RollProcChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             Chance                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URGWeaponScript::RollProcChance(const float Chance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponScript", "RollProcChance");

	Params::RGWeaponScript_RollProcChance Parms{};

	Parms.Chance = Chance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.AddWeaponModCosmeticEditorOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URWeaponModPrimaryAsset*          WeaponMod                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::AddWeaponModCosmeticEditorOnly(class URWeaponModPrimaryAsset* WeaponMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "AddWeaponModCosmeticEditorOnly");

	Params::RWeapon_AddWeaponModCosmeticEditorOnly Parms{};

	Parms.WeaponMod = WeaponMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.AttachWeaponModCosmeticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class URWeaponModPrimaryAsset*    WeaponMod                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URStaticMeshComponent*>    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class URStaticMeshComponent*> ARWeapon::AttachWeaponModCosmeticMesh(const class URWeaponModPrimaryAsset* WeaponMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "AttachWeaponModCosmeticMesh");

	Params::RWeapon_AttachWeaponModCosmeticMesh Parms{};

	Parms.WeaponMod = WeaponMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.DestroyWeaponModCosmeticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::DestroyWeaponModCosmeticMesh(class UStaticMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "DestroyWeaponModCosmeticMesh");

	Params::RWeapon_DestroyWeaponModCosmeticMesh Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.GetEjectionPortTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ARWeapon::GetEjectionPortTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetEjectionPortTransform");

	Params::RWeapon_GetEjectionPortTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.GetGunMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ARWeapon::GetGunMeshComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetGunMeshComponent");

	Params::RWeapon_GetGunMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.GetMuzzleTransforms
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FTransform>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTransform> ARWeapon::GetMuzzleTransforms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetMuzzleTransforms");

	Params::RWeapon_GetMuzzleTransforms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.GetWeaponModPrimaryAssets
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class URWeaponModPrimaryAsset*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URWeaponModPrimaryAsset*> ARWeapon::GetWeaponModPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetWeaponModPrimaryAssets");

	Params::RWeapon_GetWeaponModPrimaryAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.GetWeaponPrimaryAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URWeaponPrimaryAsset*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URWeaponPrimaryAsset* ARWeapon::GetWeaponPrimaryAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetWeaponPrimaryAsset");

	Params::RWeapon_GetWeaponPrimaryAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.IsDefaultWeaponMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URWeaponModPrimaryAsset*          Mod                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARWeapon::IsDefaultWeaponMod(class URWeaponModPrimaryAsset* Mod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "IsDefaultWeaponMod");

	Params::RWeapon_IsDefaultWeaponMod Parms{};

	Parms.Mod = Mod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.K2_OnWeaponModCosmeticAttached
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class URWeaponModPrimaryAsset*    WeaponMod                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::K2_OnWeaponModCosmeticAttached(const class URWeaponModPrimaryAsset* WeaponMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "K2_OnWeaponModCosmeticAttached");

	Params::RWeapon_K2_OnWeaponModCosmeticAttached Parms{};

	Parms.WeaponMod = WeaponMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.K2_OnWeaponModCosmeticRemoved
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class URWeaponModPrimaryAsset*    WeaponMod                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::K2_OnWeaponModCosmeticRemoved(const class URWeaponModPrimaryAsset* WeaponMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "K2_OnWeaponModCosmeticRemoved");

	Params::RWeapon_K2_OnWeaponModCosmeticRemoved Parms{};

	Parms.WeaponMod = WeaponMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.OnRep_WeaponModPrimaryAssets
// (Final, Native, Private)

void ARWeapon::OnRep_WeaponModPrimaryAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "OnRep_WeaponModPrimaryAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.OnWeaponEquipped
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARWeapon::OnWeaponEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "OnWeaponEquipped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.OnWeaponFired
// (Final, Native, Public)
// Parameters:
// bool                                    IsPrimaryMod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::OnWeaponFired(bool IsPrimaryMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "OnWeaponFired");

	Params::RWeapon_OnWeaponFired Parms{};

	Parms.IsPrimaryMod = IsPrimaryMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.OnWeaponRemoved
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARWeapon::OnWeaponRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "OnWeaponRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.SetWeaponVisibility
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const bool                              bNewVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::SetWeaponVisibility(const bool bNewVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "SetWeaponVisibility");

	Params::RWeapon_SetWeaponVisibility Parms{};

	Parms.bNewVisible = bNewVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.SetWeaponVisible
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::SetWeaponVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "SetWeaponVisible");

	Params::RWeapon_SetWeaponVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.UpdateFOVValues
// (Final, Native, Public)
// Parameters:
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon::UpdateFOVValues(float FOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "UpdateFOVValues");

	Params::RWeapon_UpdateFOVValues Parms{};

	Parms.FOV = FOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeapon.GetEquippedWeaponModPrimaryAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EWeaponModType                    WeaponModType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URWeaponModPrimaryAsset*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URWeaponModPrimaryAsset* ARWeapon::GetEquippedWeaponModPrimaryAsset(const EWeaponModType WeaponModType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetEquippedWeaponModPrimaryAsset");

	Params::RWeapon_GetEquippedWeaponModPrimaryAsset Parms{};

	Parms.WeaponModType = WeaponModType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon.GetEquippedWeaponModRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EWeaponModType                    WeaponModType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARWeapon::GetEquippedWeaponModRank(const EWeaponModType WeaponModType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon", "GetEquippedWeaponModRank");

	Params::RWeapon_GetEquippedWeaponModRank Parms{};

	Parms.WeaponModType = WeaponModType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGWeaponSkillTreeMutatorScript.OnPlayerEquippedWeapon
// (Final, Native, Private)
// Parameters:
// class ARWeapon*                         RWeapon                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponSkillTreeMutatorScript::OnPlayerEquippedWeapon(class ARWeapon* RWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponSkillTreeMutatorScript", "OnPlayerEquippedWeapon");

	Params::RGWeaponSkillTreeMutatorScript_OnPlayerEquippedWeapon Parms{};

	Parms.RWeapon = RWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponSkillTreeMutatorScript.RefreshSkillTreeMutator
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URGWeaponSkillTreeMutatorScript::RefreshSkillTreeMutator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponSkillTreeMutatorScript", "RefreshSkillTreeMutator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RGWeaponSkillTreeMutatorScript.AddMutableWeaponFloatCoefficient
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const EFloatWeaponStat                  FloatWeaponStat                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponSkillTreeMutatorScript::AddMutableWeaponFloatCoefficient(const EFloatWeaponStat FloatWeaponStat, const float Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponSkillTreeMutatorScript", "AddMutableWeaponFloatCoefficient");

	Params::RGWeaponSkillTreeMutatorScript_AddMutableWeaponFloatCoefficient Parms{};

	Parms.FloatWeaponStat = FloatWeaponStat;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGWeaponSkillTreeMutatorScript.RemoveMutableWeaponFloatCoefficient
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const EFloatWeaponStat                  FloatWeaponStat                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGWeaponSkillTreeMutatorScript::RemoveMutableWeaponFloatCoefficient(const EFloatWeaponStat FloatWeaponStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGWeaponSkillTreeMutatorScript", "RemoveMutableWeaponFloatCoefficient");

	Params::RGWeaponSkillTreeMutatorScript_RemoveMutableWeaponFloatCoefficient Parms{};

	Parms.FloatWeaponStat = FloatWeaponStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealAltar.AddHealAltarSelectionForController
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsumed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARHealAltar::AddHealAltarSelectionForController(class APlayerController* PlayerController, bool bConsumed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealAltar", "AddHealAltarSelectionForController");

	Params::RHealAltar_AddHealAltarSelectionForController Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bConsumed = bConsumed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RHealthComponent.ApplyHealthDamage
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageSources                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasCritical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCausedBy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceKilled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamageClientPrediction                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRLightningDamageCombatEventData&LightningDamageCombatEventData                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              bIgnoreDamageModifiers                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLastDamageEventData             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLastDamageEventData URHealthComponent::ApplyHealthDamage(class AActor* DamagedActor, class AController* Instigator, class AActor* DamageCauser, float Damage, int32 DamageSources, const struct FVector& HitLocation, const struct FVector& ShotFromDirection, class UPrimitiveComponent* HitComponent, bool bWasCritical, class AActor* DamageCausedBy, bool bForceKilled, bool bDamageClientPrediction, const struct FRLightningDamageCombatEventData& LightningDamageCombatEventData, const bool bIgnoreDamageModifiers, class AActor* AvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RHealthComponent", "ApplyHealthDamage");

	Params::RHealthComponent_ApplyHealthDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Instigator = Instigator;
	Parms.DamageCauser = DamageCauser;
	Parms.Damage = Damage;
	Parms.DamageSources = DamageSources;
	Parms.HitLocation = std::move(HitLocation);
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.HitComponent = HitComponent;
	Parms.bWasCritical = bWasCritical;
	Parms.DamageCausedBy = DamageCausedBy;
	Parms.bForceKilled = bForceKilled;
	Parms.bDamageClientPrediction = bDamageClientPrediction;
	Parms.LightningDamageCombatEventData = std::move(LightningDamageCombatEventData);
	Parms.bIgnoreDamageModifiers = bIgnoreDamageModifiers;
	Parms.AvatarActor = AvatarActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.CanTakeDamageFromInstigator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::CanTakeDamageFromInstigator(class AActor* Instigator, class AActor* DamagedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RHealthComponent", "CanTakeDamageFromInstigator");

	Params::RHealthComponent_CanTakeDamageFromInstigator Parms{};

	Parms.Instigator = Instigator;
	Parms.DamagedActor = DamagedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetHealthComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     OwningActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URHealthComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URHealthComponent* URHealthComponent::GetHealthComponent(const class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RHealthComponent", "GetHealthComponent");

	Params::RHealthComponent_GetHealthComponent Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.HealActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorToHeal                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealType                               HealType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHealIfDead                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::HealActor(class AActor* Instigator, class AActor* ActorToHeal, EHealType HealType, float Value, bool bHealIfDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RHealthComponent", "HealActor");

	Params::RHealthComponent_HealActor Parms{};

	Parms.Instigator = Instigator;
	Parms.ActorToHeal = ActorToHeal;
	Parms.HealType = HealType;
	Parms.Value = Value;
	Parms.bHealIfDead = bHealIfDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.KillActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToKill                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::KillActor(class AActor* ActorToKill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RHealthComponent", "KillActor");

	Params::RHealthComponent_KillActor Parms{};

	Parms.ActorToKill = ActorToKill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.AddDamageSourceMaskImmunity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewImmunity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::AddDamageSourceMaskImmunity(int32 NewImmunity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "AddDamageSourceMaskImmunity");

	Params::RHealthComponent_AddDamageSourceMaskImmunity Parms{};

	Parms.NewImmunity = NewImmunity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.BarrierTimerFunction
// (Final, Native, Private)

void URHealthComponent::BarrierTimerFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "BarrierTimerFunction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.GetDamageMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRMutableFloat                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRMutableFloat URHealthComponent::GetDamageMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetDamageMultiplier");

	Params::RHealthComponent_GetDamageMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetIsDamaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::GetIsDamaged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetIsDamaged");

	Params::RHealthComponent_GetIsDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetMaxArmor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetMaxArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetMaxArmor");

	Params::RHealthComponent_GetMaxArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetMaxBarrier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetMaxBarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetMaxBarrier");

	Params::RHealthComponent_GetMaxBarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetMaxHealth");

	Params::RHealthComponent_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetMaxPlatings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URHealthComponent::GetMaxPlatings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetMaxPlatings");

	Params::RHealthComponent_GetMaxPlatings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetMissingHealthPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetMissingHealthPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetMissingHealthPercentage");

	Params::RHealthComponent_GetMissingHealthPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetRemainingBarrierTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetRemainingBarrierTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetRemainingBarrierTimer");

	Params::RHealthComponent_GetRemainingBarrierTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.OnDamageCombatEvent
// (Final, Native, Public)
// Parameters:
// const struct FDamageCombatEvent&        EventData                                              (Parm, NativeAccessSpecifierPublic)

void URHealthComponent::OnDamageCombatEvent(const struct FDamageCombatEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnDamageCombatEvent");

	Params::RHealthComponent_OnDamageCombatEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnDamageCombatEventServerValidated
// (Final, Native, Public)
// Parameters:
// const struct FDamageCombatEvent&        EventData                                              (Parm, NativeAccessSpecifierPublic)

void URHealthComponent::OnDamageCombatEventServerValidated(const struct FDamageCombatEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnDamageCombatEventServerValidated");

	Params::RHealthComponent_OnDamageCombatEventServerValidated Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnHealCombatEvent
// (Final, Native, Private)
// Parameters:
// const struct FHealCombatEvent&          EventData                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URHealthComponent::OnHealCombatEvent(const struct FHealCombatEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnHealCombatEvent");

	Params::RHealthComponent_OnHealCombatEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnRep_Invulnerable
// (Final, Native, Private)

void URHealthComponent::OnRep_Invulnerable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnRep_Invulnerable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnRep_MaxArmor
// (Final, Native, Private)

void URHealthComponent::OnRep_MaxArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnRep_MaxArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnRep_MaxBarrier
// (Final, Native, Private)

void URHealthComponent::OnRep_MaxBarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnRep_MaxBarrier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnRep_MaxHealth
// (Final, Native, Private)

void URHealthComponent::OnRep_MaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnRep_MaxHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnRep_MaxPlating
// (Final, Native, Private)

void URHealthComponent::OnRep_MaxPlating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnRep_MaxPlating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnSetArmorCombatEvent
// (Final, Native, Private)
// Parameters:
// const struct FSetArmorCombatEvent&      EventData                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URHealthComponent::OnSetArmorCombatEvent(const struct FSetArmorCombatEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnSetArmorCombatEvent");

	Params::RHealthComponent_OnSetArmorCombatEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnSetBarrierCombatEvent
// (Final, Native, Private)
// Parameters:
// const struct FSetBarrierCombatEvent&    EventData                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URHealthComponent::OnSetBarrierCombatEvent(const struct FSetBarrierCombatEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnSetBarrierCombatEvent");

	Params::RHealthComponent_OnSetBarrierCombatEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.OnSetHealthCombatEvent
// (Final, Native, Private)
// Parameters:
// const struct FSetHealthCombatEvent&     EventData                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URHealthComponent::OnSetHealthCombatEvent(const struct FSetHealthCombatEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "OnSetHealthCombatEvent");

	Params::RHealthComponent_OnSetHealthCombatEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.PushStatusText_Multicast
// (Net, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class AController*                      Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URHealthComponent*                HealthComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Text                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// ERFloatingTextType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::PushStatusText_Multicast(class AController* Instigator, class URHealthComponent* HealthComponent, const struct FVector& Location, const class FText& Text, ERFloatingTextType Type, bool bSkipDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "PushStatusText_Multicast");

	Params::RHealthComponent_PushStatusText_Multicast Parms{};

	Parms.Instigator = Instigator;
	Parms.HealthComponent = HealthComponent;
	Parms.Location = std::move(Location);
	Parms.Text = std::move(Text);
	Parms.Type = Type;
	Parms.bSkipDelay = bSkipDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.RemoveDamageSourceMaskImmunity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RemovedImmunity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::RemoveDamageSourceMaskImmunity(int32 RemovedImmunity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "RemoveDamageSourceMaskImmunity");

	Params::RHealthComponent_RemoveDamageSourceMaskImmunity Parms{};

	Parms.RemovedImmunity = RemovedImmunity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetCurrentArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetCurrentArmor(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetCurrentArmor");

	Params::RHealthComponent_SetCurrentArmor Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetCurrentBarrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetCurrentBarrier(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetCurrentBarrier");

	Params::RHealthComponent_SetCurrentBarrier Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetCurrentHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetCurrentHealth(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetCurrentHealth");

	Params::RHealthComponent_SetCurrentHealth Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetCurrentHealth_Server
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetCurrentHealth_Server(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetCurrentHealth_Server");

	Params::RHealthComponent_SetCurrentHealth_Server Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetDamageFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERDamageFlag                            NewDamageFlag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetDamageFlag(ERDamageFlag NewDamageFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetDamageFlag");

	Params::RHealthComponent_SetDamageFlag Parms{};

	Parms.NewDamageFlag = NewDamageFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetInvulnerable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewInvulnerable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ResetInvulnerability                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetInvulnerable(bool bNewInvulnerable, class FName Key, bool ResetInvulnerability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetInvulnerable");

	Params::RHealthComponent_SetInvulnerable Parms{};

	Parms.bNewInvulnerable = bNewInvulnerable;
	Parms.Key = Key;
	Parms.ResetInvulnerability = ResetInvulnerability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.SetPreventBarrierOverkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::SetPreventBarrierOverkill(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "SetPreventBarrierOverkill");

	Params::RHealthComponent_SetPreventBarrierOverkill Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.StartBarrierTimer_Multicast
// (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// float                                   RemoveDelay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URHealthComponent::StartBarrierTimer_Multicast(float RemoveDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "StartBarrierTimer_Multicast");

	Params::RHealthComponent_StartBarrierTimer_Multicast Parms{};

	Parms.RemoveDelay = RemoveDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.UpdateMaxArmor
// (Final, Native, Public, BlueprintCallable)

void URHealthComponent::UpdateMaxArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "UpdateMaxArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.UpdateMaxBarrier
// (Final, Native, Public, BlueprintCallable)

void URHealthComponent::UpdateMaxBarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "UpdateMaxBarrier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.UpdateMaxHealth
// (Final, Native, Public, BlueprintCallable)

void URHealthComponent::UpdateMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "UpdateMaxHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.UpdateMaxPlating
// (Final, Native, Public, BlueprintCallable)

void URHealthComponent::UpdateMaxPlating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "UpdateMaxPlating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RHealthComponent.GetCanNotBeDamaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::GetCanNotBeDamaged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetCanNotBeDamaged");

	Params::RHealthComponent_GetCanNotBeDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetCurrentBarrier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetCurrentBarrier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetCurrentBarrier");

	Params::RHealthComponent_GetCurrentBarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetCurrentHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URHealthComponent::GetCurrentHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetCurrentHealth");

	Params::RHealthComponent_GetCurrentHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetCurrentPlatings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URHealthComponent::GetCurrentPlatings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetCurrentPlatings");

	Params::RHealthComponent_GetCurrentPlatings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetDamageFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERDamageFlag                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERDamageFlag URHealthComponent::GetDamageFlag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetDamageFlag");

	Params::RHealthComponent_GetDamageFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetIgnoreExecutionerModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::GetIgnoreExecutionerModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetIgnoreExecutionerModifier");

	Params::RHealthComponent_GetIgnoreExecutionerModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetInstigatorFromLastDamageEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* URHealthComponent::GetInstigatorFromLastDamageEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetInstigatorFromLastDamageEvent");

	Params::RHealthComponent_GetInstigatorFromLastDamageEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetInvulnerable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::GetInvulnerable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetInvulnerable");

	Params::RHealthComponent_GetInvulnerable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetIsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::GetIsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetIsAlive");

	Params::RHealthComponent_GetIsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RHealthComponent.GetIsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URHealthComponent::GetIsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RHealthComponent", "GetIsDead");

	Params::RHealthComponent_GetIsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.CanInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRInteractableInterface::CanInteract(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "CanInteract");

	Params::RInteractableInterface_CanInteract Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.OnFocus
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRInteractableInterface::OnFocus(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "OnFocus");

	Params::RInteractableInterface_OnFocus Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RInteractableInterface.OnFocusGone
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRInteractableInterface::OnFocusGone(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "OnFocusGone");

	Params::RInteractableInterface_OnFocusGone Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RInteractableInterface.OnInteract
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRInteractableInterface::OnInteract(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "OnInteract");

	Params::RInteractableInterface_OnInteract Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RInteractableInterface.ToggleInteractionIndicatorVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              NewVisible                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRInteractableInterface::ToggleInteractionIndicatorVisibility(class AActor* InteractingActor, const bool NewVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "ToggleInteractionIndicatorVisibility");

	Params::RInteractableInterface_ToggleInteractionIndicatorVisibility Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.NewVisible = NewVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RInteractableInterface.GetInteractableAlternativeDescription
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IRInteractableInterface::GetInteractableAlternativeDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractableAlternativeDescription");

	Params::RInteractableInterface_GetInteractableAlternativeDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.GetInteractableCost
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IRInteractableInterface::GetInteractableCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractableCost");

	Params::RInteractableInterface_GetInteractableCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.GetInteractableCostCurrencyType
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IRInteractableInterface::GetInteractableCostCurrencyType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractableCostCurrencyType");

	Params::RInteractableInterface_GetInteractableCostCurrencyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.GetInteractableDescription
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IRInteractableInterface::GetInteractableDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractableDescription");

	Params::RInteractableInterface_GetInteractableDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.GetInteractableName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IRInteractableInterface::GetInteractableName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractableName");

	Params::RInteractableInterface_GetInteractableName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.GetInteractableSubHeader
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IRInteractableInterface::GetInteractableSubHeader() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractableSubHeader");

	Params::RInteractableInterface_GetInteractableSubHeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RInteractableInterface.GetInteractionIndicatorWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UWidgetComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetComponent* IRInteractableInterface::GetInteractionIndicatorWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RInteractableInterface", "GetInteractionIndicatorWidget");

	Params::RInteractableInterface_GetInteractionIndicatorWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RKillPlayerVolume.OnActorEnterArea
// (Final, Native, Public)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARKillPlayerVolume::OnActorEnterArea(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RKillPlayerVolume", "OnActorEnterArea");

	Params::RKillPlayerVolume_OnActorEnterArea Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerationInterface.ClearFromScene
// (Native, Event, Public, BlueprintEvent)

void IRLevelGenerationInterface::ClearFromScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RLevelGenerationInterface", "ClearFromScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerationInterface.ShouldClearFromScene
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRLevelGenerationInterface::ShouldClearFromScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RLevelGenerationInterface", "ShouldClearFromScene");

	Params::RLevelGenerationInterface_ShouldClearFromScene Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetLevelManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARLevelGenerator*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARLevelGenerator* ARLevelGenerator::GetLevelManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLevelGenerator", "GetLevelManager");

	Params::RLevelGenerator_GetLevelManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetCurrentLevelSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FLevelGenerationSettings> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLevelGenerationSettings> ARLevelGenerator::GetCurrentLevelSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCurrentLevelSettings");

	Params::RLevelGenerator_GetCurrentLevelSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetCurrentLevelSettingsWithLevelAttributeTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     LevelTags                                              (Parm, NativeAccessSpecifierPublic)
// TArray<struct FLevelGenerationSettings> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLevelGenerationSettings> ARLevelGenerator::GetCurrentLevelSettingsWithLevelAttributeTags(const struct FGameplayTagContainer& LevelTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCurrentLevelSettingsWithLevelAttributeTags");

	Params::RLevelGenerator_GetCurrentLevelSettingsWithLevelAttributeTags Parms{};

	Parms.LevelTags = std::move(LevelTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetCurrentLevelSettingsWithLevelTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     LevelTags                                              (Parm, NativeAccessSpecifierPublic)
// TArray<struct FLevelGenerationSettings> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLevelGenerationSettings> ARLevelGenerator::GetCurrentLevelSettingsWithLevelTags(const struct FGameplayTagContainer& LevelTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCurrentLevelSettingsWithLevelTags");

	Params::RLevelGenerator_GetCurrentLevelSettingsWithLevelTags Parms{};

	Parms.LevelTags = std::move(LevelTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetCurrentLoadingLevelsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARLevelGenerator::GetCurrentLoadingLevelsCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCurrentLoadingLevelsCount");

	Params::RLevelGenerator_GetCurrentLoadingLevelsCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetEncounterRoomPositionOfActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARLevelGenerator::GetEncounterRoomPositionOfActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetEncounterRoomPositionOfActor");

	Params::RLevelGenerator_GetEncounterRoomPositionOfActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetIsInLoadingScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::GetIsInLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetIsInLoadingScreen");

	Params::RLevelGenerator_GetIsInLoadingScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetLobbyElevatorSequenceActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::GetLobbyElevatorSequenceActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetLobbyElevatorSequenceActive");

	Params::RLevelGenerator_GetLobbyElevatorSequenceActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetUngluTeleportSequenceActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::GetUngluTeleportSequenceActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetUngluTeleportSequenceActive");

	Params::RLevelGenerator_GetUngluTeleportSequenceActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.IsActorInLastEncounterRoom
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutEncounterRoomPosition                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::IsActorInLastEncounterRoom(class AActor* Actor, int32* OutEncounterRoomPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "IsActorInLastEncounterRoom");

	Params::RLevelGenerator_IsActorInLastEncounterRoom Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEncounterRoomPosition != nullptr)
		*OutEncounterRoomPosition = Parms.OutEncounterRoomPosition;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.LoadLevelInstance
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const struct FLevelGenerationSettings&  LevelGenerationSettings                                (ConstParm, Parm, NativeAccessSpecifierPublic)

void ARLevelGenerator::LoadLevelInstance(const struct FLevelGenerationSettings& LevelGenerationSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "LoadLevelInstance");

	Params::RLevelGenerator_LoadLevelInstance Parms{};

	Parms.LevelGenerationSettings = std::move(LevelGenerationSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.Multicast_ClearDynamicActors
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ARLevelGenerator::Multicast_ClearDynamicActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "Multicast_ClearDynamicActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.OnUpdateLevelStreaming
// (Final, Native, Private)

void ARLevelGenerator::OnUpdateLevelStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "OnUpdateLevelStreaming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.PreLevelTransition_Multicast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ARLevelGenerator::PreLevelTransition_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "PreLevelTransition_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.PruneEventRoomChests
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LastCreatedChest                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLevelGenerator::PruneEventRoomChests(class AActor* LastCreatedChest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "PruneEventRoomChests");

	Params::RLevelGenerator_PruneEventRoomChests Parms{};

	Parms.LastCreatedChest = LastCreatedChest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.PruneNodeChoiceChests
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LastCreatedChest                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLevelGenerator::PruneNodeChoiceChests(class AActor* LastCreatedChest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "PruneNodeChoiceChests");

	Params::RLevelGenerator_PruneNodeChoiceChests Parms{};

	Parms.LastCreatedChest = LastCreatedChest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.RegisterPersistentActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLevelGenerator::RegisterPersistentActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "RegisterPersistentActor");

	Params::RLevelGenerator_RegisterPersistentActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.RegisterPersistentActorIfReplicated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLevelGenerator::RegisterPersistentActorIfReplicated(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "RegisterPersistentActorIfReplicated");

	Params::RLevelGenerator_RegisterPersistentActorIfReplicated Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.SetLobbyElevatorSequenceActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewLobbyElevatorSequenceActive                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLevelGenerator::SetLobbyElevatorSequenceActive(bool NewLobbyElevatorSequenceActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "SetLobbyElevatorSequenceActive");

	Params::RLevelGenerator_SetLobbyElevatorSequenceActive Parms{};

	Parms.NewLobbyElevatorSequenceActive = NewLobbyElevatorSequenceActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.SetUngluTeleportSequenceActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewUngluTeleportSequenceActive                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLevelGenerator::SetUngluTeleportSequenceActive(bool NewUngluTeleportSequenceActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "SetUngluTeleportSequenceActive");

	Params::RLevelGenerator_SetUngluTeleportSequenceActive Parms{};

	Parms.NewUngluTeleportSequenceActive = NewUngluTeleportSequenceActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLevelGenerator.GetCameFromMainMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::GetCameFromMainMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCameFromMainMenu");

	Params::RLevelGenerator_GetCameFromMainMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetCameFromTutorial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::GetCameFromTutorial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCameFromTutorial");

	Params::RLevelGenerator_GetCameFromTutorial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetCurrentLevelIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ARLevelGenerator::GetCurrentLevelIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetCurrentLevelIds");

	Params::RLevelGenerator_GetCurrentLevelIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.GetLastLevelIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ARLevelGenerator::GetLastLevelIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "GetLastLevelIds");

	Params::RLevelGenerator_GetLastLevelIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLevelGenerator.ShouldToggleLevelVisibilities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLevelGenerator::ShouldToggleLevelVisibilities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLevelGenerator", "ShouldToggleLevelVisibilities");

	Params::RLevelGenerator_ShouldToggleLevelVisibilities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootableActor.GetNumMutatorsSpawnedInCategory
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              CategoryTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIncludeTriggers                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARLootableActor::GetNumMutatorsSpawnedInCategory(const struct FGameplayTag& CategoryTag, const bool bIncludeTriggers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "GetNumMutatorsSpawnedInCategory");

	Params::RLootableActor_GetNumMutatorsSpawnedInCategory Parms{};

	Parms.CategoryTag = std::move(CategoryTag);
	Parms.bIncludeTriggers = bIncludeTriggers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootableActor.GetSpawnedItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARLootableActor::GetSpawnedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "GetSpawnedItems");

	Params::RLootableActor_GetSpawnedItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootableActor.HasRequiredMutatorPA
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLootableActor::HasRequiredMutatorPA(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "HasRequiredMutatorPA");

	Params::RLootableActor_HasRequiredMutatorPA Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootableActor.SetAssociatedSpawnAreaSegment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AREnemySpawnAreaSegment*          Segment                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableActor::SetAssociatedSpawnAreaSegment(class AREnemySpawnAreaSegment* Segment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "SetAssociatedSpawnAreaSegment");

	Params::RLootableActor_SetAssociatedSpawnAreaSegment Parms{};

	Parms.Segment = Segment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableActor.SetAvailableMutators
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMutatorRarity                          MutatorRarity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableActor::SetAvailableMutators(EMutatorRarity MutatorRarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "SetAvailableMutators");

	Params::RLootableActor_SetAvailableMutators Parms{};

	Parms.MutatorRarity = MutatorRarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableActor.ShouldShowOnRadarBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLootableActor::ShouldShowOnRadarBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "ShouldShowOnRadarBase");

	Params::RLootableActor_ShouldShowOnRadarBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootableActor.IsAssociatedSpawnAreaSegmentCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLootableActor::IsAssociatedSpawnAreaSegmentCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableActor", "IsAssociatedSpawnAreaSegmentCompleted");

	Params::RLootableActor_IsAssociatedSpawnAreaSegmentCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootableContainer.AddGeneratedLootOptionForController
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FRLootSelectionOption>&LootOption                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasChosenLoot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::AddGeneratedLootOptionForController(const TArray<struct FRLootSelectionOption>& LootOption, class APlayerController* PlayerController, bool bHasChosenLoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "AddGeneratedLootOptionForController");

	Params::RLootableContainer_AddGeneratedLootOptionForController Parms{};

	Parms.LootOption = std::move(LootOption);
	Parms.PlayerController = PlayerController;
	Parms.bHasChosenLoot = bHasChosenLoot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RLootableContainer.AddSacrificeCostForController
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewInteractionCost                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::AddSacrificeCostForController(int32 NewInteractionCost, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "AddSacrificeCostForController");

	Params::RLootableContainer_AddSacrificeCostForController Parms{};

	Parms.NewInteractionCost = NewInteractionCost;
	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RLootableContainer.AddWishingWellCostForController
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewInteractionCost                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UsesLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::AddWishingWellCostForController(int32 NewInteractionCost, int32 UsesLeft, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "AddWishingWellCostForController");

	Params::RLootableContainer_AddWishingWellCostForController Parms{};

	Parms.NewInteractionCost = NewInteractionCost;
	Parms.UsesLeft = UsesLeft;
	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RLootableContainer.OnRewardsHasBeenSpawned
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::OnRewardsHasBeenSpawned(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "OnRewardsHasBeenSpawned");

	Params::RLootableContainer_OnRewardsHasBeenSpawned Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableContainer.OnSpawnedItemPickedUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARPickupableItem*                 PickedUpItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PickupCost                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::OnSpawnedItemPickedUp(class ARPickupableItem* PickedUpItem, int32 PickupCost, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "OnSpawnedItemPickedUp");

	Params::RLootableContainer_OnSpawnedItemPickedUp Parms{};

	Parms.PickedUpItem = PickedUpItem;
	Parms.PickupCost = PickupCost;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableContainer.OnSpawnTrigBoxCompEntered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::OnSpawnTrigBoxCompEntered(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "OnSpawnTrigBoxCompEntered");

	Params::RLootableContainer_OnSpawnTrigBoxCompEntered Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableContainer.OnVoiceTrigBoxCompEntered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::OnVoiceTrigBoxCompEntered(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "OnVoiceTrigBoxCompEntered");

	Params::RLootableContainer_OnVoiceTrigBoxCompEntered Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableContainer.SetChestStateForController
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EChestState                             NewChestState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::SetChestStateForController(EChestState NewChestState, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "SetChestStateForController");

	Params::RLootableContainer_SetChestStateForController Parms{};

	Parms.NewChestState = NewChestState;
	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RLootableContainer.SetRewardSpawnPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::SetRewardSpawnPosition(const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "SetRewardSpawnPosition");

	Params::RLootableContainer_SetRewardSpawnPosition Parms{};

	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableContainer.SetupEventLogic
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARLootableContainer::SetupEventLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "SetupEventLogic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RLootableContainer.SpawnReplicatedReward_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRewardTableRow&           RewardRow                                              (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   SpawnPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::SpawnReplicatedReward_Multicast(class APlayerController* PlayerController, const struct FRewardTableRow& RewardRow, const struct FVector& SpawnPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "SpawnReplicatedReward_Multicast");

	Params::RLootableContainer_SpawnReplicatedReward_Multicast Parms{};

	Parms.PlayerController = PlayerController;
	Parms.RewardRow = std::move(RewardRow);
	Parms.SpawnPosition = std::move(SpawnPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootableContainer.SpawnRewards
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SpawnOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARLootableContainer::SpawnRewards(class APlayerController* PlayerController, const struct FVector& SpawnOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootableContainer", "SpawnRewards");

	Params::RLootableContainer_SpawnRewards Parms{};

	Parms.PlayerController = PlayerController;
	Parms.SpawnOffset = std::move(SpawnOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.AddFloatCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::AddFloatCoefficient(EFloatWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "AddFloatCoefficient");

	Params::RGlobalWeaponModifiers_AddFloatCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.AddFloatPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::AddFloatPostAdditive(EFloatWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "AddFloatPostAdditive");

	Params::RGlobalWeaponModifiers_AddFloatPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.AddFloatPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::AddFloatPreAdditive(EFloatWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "AddFloatPreAdditive");

	Params::RGlobalWeaponModifiers_AddFloatPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.AddIntegerCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::AddIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "AddIntegerCoefficient");

	Params::RGlobalWeaponModifiers_AddIntegerCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.AddIntegerPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::AddIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "AddIntegerPostAdditive");

	Params::RGlobalWeaponModifiers_AddIntegerPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.AddIntegerPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::AddIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "AddIntegerPreAdditive");

	Params::RGlobalWeaponModifiers_AddIntegerPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.GetFloatTotalPositiveCoefficients
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGlobalWeaponModifiers::GetFloatTotalPositiveCoefficients(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "GetFloatTotalPositiveCoefficients");

	Params::RGlobalWeaponModifiers_GetFloatTotalPositiveCoefficients Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGlobalWeaponModifiers.GetFloatTotalPositivePostAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGlobalWeaponModifiers::GetFloatTotalPositivePostAdditive(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "GetFloatTotalPositivePostAdditive");

	Params::RGlobalWeaponModifiers_GetFloatTotalPositivePostAdditive Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGlobalWeaponModifiers.GetFloatTotalPositivePreAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URGlobalWeaponModifiers::GetFloatTotalPositivePreAdditive(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "GetFloatTotalPositivePreAdditive");

	Params::RGlobalWeaponModifiers_GetFloatTotalPositivePreAdditive Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RGlobalWeaponModifiers.RemoveFloatCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::RemoveFloatCoefficient(EFloatWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "RemoveFloatCoefficient");

	Params::RGlobalWeaponModifiers_RemoveFloatCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.RemoveFloatPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::RemoveFloatPostAdditive(EFloatWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "RemoveFloatPostAdditive");

	Params::RGlobalWeaponModifiers_RemoveFloatPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.RemoveFloatPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::RemoveFloatPreAdditive(EFloatWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "RemoveFloatPreAdditive");

	Params::RGlobalWeaponModifiers_RemoveFloatPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.RemoveIntegerCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::RemoveIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "RemoveIntegerCoefficient");

	Params::RGlobalWeaponModifiers_RemoveIntegerCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.RemoveIntegerPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::RemoveIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "RemoveIntegerPostAdditive");

	Params::RGlobalWeaponModifiers_RemoveIntegerPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RGlobalWeaponModifiers.RemoveIntegerPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URGlobalWeaponModifiers::RemoveIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RGlobalWeaponModifiers", "RemoveIntegerPreAdditive");

	Params::RGlobalWeaponModifiers_RemoveIntegerPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootTableManager.CanMutatorBeDropped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URMutatorPrimaryAsset*      Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARLootTableManager::CanMutatorBeDropped(const class APlayerController* PlayerController, const class URMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "CanMutatorBeDropped");

	Params::RLootTableManager_CanMutatorBeDropped Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsBasedOnRewardTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FMutatorLootTableRow>&InRows                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsBasedOnRewardTag(const struct FGameplayTag& InTag, const TArray<struct FMutatorLootTableRow>& InRows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsBasedOnRewardTag");

	Params::RLootTableManager_FilterMutatorRowsBasedOnRewardTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InRows = std::move(InRows);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByFirstRandomAmount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&UnfilteredMutators                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MinAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByFirstRandomAmount(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators, int32 MinAmount, int32 MaxAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsByFirstRandomAmount");

	Params::RLootTableManager_FilterMutatorRowsByFirstRandomAmount Parms{};

	Parms.UnfilteredMutators = std::move(UnfilteredMutators);
	Parms.MinAmount = MinAmount;
	Parms.MaxAmount = MaxAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByLootability
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FMutatorLootTableRow>&UnfilteredMutators                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByLootability(const class APlayerController* PlayerController, const TArray<struct FMutatorLootTableRow>& UnfilteredMutators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsByLootability");

	Params::RLootTableManager_FilterMutatorRowsByLootability Parms{};

	Parms.PlayerController = PlayerController;
	Parms.UnfilteredMutators = std::move(UnfilteredMutators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByRarity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&UnfilteredMutators                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EMutatorRarity                          Rarity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByRarity(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators, EMutatorRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsByRarity");

	Params::RLootTableManager_FilterMutatorRowsByRarity Parms{};

	Parms.UnfilteredMutators = std::move(UnfilteredMutators);
	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&UnfilteredMutators                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByTags(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsByTags");

	Params::RLootTableManager_FilterMutatorRowsByTags Parms{};

	Parms.UnfilteredMutators = std::move(UnfilteredMutators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByTriggersAndPassivesWeighting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&InRows                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByTriggersAndPassivesWeighting(const TArray<struct FMutatorLootTableRow>& InRows, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsByTriggersAndPassivesWeighting");

	Params::RLootTableManager_FilterMutatorRowsByTriggersAndPassivesWeighting Parms{};

	Parms.InRows = std::move(InRows);
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByWeightedRandomRarity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&UnfilteredMutators                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TMap<EMutatorRarity, float>&      MutatorChances                                         (Parm, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByWeightedRandomRarity(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators, const TMap<EMutatorRarity, float>& MutatorChances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterMutatorRowsByWeightedRandomRarity");

	Params::RLootTableManager_FilterMutatorRowsByWeightedRandomRarity Parms{};

	Parms.UnfilteredMutators = std::move(UnfilteredMutators);
	Parms.MutatorChances = std::move(MutatorChances);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.FilterRewardCategoryRowsContainedInParentTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRewardTableRow>&   InRows                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRewardTableRow>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRewardTableRow> ARLootTableManager::FilterRewardCategoryRowsContainedInParentTag(const struct FGameplayTag& InTag, const TArray<struct FRewardTableRow>& InRows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "FilterRewardCategoryRowsContainedInParentTag");

	Params::RLootTableManager_FilterRewardCategoryRowsContainedInParentTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InRows = std::move(InRows);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetAbilitySpecificCharacterMutatorLootTableRows
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            AbilitySpecificMutatorPrimaryAsset                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetAbilitySpecificCharacterMutatorLootTableRows(const class APlayerController* PlayerController, class URMutatorPrimaryAsset* AbilitySpecificMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetAbilitySpecificCharacterMutatorLootTableRows");

	Params::RLootTableManager_GetAbilitySpecificCharacterMutatorLootTableRows Parms{};

	Parms.PlayerController = PlayerController;
	Parms.AbilitySpecificMutatorPrimaryAsset = AbilitySpecificMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetAllLogbookBlessings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> ARLootTableManager::GetAllLogbookBlessings(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetAllLogbookBlessings");

	Params::RLootTableManager_GetAllLogbookBlessings Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetAllLogbookCharms
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> ARLootTableManager::GetAllLogbookCharms(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetAllLogbookCharms");

	Params::RLootTableManager_GetAllLogbookCharms Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetCharmLootSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            CharmMutatorPA                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMutatorLootSettings             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMutatorLootSettings ARLootTableManager::GetCharmLootSettings(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* CharmMutatorPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetCharmLootSettings");

	Params::RLootTableManager_GetCharmLootSettings Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharmMutatorPA = CharmMutatorPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLootableOptionsByMutatorRewardCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorRewardCategoryDataAsset* RMutatorRewardCategoryDataAsset                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumOptions                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bFilterByLootableActorBlacklist                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRLootSelectionOption>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRLootSelectionOption> ARLootTableManager::GetLootableOptionsByMutatorRewardCategory(const class UObject* WorldContextObject, class URMutatorRewardCategoryDataAsset* RMutatorRewardCategoryDataAsset, const int32 NumOptions, const bool bFilterByLootableActorBlacklist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetLootableOptionsByMutatorRewardCategory");

	Params::RLootTableManager_GetLootableOptionsByMutatorRewardCategory Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorRewardCategoryDataAsset = RMutatorRewardCategoryDataAsset;
	Parms.NumOptions = NumOptions;
	Parms.bFilterByLootableActorBlacklist = bFilterByLootableActorBlacklist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLootTableAbilityMutatorRows
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetLootTableAbilityMutatorRows(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetLootTableAbilityMutatorRows");

	Params::RLootTableManager_GetLootTableAbilityMutatorRows Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLootTableCharmRows
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMutatorRarity                    Rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetLootTableCharmRows(const class APlayerController* PlayerController, const EMutatorRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetLootTableCharmRows");

	Params::RLootTableManager_GetLootTableCharmRows Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLootTableManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARLootTableManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARLootTableManager* ARLootTableManager::GetLootTableManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetLootTableManager");

	Params::RLootTableManager_GetLootTableManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLoottableMutatorRowsWithStandardFilters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMutatorRarity                    Rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetLoottableMutatorRowsWithStandardFilters(const class APlayerController* PlayerController, const EMutatorRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetLoottableMutatorRowsWithStandardFilters");

	Params::RLootTableManager_GetLoottableMutatorRowsWithStandardFilters Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetMutatorCategoryDataAssetByMutatorPrimaryAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorRewardCategoryDataAsset* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URMutatorRewardCategoryDataAsset* ARLootTableManager::GetMutatorCategoryDataAssetByMutatorPrimaryAsset(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetMutatorCategoryDataAssetByMutatorPrimaryAsset");

	Params::RLootTableManager_GetMutatorCategoryDataAssetByMutatorPrimaryAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetMutatorPrimaryAssetsFromRows
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&MutatorRows                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> ARLootTableManager::GetMutatorPrimaryAssetsFromRows(const TArray<struct FMutatorLootTableRow>& MutatorRows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetMutatorPrimaryAssetsFromRows");

	Params::RLootTableManager_GetMutatorPrimaryAssetsFromRows Parms{};

	Parms.MutatorRows = std::move(MutatorRows);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetMutatorRewardCategoryDataAssets
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorRewardCategoryDataAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorRewardCategoryDataAsset*> ARLootTableManager::GetMutatorRewardCategoryDataAssets(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetMutatorRewardCategoryDataAssets");

	Params::RLootTableManager_GetMutatorRewardCategoryDataAssets Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetMutatorRewardCategoryDataAssetsByTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InTags                                                 (Parm, NativeAccessSpecifierPublic)
// TArray<class URMutatorRewardCategoryDataAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorRewardCategoryDataAsset*> ARLootTableManager::GetMutatorRewardCategoryDataAssetsByTags(const class UObject* WorldContextObject, const struct FGameplayTagContainer& InTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetMutatorRewardCategoryDataAssetsByTags");

	Params::RLootTableManager_GetMutatorRewardCategoryDataAssetsByTags Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTags = std::move(InTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetNumLootableMutatorsInCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CategoryTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIncludeTriggers                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARLootTableManager::GetNumLootableMutatorsInCategory(class APlayerController* PlayerController, const struct FGameplayTag& CategoryTag, const bool bIncludeTriggers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetNumLootableMutatorsInCategory");

	Params::RLootTableManager_GetNumLootableMutatorsInCategory Parms{};

	Parms.PlayerController = PlayerController;
	Parms.CategoryTag = std::move(CategoryTag);
	Parms.bIncludeTriggers = bIncludeTriggers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetRankColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Rank                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ARLootTableManager::GetRankColor(const class UObject* WorldContextObject, const int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetRankColor");

	Params::RLootTableManager_GetRankColor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetUniqueRewardCategoriesFromRewardCategryoDataAssets
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class URMutatorRewardCategoryDataAsset*>&DataAssets                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer ARLootTableManager::GetUniqueRewardCategoriesFromRewardCategryoDataAssets(const TArray<class URMutatorRewardCategoryDataAsset*>& DataAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetUniqueRewardCategoriesFromRewardCategryoDataAssets");

	Params::RLootTableManager_GetUniqueRewardCategoriesFromRewardCategryoDataAssets Parms{};

	Parms.DataAssets = std::move(DataAssets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetWeightedRarity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<EMutatorRarity, float>&      MutatorChances                                         (Parm, NativeAccessSpecifierPublic)
// EMutatorRarity                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMutatorRarity ARLootTableManager::GetWeightedRarity(const TMap<EMutatorRarity, float>& MutatorChances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "GetWeightedRarity");

	Params::RLootTableManager_GetWeightedRarity Parms{};

	Parms.MutatorChances = std::move(MutatorChances);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.ShuffleMutatorRows
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&MutatorRows                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::ShuffleMutatorRows(const TArray<struct FMutatorLootTableRow>& MutatorRows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RLootTableManager", "ShuffleMutatorRows");

	Params::RLootTableManager_ShuffleMutatorRows Parms{};

	Parms.MutatorRows = std::move(MutatorRows);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.CopyMutatorDescriptionVariableRankValues
// (Final, Native, Public)

void ARLootTableManager::CopyMutatorDescriptionVariableRankValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "CopyMutatorDescriptionVariableRankValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RLootTableManager.FilterMutatorRowsByChallengeCompletion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FMutatorLootTableRow>&UnfilteredMutators                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::FilterMutatorRowsByChallengeCompletion(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "FilterMutatorRowsByChallengeCompletion");

	Params::RLootTableManager_FilterMutatorRowsByChallengeCompletion Parms{};

	Parms.UnfilteredMutators = std::move(UnfilteredMutators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetAllEnabledMutatorRows
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetAllEnabledMutatorRows()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "GetAllEnabledMutatorRows");

	Params::RLootTableManager_GetAllEnabledMutatorRows Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetEnabledMutatorRowsByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              CategoryTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetEnabledMutatorRowsByCategory(const struct FGameplayTag& CategoryTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "GetEnabledMutatorRowsByCategory");

	Params::RLootTableManager_GetEnabledMutatorRowsByCategory Parms{};

	Parms.CategoryTag = std::move(CategoryTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLootableCharmRows
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetLootableCharmRows(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "GetLootableCharmRows");

	Params::RLootTableManager_GetLootableCharmRows Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetLootableMutatorRows
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetLootableMutatorRows(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "GetLootableMutatorRows");

	Params::RLootTableManager_GetLootableMutatorRows Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetMutatorLootSettingsFromPrimaryAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorPrimaryAsset                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMutatorLootSettings             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMutatorLootSettings ARLootTableManager::GetMutatorLootSettingsFromPrimaryAsset(class URMutatorPrimaryAsset* MutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "GetMutatorLootSettingsFromPrimaryAsset");

	Params::RLootTableManager_GetMutatorLootSettingsFromPrimaryAsset Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RLootTableManager.GetMutatorRowsFromTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMutatorLootTableRow>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMutatorLootTableRow> ARLootTableManager::GetMutatorRowsFromTable(class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RLootTableManager", "GetMutatorRowsFromTable");

	Params::RLootTableManager_GetMutatorRowsFromTable Parms{};

	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMerchant.ClearSpawnedItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchant::ClearSpawnedItems(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "ClearSpawnedItems");

	Params::RMerchant_ClearSpawnedItems Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchant.GetNumUniqueGeneratedMutatorCategories
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARMerchant::GetNumUniqueGeneratedMutatorCategories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "GetNumUniqueGeneratedMutatorCategories");

	Params::RMerchant_GetNumUniqueGeneratedMutatorCategories Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RMerchant.OnItemSold
// (Final, Native, Public)
// Parameters:
// class ARPickupableItem*                 PickedUpItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchant::OnItemSold(class ARPickupableItem* PickedUpItem, int32 Cost, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "OnItemSold");

	Params::RMerchant_OnItemSold Parms{};

	Parms.PickedUpItem = PickedUpItem;
	Parms.Cost = Cost;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchant.OnSpawnTrigBoxCompEntered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchant::OnSpawnTrigBoxCompEntered(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "OnSpawnTrigBoxCompEntered");

	Params::RMerchant_OnSpawnTrigBoxCompEntered Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchant.ResetAvailableMutatorRewardCategoryDataAssets
// (Final, Native, Public, BlueprintCallable)

void ARMerchant::ResetAvailableMutatorRewardCategoryDataAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "ResetAvailableMutatorRewardCategoryDataAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchant.SpawnItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchant::SpawnItems(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "SpawnItems");

	Params::RMerchant_SpawnItems Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchant.UnhideExtraPlinths
// (Final, Native, Protected, BlueprintCallable)

void ARMerchant::UnhideExtraPlinths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchant", "UnhideExtraPlinths");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchantPlinth.CheckAndUpdateLootForController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchantPlinth::CheckAndUpdateLootForController(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchantPlinth", "CheckAndUpdateLootForController");

	Params::RMerchantPlinth_CheckAndUpdateLootForController Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchantPlinth.ClearSpawnedItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchantPlinth::ClearSpawnedItem(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchantPlinth", "ClearSpawnedItem");

	Params::RMerchantPlinth_ClearSpawnedItem Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchantPlinth.OnItemSold
// (Final, Native, Private)
// Parameters:
// class ARPickupableItem*                 PickedUpItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchantPlinth::OnItemSold(class ARPickupableItem* PickedUpItem, int32 Cost, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchantPlinth", "OnItemSold");

	Params::RMerchantPlinth_OnItemSold Parms{};

	Parms.PickedUpItem = PickedUpItem;
	Parms.Cost = Cost;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchantPlinth.OnMutatorPASet
// (Final, Native, Private)
// Parameters:
// class URMutatorPrimaryAsset*            NewPrimaryAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchantPlinth::OnMutatorPASet(class URMutatorPrimaryAsset* NewPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchantPlinth", "OnMutatorPASet");

	Params::RMerchantPlinth_OnMutatorPASet Parms{};

	Parms.NewPrimaryAsset = NewPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchantPlinth.SetLootOptionForController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FRLootSelectionOption>&NewMutatorLootSelection                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPlinthRewardType                       NewPlinthRewardType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            NewPrimaryAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorRewardCategoryDataAsset* NewGodCategory                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMerchantPlinth::SetLootOptionForController(const TArray<struct FRLootSelectionOption>& NewMutatorLootSelection, EPlinthRewardType NewPlinthRewardType, class URMutatorPrimaryAsset* NewPrimaryAsset, bool bLooted, class URMutatorRewardCategoryDataAsset* NewGodCategory, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchantPlinth", "SetLootOptionForController");

	Params::RMerchantPlinth_SetLootOptionForController Parms{};

	Parms.NewMutatorLootSelection = std::move(NewMutatorLootSelection);
	Parms.NewPlinthRewardType = NewPlinthRewardType;
	Parms.NewPrimaryAsset = NewPrimaryAsset;
	Parms.bLooted = bLooted;
	Parms.NewGodCategory = NewGodCategory;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMerchantPlinth.TurnOnCollision
// (Event, Public, BlueprintEvent)

void ARMerchantPlinth::TurnOnCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMerchantPlinth", "TurnOnCollision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RMusicManager.GetMusicManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARMusicManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARMusicManager* ARMusicManager::GetMusicManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RMusicManager", "GetMusicManager");

	Params::RMusicManager_GetMusicManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMusicManager.GetDurationFromWaveInCue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundCue*                        SoundCue                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WaveIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARMusicManager::GetDurationFromWaveInCue(class USoundCue* SoundCue, int32 WaveIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "GetDurationFromWaveInCue");

	Params::RMusicManager_GetDurationFromWaveInCue Parms{};

	Parms.SoundCue = SoundCue;
	Parms.WaveIndex = WaveIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMusicManager.GetLevelHasMusic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARMusicManager::GetLevelHasMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "GetLevelHasMusic");

	Params::RMusicManager_GetLevelHasMusic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMusicManager.K2_OnLevelChanged
// (Event, Public, BlueprintEvent)

void ARMusicManager::K2_OnLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "K2_OnLevelChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RMusicManager.OnBossPhaseStarted
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnBossPhaseStarted(class FName NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnBossPhaseStarted");

	Params::RMusicManager_OnBossPhaseStarted Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.OnBossPhaseStarted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class FName                             NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnBossPhaseStarted_Multicast(class FName NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnBossPhaseStarted_Multicast");

	Params::RMusicManager_OnBossPhaseStarted_Multicast Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.OnLevelChanged_Internal
// (Final, Native, Private)

void ARMusicManager::OnLevelChanged_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnLevelChanged_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.OnPlayerAlive
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnPlayerAlive(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnPlayerAlive");

	Params::RMusicManager_OnPlayerAlive Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.OnPlayerAlive_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnPlayerAlive_Multicast(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnPlayerAlive_Multicast");

	Params::RMusicManager_OnPlayerAlive_Multicast Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.OnPlayerDowned
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnPlayerDowned(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnPlayerDowned");

	Params::RMusicManager_OnPlayerDowned Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.OnPlayerDowned_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnPlayerDowned_Multicast(class ARPlayerPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnPlayerDowned_Multicast");

	Params::RMusicManager_OnPlayerDowned_Multicast Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.OnSegmentCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnSegmentCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnSegmentCompleted");

	Params::RMusicManager_OnSegmentCompleted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.OnSegmentCompleted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnSegmentCompleted_Multicast(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnSegmentCompleted_Multicast");

	Params::RMusicManager_OnSegmentCompleted_Multicast Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.OnSegmentStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnSegmentStarted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnSegmentStarted");

	Params::RMusicManager_OnSegmentStarted Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.OnSegmentStarted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          EnemySpawnAreaSegment                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::OnSegmentStarted_Multicast(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "OnSegmentStarted_Multicast");

	Params::RMusicManager_OnSegmentStarted_Multicast Parms{};

	Parms.EnemySpawnAreaSegment = EnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.PlayCurrentLevelMusic
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARMusicManager::PlayCurrentLevelMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "PlayCurrentLevelMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RMusicManager.PlayEmoteSong
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class USoundBase*                 EmoteSong                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ARPawnBase*                 RequestingPlayer                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::PlayEmoteSong(const class USoundBase* EmoteSong, const class ARPawnBase* RequestingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "PlayEmoteSong");

	Params::RMusicManager_PlayEmoteSong Parms{};

	Parms.EmoteSong = EmoteSong;
	Parms.RequestingPlayer = RequestingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.PlayEmoteSong_Multicast
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// const class USoundBase*                 EmoteSong                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ARPawnBase*                 RequestingPlayer                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::PlayEmoteSong_Multicast(const class USoundBase* EmoteSong, const class ARPawnBase* RequestingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "PlayEmoteSong_Multicast");

	Params::RMusicManager_PlayEmoteSong_Multicast Parms{};

	Parms.EmoteSong = EmoteSong;
	Parms.RequestingPlayer = RequestingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.PlayEmoteSongImplementation
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class USoundBase*                 EmoteSong                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ARPawnBase*                 RequestingPlayer                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::PlayEmoteSongImplementation(const class USoundBase* EmoteSong, const class ARPawnBase* RequestingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "PlayEmoteSongImplementation");

	Params::RMusicManager_PlayEmoteSongImplementation Parms{};

	Parms.EmoteSong = EmoteSong;
	Parms.RequestingPlayer = RequestingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.PlayEventMusic
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::PlayEventMusic(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "PlayEventMusic");

	Params::RMusicManager_PlayEventMusic Parms{};

	Parms.Event = Event;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RMusicManager.SetCurrentLevelMusicData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRLevelMusicData&          NewLevelMusicData                                      (Parm, NativeAccessSpecifierPublic)

void ARMusicManager::SetCurrentLevelMusicData(const struct FRLevelMusicData& NewLevelMusicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "SetCurrentLevelMusicData");

	Params::RMusicManager_SetCurrentLevelMusicData Parms{};

	Parms.NewLevelMusicData = std::move(NewLevelMusicData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.SetMusicData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URMusicData*                      NewMusicData                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARMusicManager::SetMusicData(class URMusicData* NewMusicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "SetMusicData");

	Params::RMusicManager_SetMusicData Parms{};

	Parms.NewMusicData = NewMusicData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMusicManager.UpdateLevelMusicData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     LevelTagIDContainer                                    (Parm, NativeAccessSpecifierPublic)
// class URAreaData*                       AreaData                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARMusicManager::UpdateLevelMusicData(const struct FGameplayTagContainer& LevelTagIDContainer, class URAreaData* AreaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMusicManager", "UpdateLevelMusicData");

	Params::RMusicManager_UpdateLevelMusicData Parms{};

	Parms.LevelTagIDContainer = std::move(LevelTagIDContainer);
	Parms.AreaData = AreaData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutatorLog.GetMutatorTiles
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTileView*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTileView* URMutatorLog::GetMutatorTiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorLog", "GetMutatorTiles");

	Params::RMutatorLog_GetMutatorTiles Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RMutatorLog.NativeFillGridByCategory
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              CategoryTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bClearFirst                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutatorLog::NativeFillGridByCategory(const struct FGameplayTag& CategoryTag, const bool bClearFirst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorLog", "NativeFillGridByCategory");

	Params::RMutatorLog_NativeFillGridByCategory Parms{};

	Parms.CategoryTag = std::move(CategoryTag);
	Parms.bClearFirst = bClearFirst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutatorLog.NativeFillGridByCharms
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const bool                              bClearFirst                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutatorLog::NativeFillGridByCharms(const bool bClearFirst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorLog", "NativeFillGridByCharms");

	Params::RMutatorLog_NativeFillGridByCharms Parms{};

	Parms.bClearFirst = bClearFirst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutatorLog.NativeFillGridByMutatorTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UDataTable*                       MutatorTable                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bClearFirst                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutatorLog::NativeFillGridByMutatorTable(class UDataTable* MutatorTable, const bool bClearFirst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutatorLog", "NativeFillGridByMutatorTable");

	Params::RMutatorLog_NativeFillGridByMutatorTable Parms{};

	Parms.MutatorTable = MutatorTable;
	Parms.bClearFirst = bClearFirst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.AbortPathfindingTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNavigationManager::AbortPathfindingTask(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "AbortPathfindingTask");

	Params::RNavigationManager_AbortPathfindingTask Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.CacheVoxelCollision
// (Final, Native, Public)

void ARNavigationManager::CacheVoxelCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "CacheVoxelCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.CanNavigate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERVoxelNavigationType                   NavigationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::CanNavigate(const struct FVector& Location, ERVoxelNavigationType NavigationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "CanNavigate");

	Params::RNavigationManager_CanNavigate Parms{};

	Parms.Location = std::move(Location);
	Parms.NavigationType = NavigationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.ClampLocationToNavigableWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   DesiredLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARNavigationManager::ClampLocationToNavigableWorld(const struct FVector& DesiredLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "ClampLocationToNavigableWorld");

	Params::RNavigationManager_ClampLocationToNavigableWorld Parms{};

	Parms.DesiredLocation = std::move(DesiredLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.ConstructBuilder
// (Final, Native, Public, BlueprintCallable)

void ARNavigationManager::ConstructBuilder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "ConstructBuilder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.Debug_ClearAllVolumes
// (Final, Native, Public, BlueprintCallable)

void ARNavigationManager::Debug_ClearAllVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "Debug_ClearAllVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.Debug_DrawAllVolumes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   LineThickness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNavigationManager::Debug_DrawAllVolumes(float LineThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "Debug_DrawAllVolumes");

	Params::RNavigationManager_Debug_DrawAllVolumes Parms{};

	Parms.LineThickness = LineThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.Debug_DrawVolumesAroundPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CubeSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawPersistentLines                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LineThickness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoInitializeVolumes                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNavigationManager::Debug_DrawVolumesAroundPoint(const struct FVector& Location, int32 CubeSize, bool DrawPersistentLines, float Duration, float LineThickness, bool bAutoInitializeVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "Debug_DrawVolumesAroundPoint");

	Params::RNavigationManager_Debug_DrawVolumesAroundPoint Parms{};

	Parms.Location = std::move(Location);
	Parms.CubeSize = CubeSize;
	Parms.DrawPersistentLines = DrawPersistentLines;
	Parms.Duration = Duration;
	Parms.LineThickness = LineThickness;
	Parms.bAutoInitializeVolumes = bAutoInitializeVolumes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.Debug_DrawVoxelCollisionProfile
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MeshOrPrimitive                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OriginLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawPersistent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNavigationManager::Debug_DrawVoxelCollisionProfile(class UPrimitiveComponent* MeshOrPrimitive, const struct FVector& OriginLocation, bool bDrawPersistent, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "Debug_DrawVoxelCollisionProfile");

	Params::RNavigationManager_Debug_DrawVoxelCollisionProfile Parms{};

	Parms.MeshOrPrimitive = MeshOrPrimitive;
	Parms.OriginLocation = std::move(OriginLocation);
	Parms.bDrawPersistent = bDrawPersistent;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.Debug_ToggleWorldBoundaryInGame
// (Final, Native, Public, BlueprintCallable)

void ARNavigationManager::Debug_ToggleWorldBoundaryInGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "Debug_ToggleWorldBoundaryInGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.FindPathSolution
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRNavigationQueryParams&   QueryParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRNavigationDebugParams&   DebugParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERVoxelNavigationType                   NavigationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowJump                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxJumpDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinFlightHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxFlightHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::FindPathSolution(class AActor* Actor, const struct FVector& Destination, const struct FRNavigationQueryParams& QueryParams, const struct FRNavigationDebugParams& DebugParams, ERVoxelNavigationType NavigationType, bool bAllowJump, float MaxJumpDistance, float MinFlightHeight, float MaxFlightHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "FindPathSolution");

	Params::RNavigationManager_FindPathSolution Parms{};

	Parms.Actor = Actor;
	Parms.Destination = std::move(Destination);
	Parms.QueryParams = std::move(QueryParams);
	Parms.DebugParams = std::move(DebugParams);
	Parms.NavigationType = NavigationType;
	Parms.bAllowJump = bAllowJump;
	Parms.MaxJumpDistance = MaxJumpDistance;
	Parms.MinFlightHeight = MinFlightHeight;
	Parms.MaxFlightHeight = MaxFlightHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.FindRandomPointAroundOriginInNavWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           NavigationActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bFoundValidResult                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDesiredAltitude                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxZAngularDispacement                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAttempts                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERVoxelNavigationType                   NavigationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARNavigationManager::FindRandomPointAroundOriginInNavWorld(class AActor* NavigationActor, const struct FVector& Origin, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts, ERVoxelNavigationType NavigationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "FindRandomPointAroundOriginInNavWorld");

	Params::RNavigationManager_FindRandomPointAroundOriginInNavWorld Parms{};

	Parms.NavigationActor = NavigationActor;
	Parms.Origin = std::move(Origin);
	Parms.Distance = Distance;
	Parms.MaxDesiredAltitude = MaxDesiredAltitude;
	Parms.MaxZAngularDispacement = MaxZAngularDispacement;
	Parms.MaxAttempts = MaxAttempts;
	Parms.NavigationType = NavigationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFoundValidResult != nullptr)
		*bFoundValidResult = Parms.bFoundValidResult;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.FindRandomPointFromActorInNavWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bFoundValidResult                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDesiredAltitude                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxZAngularDispacement                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAttempts                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERVoxelNavigationType                   NavigationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARNavigationManager::FindRandomPointFromActorInNavWorld(class AActor* Actor, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts, ERVoxelNavigationType NavigationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "FindRandomPointFromActorInNavWorld");

	Params::RNavigationManager_FindRandomPointFromActorInNavWorld Parms{};

	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.MaxDesiredAltitude = MaxDesiredAltitude;
	Parms.MaxZAngularDispacement = MaxZAngularDispacement;
	Parms.MaxAttempts = MaxAttempts;
	Parms.NavigationType = NavigationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFoundValidResult != nullptr)
		*bFoundValidResult = Parms.bFoundValidResult;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.GetClosestNavigableLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   DesiredLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERVoxelNavigationType                   NavigationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NeighborSearchMaxDepthOverride                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowClimbable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARNavigationManager::GetClosestNavigableLocation(const struct FVector& DesiredLocation, ERVoxelNavigationType NavigationType, int32 NeighborSearchMaxDepthOverride, bool bAllowClimbable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "GetClosestNavigableLocation");

	Params::RNavigationManager_GetClosestNavigableLocation Parms{};

	Parms.DesiredLocation = std::move(DesiredLocation);
	Parms.NavigationType = NavigationType;
	Parms.NeighborSearchMaxDepthOverride = NeighborSearchMaxDepthOverride;
	Parms.bAllowClimbable = bAllowClimbable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.HasTask
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::HasTask(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "HasTask");

	Params::RNavigationManager_HasTask Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.InitVoxelCollision
// (Final, Native, Public, BlueprintCallable)

void ARNavigationManager::InitVoxelCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "InitVoxelCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.IsDirectPathLineSweep
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              CollisionComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bFindInitialOverlaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CollisionShapeInflation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::IsDirectPathLineSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "IsDirectPathLineSweep");

	Params::RNavigationManager_IsDirectPathLineSweep Parms{};

	Parms.CollisionComponent = CollisionComponent;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.bFindInitialOverlaps = bFindInitialOverlaps;
	Parms.CollisionShapeInflation = CollisionShapeInflation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.IsDirectPathSweep
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              CollisionComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bFindInitialOverlaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CollisionShapeInflation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::IsDirectPathSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "IsDirectPathSweep");

	Params::RNavigationManager_IsDirectPathSweep Parms{};

	Parms.CollisionComponent = CollisionComponent;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.bFindInitialOverlaps = bFindInitialOverlaps;
	Parms.CollisionShapeInflation = CollisionShapeInflation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.IsLocationBeneathLandscape
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LineTraceHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::IsLocationBeneathLandscape(const struct FVector& Location, float LineTraceHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "IsLocationBeneathLandscape");

	Params::RNavigationManager_IsLocationBeneathLandscape Parms{};

	Parms.Location = std::move(Location);
	Parms.LineTraceHeight = LineTraceHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.IsLocationWithinNavigableWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   DesiredLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::IsLocationWithinNavigableWorld(const struct FVector& DesiredLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "IsLocationWithinNavigableWorld");

	Params::RNavigationManager_IsLocationWithinNavigableWorld Parms{};

	Parms.DesiredLocation = std::move(DesiredLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.IsMeshBoundsWithinNavigableWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BoundsScaleFactor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::IsMeshBoundsWithinNavigableWorld(class UPrimitiveComponent* Mesh, float BoundsScaleFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "IsMeshBoundsWithinNavigableWorld");

	Params::RNavigationManager_IsMeshBoundsWithinNavigableWorld Parms{};

	Parms.Mesh = Mesh;
	Parms.BoundsScaleFactor = BoundsScaleFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.ScheduleDynamicCollisionUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool bTaskSuccessful)>   ResultHandler                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomCacheIdentifier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplaceExistingTask                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableCacheUsage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReloadCollisionCache                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCheapBoundsCollision                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BoundsScaleFactor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSynchronousExecution                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawDebug                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::ScheduleDynamicCollisionUpdate(class UPrimitiveComponent* Mesh, TDelegate<void(bool bTaskSuccessful)> ResultHandler, class FName CustomCacheIdentifier, bool bReplaceExistingTask, bool bDisableCacheUsage, bool bReloadCollisionCache, bool bUseCheapBoundsCollision, float BoundsScaleFactor, bool bForceSynchronousExecution, bool bDrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "ScheduleDynamicCollisionUpdate");

	Params::RNavigationManager_ScheduleDynamicCollisionUpdate Parms{};

	Parms.Mesh = Mesh;
	Parms.ResultHandler = ResultHandler;
	Parms.CustomCacheIdentifier = CustomCacheIdentifier;
	Parms.bReplaceExistingTask = bReplaceExistingTask;
	Parms.bDisableCacheUsage = bDisableCacheUsage;
	Parms.bReloadCollisionCache = bReloadCollisionCache;
	Parms.bUseCheapBoundsCollision = bUseCheapBoundsCollision;
	Parms.BoundsScaleFactor = BoundsScaleFactor;
	Parms.bForceSynchronousExecution = bForceSynchronousExecution;
	Parms.bDrawDebug = bDrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.SchedulePathfindingTask
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRNavigationQueryParams&   QueryParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRNavigationDebugParams&   DebugParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FRNavigationQueryData& Data)>ResultHandlerDelegate                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)>DynamicCollisionListener                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERVoxelNavigationType                   NavigationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowJump                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxJumpDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinFlightHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxFlightHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARNavigationManager::SchedulePathfindingTask(class AActor* Actor, const struct FVector& Destination, const struct FRNavigationQueryParams& QueryParams, const struct FRNavigationDebugParams& DebugParams, TDelegate<void(const struct FRNavigationQueryData& Data)> ResultHandlerDelegate, TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> DynamicCollisionListener, ERVoxelNavigationType NavigationType, bool bAllowJump, float MaxJumpDistance, float MinFlightHeight, float MaxFlightHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "SchedulePathfindingTask");

	Params::RNavigationManager_SchedulePathfindingTask Parms{};

	Parms.Actor = Actor;
	Parms.Destination = std::move(Destination);
	Parms.QueryParams = std::move(QueryParams);
	Parms.DebugParams = std::move(DebugParams);
	Parms.ResultHandlerDelegate = ResultHandlerDelegate;
	Parms.DynamicCollisionListener = DynamicCollisionListener;
	Parms.NavigationType = NavigationType;
	Parms.bAllowJump = bAllowJump;
	Parms.MaxJumpDistance = MaxJumpDistance;
	Parms.MinFlightHeight = MinFlightHeight;
	Parms.MaxFlightHeight = MaxFlightHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNavigationManager.StopListeningToDynamicCollisionsForPath
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)>ListenerToClear                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRNavigationQueryData&     QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARNavigationManager::StopListeningToDynamicCollisionsForPath(TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> ListenerToClear, const struct FRNavigationQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "StopListeningToDynamicCollisionsForPath");

	Params::RNavigationManager_StopListeningToDynamicCollisionsForPath Parms{};

	Parms.ListenerToClear = ListenerToClear;
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.StopListeningToDynamicCollisionsForPathIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)>ListenerToClear                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRNavigationQueryData&     QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const int32                             VolumeIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNavigationManager::StopListeningToDynamicCollisionsForPathIndex(TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> ListenerToClear, const struct FRNavigationQueryData& QueryData, const int32 VolumeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "StopListeningToDynamicCollisionsForPathIndex");

	Params::RNavigationManager_StopListeningToDynamicCollisionsForPathIndex Parms{};

	Parms.ListenerToClear = ListenerToClear;
	Parms.QueryData = std::move(QueryData);
	Parms.VolumeIndex = VolumeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.VisualizeDynamicCollisionListeners
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)>Listener                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRNavigationQueryData&     QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARNavigationManager::VisualizeDynamicCollisionListeners(TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> Listener, const struct FRNavigationQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "VisualizeDynamicCollisionListeners");

	Params::RNavigationManager_VisualizeDynamicCollisionListeners Parms{};

	Parms.Listener = Listener;
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNavigationManager.VisualizeNAVResult
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           PathSolution                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Reset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRNavigationDebugParams&   DebugParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FColor&                    LineColor                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNavigationManager::VisualizeNAVResult(const TArray<struct FVector>& PathSolution, const struct FVector& Source, const struct FVector& Destination, bool Reset, const struct FRNavigationDebugParams& DebugParams, const struct FColor& LineColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNavigationManager", "VisualizeNAVResult");

	Params::RNavigationManager_VisualizeNAVResult Parms{};

	Parms.PathSolution = std::move(PathSolution);
	Parms.Source = std::move(Source);
	Parms.Destination = std::move(Destination);
	Parms.Reset = Reset;
	Parms.DebugParams = std::move(DebugParams);
	Parms.LineColor = std::move(LineColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNodeRewardSpawnPoint.SetCharmForController
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URMutatorPrimaryAsset*            CharmPrimaryAsset                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCharmPickedUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARNodeRewardSpawnPoint::SetCharmForController(class URMutatorPrimaryAsset* CharmPrimaryAsset, bool bCharmPickedUp, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNodeRewardSpawnPoint", "SetCharmForController");

	Params::RNodeRewardSpawnPoint_SetCharmForController Parms{};

	Parms.CharmPrimaryAsset = CharmPrimaryAsset;
	Parms.bCharmPickedUp = bCharmPickedUp;
	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RNotificationScreenWidget.PushNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Message                                                (Parm, NativeAccessSpecifierPublic)
// ERNotificationSeverity                  Severity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URNotificationScreenWidget::PushNotification(class APlayerController* PlayerController, const class FText& Message, ERNotificationSeverity Severity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RNotificationScreenWidget", "PushNotification");

	Params::RNotificationScreenWidget_PushNotification Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Message = std::move(Message);
	Parms.Severity = Severity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNotificationScreenWidget.PushPickupNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Message                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URNotificationScreenWidget::PushPickupNotification(class APlayerController* PlayerController, const class FText& Message, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RNotificationScreenWidget", "PushPickupNotification");

	Params::RNotificationScreenWidget_PushPickupNotification Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Message = std::move(Message);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RNotificationWidget.OnConstructAnimationFinished
// (Native, Public)

void URNotificationWidget::OnConstructAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNotificationWidget", "OnConstructAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.AddControlInputBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::AddControlInputBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "AddControlInputBlock");

	Params::RPawnMovementComponent_AddControlInputBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.AddDashBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::AddDashBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "AddDashBlock");

	Params::RPawnMovementComponent_AddDashBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::AddForce(const struct FVector& Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "AddForce");

	Params::RPawnMovementComponent_AddForce Parms{};

	Parms.Force = std::move(Force);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelocityChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "AddImpulse");

	Params::RPawnMovementComponent_AddImpulse Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.bVelocityChange = bVelocityChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.AddInputPhysicsBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::AddInputPhysicsBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "AddInputPhysicsBlock");

	Params::RPawnMovementComponent_AddInputPhysicsBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.AddJumpBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::AddJumpBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "AddJumpBlock");

	Params::RPawnMovementComponent_AddJumpBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ClearControlInputBlocks
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::ClearControlInputBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ClearControlInputBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ClearDashBlocks
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::ClearDashBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ClearDashBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ClearInputPhysicsBlocks
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::ClearInputPhysicsBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ClearInputPhysicsBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ClearJumpBlocks
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::ClearJumpBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ClearJumpBlocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ClearMovementTarget
// (Native, Public, BlueprintCallable)

void URPawnMovementComponent::ClearMovementTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ClearMovementTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ClearRotationTarget
// (Native, Public, BlueprintCallable)

void URPawnMovementComponent::ClearRotationTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ClearRotationTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.EndCharge
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EChargeEndedReason                      Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::EndCharge(EChargeEndedReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "EndCharge");

	Params::RPawnMovementComponent_EndCharge Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.FlushMovementStateLocation
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::FlushMovementStateLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "FlushMovementStateLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ForceStopAllMovementImmediatly
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::ForceStopAllMovementImmediatly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ForceStopAllMovementImmediatly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.Knockback
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelocityChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::Knockback(const struct FVector& Impulse, bool bVelocityChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "Knockback");

	Params::RPawnMovementComponent_Knockback Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.bVelocityChange = bVelocityChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.Launch
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::Launch(const struct FVector& LaunchVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "Launch");

	Params::RPawnMovementComponent_Launch Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.OnLevelChanged
// (Final, Native, Protected)

void URPawnMovementComponent::OnLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "OnLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.OnRep_PawnMovementInput
// (Final, Native, Public)

void URPawnMovementComponent::OnRep_PawnMovementInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "OnRep_PawnMovementInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.OnRep_PawnMovementState
// (Final, Native, Public)
// Parameters:
// const struct FRPawnMovementState&       OldState                                               (Parm, NativeAccessSpecifierPublic)

void URPawnMovementComponent::OnRep_PawnMovementState(const struct FRPawnMovementState& OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "OnRep_PawnMovementState");

	Params::RPawnMovementComponent_OnRep_PawnMovementState Parms{};

	Parms.OldState = std::move(OldState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.RemoveControlInputBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::RemoveControlInputBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "RemoveControlInputBlock");

	Params::RPawnMovementComponent_RemoveControlInputBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.RemoveDashBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::RemoveDashBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "RemoveDashBlock");

	Params::RPawnMovementComponent_RemoveDashBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.RemoveInputPhysicsBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::RemoveInputPhysicsBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "RemoveInputPhysicsBlock");

	Params::RPawnMovementComponent_RemoveInputPhysicsBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.RemoveJumpBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::RemoveJumpBlock(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "RemoveJumpBlock");

	Params::RPawnMovementComponent_RemoveJumpBlock Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SendStateAndInput_Server
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// const struct FRPawnMovementState&       NewState                                               (Parm, NativeAccessSpecifierPublic)
// const struct FRPawnMovementInput&       NewInput                                               (Parm, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SendStateAndInput_Server(const struct FRPawnMovementState& NewState, const struct FRPawnMovementInput& NewInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SendStateAndInput_Server");

	Params::RPawnMovementComponent_SendStateAndInput_Server Parms{};

	Parms.NewState = std::move(NewState);
	Parms.NewInput = std::move(NewInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ServerDoJump
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// uint32                                  EventId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   JumpHeightMultiplier                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::ServerDoJump(uint32 EventId, float JumpHeightMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ServerDoJump");

	Params::RPawnMovementComponent_ServerDoJump Parms{};

	Parms.EventId = EventId;
	Parms.JumpHeightMultiplier = JumpHeightMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.ServerSetInput
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// const struct FRPawnMovementInput&       NewInput                                               (Parm, NativeAccessSpecifierPublic)

void URPawnMovementComponent::ServerSetInput(const struct FRPawnMovementInput& NewInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "ServerSetInput");

	Params::RPawnMovementComponent_ServerSetInput Parms{};

	Parms.NewInput = std::move(NewInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SetFrozenBounceOnWalls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewFrozenBounceOnWalls                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SetFrozenBounceOnWalls(bool bNewFrozenBounceOnWalls)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SetFrozenBounceOnWalls");

	Params::RPawnMovementComponent_SetFrozenBounceOnWalls Parms{};

	Parms.bNewFrozenBounceOnWalls = bNewFrozenBounceOnWalls;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SetLastWalkingLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideFailsafeTeleportLocation                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SetLastWalkingLocation(const struct FVector& Location, bool bOverrideFailsafeTeleportLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SetLastWalkingLocation");

	Params::RPawnMovementComponent_SetLastWalkingLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.bOverrideFailsafeTeleportLocation = bOverrideFailsafeTeleportLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SetMovementInput
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 NewMovementInput                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SetMovementInput(const struct FVector2D& NewMovementInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SetMovementInput");

	Params::RPawnMovementComponent_SetMovementInput Parms{};

	Parms.NewMovementInput = std::move(NewMovementInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SetMovementTargetActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SetMovementTargetActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SetMovementTargetActor");

	Params::RPawnMovementComponent_SetMovementTargetActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SetRotationTargetActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideVectorRotationLock                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SetRotationTargetActor(class AActor* Actor, bool bOverrideVectorRotationLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SetRotationTargetActor");

	Params::RPawnMovementComponent_SetRotationTargetActor Parms{};

	Parms.Actor = Actor;
	Parms.bOverrideVectorRotationLock = bOverrideVectorRotationLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.SetRotationTargetLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewLockRotationToVector                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::SetRotationTargetLocation(const struct FVector& Location, bool bNewLockRotationToVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "SetRotationTargetLocation");

	Params::RPawnMovementComponent_SetRotationTargetLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.bNewLockRotationToVector = bNewLockRotationToVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartChargeActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetReachedTolerance                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEndOnTargetReached                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::StartChargeActor(class AActor* Actor, float TargetReachedTolerance, float SpeedMultiplier, float TimeLimit, bool bEndOnTargetReached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartChargeActor");

	Params::RPawnMovementComponent_StartChargeActor Parms{};

	Parms.Actor = Actor;
	Parms.TargetReachedTolerance = TargetReachedTolerance;
	Parms.SpeedMultiplier = SpeedMultiplier;
	Parms.TimeLimit = TimeLimit;
	Parms.bEndOnTargetReached = bEndOnTargetReached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartChargeDirection
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBounceOnWalls                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopOnWalls                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBounceOnPits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopOnPits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::StartChargeDirection(const struct FVector& Direction, float SpeedMultiplier, float TimeLimit, bool bBounceOnWalls, bool bStopOnWalls, bool bBounceOnPits, bool bStopOnPits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartChargeDirection");

	Params::RPawnMovementComponent_StartChargeDirection Parms{};

	Parms.Direction = std::move(Direction);
	Parms.SpeedMultiplier = SpeedMultiplier;
	Parms.TimeLimit = TimeLimit;
	Parms.bBounceOnWalls = bBounceOnWalls;
	Parms.bStopOnWalls = bStopOnWalls;
	Parms.bBounceOnPits = bBounceOnPits;
	Parms.bStopOnPits = bStopOnPits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartChargeLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetReachedTolerance                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEndOnTargetReached                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::StartChargeLocation(const struct FVector& Location, float TargetReachedTolerance, float SpeedMultiplier, float TimeLimit, bool bEndOnTargetReached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartChargeLocation");

	Params::RPawnMovementComponent_StartChargeLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.TargetReachedTolerance = TargetReachedTolerance;
	Parms.SpeedMultiplier = SpeedMultiplier;
	Parms.TimeLimit = TimeLimit;
	Parms.bEndOnTargetReached = bEndOnTargetReached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartDash
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceMultiplier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::StartDash(const struct FVector& WorldDirection, float SpeedMultiplier, float DistanceMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartDash");

	Params::RPawnMovementComponent_StartDash Parms{};

	Parms.WorldDirection = std::move(WorldDirection);
	Parms.SpeedMultiplier = SpeedMultiplier;
	Parms.DistanceMultiplier = DistanceMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartDirectLerp
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::StartDirectLerp(const struct FVector& TargetLocation, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartDirectLerp");

	Params::RPawnMovementComponent_StartDirectLerp Parms{};

	Parms.TargetLocation = std::move(TargetLocation);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartFixedCurve
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndWorldLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      TimeModifier                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::StartFixedCurve(class UCurveFloat* Curve, const struct FVector& EndWorldLocation, float BaseTime, class UCurveFloat* TimeModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartFixedCurve");

	Params::RPawnMovementComponent_StartFixedCurve Parms{};

	Parms.Curve = Curve;
	Parms.EndWorldLocation = std::move(EndWorldLocation);
	Parms.BaseTime = BaseTime;
	Parms.TimeModifier = TimeModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StartFlying
// (Native, Public, BlueprintCallable)

void URPawnMovementComponent::StartFlying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StartFlying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StopAllHorizontalMovementImmediately
// (Final, Native, Public, BlueprintCallable)

void URPawnMovementComponent::StopAllHorizontalMovementImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StopAllHorizontalMovementImmediately");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StopDirectLerp
// (Native, Public, BlueprintCallable)

void URPawnMovementComponent::StopDirectLerp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StopDirectLerp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.StopFlying
// (Native, Public, BlueprintCallable)

void URPawnMovementComponent::StopFlying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "StopFlying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.TeleportActor
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPawnMovementComponent::TeleportActor(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "TeleportActor");

	Params::RPawnMovementComponent_TeleportActor Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPawnMovementComponent.TryJump
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   JumpHeightMultiplier                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPawnMovementComponent::TryJump(float JumpHeightMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "TryJump");

	Params::RPawnMovementComponent_TryJump Parms{};

	Parms.JumpHeightMultiplier = JumpHeightMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.GetSurfaceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface URPawnMovementComponent::GetSurfaceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "GetSurfaceType");

	Params::RPawnMovementComponent_GetSurfaceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.GetWorldInputVector
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URPawnMovementComponent::GetWorldInputVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "GetWorldInputVector");

	Params::RPawnMovementComponent_GetWorldInputVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.IsControlInputBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPawnMovementComponent::IsControlInputBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "IsControlInputBlocked");

	Params::RPawnMovementComponent_IsControlInputBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.IsDashingBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPawnMovementComponent::IsDashingBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "IsDashingBlocked");

	Params::RPawnMovementComponent_IsDashingBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.IsInputPhysicsBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPawnMovementComponent::IsInputPhysicsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "IsInputPhysicsBlocked");

	Params::RPawnMovementComponent_IsInputPhysicsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.IsJumpingBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPawnMovementComponent::IsJumpingBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "IsJumpingBlocked");

	Params::RPawnMovementComponent_IsJumpingBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.IsWalkableAngle
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPawnMovementComponent::IsWalkableAngle(const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "IsWalkableAngle");

	Params::RPawnMovementComponent_IsWalkableAngle Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPawnMovementComponent.MovementInput
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D URPawnMovementComponent::MovementInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPawnMovementComponent", "MovementInput");

	Params::RPawnMovementComponent_MovementInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RNPCPawnMovementComponent.UpdateWalkingTime
// (Final, Native, Private)

void URNPCPawnMovementComponent::UpdateWalkingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RNPCPawnMovementComponent", "UpdateWalkingTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RObjectHighlightWidget.SetInfo
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      ObjectName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URObjectHighlightWidget::SetInfo(const class FText& ObjectName, const class FText& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RObjectHighlightWidget", "SetInfo");

	Params::RObjectHighlightWidget_SetInfo Parms{};

	Parms.ObjectName = std::move(ObjectName);
	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.ROffScreenIndicatorWidget.GetDirectionImage
// (Event, Public, BlueprintEvent)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UROffScreenIndicatorWidget::GetDirectionImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROffScreenIndicatorWidget", "GetDirectionImage");

	Params::ROffScreenIndicatorWidget_GetDirectionImage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.ROffScreenIndicatorWidget.Setup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCanvasPanel*                     CanvasPanel                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UROffScreenIndicatorWidget::Setup(class UCanvasPanel* CanvasPanel, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROffScreenIndicatorWidget", "Setup");

	Params::ROffScreenIndicatorWidget_Setup Parms{};

	Parms.CanvasPanel = CanvasPanel;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROffScreenIndicatorWidget.TickUpdate
// (Final, Native, Public, BlueprintCallable)

void UROffScreenIndicatorWidget::TickUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROffScreenIndicatorWidget", "TickUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROnlineSubsystem.ClearNetworkFailure
// (Final, Native, Public, BlueprintCallable)

void UROnlineSubsystem::ClearNetworkFailure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROnlineSubsystem", "ClearNetworkFailure");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROnlineSubsystem.KickPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UROnlineSubsystem::KickPlayer(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROnlineSubsystem", "KickPlayer");

	Params::ROnlineSubsystem_KickPlayer Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROnlineSubsystem.HasNetworkFailure
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UROnlineSubsystem::HasNetworkFailure() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROnlineSubsystem", "HasNetworkFailure");

	Params::ROnlineSubsystem_HasNetworkFailure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROnlineSubsystem.IsDLCInstalled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    DLCId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UROnlineSubsystem::IsDLCInstalled(const class FString& DLCId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROnlineSubsystem", "IsDLCInstalled");

	Params::ROnlineSubsystem_IsDLCInstalled Parms{};

	Parms.DLCId = std::move(DLCId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetOverworldManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AROverworldManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AROverworldManager* AROverworldManager::GetOverworldManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ROverworldManager", "GetOverworldManager");

	Params::ROverworldManager_GetOverworldManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.AddEncounterExtraRewardData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             SoftRewardClass                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class URAreaData>        SoftFixedAreaData                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::AddEncounterExtraRewardData(TSoftClassPtr<class UClass> SoftRewardClass, TSoftObjectPtr<class URAreaData> SoftFixedAreaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "AddEncounterExtraRewardData");

	Params::ROverworldManager_AddEncounterExtraRewardData Parms{};

	Parms.SoftRewardClass = SoftRewardClass;
	Parms.SoftFixedAreaData = SoftFixedAreaData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.AddExtraLevelEntryToArea
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class URAreaData*                       AreaData                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRExtraLevelEntry&         NewExtraLevelEntry                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AROverworldManager::AddExtraLevelEntryToArea(class URAreaData* AreaData, const struct FRExtraLevelEntry& NewExtraLevelEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "AddExtraLevelEntryToArea");

	Params::ROverworldManager_AddExtraLevelEntryToArea Parms{};

	Parms.AreaData = AreaData;
	Parms.NewExtraLevelEntry = std::move(NewExtraLevelEntry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.BroadcastOnNodeCompletedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void AROverworldManager::BroadcastOnNodeCompletedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "BroadcastOnNodeCompletedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.ClearCorruptedNodeChoiceScripts
// (Final, Native, Public, BlueprintCallable)

void AROverworldManager::ClearCorruptedNodeChoiceScripts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "ClearCorruptedNodeChoiceScripts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.ClearNodeChoicePairs
// (Final, Native, Public, BlueprintCallable)

void AROverworldManager::ClearNodeChoicePairs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "ClearNodeChoicePairs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.ClearNodeChoiceVoteData
// (Final, Native, Public, BlueprintCallable)

void AROverworldManager::ClearNodeChoiceVoteData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "ClearNodeChoiceVoteData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.GetAreaIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetAreaIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetAreaIndex");

	Params::ROverworldManager_GetAreaIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetCompletedNodeIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> AROverworldManager::GetCompletedNodeIds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetCompletedNodeIds");

	Params::ROverworldManager_GetCompletedNodeIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetCurrentAreaBossNodeId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetCurrentAreaBossNodeId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetCurrentAreaBossNodeId");

	Params::ROverworldManager_GetCurrentAreaBossNodeId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetCurrentNodeData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URNodeData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URNodeData* AROverworldManager::GetCurrentNodeData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetCurrentNodeData");

	Params::ROverworldManager_GetCurrentNodeData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetCurrentNodeId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetCurrentNodeId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetCurrentNodeId");

	Params::ROverworldManager_GetCurrentNodeId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetCurrentOverworldArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FROverworldArea                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FROverworldArea AROverworldManager::GetCurrentOverworldArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetCurrentOverworldArea");

	Params::ROverworldManager_GetCurrentOverworldArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetDepth");

	Params::ROverworldManager_GetDepth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetDepthInCurrentArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetDepthInCurrentArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetDepthInCurrentArea");

	Params::ROverworldManager_GetDepthInCurrentArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetEncounterRoomPositionOfActorInOverworld
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetEncounterRoomPositionOfActorInOverworld(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetEncounterRoomPositionOfActorInOverworld");

	Params::ROverworldManager_GetEncounterRoomPositionOfActorInOverworld Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetLevelIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetLevelIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetLevelIndex");

	Params::ROverworldManager_GetLevelIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetNextNodeId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetNextNodeId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetNextNodeId");

	Params::ROverworldManager_GetNextNodeId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetNextOverworldArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FROverworldArea                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FROverworldArea AROverworldManager::GetNextOverworldArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetNextOverworldArea");

	Params::ROverworldManager_GetNextOverworldArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetNodeChoicePAWithHighestVote
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FRNodeChoiceVoteData>&NodeChoiceDataVotes                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              bGetRewardPA                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URNodeChoicePrimaryAsset*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URNodeChoicePrimaryAsset* AROverworldManager::GetNodeChoicePAWithHighestVote(const TArray<struct FRNodeChoiceVoteData>& NodeChoiceDataVotes, const bool bGetRewardPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetNodeChoicePAWithHighestVote");

	Params::ROverworldManager_GetNodeChoicePAWithHighestVote Parms{};

	Parms.NodeChoiceDataVotes = std::move(NodeChoiceDataVotes);
	Parms.bGetRewardPA = bGetRewardPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetNumCompletedNodesInCurrentArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetNumCompletedNodesInCurrentArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetNumCompletedNodesInCurrentArea");

	Params::ROverworldManager_GetNumCompletedNodesInCurrentArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetNumTotalCompletedNodes
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetNumTotalCompletedNodes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetNumTotalCompletedNodes");

	Params::ROverworldManager_GetNumTotalCompletedNodes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetOverworldAreas
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FROverworldArea>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FROverworldArea> AROverworldManager::GetOverworldAreas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetOverworldAreas");

	Params::ROverworldManager_GetOverworldAreas Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetOverworldAreasInGameLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FROverworldArea>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FROverworldArea> AROverworldManager::GetOverworldAreasInGameLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetOverworldAreasInGameLoop");

	Params::ROverworldManager_GetOverworldAreasInGameLoop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetOverworldNodeById
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FROverworldNode                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FROverworldNode AROverworldManager::GetOverworldNodeById(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetOverworldNodeById");

	Params::ROverworldManager_GetOverworldNodeById Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetRowIndexByNodeId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetRowIndexByNodeId(int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetRowIndexByNodeId");

	Params::ROverworldManager_GetRowIndexByNodeId Parms{};

	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.GetRowOfNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AROverworldManager::GetRowOfNode(int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "GetRowOfNode");

	Params::ROverworldManager_GetRowOfNode Parms{};

	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.HasPlayerVotedForCorruptedNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::HasPlayerVotedForCorruptedNode(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "HasPlayerVotedForCorruptedNode");

	Params::ROverworldManager_HasPlayerVotedForCorruptedNode Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsCurrentPortalCorrupted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsCurrentPortalCorrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsCurrentPortalCorrupted");

	Params::ROverworldManager_IsCurrentPortalCorrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsInLastArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsInLastArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsInLastArea");

	Params::ROverworldManager_IsInLastArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsNodeIdInCurrentArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             NodeID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsNodeIdInCurrentArea(const int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsNodeIdInCurrentArea");

	Params::ROverworldManager_IsNodeIdInCurrentArea Parms{};

	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsNodePlayable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FROverworldNode&           Node                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsNodePlayable(const struct FROverworldNode& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsNodePlayable");

	Params::ROverworldManager_IsNodePlayable Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsOnLastNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsOnLastNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsOnLastNode");

	Params::ROverworldManager_IsOnLastNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.NodeSelected
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const int32                             SelectedNodeId                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             PlayerId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::NodeSelected(const int32 SelectedNodeId, const int32 PlayerId, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "NodeSelected");

	Params::ROverworldManager_NodeSelected Parms{};

	Parms.SelectedNodeId = SelectedNodeId;
	Parms.PlayerId = PlayerId;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.OnLevelChanged
// (Final, Native, Private)

void AROverworldManager::OnLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "OnLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.OnLevelsUnloadedOnAreaChange
// (Final, Native, Private)

void AROverworldManager::OnLevelsUnloadedOnAreaChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "OnLevelsUnloadedOnAreaChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.OnPreLevelChanged
// (Final, Native, Private)

void AROverworldManager::OnPreLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "OnPreLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.RandomizeCorruptedNodeChoices
// (Final, Native, Public, BlueprintCallable)

void AROverworldManager::RandomizeCorruptedNodeChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "RandomizeCorruptedNodeChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.RemoveEncounterExtraRewardData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             SoftRewardClass                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class URAreaData>        SoftFixedAreaData                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::RemoveEncounterExtraRewardData(TSoftClassPtr<class UClass> SoftRewardClass, TSoftObjectPtr<class URAreaData> SoftFixedAreaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "RemoveEncounterExtraRewardData");

	Params::ROverworldManager_RemoveEncounterExtraRewardData Parms{};

	Parms.SoftRewardClass = SoftRewardClass;
	Parms.SoftFixedAreaData = SoftFixedAreaData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.RemoveExtraLevelEntryToArea
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class URAreaData*                       AreaData                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRExtraLevelEntry&         NewExtraLevelEntry                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AROverworldManager::RemoveExtraLevelEntryToArea(class URAreaData* AreaData, const struct FRExtraLevelEntry& NewExtraLevelEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "RemoveExtraLevelEntryToArea");

	Params::ROverworldManager_RemoveExtraLevelEntryToArea Parms{};

	Parms.AreaData = AreaData;
	Parms.NewExtraLevelEntry = std::move(NewExtraLevelEntry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.SetAreaIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::SetAreaIndex(int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "SetAreaIndex");

	Params::ROverworldManager_SetAreaIndex Parms{};

	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.SetAreaNodeDataAtIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FROverworldArea*                 Area                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// class URNodeData*                       NodeData                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::SetAreaNodeDataAtIndex(struct FROverworldArea* Area, class URNodeData* NodeData, const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "SetAreaNodeDataAtIndex");

	Params::ROverworldManager_SetAreaNodeDataAtIndex Parms{};

	Parms.NodeData = NodeData;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Area != nullptr)
		*Area = std::move(Parms.Area);
}


// Function RGame.ROverworldManager.SetCurrentNodeId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             NewNodeId                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::SetCurrentNodeId(const int32 NewNodeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "SetCurrentNodeId");

	Params::ROverworldManager_SetCurrentNodeId Parms{};

	Parms.NewNodeId = NewNodeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.SetLevelIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::SetLevelIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "SetLevelIndex");

	Params::ROverworldManager_SetLevelIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.SetPlayerCorruptedNodeChoiceVote_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URNodeChoicePrimaryAsset*         VotedNodeChoicePA                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URNodeChoicePrimaryAsset*         VotedNodeChoiceRewardPA                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::SetPlayerCorruptedNodeChoiceVote_Server(class APlayerState* PlayerState, class URNodeChoicePrimaryAsset* VotedNodeChoicePA, class URNodeChoicePrimaryAsset* VotedNodeChoiceRewardPA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "SetPlayerCorruptedNodeChoiceVote_Server");

	Params::ROverworldManager_SetPlayerCorruptedNodeChoiceVote_Server Parms{};

	Parms.PlayerState = PlayerState;
	Parms.VotedNodeChoicePA = VotedNodeChoicePA;
	Parms.VotedNodeChoiceRewardPA = VotedNodeChoiceRewardPA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.SpawnNodeRewardActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           SpawnPointActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               RewardClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URNodeData*                       NodeData                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AROverworldManager::SpawnNodeRewardActor(class AActor* SpawnPointActor, TSubclassOf<class AActor> RewardClass, class URNodeData* NodeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "SpawnNodeRewardActor");

	Params::ROverworldManager_SpawnNodeRewardActor Parms{};

	Parms.SpawnPointActor = SpawnPointActor;
	Parms.RewardClass = RewardClass;
	Parms.NodeData = NodeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.ROverworldManager.IsInLobby
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsInLobby() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsInLobby");

	Params::ROverworldManager_IsInLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsInTutorial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsInTutorial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsInTutorial");

	Params::ROverworldManager_IsInTutorial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.ROverworldManager.IsInUngluArena
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AROverworldManager::IsInUngluArena() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ROverworldManager", "IsInUngluArena");

	Params::ROverworldManager_IsInUngluArena Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPersistentReplicatedActorInterface.PostRegisterPersistentReplicatedActor
// (Native, Event, Public, BlueprintEvent)

void IRPersistentReplicatedActorInterface::PostRegisterPersistentReplicatedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RPersistentReplicatedActorInterface", "PostRegisterPersistentReplicatedActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableItem.CallOnSimulateLootPhysicsFinished
// (Final, Native, Public, BlueprintCallable)

void ARPickupableItem::CallOnSimulateLootPhysicsFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "CallOnSimulateLootPhysicsFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableItem.CallOnSimulateLootPhysicsFinished_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ARPickupableItem::CallOnSimulateLootPhysicsFinished_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "CallOnSimulateLootPhysicsFinished_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableItem.GetBaseCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARPickupableItem::GetBaseCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "GetBaseCost");

	Params::RPickupableItem_GetBaseCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableItem.GetPickupCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARPickupableItem::GetPickupCost(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "GetPickupCost");

	Params::RPickupableItem_GetPickupCost Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableItem.GetQuantity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARPickupableItem::GetQuantity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "GetQuantity");

	Params::RPickupableItem_GetQuantity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableItem.HasEnoughCurrencyForPickup
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPickupableItem::HasEnoughCurrencyForPickup(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "HasEnoughCurrencyForPickup");

	Params::RPickupableItem_HasEnoughCurrencyForPickup Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableItem.MakeItemInformationObscured
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      Name_0                                                 (Parm, NativeAccessSpecifierPublic)
// const class FText&                      Description                                            (Parm, NativeAccessSpecifierPublic)

void ARPickupableItem::MakeItemInformationObscured(const class FText& Name_0, const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "MakeItemInformationObscured");

	Params::RPickupableItem_MakeItemInformationObscured Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableItem.OnSimulateLootPhysicsFinished
// (Event, Public, BlueprintEvent)

void ARPickupableItem::OnSimulateLootPhysicsFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "OnSimulateLootPhysicsFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableItem.Pickup
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPickupableItem::Pickup(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "Pickup");

	Params::RPickupableItem_Pickup Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableItem.PickupableSpawned
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableItem::PickupableSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "PickupableSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableItem.SetPickupCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewCost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableItem::SetPickupCost(int32 NewCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "SetPickupCost");

	Params::RPickupableItem_SetPickupCost Parms{};

	Parms.NewCost = NewCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableItem.SetQuantity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableItem::SetQuantity(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "SetQuantity");

	Params::RPickupableItem_SetQuantity Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableItem.SetVisualIdentifier
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableItem::SetVisualIdentifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "SetVisualIdentifier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableItem.SimulateLootPhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPickupableItem::SimulateLootPhysics(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "SimulateLootPhysics");

	Params::RPickupableItem_SimulateLootPhysics Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableItem.TriggerPickup
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableItem::TriggerPickup(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableItem", "TriggerPickup");

	Params::RPickupableItem_TriggerPickup Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPickupableMutator.GenerateMutator
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableMutator::GenerateMutator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "GenerateMutator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableMutator.GenerateMutatorByFixedRarity
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableMutator::GenerateMutatorByFixedRarity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "GenerateMutatorByFixedRarity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableMutator.GetGeneratedGodCategoryDataAsset
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UDataAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataAsset* ARPickupableMutator::GetGeneratedGodCategoryDataAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "GetGeneratedGodCategoryDataAsset");

	Params::RPickupableMutator_GetGeneratedGodCategoryDataAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RPickupableMutator.NativeUpdateMutatorIconColor
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableMutator::NativeUpdateMutatorIconColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "NativeUpdateMutatorIconColor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableMutator.OnRep_MutatorPrimaryAsset
// (Final, Native, Private)

void ARPickupableMutator::OnRep_MutatorPrimaryAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "OnRep_MutatorPrimaryAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableMutator.OnRep_Rank
// (Final, Native, Private)

void ARPickupableMutator::OnRep_Rank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "OnRep_Rank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableMutator.PickupMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPickupableMutator::PickupMutator(class APlayerController* PlayerController, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "PickupMutator");

	Params::RPickupableMutator_PickupMutator Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableMutator.SetMutatorPrimaryAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URMutatorPrimaryAsset*            MutatorAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableMutator::SetMutatorPrimaryAsset(class URMutatorPrimaryAsset* MutatorAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "SetMutatorPrimaryAsset");

	Params::RPickupableMutator_SetMutatorPrimaryAsset Parms{};

	Parms.MutatorAsset = MutatorAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableMutator.SetMutatorPrimaryAssetFromTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InRewardTableType                                      (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMutatorRarity                    Rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableMutator::SetMutatorPrimaryAssetFromTable(const struct FGameplayTag& InRewardTableType, class APlayerController* PlayerController, const EMutatorRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "SetMutatorPrimaryAssetFromTable");

	Params::RPickupableMutator_SetMutatorPrimaryAssetFromTable Parms{};

	Parms.InRewardTableType = std::move(InRewardTableType);
	Parms.PlayerController = PlayerController;
	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableMutator.UpdateGeneratedGodCategory
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URMutatorRewardCategoryDataAsset* NewGodCategory                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableMutator::UpdateGeneratedGodCategory(class URMutatorRewardCategoryDataAsset* NewGodCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "UpdateGeneratedGodCategory");

	Params::RPickupableMutator_UpdateGeneratedGodCategory Parms{};

	Parms.NewGodCategory = NewGodCategory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPickupableMutator.UpdateGeneratedMutatorOptions
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FRLootSelectionOption>&NewLootOptions                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARPickupableMutator::UpdateGeneratedMutatorOptions(const TArray<struct FRLootSelectionOption>& NewLootOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "UpdateGeneratedMutatorOptions");

	Params::RPickupableMutator_UpdateGeneratedMutatorOptions Parms{};

	Parms.NewLootOptions = std::move(NewLootOptions);

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPickupableMutator.UpdateMutatorIconColorEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableMutator::UpdateMutatorIconColorEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "UpdateMutatorIconColorEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPickupableMutator.UpdateTooltipInfo
// (Native, Public, BlueprintCallable)

void ARPickupableMutator::UpdateTooltipInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "UpdateTooltipInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableMutator.GetContextMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARPickupableMutator::GetContextMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "GetContextMessage");

	Params::RPickupableMutator_GetContextMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableMutator.GetMutatorPrimaryAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URMutatorPrimaryAsset*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URMutatorPrimaryAsset* ARPickupableMutator::GetMutatorPrimaryAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableMutator", "GetMutatorPrimaryAsset");

	Params::RPickupableMutator_GetMutatorPrimaryAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableCharm.BreakCharm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARPlayerController*               BrokenBy                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableCharm::BreakCharm(class ARPlayerController* BrokenBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableCharm", "BreakCharm");

	Params::RPickupableCharm_BreakCharm Parms{};

	Parms.BrokenBy = BrokenBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableCharm.CallOnOnMutatorPaSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URMutatorPrimaryAsset*            NewPrimaryAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPickupableCharm::CallOnOnMutatorPaSet(class URMutatorPrimaryAsset* NewPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableCharm", "CallOnOnMutatorPaSet");

	Params::RPickupableCharm_CallOnOnMutatorPaSet Parms{};

	Parms.NewPrimaryAsset = NewPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPickupableCharm.GetCharmLootSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMutatorLootSettings             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMutatorLootSettings ARPickupableCharm::GetCharmLootSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableCharm", "GetCharmLootSettings");

	Params::RPickupableCharm_GetCharmLootSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPickupableCharm.NativeUpdateVisuals
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARPickupableCharm::NativeUpdateVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPickupableCharm", "NativeUpdateVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RPingableInterface.GetPingableIconTexture
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* IRPingableInterface::GetPingableIconTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RPingableInterface", "GetPingableIconTexture");

	Params::RPingableInterface_GetPingableIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPingableInterface.GetPingableName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IRPingableInterface::GetPingableName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RPingableInterface", "GetPingableName");

	Params::RPingableInterface_GetPingableName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPingableInterface.IsCurrentlyPinged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRPingableInterface::IsCurrentlyPinged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RPingableInterface", "IsCurrentlyPinged");

	Params::RPingableInterface_IsCurrentlyPinged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPingBeaconManager.GetPingBeaconManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARPingBeaconManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARPingBeaconManager* ARPingBeaconManager::GetPingBeaconManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPingBeaconManager", "GetPingBeaconManager");

	Params::RPingBeaconManager_GetPingBeaconManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPingBeaconManager.QueuePingRequest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBlueprintSessionResult&         Session                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(int32 Latency)>          Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPingBeaconManager::QueuePingRequest(struct FBlueprintSessionResult& Session, TDelegate<void(int32 Latency)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingBeaconManager", "QueuePingRequest");

	Params::RPingBeaconManager_QueuePingRequest Parms{};

	Parms.Session = std::move(Session);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Session = std::move(Parms.Session);
}


// Function RGame.RPingClient.Ping_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARPingClient::Ping_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingClient", "Ping_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPingClient.PingResponse_Client
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARPingClient::PingResponse_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingClient", "PingResponse_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPingHost.InitializeHost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPingHost::InitializeHost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingHost", "InitializeHost");

	Params::RPingHost_InitializeHost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPingHost.RegisterHostObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOnlineBeaconHostObject*          HostObject                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPingHost::RegisterHostObject(class AOnlineBeaconHostObject* HostObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingHost", "RegisterHostObject");

	Params::RPingHost_RegisterHostObject Parms{};

	Parms.HostObject = HostObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPingIndicator.SetDefaultLifespan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPingIndicator::SetDefaultLifespan(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingIndicator", "SetDefaultLifespan");

	Params::RPingIndicator_SetDefaultLifespan Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPingIndicator.SetIndicatorIcon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UTexture2D*                 IconTexture                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPingIndicator::SetIndicatorIcon(const class UTexture2D* IconTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPingIndicator", "SetIndicatorIcon");

	Params::RPingIndicator_SetIndicatorIcon Parms{};

	Parms.IconTexture = IconTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RPlayerGScriptComponent.AddCharacterMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URCharacterMutatorPrimaryAsset*   Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::AddCharacterMutator(class URPlayerGScriptComponent* OwningComponent, class URCharacterMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "AddCharacterMutator");

	Params::RPlayerGScriptComponent_AddCharacterMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.AddMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::AddMutator(class URPlayerGScriptComponent* OwningComponent, class URMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "AddMutator");

	Params::RPlayerGScriptComponent_AddMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.AddProjectileMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URProjectileMutatorPrimaryAsset*  Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::AddProjectileMutator(class URPlayerGScriptComponent* OwningComponent, class URProjectileMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "AddProjectileMutator");

	Params::RPlayerGScriptComponent_AddProjectileMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.AddWeaponMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URWeaponMutatorPrimaryAsset*      Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::AddWeaponMutator(class URPlayerGScriptComponent* OwningComponent, class URWeaponMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "AddWeaponMutator");

	Params::RPlayerGScriptComponent_AddWeaponMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.CanSelectNewCharacterMutator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::CanSelectNewCharacterMutator(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "CanSelectNewCharacterMutator");

	Params::RPlayerGScriptComponent_CanSelectNewCharacterMutator Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.ClearCharacterMutators
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ClearCharacterMutators(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "ClearCharacterMutators");

	Params::RPlayerGScriptComponent_ClearCharacterMutators Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ClearProjectileMutators
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ClearProjectileMutators(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "ClearProjectileMutators");

	Params::RPlayerGScriptComponent_ClearProjectileMutators Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ClearWeaponMutators
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ClearWeaponMutators(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "ClearWeaponMutators");

	Params::RPlayerGScriptComponent_ClearWeaponMutators Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.GetActivatableAbilityByIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             AbilityIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGAbilityCharacterMutatorScript* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGAbilityCharacterMutatorScript* URPlayerGScriptComponent::GetActivatableAbilityByIndex(class URGScriptComponent* OwningComponent, const int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetActivatableAbilityByIndex");

	Params::RPlayerGScriptComponent_GetActivatableAbilityByIndex Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetActivatableAbilityByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AbilityName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGAbilityCharacterMutatorScript* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGAbilityCharacterMutatorScript* URPlayerGScriptComponent::GetActivatableAbilityByName(class URGScriptComponent* OwningComponent, class FName AbilityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetActivatableAbilityByName");

	Params::RPlayerGScriptComponent_GetActivatableAbilityByName Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.AbilityName = AbilityName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetAllActivatableAbilityScripts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExcludeStartEquippedAbilities                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URGAbilityCharacterMutatorScript*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URGAbilityCharacterMutatorScript*> URPlayerGScriptComponent::GetAllActivatableAbilityScripts(class URGScriptComponent* OwningComponent, bool bExcludeStartEquippedAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetAllActivatableAbilityScripts");

	Params::RPlayerGScriptComponent_GetAllActivatableAbilityScripts Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.bExcludeStartEquippedAbilities = bExcludeStartEquippedAbilities;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetCurrentResources
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URPlayerGScriptComponent::GetCurrentResources(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetCurrentResources");

	Params::RPlayerGScriptComponent_GetCurrentResources Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetEquippedActivatableAbility
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGAbilityCharacterMutatorScript* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGAbilityCharacterMutatorScript* URPlayerGScriptComponent::GetEquippedActivatableAbility(class URGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetEquippedActivatableAbility");

	Params::RPlayerGScriptComponent_GetEquippedActivatableAbility Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetEquippedActivatableAbilityPrimaryAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URGScriptComponent*               OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URCharacterMutatorPrimaryAsset*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URCharacterMutatorPrimaryAsset* URPlayerGScriptComponent::GetEquippedActivatableAbilityPrimaryAsset(class URGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetEquippedActivatableAbilityPrimaryAsset");

	Params::RPlayerGScriptComponent_GetEquippedActivatableAbilityPrimaryAsset Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetPlayerGScriptComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class APlayerController*          Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URPlayerGScriptComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URPlayerGScriptComponent* URPlayerGScriptComponent::GetPlayerGScriptComponent(const class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetPlayerGScriptComponent");

	Params::RPlayerGScriptComponent_GetPlayerGScriptComponent Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetResourcesRequiredToGainNewMutator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URPlayerGScriptComponent::GetResourcesRequiredToGainNewMutator(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "GetResourcesRequiredToGainNewMutator");

	Params::RPlayerGScriptComponent_GetResourcesRequiredToGainNewMutator Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.IncrementResources
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::IncrementResources(class URPlayerGScriptComponent* OwningComponent, int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "IncrementResources");

	Params::RPlayerGScriptComponent_IncrementResources Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.RemoveAllStatusEffects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::RemoveAllStatusEffects(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "RemoveAllStatusEffects");

	Params::RPlayerGScriptComponent_RemoveAllStatusEffects Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.RemoveCharacterMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URCharacterMutatorPrimaryAsset*Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::RemoveCharacterMutator(class URPlayerGScriptComponent* OwningComponent, const class URCharacterMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "RemoveCharacterMutator");

	Params::RPlayerGScriptComponent_RemoveCharacterMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.RemoveMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URMutatorPrimaryAsset*            Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::RemoveMutator(class URPlayerGScriptComponent* OwningComponent, class URMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "RemoveMutator");

	Params::RPlayerGScriptComponent_RemoveMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.RemoveProjectileMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URProjectileMutatorPrimaryAsset*Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::RemoveProjectileMutator(class URPlayerGScriptComponent* OwningComponent, const class URProjectileMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "RemoveProjectileMutator");

	Params::RPlayerGScriptComponent_RemoveProjectileMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.RemoveWeaponMutator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class URWeaponMutatorPrimaryAsset*Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::RemoveWeaponMutator(class URPlayerGScriptComponent* OwningComponent, const class URWeaponMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "RemoveWeaponMutator");

	Params::RPlayerGScriptComponent_RemoveWeaponMutator Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ResetGScriptComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ResetGScriptComponent(class URPlayerGScriptComponent* OwningComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "ResetGScriptComponent");

	Params::RPlayerGScriptComponent_ResetGScriptComponent Parms{};

	Parms.OwningComponent = OwningComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.SpawnProjectileMutators
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URPlayerGScriptComponent*         OwningComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoRep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::SpawnProjectileMutators(class URPlayerGScriptComponent* OwningComponent, class FName Category, bool bNoRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlayerGScriptComponent", "SpawnProjectileMutators");

	Params::RPlayerGScriptComponent_SpawnProjectileMutators Parms{};

	Parms.OwningComponent = OwningComponent;
	Parms.Category = Category;
	Parms.bNoRep = bNoRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.CharacterMutators_RepNotify
// (Final, Native, Private)
// Parameters:
// const TArray<struct FCharacterMutator>& PreviousValue                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::CharacterMutators_RepNotify(const TArray<struct FCharacterMutator>& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "CharacterMutators_RepNotify");

	Params::RPlayerGScriptComponent_CharacterMutators_RepNotify Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.GetMutatorRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URPlayerGScriptComponent::GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetMutatorRank");

	Params::RPlayerGScriptComponent_GetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetNumUniqueEquippedMutatorCategories
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     Categories                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URPlayerGScriptComponent::GetNumUniqueEquippedMutatorCategories(const struct FGameplayTagContainer& Categories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetNumUniqueEquippedMutatorCategories");

	Params::RPlayerGScriptComponent_GetNumUniqueEquippedMutatorCategories Parms{};

	Parms.Categories = std::move(Categories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.HasCappedMutatorRewardCategories
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     Categories                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::HasCappedMutatorRewardCategories(const struct FGameplayTagContainer& Categories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "HasCappedMutatorRewardCategories");

	Params::RPlayerGScriptComponent_HasCappedMutatorRewardCategories Parms{};

	Parms.Categories = std::move(Categories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.ProjectileMutators_RepNotify
// (Final, Native, Private)
// Parameters:
// const TArray<struct FProjectileMutator>&PreviousValue                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ProjectileMutators_RepNotify(const TArray<struct FProjectileMutator>& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ProjectileMutators_RepNotify");

	Params::RPlayerGScriptComponent_ProjectileMutators_RepNotify Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ServerAddCharacterMutator
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URCharacterMutatorPrimaryAsset*   Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ServerAddCharacterMutator(class URCharacterMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ServerAddCharacterMutator");

	Params::RPlayerGScriptComponent_ServerAddCharacterMutator Parms{};

	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ServerAddProjectileMutator
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URProjectileMutatorPrimaryAsset*  Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ServerAddProjectileMutator(class URProjectileMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ServerAddProjectileMutator");

	Params::RPlayerGScriptComponent_ServerAddProjectileMutator Parms{};

	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ServerAddWeaponMutator
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URWeaponMutatorPrimaryAsset*      Mutator                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MutatorRank                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ServerAddWeaponMutator(class URWeaponMutatorPrimaryAsset* Mutator, int32 MutatorRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ServerAddWeaponMutator");

	Params::RPlayerGScriptComponent_ServerAddWeaponMutator Parms{};

	Parms.Mutator = Mutator;
	Parms.MutatorRank = MutatorRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ServerRemoveCharacterMutator
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class URCharacterMutatorPrimaryAsset*Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ServerRemoveCharacterMutator(const class URCharacterMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ServerRemoveCharacterMutator");

	Params::RPlayerGScriptComponent_ServerRemoveCharacterMutator Parms{};

	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ServerRemoveProjectileMutator
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class URProjectileMutatorPrimaryAsset*Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ServerRemoveProjectileMutator(const class URProjectileMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ServerRemoveProjectileMutator");

	Params::RPlayerGScriptComponent_ServerRemoveProjectileMutator Parms{};

	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.ServerRemoveWeaponMutator
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class URWeaponMutatorPrimaryAsset*Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::ServerRemoveWeaponMutator(const class URWeaponMutatorPrimaryAsset* Mutator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "ServerRemoveWeaponMutator");

	Params::RPlayerGScriptComponent_ServerRemoveWeaponMutator Parms{};

	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.SetChosenMutatorRewardCategories_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTagContainer&     NewChosenMutatorRewardCategories                       (Parm, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::SetChosenMutatorRewardCategories_Server(const struct FGameplayTagContainer& NewChosenMutatorRewardCategories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "SetChosenMutatorRewardCategories_Server");

	Params::RPlayerGScriptComponent_SetChosenMutatorRewardCategories_Server Parms{};

	Parms.NewChosenMutatorRewardCategories = std::move(NewChosenMutatorRewardCategories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.SetMutatorRank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewRank                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::SetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 NewRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "SetMutatorRank");

	Params::RPlayerGScriptComponent_SetMutatorRank Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.NewRank = NewRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.SetMutatorRank_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewRank                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::SetMutatorRank_Server(class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 NewRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "SetMutatorRank_Server");

	Params::RPlayerGScriptComponent_SetMutatorRank_Server Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;
	Parms.NewRank = NewRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.SetNumMutatorCategoryRerolls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewNumMutatorCategoryRerolls                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::SetNumMutatorCategoryRerolls(int32 NewNumMutatorCategoryRerolls)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "SetNumMutatorCategoryRerolls");

	Params::RPlayerGScriptComponent_SetNumMutatorCategoryRerolls Parms{};

	Parms.NewNumMutatorCategoryRerolls = NewNumMutatorCategoryRerolls;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.SetNumMutatorCategoryRerolls_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   NewNumMutatorCategoryRerolls                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::SetNumMutatorCategoryRerolls_Server(int32 NewNumMutatorCategoryRerolls)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "SetNumMutatorCategoryRerolls_Server");

	Params::RPlayerGScriptComponent_SetNumMutatorCategoryRerolls_Server Parms{};

	Parms.NewNumMutatorCategoryRerolls = NewNumMutatorCategoryRerolls;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.UpdateMutatorRewardCategoryBonusMutators
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URMutatorPrimaryAsset*            RMutatorPrimaryAsset                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::UpdateMutatorRewardCategoryBonusMutators(class URMutatorPrimaryAsset* RMutatorPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "UpdateMutatorRewardCategoryBonusMutators");

	Params::RPlayerGScriptComponent_UpdateMutatorRewardCategoryBonusMutators Parms{};

	Parms.RMutatorPrimaryAsset = RMutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.WeaponMutators_RepNotify
// (Final, Native, Private)
// Parameters:
// const TArray<struct FWeaponMutator>&    PreviousValue                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void URPlayerGScriptComponent::WeaponMutators_RepNotify(const TArray<struct FWeaponMutator>& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "WeaponMutators_RepNotify");

	Params::RPlayerGScriptComponent_WeaponMutators_RepNotify Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerGScriptComponent.GetCharacterMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URCharacterMutatorPrimaryAsset*MutatorPrimaryAsset                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGCharacterMutatorScript*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGCharacterMutatorScript* URPlayerGScriptComponent::GetCharacterMutator(const class URCharacterMutatorPrimaryAsset* MutatorPrimaryAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetCharacterMutator");

	Params::RPlayerGScriptComponent_GetCharacterMutator Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetCharacterMutatorPrimaryAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URGCharacterMutatorScript*  MutatorScript                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URCharacterMutatorPrimaryAsset*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URCharacterMutatorPrimaryAsset* URPlayerGScriptComponent::GetCharacterMutatorPrimaryAsset(const class URGCharacterMutatorScript* MutatorScript) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetCharacterMutatorPrimaryAsset");

	Params::RPlayerGScriptComponent_GetCharacterMutatorPrimaryAsset Parms{};

	Parms.MutatorScript = MutatorScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetDisplayEquippedMutators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URPlayerGScriptComponent::GetDisplayEquippedMutators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetDisplayEquippedMutators");

	Params::RPlayerGScriptComponent_GetDisplayEquippedMutators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetDisplayEquippedMutatorsWithSlotSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URPlayerGScriptComponent::GetDisplayEquippedMutatorsWithSlotSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetDisplayEquippedMutatorsWithSlotSpace");

	Params::RPlayerGScriptComponent_GetDisplayEquippedMutatorsWithSlotSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetEquippedMutators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URPlayerGScriptComponent::GetEquippedMutators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetEquippedMutators");

	Params::RPlayerGScriptComponent_GetEquippedMutators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetEquippedMutatorsByGodCategories
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// const bool                              bIncludeTriggers                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URPlayerGScriptComponent::GetEquippedMutatorsByGodCategories(const struct FGameplayTagContainer& Tags, const bool bIncludeTriggers) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetEquippedMutatorsByGodCategories");

	Params::RPlayerGScriptComponent_GetEquippedMutatorsByGodCategories Parms{};

	Parms.Tags = std::move(Tags);
	Parms.bIncludeTriggers = bIncludeTriggers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetEquippedMutatorsByMutatorTypeTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     TagContainer                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
// TArray<class URMutatorPrimaryAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URMutatorPrimaryAsset*> URPlayerGScriptComponent::GetEquippedMutatorsByMutatorTypeTags(const struct FGameplayTagContainer& TagContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetEquippedMutatorsByMutatorTypeTags");

	Params::RPlayerGScriptComponent_GetEquippedMutatorsByMutatorTypeTags Parms{};

	Parms.TagContainer = std::move(TagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetGlobalWeaponModifiers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URGlobalWeaponModifiers*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGlobalWeaponModifiers* URPlayerGScriptComponent::GetGlobalWeaponModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetGlobalWeaponModifiers");

	Params::RPlayerGScriptComponent_GetGlobalWeaponModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetWeaponMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URWeaponMutatorPrimaryAsset*MutatorPrimaryAsset                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URGWeaponMutatorScript*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URGWeaponMutatorScript* URPlayerGScriptComponent::GetWeaponMutator(const class URWeaponMutatorPrimaryAsset* MutatorPrimaryAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetWeaponMutator");

	Params::RPlayerGScriptComponent_GetWeaponMutator Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.GetWeaponMutatorPrimaryAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URGWeaponMutatorScript*     MutatorScript                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URWeaponMutatorPrimaryAsset*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URWeaponMutatorPrimaryAsset* URPlayerGScriptComponent::GetWeaponMutatorPrimaryAsset(const class URGWeaponMutatorScript* MutatorScript) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "GetWeaponMutatorPrimaryAsset");

	Params::RPlayerGScriptComponent_GetWeaponMutatorPrimaryAsset Parms{};

	Parms.MutatorScript = MutatorScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.HasCharacterMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URCharacterMutatorPrimaryAsset*MutatorPrimaryAsset                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::HasCharacterMutator(const class URCharacterMutatorPrimaryAsset* MutatorPrimaryAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "HasCharacterMutator");

	Params::RPlayerGScriptComponent_HasCharacterMutator Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.HasMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URMutatorPrimaryAsset*      Mutator                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::HasMutator(const class URMutatorPrimaryAsset* Mutator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "HasMutator");

	Params::RPlayerGScriptComponent_HasMutator Parms{};

	Parms.Mutator = Mutator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.HasProjectileMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URProjectileMutatorPrimaryAsset*MutatorPrimaryAsset                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::HasProjectileMutator(const class URProjectileMutatorPrimaryAsset* MutatorPrimaryAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "HasProjectileMutator");

	Params::RPlayerGScriptComponent_HasProjectileMutator Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerGScriptComponent.HasWeaponMutator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URWeaponMutatorPrimaryAsset*MutatorPrimaryAsset                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerGScriptComponent::HasWeaponMutator(const class URWeaponMutatorPrimaryAsset* MutatorPrimaryAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerGScriptComponent", "HasWeaponMutator");

	Params::RPlayerGScriptComponent_HasWeaponMutator Parms{};

	Parms.MutatorPrimaryAsset = MutatorPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerInteractComponent.GetAndCacheTargetResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const TArray<struct FHitResult>& HitResults)>Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlayerInteractComponent::GetAndCacheTargetResult(TDelegate<void(const TArray<struct FHitResult>& HitResults)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerInteractComponent", "GetAndCacheTargetResult");

	Params::RPlayerInteractComponent_GetAndCacheTargetResult Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerInteractComponent.HasInteractableTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URPlayerInteractComponent::HasInteractableTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerInteractComponent", "HasInteractableTarget");

	Params::RPlayerInteractComponent_HasInteractableTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerInteractComponent.OnGetTargetingResult
// (Final, Native, Protected)
// Parameters:
// const TArray<struct FHitResult>&        HitResults                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URPlayerInteractComponent::OnGetTargetingResult(const TArray<struct FHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerInteractComponent", "OnGetTargetingResult");

	Params::RPlayerInteractComponent_OnGetTargetingResult Parms{};

	Parms.HitResults = std::move(HitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerInteractComponent.OnInteract
// (Final, Native, Public, BlueprintCallable)

void URPlayerInteractComponent::OnInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerInteractComponent", "OnInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.AddGold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::AddGold(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "AddGold");

	Params::RPlayerState_AddGold Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.AddKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::AddKeys(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "AddKeys");

	Params::RPlayerState_AddKeys Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.GetUniqueNetIdString
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARPlayerState::GetUniqueNetIdString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "GetUniqueNetIdString");

	Params::RPlayerState_GetUniqueNetIdString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerState.GetViolentCommitmentStacks
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARPlayerState::GetViolentCommitmentStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "GetViolentCommitmentStacks");

	Params::RPlayerState_GetViolentCommitmentStacks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerState.HasKeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARPlayerState::HasKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "HasKeys");

	Params::RPlayerState_HasKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlayerState.OnChallengeCompleted_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnChallengeCompleted_Multicast(class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnChallengeCompleted_Multicast");

	Params::RPlayerState_OnChallengeCompleted_Multicast Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnChallengeCompleted_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             ChallengeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnChallengeCompleted_Server(class FName ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnChallengeCompleted_Server");

	Params::RPlayerState_OnChallengeCompleted_Server Parms{};

	Parms.ChallengeId = ChallengeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnDamageDealt
// (Final, Native, Protected)
// Parameters:
// class ARPawnBase*                       InstigatorPawn                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARPlayerState::OnDamageDealt(class ARPawnBase* InstigatorPawn, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnDamageDealt");

	Params::RPlayerState_OnDamageDealt Parms{};

	Parms.InstigatorPawn = InstigatorPawn;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnDamageTaken
// (Final, Native, Protected)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageData                                             (Parm, NativeAccessSpecifierPublic)

void ARPlayerState::OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnDamageTaken");

	Params::RPlayerState_OnDamageTaken Parms{};

	Parms.Component = Component;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnFinishRun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    RunFailed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnFinishRun(bool RunFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnFinishRun");

	Params::RPlayerState_OnFinishRun Parms{};

	Parms.RunFailed = RunFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnGoldCollected_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewTotal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnGoldCollected_Multicast(float Delta, float NewTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnGoldCollected_Multicast");

	Params::RPlayerState_OnGoldCollected_Multicast Parms{};

	Parms.Delta = Delta;
	Parms.NewTotal = NewTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnGoldCollected_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnGoldCollected_Server(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnGoldCollected_Server");

	Params::RPlayerState_OnGoldCollected_Server Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnHealthDepleted
// (Final, Native, Protected)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void ARPlayerState::OnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnHealthDepleted");

	Params::RPlayerState_OnHealthDepleted Parms{};

	Parms.Component = Component;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnKeyCollected
// (Final, Native, Protected)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTotal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnKeyCollected(int32 Delta, int32 NewTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnKeyCollected");

	Params::RPlayerState_OnKeyCollected Parms{};

	Parms.Delta = Delta;
	Parms.NewTotal = NewTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnKeyCollected_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTotal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnKeyCollected_Multicast(int32 Delta, int32 NewTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnKeyCollected_Multicast");

	Params::RPlayerState_OnKeyCollected_Multicast Parms{};

	Parms.Delta = Delta;
	Parms.NewTotal = NewTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnKeyCollected_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTotal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnKeyCollected_Server(int32 Delta, int32 NewTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnKeyCollected_Server");

	Params::RPlayerState_OnKeyCollected_Server Parms{};

	Parms.Delta = Delta;
	Parms.NewTotal = NewTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnMaximumHealthChanged
// (Final, Native, Protected)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnMaximumHealthChanged(class URHealthComponent* Component, float MaximumHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnMaximumHealthChanged");

	Params::RPlayerState_OnMaximumHealthChanged Parms{};

	Parms.Component = Component;
	Parms.MaximumHealth = MaximumHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnMutatorsChanged
// (Final, Native, Protected)
// Parameters:
// class URPlayerGScriptComponent*         OwnerComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnMutatorsChanged(class URPlayerGScriptComponent* OwnerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnMutatorsChanged");

	Params::RPlayerState_OnMutatorsChanged Parms{};

	Parms.OwnerComponent = OwnerComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnPlayerPawnDowned
// (Final, Native, Protected)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnPlayerPawnDowned(class ARPlayerPawn* RPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnPlayerPawnDowned");

	Params::RPlayerState_OnPlayerPawnDowned Parms{};

	Parms.RPlayerPawn = RPlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnProjectileHit
// (Final, Native, Protected)
// Parameters:
// class ARPlayerPawn*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARProjectileBase*                 ProjectileActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnProjectileHit(class ARPlayerPawn* Player, class AActor* HitActor, class ARProjectileBase* ProjectileActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnProjectileHit");

	Params::RPlayerState_OnProjectileHit Parms{};

	Parms.Player = Player;
	Parms.HitActor = HitActor;
	Parms.ProjectileActor = ProjectileActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnRevivedCastFinished
// (Final, Native, Protected)
// Parameters:
// class ARPlayerPawn*                     RevivingPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::OnRevivedCastFinished(class ARPlayerPawn* RevivingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnRevivedCastFinished");

	Params::RPlayerState_OnRevivedCastFinished Parms{};

	Parms.RevivingPlayer = RevivingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.OnStartRun
// (Final, Native, Protected)

void ARPlayerState::OnStartRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "OnStartRun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.ReconnectSync_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FRDisconnectedPlayerData&  PlayerData                                             (Parm, NativeAccessSpecifierPublic)

void ARPlayerState::ReconnectSync_Multicast(const struct FRDisconnectedPlayerData& PlayerData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "ReconnectSync_Multicast");

	Params::RPlayerState_ReconnectSync_Multicast Parms{};

	Parms.PlayerData = std::move(PlayerData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.ResetPlayerStats
// (Final, Native, Private)
// Parameters:
// class ARPlayerPawn*                     RPlayerPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::ResetPlayerStats(class ARPlayerPawn* RPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "ResetPlayerStats");

	Params::RPlayerState_ResetPlayerStats Parms{};

	Parms.RPlayerPawn = RPlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.ResetRunStats
// (Final, Native, Public, BlueprintCallable)

void ARPlayerState::ResetRunStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "ResetRunStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetBloodPassive7Value
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewBloodPassive7Value                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetBloodPassive7Value(float NewBloodPassive7Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetBloodPassive7Value");

	Params::RPlayerState_SetBloodPassive7Value Parms{};

	Parms.NewBloodPassive7Value = NewBloodPassive7Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetEnableGoldGain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewEnabled                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetEnableGoldGain(const bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetEnableGoldGain");

	Params::RPlayerState_SetEnableGoldGain Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetHealthBonusRank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewHealthBonusRank                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetHealthBonusRank(int32 NewHealthBonusRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetHealthBonusRank");

	Params::RPlayerState_SetHealthBonusRank Parms{};

	Parms.NewHealthBonusRank = NewHealthBonusRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetHealthyCommitmentStacks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewHealthyCommitmentStacks                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetHealthyCommitmentStacks(int32 NewHealthyCommitmentStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetHealthyCommitmentStacks");

	Params::RPlayerState_SetHealthyCommitmentStacks Parms{};

	Parms.NewHealthyCommitmentStacks = NewHealthyCommitmentStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetPlayerFrameWidgetClass_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TSubclassOf<class URPlayerFrameUserWidget>NewPlayerFrameWidgetClass                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetPlayerFrameWidgetClass_Multicast(TSubclassOf<class URPlayerFrameUserWidget> NewPlayerFrameWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetPlayerFrameWidgetClass_Multicast");

	Params::RPlayerState_SetPlayerFrameWidgetClass_Multicast Parms{};

	Parms.NewPlayerFrameWidgetClass = NewPlayerFrameWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetPlayerFrameWidgetClass_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TSubclassOf<class URPlayerFrameUserWidget>NewPlayerFrameWidgetClass                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetPlayerFrameWidgetClass_Server(TSubclassOf<class URPlayerFrameUserWidget> NewPlayerFrameWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetPlayerFrameWidgetClass_Server");

	Params::RPlayerState_SetPlayerFrameWidgetClass_Server Parms{};

	Parms.NewPlayerFrameWidgetClass = NewPlayerFrameWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetRunStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRRunStats&                RunStats                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ARPlayerState::SetRunStats(const struct FRRunStats& RunStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetRunStats");

	Params::RPlayerState_SetRunStats Parms{};

	Parms.RunStats = std::move(RunStats);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetRunSuccesful
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    RunSuccesful                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetRunSuccesful(bool RunSuccesful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetRunSuccesful");

	Params::RPlayerState_SetRunSuccesful Parms{};

	Parms.RunSuccesful = RunSuccesful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetSecondWindUsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewSecondWindUsed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetSecondWindUsed(bool bNewSecondWindUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetSecondWindUsed");

	Params::RPlayerState_SetSecondWindUsed Parms{};

	Parms.bNewSecondWindUsed = bNewSecondWindUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlayerState.SetViolentCommitmentStacks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewViolentCommitmentStacks                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPlayerState::SetViolentCommitmentStacks(int32 NewViolentCommitmentStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlayerState", "SetViolentCommitmentStacks");

	Params::RPlayerState_SetViolentCommitmentStacks Parms{};

	Parms.NewViolentCommitmentStacks = NewViolentCommitmentStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlaySyncedMontageCallbackProxy.CreateProxyObjectForPlayMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<class USkeletalMeshComponent*>&InSkeletalMeshComponents                               (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ARPlayerPawn*                     PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UAnimMontage*>&      MontagesToPlay                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldStopAllMontages                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URPlaySyncedMontageCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URPlaySyncedMontageCallbackProxy* URPlaySyncedMontageCallbackProxy::CreateProxyObjectForPlayMontage(const TArray<class USkeletalMeshComponent*>& InSkeletalMeshComponents, class ARPlayerPawn* PlayerPawn, const TArray<class UAnimMontage*>& MontagesToPlay, float PlayRate, float StartingPosition, class FName StartingSection, bool bShouldStopAllMontages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPlaySyncedMontageCallbackProxy", "CreateProxyObjectForPlayMontage");

	Params::RPlaySyncedMontageCallbackProxy_CreateProxyObjectForPlayMontage Parms{};

	Parms.InSkeletalMeshComponents = std::move(InSkeletalMeshComponents);
	Parms.PlayerPawn = PlayerPawn;
	Parms.MontagesToPlay = std::move(MontagesToPlay);
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;
	Parms.bShouldStopAllMontages = bShouldStopAllMontages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPlaySyncedMontageCallbackProxy.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlaySyncedMontageCallbackProxy::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlaySyncedMontageCallbackProxy", "OnMontageBlendingOut");

	Params::RPlaySyncedMontageCallbackProxy_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlaySyncedMontageCallbackProxy.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URPlaySyncedMontageCallbackProxy::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlaySyncedMontageCallbackProxy", "OnMontageEnded");

	Params::RPlaySyncedMontageCallbackProxy_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlaySyncedMontageCallbackProxy.OnNotifyBeginReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URPlaySyncedMontageCallbackProxy::OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlaySyncedMontageCallbackProxy", "OnNotifyBeginReceived");

	Params::RPlaySyncedMontageCallbackProxy_OnNotifyBeginReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPlaySyncedMontageCallbackProxy.OnNotifyEndReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URPlaySyncedMontageCallbackProxy::OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPlaySyncedMontageCallbackProxy", "OnNotifyEndReceived");

	Params::RPlaySyncedMontageCallbackProxy_OnNotifyEndReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPoolManager.GetPoolManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARPoolManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARPoolManager* ARPoolManager::GetPoolManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RPoolManager", "GetPoolManager");

	Params::RPoolManager_GetPoolManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RPotGeometryCollectionActor.CrumblePot
// (Net, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// EBreakType                              BreakType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARPotGeometryCollectionActor::CrumblePot(EBreakType BreakType, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPotGeometryCollectionActor", "CrumblePot");

	Params::RPotGeometryCollectionActor_CrumblePot Parms{};

	Parms.BreakType = BreakType;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPotGeometryCollectionActor.OnRefDoorOpened
// (Final, Native, Public)

void ARPotGeometryCollectionActor::OnRefDoorOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPotGeometryCollectionActor", "OnRefDoorOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RPotGeometryCollectionActor.RandomizeVariants
// (Final, Native, Public, BlueprintCallable)

void ARPotGeometryCollectionActor::RandomizeVariants()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RPotGeometryCollectionActor", "RandomizeVariants");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.MoveInterpolationTarget
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::MoveInterpolationTarget(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "MoveInterpolationTarget");

	Params::RProjectileMovementComponent_MoveInterpolationTarget Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.OnHomingTargetHealthDepleted
// (Final, Native, Private)
// Parameters:
// class URHealthComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (Parm, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::OnHomingTargetHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "OnHomingTargetHealthDepleted");

	Params::RProjectileMovementComponent_OnHomingTargetHealthDepleted Parms{};

	Parms.Component = Component;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.OnRep_HomingTarget
// (Native, Protected)

void URProjectileMovementComponent::OnRep_HomingTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "OnRep_HomingTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.ResetInterpolation
// (Native, Public, BlueprintCallable)

void URProjectileMovementComponent::ResetInterpolation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "ResetInterpolation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetBlockMovementTick
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bNewBlockMovementTick                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetBlockMovementTick(bool bNewBlockMovementTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetBlockMovementTick");

	Params::RProjectileMovementComponent_SetBlockMovementTick Parms{};

	Parms.bNewBlockMovementTick = bNewBlockMovementTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetCanBounceOnPawns
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bNewCanBounce                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetCanBounceOnPawns(bool bNewCanBounce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetCanBounceOnPawns");

	Params::RProjectileMovementComponent_SetCanBounceOnPawns Parms{};

	Parms.bNewCanBounce = bNewCanBounce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetHomingSocket
// (Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             InHomingSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetHomingSocket(class FName InHomingSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetHomingSocket");

	Params::RProjectileMovementComponent_SetHomingSocket Parms{};

	Parms.InHomingSocketName = InHomingSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetHomingTarget
// (Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InHomingTarget                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetHomingTarget(class USceneComponent* InHomingTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetHomingTarget");

	Params::RProjectileMovementComponent_SetHomingTarget Parms{};

	Parms.InHomingTarget = InHomingTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetInterpolatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetInterpolatedComponent(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetInterpolatedComponent");

	Params::RProjectileMovementComponent_SetInterpolatedComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetPiercing
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bNewPiercing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetPiercing(bool bNewPiercing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetPiercing");

	Params::RProjectileMovementComponent_SetPiercing Parms{};

	Parms.bNewPiercing = bNewPiercing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetVelocity(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetVelocity");

	Params::RProjectileMovementComponent_SetVelocity Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.SetVelocityInLocalSpace
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "SetVelocityInLocalSpace");

	Params::RProjectileMovementComponent_SetVelocityInLocalSpace Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.StopSimulating
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URProjectileMovementComponent::StopSimulating(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "StopSimulating");

	Params::RProjectileMovementComponent_StopSimulating Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RProjectileMovementComponent.ComputeAcceleration
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URProjectileMovementComponent::ComputeAcceleration(const struct FVector& InVelocity, float DeltaTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "ComputeAcceleration");

	Params::RProjectileMovementComponent_ComputeAcceleration Parms{};

	Parms.InVelocity = std::move(InVelocity);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileMovementComponent.IsInterpolationComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URProjectileMovementComponent::IsInterpolationComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "IsInterpolationComplete");

	Params::RProjectileMovementComponent_IsInterpolationComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileMovementComponent.IsVelocityUnderSimulationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URProjectileMovementComponent::IsVelocityUnderSimulationThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "IsVelocityUnderSimulationThreshold");

	Params::RProjectileMovementComponent_IsVelocityUnderSimulationThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RProjectileMovementComponent.LimitVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RProjectileMovementComponent", "LimitVelocity");

	Params::RProjectileMovementComponent_LimitVelocity Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRadarManager.GetRadarManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARRadarManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARRadarManager* ARRadarManager::GetRadarManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRadarManager", "GetRadarManager");

	Params::RRadarManager_GetRadarManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRadarManager.CleanupRadarObjectList
// (Final, Native, Public, BlueprintCallable)

void ARRadarManager::CleanupRadarObjectList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRadarManager", "CleanupRadarObjectList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRadarManager.RegisterRadarObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RadarObject                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRadarManager::RegisterRadarObject(class AActor* RadarObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRadarManager", "RegisterRadarObject");

	Params::RRadarManager_RegisterRadarObject Parms{};

	Parms.RadarObject = RadarObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRadarManager.UnregisterRadarObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ObjectToUnRegister                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRadarManager::UnregisterRadarObject(class AActor* ObjectToUnRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRadarManager", "UnregisterRadarObject");

	Params::RRadarManager_UnregisterRadarObject Parms{};

	Parms.ObjectToUnRegister = ObjectToUnRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRadarObjectInterface.GetRadarIconColor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor IRRadarObjectInterface::GetRadarIconColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRadarObjectInterface", "GetRadarIconColor");

	Params::RRadarObjectInterface_GetRadarIconColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRadarObjectInterface.GetRadarIconSize
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D IRRadarObjectInterface::GetRadarIconSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRadarObjectInterface", "GetRadarIconSize");

	Params::RRadarObjectInterface_GetRadarIconSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRadarObjectInterface.GetRadarObjectIcon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USlateBrushAsset*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USlateBrushAsset* IRRadarObjectInterface::GetRadarObjectIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRadarObjectInterface", "GetRadarObjectIcon");

	Params::RRadarObjectInterface_GetRadarObjectIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRadarObjectInterface.ShouldShowOnRadar
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRRadarObjectInterface::ShouldShowOnRadar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRadarObjectInterface", "ShouldShowOnRadar");

	Params::RRadarObjectInterface_ShouldShowOnRadar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRelevancyInterface.NativeOnRelevancyChanged
// (Native, Public, HasOutParams)
// Parameters:
// const struct FRRelevancyParams&         ProximityParams                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IRRelevancyInterface::NativeOnRelevancyChanged(const struct FRRelevancyParams& ProximityParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRelevancyInterface", "NativeOnRelevancyChanged");

	Params::RRelevancyInterface_NativeOnRelevancyChanged Parms{};

	Parms.ProximityParams = std::move(ProximityParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRelevancyInterface.ReceiveOnRelevancyChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FRRelevancyParams&         RelevancyParams                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IRRelevancyInterface::ReceiveOnRelevancyChanged(const struct FRRelevancyParams& RelevancyParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRelevancyInterface", "ReceiveOnRelevancyChanged");

	Params::RRelevancyInterface_ReceiveOnRelevancyChanged Parms{};

	Parms.RelevancyParams = std::move(RelevancyParams);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function RGame.RRelevancyManager.DumpParams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRRelevancyParams&         Params_0                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARRelevancyManager::DumpParams(const struct FRRelevancyParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRelevancyManager", "DumpParams");

	Params::RRelevancyManager_DumpParams Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRelevancyManager.GetRelevancyManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARRelevancyManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARRelevancyManager* ARRelevancyManager::GetRelevancyManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRelevancyManager", "GetRelevancyManager");

	Params::RRelevancyManager_GetRelevancyManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRelevancyManager.RegisterRelevancyActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRRelevancyRegisterParams& Params_0                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARRelevancyManager::RegisterRelevancyActor(class AActor* Actor, const struct FRRelevancyRegisterParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRelevancyManager", "RegisterRelevancyActor");

	Params::RRelevancyManager_RegisterRelevancyActor Parms{};

	Parms.Actor = Actor;
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RReplicatedLevelInstance.OnAllLevelsUnloaded
// (Final, Native, Private)

void ARReplicatedLevelInstance::OnAllLevelsUnloaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RReplicatedLevelInstance", "OnAllLevelsUnloaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RReplicatedLevelInstance.OnLevelLoaded
// (Final, Native, Private)

void ARReplicatedLevelInstance::OnLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RReplicatedLevelInstance", "OnLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RReplicatedLevelInstance.OnRep_StreamingLevelInstanceInfo
// (Final, Native, Private)

void ARReplicatedLevelInstance::OnRep_StreamingLevelInstanceInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RReplicatedLevelInstance", "OnRep_StreamingLevelInstanceInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RResource.SetValueAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARResource::SetValueAmount(float newAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResource", "SetValueAmount");

	Params::RResource_SetValueAmount Parms{};

	Parms.newAmount = newAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RResourceProjectile.OnComponentHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARResourceProjectile::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResourceProjectile", "OnComponentHit");

	Params::RResourceProjectile_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RResourceProjectile.OnResourcePickedUp
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     PickedUpBy                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARResourceProjectile::OnResourcePickedUp(class ARPlayerPawn* PickedUpBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResourceProjectile", "OnResourcePickedUp");

	Params::RResourceProjectile_OnResourcePickedUp Parms{};

	Parms.PickedUpBy = PickedUpBy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RResourceProjectile.Pickup
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     PickedUpBy                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARResourceProjectile::Pickup(class ARPlayerPawn* PickedUpBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResourceProjectile", "Pickup");

	Params::RResourceProjectile_Pickup Parms{};

	Parms.PickedUpBy = PickedUpBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RResourceProjectile.SetResourceAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARResourceProjectile::SetResourceAmount(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResourceProjectile", "SetResourceAmount");

	Params::RResourceProjectile_SetResourceAmount Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RResourceProjectile.SetTargetPlayerPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARResourceProjectile::SetTargetPlayerPawn(class APawn* InPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResourceProjectile", "SetTargetPlayerPawn");

	Params::RResourceProjectile_SetTargetPlayerPawn Parms{};

	Parms.InPawn = InPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RResourceProjectile.GetTargetPlayerPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARPlayerPawn*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARPlayerPawn* ARResourceProjectile::GetTargetPlayerPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RResourceProjectile", "GetTargetPlayerPawn");

	Params::RResourceProjectile_GetTargetPlayerPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRocket.Explode
// (Final, Native, Public, BlueprintCallable)

void ARRocket::Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRocket", "Explode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRocket.SetBaseAreaOfEffectSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newBaseAreaOfEffectRadius                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRocket::SetBaseAreaOfEffectSize(float newBaseAreaOfEffectRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRocket", "SetBaseAreaOfEffectSize");

	Params::RRocket_SetBaseAreaOfEffectSize Parms{};

	Parms.newBaseAreaOfEffectRadius = newBaseAreaOfEffectRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveInterface.GetCompletionDecrementAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRRoomObjectiveInterface::GetCompletionDecrementAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "GetCompletionDecrementAmount");

	Params::RRoomObjectiveInterface_GetCompletionDecrementAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveInterface.GetCompletionIncrementAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRRoomObjectiveInterface::GetCompletionIncrementAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "GetCompletionIncrementAmount");

	Params::RRoomObjectiveInterface_GetCompletionIncrementAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveInterface.GetCurrentCompletionAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRRoomObjectiveInterface::GetCurrentCompletionAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "GetCurrentCompletionAmount");

	Params::RRoomObjectiveInterface_GetCurrentCompletionAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveInterface.GetRequiredCompletionAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRRoomObjectiveInterface::GetRequiredCompletionAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "GetRequiredCompletionAmount");

	Params::RRoomObjectiveInterface_GetRequiredCompletionAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveInterface.IsObjectCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRRoomObjectiveInterface::IsObjectCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "IsObjectCompleted");

	Params::RRoomObjectiveInterface_IsObjectCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveInterface.SetCurrentCompletionAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const float                             newAmount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRRoomObjectiveInterface::SetCurrentCompletionAmount(const float newAmount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "SetCurrentCompletionAmount");

	Params::RRoomObjectiveInterface_SetCurrentCompletionAmount Parms{};

	Parms.newAmount = newAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveInterface.SetSharedCompletionAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const float                             newAmount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRRoomObjectiveInterface::SetSharedCompletionAmount(const float newAmount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoomObjectiveInterface", "SetSharedCompletionAmount");

	Params::RRoomObjectiveInterface_SetSharedCompletionAmount Parms{};

	Parms.newAmount = newAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveObject.CompleteObject
// (Final, Native, Public, BlueprintCallable)

void ARRoomObjectiveObject::CompleteObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "CompleteObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveObject.GetChargeValueFromPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>&            PlayerActors                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARRoomObjectiveObject::GetChargeValueFromPlayers(const TArray<class AActor*>& PlayerActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "GetChargeValueFromPlayers");

	Params::RRoomObjectiveObject_GetChargeValueFromPlayers Parms{};

	Parms.PlayerActors = std::move(PlayerActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveObject.OnIsObjectiveCompletedReplicated
// (Event, Public, BlueprintEvent)

void ARRoomObjectiveObject::OnIsObjectiveCompletedReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "OnIsObjectiveCompletedReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RRoomObjectiveObject.OnRep_IsObjectCompleted
// (Final, Native, Public)

void ARRoomObjectiveObject::OnRep_IsObjectCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "OnRep_IsObjectCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveObject.BroadcastOnRoomObjectiveObjectCompleted
// (Final, Native, Protected, BlueprintCallable, Const)

void ARRoomObjectiveObject::BroadcastOnRoomObjectiveObjectCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "BroadcastOnRoomObjectiveObjectCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveObject.BroadcastOnRoomObjectiveObjectUpdated
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// const float                             AmountProgressed                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             AmountRequired                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRoomObjectiveObject::BroadcastOnRoomObjectiveObjectUpdated(const float AmountProgressed, const float AmountRequired) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "BroadcastOnRoomObjectiveObjectUpdated");

	Params::RRoomObjectiveObject_BroadcastOnRoomObjectiveObjectUpdated Parms{};

	Parms.AmountProgressed = AmountProgressed;
	Parms.AmountRequired = AmountRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectiveObject.IsCurrentSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AREnemySpawnAreaSegment*          REnemySpawnAreaSegment                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARRoomObjectiveObject::IsCurrentSegment(class AREnemySpawnAreaSegment* REnemySpawnAreaSegment) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "IsCurrentSegment");

	Params::RRoomObjectiveObject_IsCurrentSegment Parms{};

	Parms.REnemySpawnAreaSegment = REnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectiveObject.ShouldShowOnRadar
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARRoomObjectiveObject::ShouldShowOnRadar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectiveObject", "ShouldShowOnRadar");

	Params::RRoomObjectiveObject_ShouldShowOnRadar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectivePawn.DisableComponentVisuals
// (Event, Public, BlueprintEvent)

void ARRoomObjectivePawn::DisableComponentVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "DisableComponentVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RRoomObjectivePawn.DisableComponentVisuals_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARRoomObjectivePawn::DisableComponentVisuals_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "DisableComponentVisuals_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.DisableDefaultInvulnerability_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ARRoomObjectivePawn::DisableDefaultInvulnerability_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "DisableDefaultInvulnerability_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.GetNumCompletedObjectiveObjects
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARRoomObjectivePawn::GetNumCompletedObjectiveObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "GetNumCompletedObjectiveObjects");

	Params::RRoomObjectivePawn_GetNumCompletedObjectiveObjects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectivePawn.GetNumRemainingObjectiveObjects
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARRoomObjectivePawn::GetNumRemainingObjectiveObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "GetNumRemainingObjectiveObjects");

	Params::RRoomObjectivePawn_GetNumRemainingObjectiveObjects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectivePawn.OnDestroyedReplicated
// (Event, Public, BlueprintEvent)

void ARRoomObjectivePawn::OnDestroyedReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnDestroyedReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RRoomObjectivePawn.OnHealthDepleted
// (Final, Native, Private)
// Parameters:
// class URHealthComponent*                RHealthComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (Parm, NativeAccessSpecifierPublic)

void ARRoomObjectivePawn::OnHealthDepleted(class URHealthComponent* RHealthComponent, const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnHealthDepleted");

	Params::RRoomObjectivePawn_OnHealthDepleted Parms{};

	Parms.RHealthComponent = RHealthComponent;
	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.OnObjectiveStarted
// (Final, Native, Private)
// Parameters:
// class URGObjectiveScript*               ObjectiveScript                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRoomObjectivePawn::OnObjectiveStarted(class URGObjectiveScript* ObjectiveScript)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnObjectiveStarted");

	Params::RRoomObjectivePawn_OnObjectiveStarted Parms{};

	Parms.ObjectiveScript = ObjectiveScript;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.OnRep_Destroyed
// (Final, Native, Public)

void ARRoomObjectivePawn::OnRep_Destroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnRep_Destroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.OnSegmentCompleted
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          SegmentCompleted                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRoomObjectivePawn::OnSegmentCompleted(class AREnemySpawnAreaSegment* SegmentCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnSegmentCompleted");

	Params::RRoomObjectivePawn_OnSegmentCompleted Parms{};

	Parms.SegmentCompleted = SegmentCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.OnSegmentStarted
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          SegmentStarted                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRoomObjectivePawn::OnSegmentStarted(class AREnemySpawnAreaSegment* SegmentStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnSegmentStarted");

	Params::RRoomObjectivePawn_OnSegmentStarted Parms{};

	Parms.SegmentStarted = SegmentStarted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.OnSpawnedRoomObjectiveObject
// (Final, Native, Public)
// Parameters:
// class AREnemySpawnAreaSegment*          SpawningSegment                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRoomObjectivePawn::OnSpawnedRoomObjectiveObject(class AREnemySpawnAreaSegment* SpawningSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "OnSpawnedRoomObjectiveObject");

	Params::RRoomObjectivePawn_OnSpawnedRoomObjectiveObject Parms{};

	Parms.SpawningSegment = SpawningSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.PushObjectiveProgressMessage_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARRoomObjectivePawn::PushObjectiveProgressMessage_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "PushObjectiveProgressMessage_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.PushObjectiveProgressMessage_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARRoomObjectivePawn::PushObjectiveProgressMessage_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "PushObjectiveProgressMessage_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoomObjectivePawn.UpdateHealthVisuals
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             Health                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             HueShift                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARRoomObjectivePawn::UpdateHealthVisuals(const float Health, const float HueShift)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "UpdateHealthVisuals");

	Params::RRoomObjectivePawn_UpdateHealthVisuals Parms{};

	Parms.Health = Health;
	Parms.HueShift = HueShift;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RRoomObjectivePawn.IsCurrentSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AREnemySpawnAreaSegment*          REnemySpawnAreaSegment                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARRoomObjectivePawn::IsCurrentSegment(class AREnemySpawnAreaSegment* REnemySpawnAreaSegment) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "IsCurrentSegment");

	Params::RRoomObjectivePawn_IsCurrentSegment Parms{};

	Parms.REnemySpawnAreaSegment = REnemySpawnAreaSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectivePawn.IsObjectCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARRoomObjectivePawn::IsObjectCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "IsObjectCompleted");

	Params::RRoomObjectivePawn_IsObjectCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoomObjectivePawn.ShouldShowOnRadar
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARRoomObjectivePawn::ShouldShowOnRadar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RRoomObjectivePawn", "ShouldShowOnRadar");

	Params::RRoomObjectivePawn_ShouldShowOnRadar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRoutedObjectInterface.RunRoutedObjectBehaviour
// (Native, Event, Public, BlueprintEvent)

void IRRoutedObjectInterface::RunRoutedObjectBehaviour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoutedObjectInterface", "RunRoutedObjectBehaviour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoutedObjectInterface.RunRoutedObjectBehaviourByName
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BehaviourName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRRoutedObjectInterface::RunRoutedObjectBehaviourByName(class FName BehaviourName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoutedObjectInterface", "RunRoutedObjectBehaviourByName");

	Params::RRoutedObjectInterface_RunRoutedObjectBehaviourByName Parms{};

	Parms.BehaviourName = BehaviourName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRoutedObjectInterface.RunRoutedObjectBehaviourWithData
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const struct FRoutedObjectData&         RoutedData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IRRoutedObjectInterface::RunRoutedObjectBehaviourWithData(const struct FRoutedObjectData& RoutedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("RRoutedObjectInterface", "RunRoutedObjectBehaviourWithData");

	Params::RRoutedObjectInterface_RunRoutedObjectBehaviourWithData Parms{};

	Parms.RoutedData = std::move(RoutedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RRuntimeSettings.GetAreaPreloadTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       AreaName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDataTable*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDataTable*> URRuntimeSettings::GetAreaPreloadTables(const class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetAreaPreloadTables");

	Params::RRuntimeSettings_GetAreaPreloadTables Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetCharacterMutatorSetTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetCharacterMutatorSetTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetCharacterMutatorSetTable");

	Params::RRuntimeSettings_GetCharacterMutatorSetTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetDefaultAreaData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataAsset* URRuntimeSettings::GetDefaultAreaData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetDefaultAreaData");

	Params::RRuntimeSettings_GetDefaultAreaData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetDefaultMultiplayerSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataAsset* URRuntimeSettings::GetDefaultMultiplayerSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetDefaultMultiplayerSettings");

	Params::RRuntimeSettings_GetDefaultMultiplayerSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetEnemyGroupTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetEnemyGroupTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetEnemyGroupTable");

	Params::RRuntimeSettings_GetEnemyGroupTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetEnemyMutatorTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetEnemyMutatorTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetEnemyMutatorTable");

	Params::RRuntimeSettings_GetEnemyMutatorTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetEnemyResourceTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetEnemyResourceTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetEnemyResourceTable");

	Params::RRuntimeSettings_GetEnemyResourceTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetEnemySpawnSound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* URRuntimeSettings::GetEnemySpawnSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetEnemySpawnSound");

	Params::RRuntimeSettings_GetEnemySpawnSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetEnemySpawnTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetEnemySpawnTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetEnemySpawnTable");

	Params::RRuntimeSettings_GetEnemySpawnTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetFloatingTextSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URFloatingTextSettings*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URFloatingTextSettings* URRuntimeSettings::GetFloatingTextSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetFloatingTextSettings");

	Params::RRuntimeSettings_GetFloatingTextSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetGlobalPreloadTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UDataTable*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDataTable*> URRuntimeSettings::GetGlobalPreloadTables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetGlobalPreloadTables");

	Params::RRuntimeSettings_GetGlobalPreloadTables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetGoldCoinActorClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* URRuntimeSettings::GetGoldCoinActorClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetGoldCoinActorClass");

	Params::RRuntimeSettings_GetGoldCoinActorClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetHitEffectSurfaceTypeData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetHitEffectSurfaceTypeData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetHitEffectSurfaceTypeData");

	Params::RRuntimeSettings_GetHitEffectSurfaceTypeData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetHitSoundSurfaceTypeData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetHitSoundSurfaceTypeData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetHitSoundSurfaceTypeData");

	Params::RRuntimeSettings_GetHitSoundSurfaceTypeData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetIsDemoBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URRuntimeSettings::GetIsDemoBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetIsDemoBuild");

	Params::RRuntimeSettings_GetIsDemoBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetIsPrereleaseBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URRuntimeSettings::GetIsPrereleaseBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetIsPrereleaseBuild");

	Params::RRuntimeSettings_GetIsPrereleaseBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetIsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URRuntimeSettings::GetIsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetIsShippingBuild");

	Params::RRuntimeSettings_GetIsShippingBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetKeyboardLayoutDataTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetKeyboardLayoutDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetKeyboardLayoutDataTable");

	Params::RRuntimeSettings_GetKeyboardLayoutDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetKeywordsDataTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetKeywordsDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetKeywordsDataTable");

	Params::RRuntimeSettings_GetKeywordsDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetMutatorPreloadTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UDataTable*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDataTable*> URRuntimeSettings::GetMutatorPreloadTables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetMutatorPreloadTables");

	Params::RRuntimeSettings_GetMutatorPreloadTables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetMutatorScalingTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetMutatorScalingTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetMutatorScalingTable");

	Params::RRuntimeSettings_GetMutatorScalingTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetPawnDamageTakenEffectDataTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetPawnDamageTakenEffectDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetPawnDamageTakenEffectDataTable");

	Params::RRuntimeSettings_GetPawnDamageTakenEffectDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetProjectileImpactEffectTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetProjectileImpactEffectTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetProjectileImpactEffectTable");

	Params::RRuntimeSettings_GetProjectileImpactEffectTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetWeaponDataTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetWeaponDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetWeaponDataTable");

	Params::RRuntimeSettings_GetWeaponDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RRuntimeSettings.GetWeaponDropTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* URRuntimeSettings::GetWeaponDropTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RRuntimeSettings", "GetWeaponDropTable");

	Params::RRuntimeSettings_GetWeaponDropTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.AddCompletedArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    AreaName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::AddCompletedArea(const class FString& AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "AddCompletedArea");

	Params::RSaveGame_AddCompletedArea Parms{};

	Parms.AreaName = std::move(AreaName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.AddDifficultyPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::AddDifficultyPoints(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "AddDifficultyPoints");

	Params::RSaveGame_AddDifficultyPoints Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.AddNumTimesOpenedLogBook
// (Final, Native, Public, BlueprintCallable)

void URSaveGame::AddNumTimesOpenedLogBook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "AddNumTimesOpenedLogBook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.DecrementSoulFragments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::DecrementSoulFragments(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "DecrementSoulFragments");

	Params::RSaveGame_DecrementSoulFragments Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.GetEquippedLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRLoadout*                       Loadout                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::GetEquippedLoadout(struct FRLoadout* Loadout, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetEquippedLoadout");

	Params::RSaveGame_GetEquippedLoadout Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Loadout != nullptr)
		*Loadout = std::move(Parms.Loadout);
}


// Function RGame.RSaveGame.GetLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class URWeaponPrimaryAsset*             Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRLoadout*                       Loadout                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::GetLoadout(class URWeaponPrimaryAsset* Weapon, struct FRLoadout* Loadout, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetLoadout");

	Params::RSaveGame_GetLoadout Parms{};

	Parms.Weapon = Weapon;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Loadout != nullptr)
		*Loadout = std::move(Parms.Loadout);
}


// Function RGame.RSaveGame.IncrementSoulFragments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::IncrementSoulFragments(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "IncrementSoulFragments");

	Params::RSaveGame_IncrementSoulFragments Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.IsLoadoutOptionUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URPrimaryDataAsset*               PrimaryAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URSaveGame::IsLoadoutOptionUnlocked(class URPrimaryDataAsset* PrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "IsLoadoutOptionUnlocked");

	Params::RSaveGame_IsLoadoutOptionUnlocked Parms{};

	Parms.PrimaryAsset = PrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.SetCosmeticLoadoutOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FPlayerCosmeticOption&     CosmeticOption                                         (Parm, NativeAccessSpecifierPublic)

void URSaveGame::SetCosmeticLoadoutOption(const struct FPlayerCosmeticOption& CosmeticOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetCosmeticLoadoutOption");

	Params::RSaveGame_SetCosmeticLoadoutOption Parms{};

	Parms.CosmeticOption = std::move(CosmeticOption);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetDemoDifficultyPointsCapped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetDemoDifficultyPointsCapped(const bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetDemoDifficultyPointsCapped");

	Params::RSaveGame_SetDemoDifficultyPointsCapped Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetEquippedLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRLoadout&                       Loadout                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URSaveGame::SetEquippedLoadout(struct FRLoadout& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetEquippedLoadout");

	Params::RSaveGame_SetEquippedLoadout Parms{};

	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Loadout = std::move(Parms.Loadout);
}


// Function RGame.RSaveGame.SetHasEverSpentDifficultyPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetHasEverSpentDifficultyPoints(const bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetHasEverSpentDifficultyPoints");

	Params::RSaveGame_SetHasEverSpentDifficultyPoints Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetHasSeenFirstDeathTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHasSeen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetHasSeenFirstDeathTutorial(bool bHasSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetHasSeenFirstDeathTutorial");

	Params::RSaveGame_SetHasSeenFirstDeathTutorial Parms{};

	Parms.bHasSeen = bHasSeen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetHasSeenInitialTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHasSeen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetHasSeenInitialTutorial(bool bHasSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetHasSeenInitialTutorial");

	Params::RSaveGame_SetHasSeenInitialTutorial Parms{};

	Parms.bHasSeen = bHasSeen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetHasSeenWorkbenchFirstTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHasSeen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetHasSeenWorkbenchFirstTime(bool bHasSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetHasSeenWorkbenchFirstTime");

	Params::RSaveGame_SetHasSeenWorkbenchFirstTime Parms{};

	Parms.bHasSeen = bHasSeen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetHiddenCoinsFound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFound                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetHiddenCoinsFound(const class FString& Key, bool bFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetHiddenCoinsFound");

	Params::RSaveGame_SetHiddenCoinsFound Parms{};

	Parms.Key = std::move(Key);
	Parms.bFound = bFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetIsDemoSaveGameData
// (Final, Native, Public, BlueprintCallable)

void URSaveGame::SetIsDemoSaveGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetIsDemoSaveGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetIsPrereleaseSaveGameData
// (Final, Native, Public, BlueprintCallable)

void URSaveGame::SetIsPrereleaseSaveGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetIsPrereleaseSaveGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetIsTutorialDone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewDone                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetIsTutorialDone(bool bNewDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetIsTutorialDone");

	Params::RSaveGame_SetIsTutorialDone Parms{};

	Parms.bNewDone = bNewDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetLatestSessionId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LatestSessionId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetLatestSessionId(const class FString& LatestSessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetLatestSessionId");

	Params::RSaveGame_SetLatestSessionId Parms{};

	Parms.LatestSessionId = std::move(LatestSessionId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRLoadout&                       Loadout                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URSaveGame::SetLoadout(struct FRLoadout& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetLoadout");

	Params::RSaveGame_SetLoadout Parms{};

	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Loadout = std::move(Parms.Loadout);
}


// Function RGame.RSaveGame.SetLoadoutSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URWeaponPrimaryAsset*             Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadoutSlot                            LoadoutSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URPrimaryDataAsset*               PrimaryAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetLoadoutSlot(class URWeaponPrimaryAsset* Weapon, ELoadoutSlot LoadoutSlot, class URPrimaryDataAsset* PrimaryAsset, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetLoadoutSlot");

	Params::RSaveGame_SetLoadoutSlot Parms{};

	Parms.Weapon = Weapon;
	Parms.LoadoutSlot = LoadoutSlot;
	Parms.PrimaryAsset = PrimaryAsset;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.SetSkillTreeAssignedPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       SkillKey                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Points                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::SetSkillTreeAssignedPoints(const class FName SkillKey, const int32 Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "SetSkillTreeAssignedPoints");

	Params::RSaveGame_SetSkillTreeAssignedPoints Parms{};

	Parms.SkillKey = SkillKey;
	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.UnlockLoadoutOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URPrimaryDataAsset*               PrimaryAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::UnlockLoadoutOption(class URPrimaryDataAsset* PrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "UnlockLoadoutOption");

	Params::RSaveGame_UnlockLoadoutOption Parms{};

	Parms.PrimaryAsset = PrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.UnlockWeaponModLoadoutOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URWeaponModPrimaryAsset*          WeaponModPrimaryAsset                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGame::UnlockWeaponModLoadoutOption(class URWeaponModPrimaryAsset* WeaponModPrimaryAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "UnlockWeaponModLoadoutOption");

	Params::RSaveGame_UnlockWeaponModLoadoutOption Parms{};

	Parms.WeaponModPrimaryAsset = WeaponModPrimaryAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGame.GetDemoDifficultyPointsCapped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URSaveGame::GetDemoDifficultyPointsCapped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetDemoDifficultyPointsCapped");

	Params::RSaveGame_GetDemoDifficultyPointsCapped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.GetDifficultyTreeAssignedPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URSaveGame::GetDifficultyTreeAssignedPoints(const class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetDifficultyTreeAssignedPoints");

	Params::RSaveGame_GetDifficultyTreeAssignedPoints Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.GetDifficultyTreeTotalAssignedPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URSaveGame::GetDifficultyTreeTotalAssignedPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetDifficultyTreeTotalAssignedPoints");

	Params::RSaveGame_GetDifficultyTreeTotalAssignedPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.GetHasEverSpentDifficultyPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URSaveGame::GetHasEverSpentDifficultyPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetHasEverSpentDifficultyPoints");

	Params::RSaveGame_GetHasEverSpentDifficultyPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.GetIsTutorialDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URSaveGame::GetIsTutorialDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetIsTutorialDone");

	Params::RSaveGame_GetIsTutorialDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.GetLatestSessionId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URSaveGame::GetLatestSessionId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetLatestSessionId");

	Params::RSaveGame_GetLatestSessionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGame.GetSkillTreeAssignedPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       SkillKey                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URSaveGame::GetSkillTreeAssignedPoints(const class FName SkillKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGame", "GetSkillTreeAssignedPoints");

	Params::RSaveGame_GetSkillTreeAssignedPoints Parms{};

	Parms.SkillKey = SkillKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.ClearNonDemoSaveDataIfDemoBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::ClearNonDemoSaveDataIfDemoBuild(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "ClearNonDemoSaveDataIfDemoBuild");

	Params::RSaveGameManager_ClearNonDemoSaveDataIfDemoBuild Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameManager.ClearPrereleaseSaveData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::ClearPrereleaseSaveData(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "ClearPrereleaseSaveData");

	Params::RSaveGameManager_ClearPrereleaseSaveData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameManager.ClearSaveGameSlotsIfInvalidChangelist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::ClearSaveGameSlotsIfInvalidChangelist(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "ClearSaveGameSlotsIfInvalidChangelist");

	Params::RSaveGameManager_ClearSaveGameSlotsIfInvalidChangelist Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameManager.CreateSaveGame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URSaveGame*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URSaveGame* URSaveGameManager::CreateSaveGame(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "CreateSaveGame");

	Params::RSaveGameManager_CreateSaveGame Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.DeleteSaveSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::DeleteSaveSlot(const class FString& SlotName, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "DeleteSaveSlot");

	Params::RSaveGameManager_DeleteSaveSlot Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameManager.DoesSaveGameExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URSaveGameManager::DoesSaveGameExist(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "DoesSaveGameExist");

	Params::RSaveGameManager_DoesSaveGameExist Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.GetCurrentSaveGame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URSaveGame*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URSaveGame* URSaveGameManager::GetCurrentSaveGame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "GetCurrentSaveGame");

	Params::RSaveGameManager_GetCurrentSaveGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.GetNumSavedRunStats
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URSaveGameManager::GetNumSavedRunStats(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "GetNumSavedRunStats");

	Params::RSaveGameManager_GetNumSavedRunStats Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.GetProjectVersionChangelist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URSaveGameManager::GetProjectVersionChangelist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "GetProjectVersionChangelist");

	Params::RSaveGameManager_GetProjectVersionChangelist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.LoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URSaveGame*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URSaveGame* URSaveGameManager::LoadGameFromSlot(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "LoadGameFromSlot");

	Params::RSaveGameManager_LoadGameFromSlot Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.QuickSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERSavedGameResult                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERSavedGameResult URSaveGameManager::QuickSave(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "QuickSave");

	Params::RSaveGameManager_QuickSave Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.SaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERSavedGameResult                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERSavedGameResult URSaveGameManager::SaveGameToSlot(const class UObject* WorldContextObject, const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "SaveGameToSlot");

	Params::RSaveGameManager_SaveGameToSlot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameManager.SetCurrentSaveGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URSaveGame*                       SaveGame                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::SetCurrentSaveGame(const class UObject* WorldContextObject, class URSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "SetCurrentSaveGame");

	Params::RSaveGameManager_SetCurrentSaveGame Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameManager.SetCurrentSaveGameToLastSessionSaveGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::SetCurrentSaveGameToLastSessionSaveGame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "SetCurrentSaveGameToLastSessionSaveGame");

	Params::RSaveGameManager_SetCurrentSaveGameToLastSessionSaveGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameManager.UpdateCreationChangelistIfDemoBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameManager::UpdateCreationChangelistIfDemoBuild(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameManager", "UpdateCreationChangelistIfDemoBuild");

	Params::RSaveGameManager_UpdateCreationChangelistIfDemoBuild Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameSession.GetLastSaveGameSession
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URSaveGameSession*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URSaveGameSession* URSaveGameSession::GetLastSaveGameSession(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RSaveGameSession", "GetLastSaveGameSession");

	Params::RSaveGameSession_GetLastSaveGameSession Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameSession.AddSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SaveGameSlot                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameSession::AddSaveGame(const class FString& SaveGameSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGameSession", "AddSaveGame");

	Params::RSaveGameSession_AddSaveGame Parms{};

	Parms.SaveGameSlot = std::move(SaveGameSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSaveGameSession.GetAllSaveGames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class URSaveGame*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URSaveGame*> URSaveGameSession::GetAllSaveGames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGameSession", "GetAllSaveGames");

	Params::RSaveGameSession_GetAllSaveGames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameSession.GetLastSaveGameSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URSaveGameSession::GetLastSaveGameSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGameSession", "GetLastSaveGameSlot");

	Params::RSaveGameSession_GetLastSaveGameSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSaveGameSession.RemoveSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SaveGameSlot                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSaveGameSession::RemoveSaveGame(const class FString& SaveGameSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSaveGameSession", "RemoveSaveGame");

	Params::RSaveGameSession_RemoveSaveGame Parms{};

	Parms.SaveGameSlot = std::move(SaveGameSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSettingTabWidget.ApplySettings
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URSettingTabWidget::ApplySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSettingTabWidget", "ApplySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSettingTabWidget.GetDesiredFocusWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* URSettingTabWidget::GetDesiredFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSettingTabWidget", "GetDesiredFocusWidget");

	Params::RSettingTabWidget_GetDesiredFocusWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSettingTabWidget.ResetSettings
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URSettingTabWidget::ResetSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSettingTabWidget", "ResetSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSpectateHud.OnSpectatedPlayerChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     NewSpectatedPlayer                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSpectateHud::OnSpectatedPlayerChanged(class ARPlayerPawn* NewSpectatedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSpectateHud", "OnSpectatedPlayerChanged");

	Params::RSpectateHud_OnSpectatedPlayerChanged Parms{};

	Parms.NewSpectatedPlayer = NewSpectatedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSpectatorPawn.OnPlayerPawnKilled
// (Final, Native, Protected)
// Parameters:
// class ARPlayerPawn*                     PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARSpectatorPawn::OnPlayerPawnKilled(class ARPlayerPawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSpectatorPawn", "OnPlayerPawnKilled");

	Params::RSpectatorPawn_OnPlayerPawnKilled Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSpectatorPawn.OnPlayerPawnRevived
// (Final, Native, Protected)
// Parameters:
// class ARPlayerPawn*                     PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARSpectatorPawn::OnPlayerPawnRevived(class ARPlayerPawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSpectatorPawn", "OnPlayerPawnRevived");

	Params::RSpectatorPawn_OnPlayerPawnRevived Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSpectatorPawn.OnSpectatedPlayerChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARPlayerPawn*                     NewSpectatedPlayer                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARSpectatorPawn::OnSpectatedPlayerChanged(class ARPlayerPawn* NewSpectatedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSpectatorPawn", "OnSpectatedPlayerChanged");

	Params::RSpectatorPawn_OnSpectatedPlayerChanged Parms{};

	Parms.NewSpectatedPlayer = NewSpectatedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSpectatorPawn.SpectateNextPlayer
// (Final, Native, Public, BlueprintCallable)

void ARSpectatorPawn::SpectateNextPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSpectatorPawn", "SpectateNextPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RSpectatorPawn.SpectatePreviousPlayer
// (Final, Native, Public, BlueprintCallable)

void ARSpectatorPawn::SpectatePreviousPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSpectatorPawn", "SpectatePreviousPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RStatTracker.GetStatTracker
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARStatTracker*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARStatTracker* ARStatTracker::GetStatTracker(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RStatTracker", "GetStatTracker");

	Params::RStatTracker_GetStatTracker Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStatTracker.SaveLogToFile
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>&                  lines                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARStatTracker::SaveLogToFile(TArray<class FString>& lines, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RStatTracker", "SaveLogToFile");

	Params::RStatTracker_SaveLogToFile Parms{};

	Parms.lines = std::move(lines);
	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	lines = std::move(Parms.lines);
}


// Function RGame.RStringLibrary.FilterBadWords
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URStringLibrary::FilterBadWords(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RStringLibrary", "FilterBadWords");

	Params::RStringLibrary_FilterBadWords Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStringLibrary.ParseDescriptionWithVariable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDescriptionVariable&      DescriptionVariable                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URStringLibrary::ParseDescriptionWithVariable(const class FText& InText, const struct FDescriptionVariable& DescriptionVariable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RStringLibrary", "ParseDescriptionWithVariable");

	Params::RStringLibrary_ParseDescriptionWithVariable Parms{};

	Parms.InText = std::move(InText);
	Parms.DescriptionVariable = std::move(DescriptionVariable);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStringLibrary.ParseDescriptionWithVariables
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FDescriptionVariable>&DescriptionVariables                                   (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URStringLibrary::ParseDescriptionWithVariables(const class FText& InText, const TArray<struct FDescriptionVariable>& DescriptionVariables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RStringLibrary", "ParseDescriptionWithVariables");

	Params::RStringLibrary_ParseDescriptionWithVariables Parms{};

	Parms.InText = std::move(InText);
	Parms.DescriptionVariables = std::move(DescriptionVariables);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RStringLibrary.TextContainsBadWord
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URStringLibrary::TextContainsBadWord(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RStringLibrary", "TextContainsBadWord");

	Params::RStringLibrary_TextContainsBadWord Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSubCrosshair.GetDynamicCrosshairMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* URSubCrosshair::GetDynamicCrosshairMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSubCrosshair", "GetDynamicCrosshairMaterial");

	Params::RSubCrosshair_GetDynamicCrosshairMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RSubCrosshair.UpdateTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URSubCrosshair::UpdateTarget(class FName PropertyName, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RSubCrosshair", "UpdateTarget");

	Params::RSubCrosshair_UpdateTarget Parms{};

	Parms.PropertyName = PropertyName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.AddFoundInteractableInNode
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           FoundInteractableActor                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARTelemetryManager::AddFoundInteractableInNode(class AActor* FoundInteractableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "AddFoundInteractableInNode");

	Params::RTelemetryManager_AddFoundInteractableInNode Parms{};

	Parms.FoundInteractableActor = FoundInteractableActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.AddInteractableInNode
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InteractableActor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARTelemetryManager::AddInteractableInNode(class AActor* InteractableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "AddInteractableInNode");

	Params::RTelemetryManager_AddInteractableInNode Parms{};

	Parms.InteractableActor = InteractableActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.ConvertBitmaskToEnumAsByte
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EDamageSource>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EDamageSource> ARTelemetryManager::ConvertBitmaskToEnumAsByte(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "ConvertBitmaskToEnumAsByte");

	Params::RTelemetryManager_ConvertBitmaskToEnumAsByte Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RTelemetryManager.OnAllowTelemetryDataCollectionUpdated
// (Final, Native, Private)
// Parameters:
// const bool                              bNewValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARTelemetryManager::OnAllowTelemetryDataCollectionUpdated(const bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "OnAllowTelemetryDataCollectionUpdated");

	Params::RTelemetryManager_OnAllowTelemetryDataCollectionUpdated Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.PerformLogin
// (Final, Native, Public, BlueprintCallable)

void ARTelemetryManager::PerformLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "PerformLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.ResetDamageDealtAndTakenInEncounter
// (Final, Native, Protected, BlueprintCallable)

void ARTelemetryManager::ResetDamageDealtAndTakenInEncounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "ResetDamageDealtAndTakenInEncounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnChallengeCompleted
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRChallenge&               RChallenge                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnChallengeCompleted(const struct FRChallenge& RChallenge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnChallengeCompleted");

	Params::RTelemetryManager_WriteOnChallengeCompleted Parms{};

	Parms.RChallenge = std::move(RChallenge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnDeath
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDamageCombatEvent&        DamageCombatEvent                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnDeath(const struct FDamageCombatEvent& DamageCombatEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnDeath");

	Params::RTelemetryManager_WriteOnDeath Parms{};

	Parms.DamageCombatEvent = std::move(DamageCombatEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnFightEnd
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const bool                              bWasObjective                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RoomObjectiveType                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumMeleeUsages                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsEndBoss                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnFightEnd(const bool bWasObjective, const class FString& RoomObjectiveType, const int32 NumMeleeUsages, const bool bIsEndBoss)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnFightEnd");

	Params::RTelemetryManager_WriteOnFightEnd Parms{};

	Parms.bWasObjective = bWasObjective;
	Parms.RoomObjectiveType = std::move(RoomObjectiveType);
	Parms.NumMeleeUsages = NumMeleeUsages;
	Parms.bIsEndBoss = bIsEndBoss;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnLoadingScreen
// (Final, Native, Protected, BlueprintCallable)

void ARTelemetryManager::WriteOnLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnLobbyEnd
// (Final, Native, Protected, BlueprintCallable)

void ARTelemetryManager::WriteOnLobbyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnLobbyEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnLogBookUsed
// (Final, Native, Protected, BlueprintCallable)

void ARTelemetryManager::WriteOnLogBookUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnLogBookUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnPickupGodMutator
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    ChosenGodCategoryName                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            DiscardedGodCategoryNames                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    ChosenGodMutatorName                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            DiscardedGodMutatorNames                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnPickupGodMutator(const class FString& ChosenGodCategoryName, const TArray<class FString>& DiscardedGodCategoryNames, const class FString& ChosenGodMutatorName, const TArray<class FString>& DiscardedGodMutatorNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnPickupGodMutator");

	Params::RTelemetryManager_WriteOnPickupGodMutator Parms{};

	Parms.ChosenGodCategoryName = std::move(ChosenGodCategoryName);
	Parms.DiscardedGodCategoryNames = std::move(DiscardedGodCategoryNames);
	Parms.ChosenGodMutatorName = std::move(ChosenGodMutatorName);
	Parms.DiscardedGodMutatorNames = std::move(DiscardedGodMutatorNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnPurchase
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    PurchasedItemName                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             PurchasedItemCost                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            NotPurchasedItems                                      (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnPurchase(const class FString& PurchasedItemName, const int32 PurchasedItemCost, const TArray<class AActor*>& NotPurchasedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnPurchase");

	Params::RTelemetryManager_WriteOnPurchase Parms{};

	Parms.PurchasedItemName = std::move(PurchasedItemName);
	Parms.PurchasedItemCost = PurchasedItemCost;
	Parms.NotPurchasedItems = std::move(NotPurchasedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnRoomEnd
// (Final, Native, Protected, BlueprintCallable)

void ARTelemetryManager::WriteOnRoomEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnRoomEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnRunEnded
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const bool                              bCurrentRunSuccesful                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnRunEnded(const bool bCurrentRunSuccesful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnRunEnded");

	Params::RTelemetryManager_WriteOnRunEnded Parms{};

	Parms.bCurrentRunSuccesful = bCurrentRunSuccesful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.WriteOnRunEnded_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const bool                              bCurrentRunSuccesful                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARTelemetryManager::WriteOnRunEnded_Multicast(const bool bCurrentRunSuccesful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "WriteOnRunEnded_Multicast");

	Params::RTelemetryManager_WriteOnRunEnded_Multicast Parms{};

	Parms.bCurrentRunSuccesful = bCurrentRunSuccesful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTelemetryManager.GetInstigatorDisplayName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InstigatorActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARTelemetryManager::GetInstigatorDisplayName(class AActor* InstigatorActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTelemetryManager", "GetInstigatorDisplayName");

	Params::RTelemetryManager_GetInstigatorDisplayName Parms{};

	Parms.InstigatorActor = InstigatorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RTempCharacter.AddRecoil
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Recoil                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARTempCharacter::AddRecoil(const struct FRotator& Recoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTempCharacter", "AddRecoil");

	Params::RTempCharacter_AddRecoil Parms{};

	Parms.Recoil = std::move(Recoil);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTeslaGunLightningOrbScript.NativeCheckForChallengeProgression
// (Event, Protected, BlueprintEvent)

void URTeslaGunLightningOrbScript::NativeCheckForChallengeProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTeslaGunLightningOrbScript", "NativeCheckForChallengeProgression");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RTeslaGunLightningOrbScript.NativeCheckHighVoltage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URTeslaGunLightningOrbScript::NativeCheckHighVoltage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTeslaGunLightningOrbScript", "NativeCheckHighVoltage");

	Params::RTeslaGunLightningOrbScript_NativeCheckHighVoltage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RTeslaGunLightningOrbScript.NativeZapEnemy
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           EnemyActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ZapOrigin                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTeslaGunLightningOrbScript::NativeZapEnemy(class AActor* EnemyActor, const struct FVector& ZapOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTeslaGunLightningOrbScript", "NativeZapEnemy");

	Params::RTeslaGunLightningOrbScript_NativeZapEnemy Parms{};

	Parms.EnemyActor = EnemyActor;
	Parms.ZapOrigin = std::move(ZapOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RTriggerMutatorScript.HandleDealtDamageEvent
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARPawnBase*                       RPawnBase                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageCombatEvent&        DamageEventData                                        (ConstParm, Parm, NativeAccessSpecifierPublic)

void URTriggerMutatorScript::HandleDealtDamageEvent(class ARPawnBase* RPawnBase, const struct FDamageCombatEvent& DamageEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTriggerMutatorScript", "HandleDealtDamageEvent");

	Params::RTriggerMutatorScript_HandleDealtDamageEvent Parms{};

	Parms.RPawnBase = RPawnBase;
	Parms.DamageEventData = std::move(DamageEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RUIManager.GetUIManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARUIManager*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARUIManager* ARUIManager::GetUIManager(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RUIManager", "GetUIManager");

	Params::RUIManager_GetUIManager Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RUIManager.IsWidgetStackEmpty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExcludeNonInputWidgets                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARUIManager::IsWidgetStackEmpty(class APlayerController* PlayerController, bool bExcludeNonInputWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RUIManager", "IsWidgetStackEmpty");

	Params::RUIManager_IsWidgetStackEmpty Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bExcludeNonInputWidgets = bExcludeNonInputWidgets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RUIManager.PopWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URCommonActivatableWidget*        ActivatableWidget                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARUIManager::PopWidget(class URCommonActivatableWidget* ActivatableWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RUIManager", "PopWidget");

	Params::RUIManager_PopWidget Parms{};

	Parms.ActivatableWidget = ActivatableWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RUIManager.PushWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class URCommonActivatableWidget>ActivatableWidgetClass                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URCommonActivatableWidget**       OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARUIManager::PushWidget(TSubclassOf<class URCommonActivatableWidget> ActivatableWidgetClass, class URCommonActivatableWidget** OutWidget, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RUIManager", "PushWidget");

	Params::RUIManager_PushWidget Parms{};

	Parms.ActivatableWidgetClass = ActivatableWidgetClass;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function RGame.RUIManager.DragDropOperationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDragDropOperationEvent                 OperationType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARUIManager::DragDropOperationStarted(EDragDropOperationEvent OperationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUIManager", "DragDropOperationStarted");

	Params::RUIManager_DragDropOperationStarted Parms{};

	Parms.OperationType = OperationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RUngluMovementSpline.BroadcastOnCloneFinishedMoving
// (Final, Native, Protected, BlueprintCallable)

void ARUngluMovementSpline::BroadcastOnCloneFinishedMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUngluMovementSpline", "BroadcastOnCloneFinishedMoving");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RUngluMovementSpline.GetMoveTimelineComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTimelineComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimelineComponent* ARUngluMovementSpline::GetMoveTimelineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUngluMovementSpline", "GetMoveTimelineComponent");

	Params::RUngluMovementSpline_GetMoveTimelineComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RUngluMovementSpline.GetSplineComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* ARUngluMovementSpline::GetSplineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUngluMovementSpline", "GetSplineComponent");

	Params::RUngluMovementSpline_GetSplineComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function RGame.RUngluMovementSpline.MoveCloneToPosition
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARPawnBase*                       CloneTarget                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRequirement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARUngluMovementSpline::MoveCloneToPosition(class ARPawnBase* CloneTarget, float PlayRate, const struct FVector& TargetLocation, float DistanceRequirement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUngluMovementSpline", "MoveCloneToPosition");

	Params::RUngluMovementSpline_MoveCloneToPosition Parms{};

	Parms.CloneTarget = CloneTarget;
	Parms.PlayRate = PlayRate;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.DistanceRequirement = DistanceRequirement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RUngluMovementSpline.SetSplineStopped
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bStop                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARUngluMovementSpline::SetSplineStopped(const bool bStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUngluMovementSpline", "SetSplineStopped");

	Params::RUngluMovementSpline_SetSplineStopped Parms{};

	Parms.bStop = bStop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RUngluMovementSpline.StartMovement
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARUngluMovementSpline::StartMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RUngluMovementSpline", "StartMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function RGame.RWeaponAnimInstance.GetPawnOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARPlayerPawn*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARPlayerPawn* URWeaponAnimInstance::GetPawnOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponAnimInstance", "GetPawnOwner");

	Params::RWeaponAnimInstance_GetPawnOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeaponAnimInstance.OnInstanceInitialized
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void URWeaponAnimInstance::OnInstanceInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponAnimInstance", "OnInstanceInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeaponAnimInstance.OnWeaponFired
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsPrimaryMod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URWeaponAnimInstance::OnWeaponFired(bool IsPrimaryMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponAnimInstance", "OnWeaponFired");

	Params::RWeaponAnimInstance_OnWeaponFired Parms{};

	Parms.IsPrimaryMod = IsPrimaryMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeaponPrimaryAsset.GetCompatibleModsBySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EWeaponModAttachmentSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URWeaponModPrimaryAsset*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URWeaponModPrimaryAsset*> URWeaponPrimaryAsset::GetCompatibleModsBySlot(EWeaponModAttachmentSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponPrimaryAsset", "GetCompatibleModsBySlot");

	Params::RWeaponPrimaryAsset_GetCompatibleModsBySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeaponPrimaryAsset.GetDefaultCosmeticPA
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URWeaponCosmeticPrimaryAsset*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URWeaponCosmeticPrimaryAsset* URWeaponPrimaryAsset::GetDefaultCosmeticPA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponPrimaryAsset", "GetDefaultCosmeticPA");

	Params::RWeaponPrimaryAsset_GetDefaultCosmeticPA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutableWeaponSettings.AddFloatCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::AddFloatCoefficient(EFloatWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "AddFloatCoefficient");

	Params::RMutableWeaponSettings_AddFloatCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.AddFloatPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::AddFloatPostAdditive(EFloatWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "AddFloatPostAdditive");

	Params::RMutableWeaponSettings_AddFloatPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.AddFloatPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::AddFloatPreAdditive(EFloatWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "AddFloatPreAdditive");

	Params::RMutableWeaponSettings_AddFloatPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.AddIntegerCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::AddIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "AddIntegerCoefficient");

	Params::RMutableWeaponSettings_AddIntegerCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.AddIntegerPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::AddIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "AddIntegerPostAdditive");

	Params::RMutableWeaponSettings_AddIntegerPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.AddIntegerPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::AddIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "AddIntegerPreAdditive");

	Params::RMutableWeaponSettings_AddIntegerPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.GetFloatTotalPositiveCoefficients
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URMutableWeaponSettings::GetFloatTotalPositiveCoefficients(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "GetFloatTotalPositiveCoefficients");

	Params::RMutableWeaponSettings_GetFloatTotalPositiveCoefficients Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutableWeaponSettings.GetFloatTotalPositivePostAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URMutableWeaponSettings::GetFloatTotalPositivePostAdditive(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "GetFloatTotalPositivePostAdditive");

	Params::RMutableWeaponSettings_GetFloatTotalPositivePostAdditive Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutableWeaponSettings.GetFloatTotalPositivePreAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URMutableWeaponSettings::GetFloatTotalPositivePreAdditive(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "GetFloatTotalPositivePreAdditive");

	Params::RMutableWeaponSettings_GetFloatTotalPositivePreAdditive Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutableWeaponSettings.GetFloatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URMutableWeaponSettings::GetFloatValue(EFloatWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "GetFloatValue");

	Params::RMutableWeaponSettings_GetFloatValue Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutableWeaponSettings.GetIntegerValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URMutableWeaponSettings::GetIntegerValue(EIntegerWeaponStat Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "GetIntegerValue");

	Params::RMutableWeaponSettings_GetIntegerValue Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RMutableWeaponSettings.RemoveFloatCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::RemoveFloatCoefficient(EFloatWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "RemoveFloatCoefficient");

	Params::RMutableWeaponSettings_RemoveFloatCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.RemoveFloatPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::RemoveFloatPostAdditive(EFloatWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "RemoveFloatPostAdditive");

	Params::RMutableWeaponSettings_RemoveFloatPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.RemoveFloatPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFloatWeaponStat                        Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::RemoveFloatPreAdditive(EFloatWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "RemoveFloatPreAdditive");

	Params::RMutableWeaponSettings_RemoveFloatPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.RemoveIntegerCoefficient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::RemoveIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "RemoveIntegerCoefficient");

	Params::RMutableWeaponSettings_RemoveIntegerCoefficient Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.RemoveIntegerPostAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::RemoveIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "RemoveIntegerPostAdditive");

	Params::RMutableWeaponSettings_RemoveIntegerPostAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RMutableWeaponSettings.RemoveIntegerPreAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIntegerWeaponStat                      Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URMutableWeaponSettings::RemoveIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RMutableWeaponSettings", "RemoveIntegerPreAdditive");

	Params::RMutableWeaponSettings_RemoveIntegerPreAdditive Parms{};

	Parms.Stat = Stat;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeaponWorkbench.ClearGScripts
// (Final, Native, Protected, BlueprintCallable)

void ARWeaponWorkbench::ClearGScripts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponWorkbench", "ClearGScripts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeaponWorkbench.SortListOptions
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class URPrimaryDataAsset*>&      Options                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARWeaponWorkbench::SortListOptions(TArray<class URPrimaryDataAsset*>& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponWorkbench", "SortListOptions");

	Params::RWeaponWorkbench_SortListOptions Parms{};

	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Options = std::move(Parms.Options);
}


// Function RGame.RWeaponWorkbench.UpdateBody
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class URWeaponPrimaryAsset*             NewPrimaryAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeaponWorkbench::UpdateBody(class URWeaponPrimaryAsset* NewPrimaryAsset, class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponWorkbench", "UpdateBody");

	Params::RWeaponWorkbench_UpdateBody Parms{};

	Parms.NewPrimaryAsset = NewPrimaryAsset;
	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeaponWorkbench.UpdateMod
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class URWeaponModPrimaryAsset*          NewPrimaryAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EWeaponModAttachmentSlot          TargetAttachmentSlot                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeaponWorkbench::UpdateMod(class URWeaponModPrimaryAsset* NewPrimaryAsset, const EWeaponModAttachmentSlot TargetAttachmentSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponWorkbench", "UpdateMod");

	Params::RWeaponWorkbench_UpdateMod Parms{};

	Parms.NewPrimaryAsset = NewPrimaryAsset;
	Parms.TargetAttachmentSlot = TargetAttachmentSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RGame.RWeaponWorkbench.GetCurrentBody
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ARWeapon>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ARWeapon> ARWeaponWorkbench::GetCurrentBody() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponWorkbench", "GetCurrentBody");

	Params::RWeaponWorkbench_GetCurrentBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeaponWorkbench.GetCurrentWeaponPrimaryAsset
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URWeaponPrimaryAsset*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URWeaponPrimaryAsset* ARWeaponWorkbench::GetCurrentWeaponPrimaryAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeaponWorkbench", "GetCurrentWeaponPrimaryAsset");

	Params::RWeaponWorkbench_GetCurrentWeaponPrimaryAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RGame.RWeapon_EngineRifle.ToggleSecondaryModFX
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bNewVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARWeapon_EngineRifle::ToggleSecondaryModFX(const bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon_EngineRifle", "ToggleSecondaryModFX");

	Params::RWeapon_EngineRifle_ToggleSecondaryModFX Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function RGame.RWeapon_EngineRifle.UpdateProjectileShotFX
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ARWeapon_EngineRifle::UpdateProjectileShotFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RWeapon_EngineRifle", "UpdateProjectileShotFX");

	UObject::ProcessEvent(Func, nullptr);
}

}

