#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RGame

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DMUtilities_classes.hpp"
#include "RGame_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayTags_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "CommonUI_classes.hpp"
#include "Niagara_structs.hpp"
#include "Niagara_classes.hpp"
#include "FieldSystemEngine_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "CommonInput_structs.hpp"
#include "GeometryCollectionEngine_classes.hpp"
#include "GameplayTasks_classes.hpp"
#include "OnlineSubsystemUtils_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"


namespace SDK
{

// Class RGame.RPawnBase
// 0x43A0 (0x46C8 - 0x0328)
class ARPawnBase : public APawn
{
public:
	class FName                                   ServerPawnName;                                    // 0x0328(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHealthComponent*                      HealthComponent;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class ARPawnBase* Pawn, const struct FDamageCombatEvent& DamageEventData)> OnDealtDamage; // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPawnBase* Pawn, class AActor* DamagedActor, bool bWasCritical, int32 DamageSourceMask)> OnPreDealtDamage; // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsAI;                                             // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockPitchAndRollRotation;                         // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutatorModifiers                     MutatorModifiers;                                  // 0x0370(0x2178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutatorModifiers                     DamageTakenModifiers;                              // 0x24E8(0x2178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   DamageTakenFXTag;                                  // 0x4660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URStatusEffectGScript* StatusEffectScript)> OnStatusEffectAttached; // 0x4668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URStatusEffectGScript* StatusEffectScript)> OnAttachedStatusEffectStacked; // 0x4678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URStatusEffectGScript* StatusEffectScript)> OnAttachedStatusEffectRemoved; // 0x4688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URStatusEffectGScript* StatusEffectScript)> OnAppliedStatusEffectRemoved; // 0x4698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URStatusEffectGScript* StatusEffectScript)> OnStatusEffectApplied; // 0x46A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URStatusEffectGScript* StatusEffectScript)> OnStatusEffectStacked; // 0x46B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool GetIsAlive();
	void OnDamageCombatEvent(const struct FDamageCombatEvent& DamageEventData);
	void OnRep_ServerPawnName();

	class UCapsuleComponent* GetCapsuleComponent() const;
	class FName GetGScriptCategory() const;
	class URGScriptComponent* GetGScriptComponent() const;
	class URHealthComponent* GetHealthComponent() const;
	class URPawnMovementComponent* GetRPawnMovementComponent() const;
	class USkeletalMeshComponent* GetSkeletalMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPawnBase">();
	}
	static class ARPawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPawnBase>();
	}
};
static_assert(alignof(ARPawnBase) == 0x000008, "Wrong alignment on ARPawnBase");
static_assert(sizeof(ARPawnBase) == 0x0046C8, "Wrong size on ARPawnBase");
static_assert(offsetof(ARPawnBase, ServerPawnName) == 0x000328, "Member 'ARPawnBase::ServerPawnName' has a wrong offset!");
static_assert(offsetof(ARPawnBase, CapsuleComponent) == 0x000330, "Member 'ARPawnBase::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ARPawnBase, SkeletalMesh) == 0x000338, "Member 'ARPawnBase::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ARPawnBase, HealthComponent) == 0x000340, "Member 'ARPawnBase::HealthComponent' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnDealtDamage) == 0x000348, "Member 'ARPawnBase::OnDealtDamage' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnPreDealtDamage) == 0x000358, "Member 'ARPawnBase::OnPreDealtDamage' has a wrong offset!");
static_assert(offsetof(ARPawnBase, bIsAI) == 0x000368, "Member 'ARPawnBase::bIsAI' has a wrong offset!");
static_assert(offsetof(ARPawnBase, bLockPitchAndRollRotation) == 0x000369, "Member 'ARPawnBase::bLockPitchAndRollRotation' has a wrong offset!");
static_assert(offsetof(ARPawnBase, MutatorModifiers) == 0x000370, "Member 'ARPawnBase::MutatorModifiers' has a wrong offset!");
static_assert(offsetof(ARPawnBase, DamageTakenModifiers) == 0x0024E8, "Member 'ARPawnBase::DamageTakenModifiers' has a wrong offset!");
static_assert(offsetof(ARPawnBase, DamageTakenFXTag) == 0x004660, "Member 'ARPawnBase::DamageTakenFXTag' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnStatusEffectAttached) == 0x004668, "Member 'ARPawnBase::OnStatusEffectAttached' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnAttachedStatusEffectStacked) == 0x004678, "Member 'ARPawnBase::OnAttachedStatusEffectStacked' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnAttachedStatusEffectRemoved) == 0x004688, "Member 'ARPawnBase::OnAttachedStatusEffectRemoved' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnAppliedStatusEffectRemoved) == 0x004698, "Member 'ARPawnBase::OnAppliedStatusEffectRemoved' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnStatusEffectApplied) == 0x0046A8, "Member 'ARPawnBase::OnStatusEffectApplied' has a wrong offset!");
static_assert(offsetof(ARPawnBase, OnStatusEffectStacked) == 0x0046B8, "Member 'ARPawnBase::OnStatusEffectStacked' has a wrong offset!");

// Class RGame.RPlayerPawn
// 0x18D0 (0x5F98 - 0x46C8)
class ARPlayerPawn : public ARPawnBase
{
public:
	uint8                                         Pad_46C8[0x4C];                                    // 0x46C8(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  AimAssistTarget;                                   // 0x4714(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USkeletalMeshComponent>  AimAssistTargetSK;                                 // 0x471C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4724[0x1C];                                    // 0x4724(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class ARLevelGenerator*                       CachedLevelGenerator;                              // 0x4740(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4748[0x38];                                    // 0x4748(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class URPlayerGScriptComponent*               GScriptOwnerComponent;                             // 0x4780(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URPlayerPawnMovementComponent*          PlayerMovementComponent;                           // 0x4788(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDMActorProximitySphereComponent*       ActorProximitySphereComponent;                     // 0x4790(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCineCameraComponent*                   FirstPersonCamera;                                 // 0x4798(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x47A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      ScopeMaterial;                                     // 0x47A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CameraRigSkeleton;                                 // 0x47B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSkeletalMeshComponent*                ArmsSkeletalMesh;                                  // 0x47B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HelmetMesh;                                        // 0x47C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CharacterMontage;                                  // 0x47C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ArmsMontage;                                       // 0x47D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CharacterMontageAdditive;                          // 0x47D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ArmsMontageAdditive;                               // 0x47E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFirstPersonModelFOV;                           // 0x47E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47E9[0x3];                                     // 0x47E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstPersonModelFOV;                               // 0x47EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DownedStatusEffectClass;                           // 0x47F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URGCharacterScript>         BaseCharacterScript;                               // 0x4818(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URGCharacterScript*                     RuntimeCharacterScript;                            // 0x4820(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARWeapon*                               EquippedWeapon;                                    // 0x4828(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshHueShift;                                      // 0x4830(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseTurnRate;                                      // 0x4834(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x4838(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawThreshold;                                      // 0x483C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CorrectionRate;                                    // 0x4840(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawCorrectionTolerance;                            // 0x4850(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4854[0x1];                                     // 0x4854(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReloadHeldDuringCharge;                           // 0x4855(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReloadHeldDuringNonAutomaticFire;                 // 0x4856(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4857[0x19];                                    // 0x4857(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         ReviveCastTime;                                    // 0x4870(0x0128)(Edit, BlueprintVisible, Net, Protected, NativeAccessSpecifierProtected)
	struct FRMutableFloat                         ReviveHealthCostPercentage;                        // 0x4998(0x0128)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class ARPlayerPawn*                           CurrentRevivingPawn;                               // 0x4AC0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ReviveStartLocation;                               // 0x4AC8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AE0[0x8];                                     // 0x4AE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumMutatorSlots;                                   // 0x4AE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AEC[0x1C];                                    // 0x4AEC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthLostFromFall;                                // 0x4B08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0C[0x4];                                     // 0x4B0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeSweepRange;                                   // 0x4B10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeSweepRadius;                                  // 0x4B14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHitResult>                     CachedMeleeHits;                                   // 0x4B18(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ARNPCPawnBase*                          LastKilledEnemy;                                   // 0x4B28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URPawnDownedWidget*                     PawnDownedWidget;                                  // 0x4B30(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ARPlayerPawn*, struct FTimerHandle> PendingRevived;                                   // 0x4B38(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B88[0x4];                                     // 0x4B88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputRetryDelay;                                   // 0x4B8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B90[0xF0];                                    // 0x4B90(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRoomObjectiveItemsHeld;                         // 0x4C80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C84[0x4];                                     // 0x4C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             RespawnLocationUpdateBlocks;                       // 0x4C88(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class ARPingIndicator*                        CurrentPingIndicatorRef;                           // 0x4CD8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasHeavyPayload;                                  // 0x4CE0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CE1[0x3];                                     // 0x4CE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistMaxDetectionDistance;                     // 0x4CE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AimAssistStrengthCurve;                            // 0x4CE8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistDetectionCapsuleRadius;                   // 0x4CF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistDetectionCapsuleRadiusTargetMultiplier;   // 0x4CF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistAutoRotationSpeed;                        // 0x4CF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistTurnRate;                                 // 0x4CFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistLookUpRate;                               // 0x4D00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinAimAssistTargetLockTime;                        // 0x4D04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistZDistanceMultiplier;                      // 0x4D08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0C[0x4];                                     // 0x4D0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      AimAssistBlockingObjectTypes;                      // 0x4D10(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      AimAssistValidObjectTypes;                         // 0x4D20(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         VerticalInputClearThreshold;                       // 0x4D30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistAngleThreshold;                           // 0x4D34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFrameRateIndependentAimAssist;                 // 0x4D38(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D39[0x3];                                     // 0x4D39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadTurnRateThreshold;                          // 0x4D3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadTurnSensitivityIncrement;                   // 0x4D40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadTurnMaxDynamicSensitivity;                  // 0x4D44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerMeshAttachment                  MeleeWeaponMeshAttachment;                         // 0x4D48(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayerMeshAttachment                  SyringeMeshAttachment;                             // 0x4DA8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayerMeshAttachment                  AnchorMeshAttachment;                              // 0x4E08(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayerMeshAttachment                  AtlanteanCubeMeshAttachment;                       // 0x4E68(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayerMeshAttachment                  DropShieldMeshAttachment;                          // 0x4EC8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayerMeshAttachment                  HeavyPayloadMeshAttachment;                        // 0x4F28(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CachedMeleeWeaponMesh;                             // 0x4F88(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CachedSyringeMesh;                                 // 0x4F90(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CachedAnchorMesh;                                  // 0x4F98(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CachedAtlanteanCubeMesh;                           // 0x4FA0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CachedDropShieldMesh;                              // 0x4FA8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CachedHeavyPayloadMesh;                            // 0x4FB0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FB8[0x90];                                    // 0x4FB8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalCrosshairDirection;                           // 0x5048(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalCrosshairOffset;                              // 0x5060(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatStartTime;                                   // 0x5078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCombat;                                         // 0x507C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPingInfo;                                     // 0x507D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_507E[0x2];                                     // 0x507E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastTimeDealtDamage;                               // 0x5080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5084[0x4];                                     // 0x5084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableInteger                       ExtraMutatorLootModifier;                          // 0x5088(0x0120)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         MeleeSpeed;                                        // 0x51A8(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         AbilitySpeed;                                      // 0x52D0(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ReviveHealBaseAmount;                              // 0x53F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53FC[0x4];                                     // 0x53FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         ReviveHealModifier;                                // 0x5400(0x0128)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_5528[0x10];                                    // 0x5528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         GoldGainModifier;                                  // 0x5538(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   GoldDisplayText;                                   // 0x5660(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ADSAimOffset;                                      // 0x5670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5674[0x4];                                     // 0x5674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x5678(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ElementalPostProcessMaterial;                      // 0x5680(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               UnderwaterPostProcessMaterial;                     // 0x5688(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       CharacterDynamicMaterialInstances;                 // 0x5690(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SpawnedAttachedDustFX;                             // 0x56A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      CurrentCosmeticPaintJobMI;                         // 0x56A8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URPrimaryDataAsset*                     CurrentCosmeticWeaponPaintPA;                      // 0x56B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerVoiceSettings                   CurrentPlayerVoiceSettings;                        // 0x56B8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentVoicePriority;                              // 0x56C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56CC[0xC];                                     // 0x56CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCosmeticLoadout                      RCosmeticLoadout;                                  // 0x56D8(0x0340)(Net, RepNotify, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            ActiveAbilityInput;                                // 0x5A18(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            DashInput;                                         // 0x5A40(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            FireInput;                                         // 0x5A68(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            HealInput;                                         // 0x5A90(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            JumpInput;                                         // 0x5AB8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            LookRightInput;                                    // 0x5AE0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            LookRightInputGamepad;                             // 0x5B08(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            LookUpInput;                                       // 0x5B30(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            LookUpInputGamepad;                                // 0x5B58(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MeleeInput;                                        // 0x5B80(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MoveBackInput;                                     // 0x5BA8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MoveForwardInput;                                  // 0x5BD0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MoveForwardInputGamepad;                           // 0x5BF8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MoveLeftInput;                                     // 0x5C20(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MoveRightInput;                                    // 0x5C48(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MoveRightInputGamepad;                             // 0x5C70(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            ReloadInput;                                       // 0x5C98(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            SecondaryFireInput;                                // 0x5CC0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CE8[0xF0];                                    // 0x5CE8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player, class URGScript* SourceScript, bool Active)> OnShieldToggled; // 0x5DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player, class URGScript* SourceScript, int32 Ammo, int32 Delta)> OnAmmoUpdated; // 0x5DE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ClipSize)> OnClipSizeUpdated;                                // 0x5DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARWeapon* Weapon)> OnWeaponEquipped;                         // 0x5E08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player, class AActor* HitActor, class ARProjectileBase* ProjectileActor)> OnProjectileHit; // 0x5E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player, const TArray<struct FHitResult>& Hits)> OnPlayerAreaAttack; // 0x5E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player, const TArray<struct FHitResult>& Hits)> OnPlayerLesserAreaAttack; // 0x5E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCombatEntered;                                   // 0x5E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCombatLeft;                                      // 0x5E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player)> OnPlayerPawnDowned;                   // 0x5E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player)> OnPlayerPawnKilled;                   // 0x5E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player)> OnPlayerPawnRevived;                  // 0x5E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player)> OnPlayerPawnRespawned;                // 0x5E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARNPCPawnBase* NPC)> OnNPCPawnKilled;                        // 0x5EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* RevivingPlayer, float CastTime, float CurrentCastTime)> OnRevivedCastStarted; // 0x5EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* RevivingPlayer)> OnRevivedCastFinished;        // 0x5EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* RevivingPlayer)> OnRevivedCastInterrupted;     // 0x5ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* Player, bool bIsPrimary)> OnPlayerWeaponModFire; // 0x5EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float FOV)>     OnFOVChanged;                                      // 0x5EF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsCurrentlySpectated)> OnCurrentlySpectatedChanged;          // 0x5F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 AbilityIndex)> OnAbilityUsed;                                // 0x5F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerFellOutOfWorld;                            // 0x5F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerTeleported;                                // 0x5F38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerStartTeleport;                             // 0x5F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerPickedUpSoulFragment;                      // 0x5F58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerBrokePot;                                  // 0x5F68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URGWeaponModScript* WeaponModScript)> OnPlayerFanFireProjectile; // 0x5F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UAudioComponent* PlayingVoiceAC, class FText PlayerName, class FText Subtitle)> OnVoiceLinePlayed; // 0x5F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class FName GetEquippedWeaponCategory();

	void AddGameplayTag(const struct FGameplayTag& NewGameplayTag);
	void AddPawnDownedWidget();
	void AddPingInputBlock(class FName Key);
	class UMaterialInstanceDynamic* AddPostProcessMaterial(class APostProcessVolume* Volume, class UMaterialInterface* MaterialParent);
	void AddRecoil(const struct FRotator& Recoil);
	void AddRespawnLocationUpdateBlock(class FName Key);
	void AddRoomObjectiveItemsHeld(int32 Amount);
	void AddRotationInputBlock(class FName Key);
	void AddTemporaryInputBlockers(class FName Key, bool bBlockControlInput, bool bBlockInputPhysics, bool bBlockDash, bool bBlockJump, bool bBlockRotation, float Duration);
	void AddWeaponVisibilityBlock(class FName Key);
	void AnimEvent_Multicast(class FName Event);
	void BroadcastOnPlayerBrokePot_Multicast();
	void CallOnPlayerAreaAttack(const TArray<struct FHitResult>& Hits);
	void CallOnPlayerLesserAreaAttack(const TArray<struct FHitResult>& Hits);
	void CallOnPlayerPickedUpSoulFragment();
	void CancelFadeOutTeleport();
	void ClearAllInputBlockers();
	void ClearDownedState();
	void ClearPingInputBlocks();
	void ClearRotationInputBlocks();
	void ClearWeaponVisibilityBlocks();
	void DisableActionsWhenDowned(class FName Key);
	void EmoteCameraZoomOutImplementation();
	void EmoteMontageEnded();
	void EnableActionsWhenRevived(class FName Key);
	void EnterCombat();
	TArray<class UMaterialInstanceDynamic*> GetCharacterMaterials();
	void GetCrosshairWorldTransform(struct FVector* WorldLocation, struct FVector* WorldDirection);
	class URGWeaponScript* GetCurrentWeaponScript();
	int32 GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	struct FVector GetMuzzleLocation();
	struct FTransform GetPawnViewTransform();
	void GetPawnWorldViewTransform(struct FVector* WorldLocation, struct FVector* WorldDirection);
	struct FLinearColor GetPlayerColor();
	float GetReviveCastTime();
	float GetReviveHealthCostPercentage();
	void HandleInputMethodChanged(ECommonInputType NewInputType);
	bool HasGameplayTag(const struct FGameplayTag& Tag);
	void InterruptEmote();
	bool IsInEmoteState();
	void LeaveCombat();
	void OnAbilityActivate(int32 AbilityIndex);
	void OnAbilityReleased(int32 AbilityIndex);
	void OnEnemyKilled(class ARNPCPawnBase* EnemyPawn);
	void OnFire();
	void OnLevelChanged();
	void OnPlayerFellOutOfWorld_Multicast();
	void OnPlayerPawnDowned_Multicast();
	void OnPlayerPawnKilled_Multicast();
	void OnPlayerPawnRespawned_Multicast();
	void OnPlayerPawnRevived_Multicast();
	void OnPlayerStartTeleport_Multicast();
	void OnPlayerTeleported_Multicast(const struct FVector& Location);
	void OnPlayerWeaponModFired(bool IsPrimaryMod);
	void OnPostProcessVolumeAssigned(class APostProcessVolume* Volume);
	void OnPreLevelChanged();
	void OnReleasedReload();
	void OnReleaseFire();
	void OnReleaseSecondaryFire();
	void OnReload();
	void OnRep_CosmeticLoadout();
	void OnRep_EquippedWeapon();
	void OnRep_MeshHueShift();
	void OnRevivedCastFinished_Multicast(class ARPlayerPawn* RevivingPlayer);
	void OnRevivedCastInterrupted_Multicast(class ARPlayerPawn* RevivingPlayer);
	void OnRevivedCastStarted_Multicast(class ARPlayerPawn* RevivingPlayer, float CastTime, float CurrentCastTime);
	void OnRevivingPlayerHealthDepleted(class URHealthComponent* RevivingPlayerHealthComponent, const struct FDamageCombatEvent& DamageEventData);
	void OnRevivingPlayerMovement(class ARPawnBase* Pawn);
	void OnRevivingPlayerWeaponModFired(class ARPlayerPawn* Player, bool IsPrimaryFire);
	void OnRunStarted();
	void OnSecondaryFire();
	void OnSegmentCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnSegmentStarted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnWidgetPushed(class URCommonActivatableWidget* Widget);
	void OnWidgetPushedDelayed();
	bool PlayCameraShakeIfLocalPlayer(TSubclassOf<class UCameraShakeBase> ShakeClass, class UMaterialInterface* DecalMaterial, class UNiagaraSystem* SystemTemplate, class USoundBase* Sound, const bool ShouldAutoPoolNiagara, const ENCPoolMethod PoolingMethod);
	void PlayDoorTeleportTimeline(float Duration);
	void PlayEmote(const class FName EmoteName);
	void PlayEmote_Multicast(const class FName EmoteName);
	void PlayEmote_Server(const class FName EmoteName);
	void PlayEmoteMontage(const class FName EmoteName);
	void PlayPostProcessDamageTaken(const struct FDamageCombatEvent& DamageCombatEvent);
	void PlayVignetteTimeline(const float Duration, const float IntensityMultiplier);
	void PlayVoiceLine(const class FName Event, const TArray<struct FVoiceQueryDataPair>& EventData);
	void PlayVoiceLine_Server(const class FName Event, const TArray<struct FVoiceQueryDataPair>& EventData);
	void RemoveGameplayTag(const struct FGameplayTag& GameplayTag, const struct FTimerHandle& TimerHandle);
	void RemovePawnDownedWidget();
	void RemovePingInputBlock(class FName Key);
	void RemoveRespawnLocationUpdateBlock(class FName Key);
	void RemoveRotationInputBlock(class FName Key);
	void RemoveWeaponVisibilityBlock(class FName Key);
	void ResetEnvironmentFX(const class FName ParameterName, const float Param);
	void ResetRoomObjectiveItemsHeld_Multicast();
	void RevivePlayer();
	void ServerOnAbilityActivate(int32 AbilityIndex);
	void ServerOnAbilityReleased(int32 AbilityIndex);
	void ServerOnFire(int32 CurrentAmmo);
	void ServerOnReleaseFire(uint32 LastProjectileId);
	void ServerOnReleaseSecondaryFire(uint32 LastProjectileId);
	void ServerOnReload();
	void ServerOnSecondaryFire(int32 CurrentAmmo);
	void SetFOV(float FOV);
	void SetLocationAndRotation_Multicast(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void SetLookUpRate(float Value);
	void SetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 NewRank);
	void SetPlayerAliveRevive_Multicast();
	class USkeletalMeshComponent* SetSyringeVisibility(bool Visibility);
	void SetTurnRate(float Value);
	void SetUpEventBinds();
	void ShowDownedHighlighting(const bool bNewShow);
	void SimulateMoveForward(const float Value);
	void SpawnVoiceLine(const struct FVoiceData& VoiceOverData, const float Priority);
	void SpawnVoiceLine_Multicast(const class FName Event, const float Priority, const int32 VariationsIndex);
	void StartFadeOutTeleport(float FadeTime);
	void StartVoiceLineCooldown(const float Time, const float Priority);
	TArray<struct FHitResult> SweepMeleeHitActors(float RangeOverride);
	void ToggleAbilityVisibility(bool AnchorVisibility, bool DropShieldVisibility, bool AtlanteanCubeVisibility);
	void ToggleElementalPostProcessVisual(const class FName ParameterName, const float Value);
	void TogglePayload(bool Active);
	void ToggleShowPingInfo();
	void ToggleUnderwaterPostProcessVisual(const bool bVisible);
	void ToggleWeaponVisibilities(bool bNewMeleeVisibility, bool bNewWeaponVisibility, class FName Key, bool bHideOnServer);
	void ToggleWeaponVisibility(bool MeleeNewVisibility, bool PrimaryNewVisibility);
	void TryUpdatePlayerResetPosition();
	void UndrawPingOnSelf();
	void UnequipWeapon(class ARWeapon* Weapon);
	void UpdatePlayerMesh();

	class USkeletalMeshComponent* GetArmsSkeletalMeshComponent() const;
	class UAnimMontage* GetDefaultArmsMontage() const;
	class UAnimMontage* GetDefaultArmsMontageAdditive() const;
	class UAnimMontage* GetDefaultCharacterMontage() const;
	class UAnimMontage* GetDefaultCharacterMontageAdditive() const;
	class ARWeapon* GetEquippedWeapon() const;
	class UCineCameraComponent* GetFirstPersonCamera() const;
	class UStaticMeshComponent* GetHelmetStaticMeshComponent() const;
	class UDMActorProximitySphereComponent* GetProximitySphereComponent() const;
	bool IsDowned() const;
	bool IsPingInputBlocked() const;
	bool IsRespawnLocationUpdateBlocked() const;
	bool IsRotationInputBlocked() const;
	bool IsWeaponVisibilityBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerPawn">();
	}
	static class ARPlayerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPlayerPawn>();
	}
};
static_assert(alignof(ARPlayerPawn) == 0x000008, "Wrong alignment on ARPlayerPawn");
static_assert(sizeof(ARPlayerPawn) == 0x005F98, "Wrong size on ARPlayerPawn");
static_assert(offsetof(ARPlayerPawn, AimAssistTarget) == 0x004714, "Member 'ARPlayerPawn::AimAssistTarget' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistTargetSK) == 0x00471C, "Member 'ARPlayerPawn::AimAssistTargetSK' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedLevelGenerator) == 0x004740, "Member 'ARPlayerPawn::CachedLevelGenerator' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, GScriptOwnerComponent) == 0x004780, "Member 'ARPlayerPawn::GScriptOwnerComponent' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, PlayerMovementComponent) == 0x004788, "Member 'ARPlayerPawn::PlayerMovementComponent' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ActorProximitySphereComponent) == 0x004790, "Member 'ARPlayerPawn::ActorProximitySphereComponent' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, FirstPersonCamera) == 0x004798, "Member 'ARPlayerPawn::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, PostProcessComponent) == 0x0047A0, "Member 'ARPlayerPawn::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ScopeMaterial) == 0x0047A8, "Member 'ARPlayerPawn::ScopeMaterial' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CameraRigSkeleton) == 0x0047B0, "Member 'ARPlayerPawn::CameraRigSkeleton' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ArmsSkeletalMesh) == 0x0047B8, "Member 'ARPlayerPawn::ArmsSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, HelmetMesh) == 0x0047C0, "Member 'ARPlayerPawn::HelmetMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CharacterMontage) == 0x0047C8, "Member 'ARPlayerPawn::CharacterMontage' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ArmsMontage) == 0x0047D0, "Member 'ARPlayerPawn::ArmsMontage' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CharacterMontageAdditive) == 0x0047D8, "Member 'ARPlayerPawn::CharacterMontageAdditive' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ArmsMontageAdditive) == 0x0047E0, "Member 'ARPlayerPawn::ArmsMontageAdditive' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bUseFirstPersonModelFOV) == 0x0047E8, "Member 'ARPlayerPawn::bUseFirstPersonModelFOV' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, FirstPersonModelFOV) == 0x0047EC, "Member 'ARPlayerPawn::FirstPersonModelFOV' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, DownedStatusEffectClass) == 0x0047F0, "Member 'ARPlayerPawn::DownedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, BaseCharacterScript) == 0x004818, "Member 'ARPlayerPawn::BaseCharacterScript' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, RuntimeCharacterScript) == 0x004820, "Member 'ARPlayerPawn::RuntimeCharacterScript' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, EquippedWeapon) == 0x004828, "Member 'ARPlayerPawn::EquippedWeapon' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MeshHueShift) == 0x004830, "Member 'ARPlayerPawn::MeshHueShift' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, BaseTurnRate) == 0x004834, "Member 'ARPlayerPawn::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, BaseLookUpRate) == 0x004838, "Member 'ARPlayerPawn::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, YawThreshold) == 0x00483C, "Member 'ARPlayerPawn::YawThreshold' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CorrectionRate) == 0x004840, "Member 'ARPlayerPawn::CorrectionRate' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, YawCorrectionTolerance) == 0x004850, "Member 'ARPlayerPawn::YawCorrectionTolerance' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bReloadHeldDuringCharge) == 0x004855, "Member 'ARPlayerPawn::bReloadHeldDuringCharge' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bReloadHeldDuringNonAutomaticFire) == 0x004856, "Member 'ARPlayerPawn::bReloadHeldDuringNonAutomaticFire' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ReviveCastTime) == 0x004870, "Member 'ARPlayerPawn::ReviveCastTime' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ReviveHealthCostPercentage) == 0x004998, "Member 'ARPlayerPawn::ReviveHealthCostPercentage' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CurrentRevivingPawn) == 0x004AC0, "Member 'ARPlayerPawn::CurrentRevivingPawn' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ReviveStartLocation) == 0x004AC8, "Member 'ARPlayerPawn::ReviveStartLocation' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, NumMutatorSlots) == 0x004AE8, "Member 'ARPlayerPawn::NumMutatorSlots' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, HealthLostFromFall) == 0x004B08, "Member 'ARPlayerPawn::HealthLostFromFall' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MeleeSweepRange) == 0x004B10, "Member 'ARPlayerPawn::MeleeSweepRange' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MeleeSweepRadius) == 0x004B14, "Member 'ARPlayerPawn::MeleeSweepRadius' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedMeleeHits) == 0x004B18, "Member 'ARPlayerPawn::CachedMeleeHits' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LastKilledEnemy) == 0x004B28, "Member 'ARPlayerPawn::LastKilledEnemy' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, PawnDownedWidget) == 0x004B30, "Member 'ARPlayerPawn::PawnDownedWidget' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, PendingRevived) == 0x004B38, "Member 'ARPlayerPawn::PendingRevived' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, InputRetryDelay) == 0x004B8C, "Member 'ARPlayerPawn::InputRetryDelay' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, NumRoomObjectiveItemsHeld) == 0x004C80, "Member 'ARPlayerPawn::NumRoomObjectiveItemsHeld' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, RespawnLocationUpdateBlocks) == 0x004C88, "Member 'ARPlayerPawn::RespawnLocationUpdateBlocks' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CurrentPingIndicatorRef) == 0x004CD8, "Member 'ARPlayerPawn::CurrentPingIndicatorRef' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bHasHeavyPayload) == 0x004CE0, "Member 'ARPlayerPawn::bHasHeavyPayload' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistMaxDetectionDistance) == 0x004CE4, "Member 'ARPlayerPawn::AimAssistMaxDetectionDistance' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistStrengthCurve) == 0x004CE8, "Member 'ARPlayerPawn::AimAssistStrengthCurve' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistDetectionCapsuleRadius) == 0x004CF0, "Member 'ARPlayerPawn::AimAssistDetectionCapsuleRadius' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistDetectionCapsuleRadiusTargetMultiplier) == 0x004CF4, "Member 'ARPlayerPawn::AimAssistDetectionCapsuleRadiusTargetMultiplier' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistAutoRotationSpeed) == 0x004CF8, "Member 'ARPlayerPawn::AimAssistAutoRotationSpeed' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistTurnRate) == 0x004CFC, "Member 'ARPlayerPawn::AimAssistTurnRate' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistLookUpRate) == 0x004D00, "Member 'ARPlayerPawn::AimAssistLookUpRate' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MinAimAssistTargetLockTime) == 0x004D04, "Member 'ARPlayerPawn::MinAimAssistTargetLockTime' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistZDistanceMultiplier) == 0x004D08, "Member 'ARPlayerPawn::AimAssistZDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistBlockingObjectTypes) == 0x004D10, "Member 'ARPlayerPawn::AimAssistBlockingObjectTypes' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistValidObjectTypes) == 0x004D20, "Member 'ARPlayerPawn::AimAssistValidObjectTypes' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, VerticalInputClearThreshold) == 0x004D30, "Member 'ARPlayerPawn::VerticalInputClearThreshold' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AimAssistAngleThreshold) == 0x004D34, "Member 'ARPlayerPawn::AimAssistAngleThreshold' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bUseFrameRateIndependentAimAssist) == 0x004D38, "Member 'ARPlayerPawn::bUseFrameRateIndependentAimAssist' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, GamepadTurnRateThreshold) == 0x004D3C, "Member 'ARPlayerPawn::GamepadTurnRateThreshold' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, GamepadTurnSensitivityIncrement) == 0x004D40, "Member 'ARPlayerPawn::GamepadTurnSensitivityIncrement' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, GamepadTurnMaxDynamicSensitivity) == 0x004D44, "Member 'ARPlayerPawn::GamepadTurnMaxDynamicSensitivity' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MeleeWeaponMeshAttachment) == 0x004D48, "Member 'ARPlayerPawn::MeleeWeaponMeshAttachment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, SyringeMeshAttachment) == 0x004DA8, "Member 'ARPlayerPawn::SyringeMeshAttachment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AnchorMeshAttachment) == 0x004E08, "Member 'ARPlayerPawn::AnchorMeshAttachment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AtlanteanCubeMeshAttachment) == 0x004E68, "Member 'ARPlayerPawn::AtlanteanCubeMeshAttachment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, DropShieldMeshAttachment) == 0x004EC8, "Member 'ARPlayerPawn::DropShieldMeshAttachment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, HeavyPayloadMeshAttachment) == 0x004F28, "Member 'ARPlayerPawn::HeavyPayloadMeshAttachment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedMeleeWeaponMesh) == 0x004F88, "Member 'ARPlayerPawn::CachedMeleeWeaponMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedSyringeMesh) == 0x004F90, "Member 'ARPlayerPawn::CachedSyringeMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedAnchorMesh) == 0x004F98, "Member 'ARPlayerPawn::CachedAnchorMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedAtlanteanCubeMesh) == 0x004FA0, "Member 'ARPlayerPawn::CachedAtlanteanCubeMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedDropShieldMesh) == 0x004FA8, "Member 'ARPlayerPawn::CachedDropShieldMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CachedHeavyPayloadMesh) == 0x004FB0, "Member 'ARPlayerPawn::CachedHeavyPayloadMesh' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LocalCrosshairDirection) == 0x005048, "Member 'ARPlayerPawn::LocalCrosshairDirection' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LocalCrosshairOffset) == 0x005060, "Member 'ARPlayerPawn::LocalCrosshairOffset' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CombatStartTime) == 0x005078, "Member 'ARPlayerPawn::CombatStartTime' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bInCombat) == 0x00507C, "Member 'ARPlayerPawn::bInCombat' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, bShowPingInfo) == 0x00507D, "Member 'ARPlayerPawn::bShowPingInfo' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LastTimeDealtDamage) == 0x005080, "Member 'ARPlayerPawn::LastTimeDealtDamage' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ExtraMutatorLootModifier) == 0x005088, "Member 'ARPlayerPawn::ExtraMutatorLootModifier' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MeleeSpeed) == 0x0051A8, "Member 'ARPlayerPawn::MeleeSpeed' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, AbilitySpeed) == 0x0052D0, "Member 'ARPlayerPawn::AbilitySpeed' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ReviveHealBaseAmount) == 0x0053F8, "Member 'ARPlayerPawn::ReviveHealBaseAmount' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ReviveHealModifier) == 0x005400, "Member 'ARPlayerPawn::ReviveHealModifier' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, GoldGainModifier) == 0x005538, "Member 'ARPlayerPawn::GoldGainModifier' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, GoldDisplayText) == 0x005660, "Member 'ARPlayerPawn::GoldDisplayText' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ADSAimOffset) == 0x005670, "Member 'ARPlayerPawn::ADSAimOffset' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, PostProcessVolume) == 0x005678, "Member 'ARPlayerPawn::PostProcessVolume' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ElementalPostProcessMaterial) == 0x005680, "Member 'ARPlayerPawn::ElementalPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, UnderwaterPostProcessMaterial) == 0x005688, "Member 'ARPlayerPawn::UnderwaterPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CharacterDynamicMaterialInstances) == 0x005690, "Member 'ARPlayerPawn::CharacterDynamicMaterialInstances' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, SpawnedAttachedDustFX) == 0x0056A0, "Member 'ARPlayerPawn::SpawnedAttachedDustFX' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CurrentCosmeticPaintJobMI) == 0x0056A8, "Member 'ARPlayerPawn::CurrentCosmeticPaintJobMI' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CurrentCosmeticWeaponPaintPA) == 0x0056B0, "Member 'ARPlayerPawn::CurrentCosmeticWeaponPaintPA' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CurrentPlayerVoiceSettings) == 0x0056B8, "Member 'ARPlayerPawn::CurrentPlayerVoiceSettings' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, CurrentVoicePriority) == 0x0056C8, "Member 'ARPlayerPawn::CurrentVoicePriority' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, RCosmeticLoadout) == 0x0056D8, "Member 'ARPlayerPawn::RCosmeticLoadout' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ActiveAbilityInput) == 0x005A18, "Member 'ARPlayerPawn::ActiveAbilityInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, DashInput) == 0x005A40, "Member 'ARPlayerPawn::DashInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, FireInput) == 0x005A68, "Member 'ARPlayerPawn::FireInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, HealInput) == 0x005A90, "Member 'ARPlayerPawn::HealInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, JumpInput) == 0x005AB8, "Member 'ARPlayerPawn::JumpInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LookRightInput) == 0x005AE0, "Member 'ARPlayerPawn::LookRightInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LookRightInputGamepad) == 0x005B08, "Member 'ARPlayerPawn::LookRightInputGamepad' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LookUpInput) == 0x005B30, "Member 'ARPlayerPawn::LookUpInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, LookUpInputGamepad) == 0x005B58, "Member 'ARPlayerPawn::LookUpInputGamepad' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MeleeInput) == 0x005B80, "Member 'ARPlayerPawn::MeleeInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MoveBackInput) == 0x005BA8, "Member 'ARPlayerPawn::MoveBackInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MoveForwardInput) == 0x005BD0, "Member 'ARPlayerPawn::MoveForwardInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MoveForwardInputGamepad) == 0x005BF8, "Member 'ARPlayerPawn::MoveForwardInputGamepad' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MoveLeftInput) == 0x005C20, "Member 'ARPlayerPawn::MoveLeftInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MoveRightInput) == 0x005C48, "Member 'ARPlayerPawn::MoveRightInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, MoveRightInputGamepad) == 0x005C70, "Member 'ARPlayerPawn::MoveRightInputGamepad' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, ReloadInput) == 0x005C98, "Member 'ARPlayerPawn::ReloadInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, SecondaryFireInput) == 0x005CC0, "Member 'ARPlayerPawn::SecondaryFireInput' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnShieldToggled) == 0x005DD8, "Member 'ARPlayerPawn::OnShieldToggled' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnAmmoUpdated) == 0x005DE8, "Member 'ARPlayerPawn::OnAmmoUpdated' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnClipSizeUpdated) == 0x005DF8, "Member 'ARPlayerPawn::OnClipSizeUpdated' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnWeaponEquipped) == 0x005E08, "Member 'ARPlayerPawn::OnWeaponEquipped' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnProjectileHit) == 0x005E18, "Member 'ARPlayerPawn::OnProjectileHit' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerAreaAttack) == 0x005E28, "Member 'ARPlayerPawn::OnPlayerAreaAttack' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerLesserAreaAttack) == 0x005E38, "Member 'ARPlayerPawn::OnPlayerLesserAreaAttack' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnCombatEntered) == 0x005E48, "Member 'ARPlayerPawn::OnCombatEntered' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnCombatLeft) == 0x005E58, "Member 'ARPlayerPawn::OnCombatLeft' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerPawnDowned) == 0x005E68, "Member 'ARPlayerPawn::OnPlayerPawnDowned' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerPawnKilled) == 0x005E78, "Member 'ARPlayerPawn::OnPlayerPawnKilled' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerPawnRevived) == 0x005E88, "Member 'ARPlayerPawn::OnPlayerPawnRevived' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerPawnRespawned) == 0x005E98, "Member 'ARPlayerPawn::OnPlayerPawnRespawned' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnNPCPawnKilled) == 0x005EA8, "Member 'ARPlayerPawn::OnNPCPawnKilled' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnRevivedCastStarted) == 0x005EB8, "Member 'ARPlayerPawn::OnRevivedCastStarted' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnRevivedCastFinished) == 0x005EC8, "Member 'ARPlayerPawn::OnRevivedCastFinished' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnRevivedCastInterrupted) == 0x005ED8, "Member 'ARPlayerPawn::OnRevivedCastInterrupted' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerWeaponModFire) == 0x005EE8, "Member 'ARPlayerPawn::OnPlayerWeaponModFire' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnFOVChanged) == 0x005EF8, "Member 'ARPlayerPawn::OnFOVChanged' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnCurrentlySpectatedChanged) == 0x005F08, "Member 'ARPlayerPawn::OnCurrentlySpectatedChanged' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnAbilityUsed) == 0x005F18, "Member 'ARPlayerPawn::OnAbilityUsed' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerFellOutOfWorld) == 0x005F28, "Member 'ARPlayerPawn::OnPlayerFellOutOfWorld' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerTeleported) == 0x005F38, "Member 'ARPlayerPawn::OnPlayerTeleported' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerStartTeleport) == 0x005F48, "Member 'ARPlayerPawn::OnPlayerStartTeleport' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerPickedUpSoulFragment) == 0x005F58, "Member 'ARPlayerPawn::OnPlayerPickedUpSoulFragment' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerBrokePot) == 0x005F68, "Member 'ARPlayerPawn::OnPlayerBrokePot' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnPlayerFanFireProjectile) == 0x005F78, "Member 'ARPlayerPawn::OnPlayerFanFireProjectile' has a wrong offset!");
static_assert(offsetof(ARPlayerPawn, OnVoiceLinePlayed) == 0x005F88, "Member 'ARPlayerPawn::OnVoiceLinePlayed' has a wrong offset!");

// Class RGame.RClientPredictionDebugContext
// 0x0008 (0x0030 - 0x0028)
class URClientPredictionDebugContext final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawClientPredictionDebugCapsule(float Radius, float HalfHeight, const struct FVector& Location, const struct FRotator& Rotation);
	void DrawClientPredictionDebugSphere(float Radius, const struct FVector& Location);

	class FName GetTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RClientPredictionDebugContext">();
	}
	static class URClientPredictionDebugContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<URClientPredictionDebugContext>();
	}
};
static_assert(alignof(URClientPredictionDebugContext) == 0x000008, "Wrong alignment on URClientPredictionDebugContext");
static_assert(sizeof(URClientPredictionDebugContext) == 0x000030, "Wrong size on URClientPredictionDebugContext");

// Class RGame.ClientPredictionInterface
// 0x0000 (0x0000 - 0x0000)
class IClientPredictionInterface final
{
public:
	void DebugClientPredictionState(class URClientPredictionDebugContext* DebugContext);
	void OnClientPredictionChangeInput();
	void OnClientPredictionChangeState();
	void OnOwningClientPredictionInputChanged();
	void TickPredictedObject(float DeltaTime);

	bool IsOwnerOfClientPredictionInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientPredictionInterface">();
	}
	static class IClientPredictionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IClientPredictionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IClientPredictionInterface) == 0x000001, "Wrong alignment on IClientPredictionInterface");
static_assert(sizeof(IClientPredictionInterface) == 0x000001, "Wrong size on IClientPredictionInterface");

// Class RGame.RObjectiveManager
// 0x0098 (0x0340 - 0x02A8)
class ARObjectiveManager : public AActor
{
public:
	class URGObjectiveScript*                     LastCreatedObjectiveScript;                        // 0x02A8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URObjectivePrimaryDataAsset*>    ObjectivePAs;                                      // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAlwaysAllowMultiplyerObjectives;                  // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToGenerateRoomObjective;                     // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARPlayerPawn*>                   RoomObjectiveContributingPlayers;                  // 0x02E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRoomObjectiveSegmentCompleted;                   // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URGObjectiveScript* ObjectiveScript)> OnObjectiveStarted;    // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ObjectiveTag)> OnObjectiveRemoved;      // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ObjectiveTag, bool bCompleted)> OnObjectiveEnded; // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo)> OnObjectiveUpdated; // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class ARObjectiveManager* GetObjectiveManager(const class UObject* WorldContextObject);

	void AdjustObjectsByNumPlayers(class AREnemySpawnAreaSegment* Segment);
	void EndObjective(const struct FGameplayTag& ObjectiveTag, bool bCompleted);
	class URObjectivePrimaryDataAsset* GetFirstObjectiveAssetByTag(const struct FGameplayTag& Tag);
	TArray<class URObjectivePrimaryDataAsset*> GetObjectiveAssetsByTag(const struct FGameplayTag& Tag);
	void HandlePlayerLeft(class APlayerState* PlayerState);
	void OnAreaChanged(class FName AreaName);
	void OnPreLevelChanged();
	void OnRep_LastCreatedObjectiveScript();
	void OnSpawnAreaSegmentCompleted(class AREnemySpawnAreaSegment* Segment);
	void StartObjective(const struct FRObjectiveData& ObjectiveData);
	void UpdateObjective(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo);

	void BroadcastObjectiveEnded_Multicast(const struct FGameplayTag& ObjectiveTag, bool bCompleted) const;
	void BroadcastObjectiveRemoved_Multicast(const struct FGameplayTag& ObjectiveTag) const;
	void BroadcastObjectiveUpdated_Multicast(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo) const;
	void BroadcastRoomObjectiveSegmentCompleted_Multicast() const;
	void LocalBroadcastObjectiveEnded(const struct FGameplayTag& ObjectiveTag, bool bCompleted) const;
	void LocalBroadcastObjectiveUpdated(const struct FGameplayTag& ObjectiveTag, const class FText& UpdateInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RObjectiveManager">();
	}
	static class ARObjectiveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARObjectiveManager>();
	}
};
static_assert(alignof(ARObjectiveManager) == 0x000008, "Wrong alignment on ARObjectiveManager");
static_assert(sizeof(ARObjectiveManager) == 0x000340, "Wrong size on ARObjectiveManager");
static_assert(offsetof(ARObjectiveManager, LastCreatedObjectiveScript) == 0x0002A8, "Member 'ARObjectiveManager::LastCreatedObjectiveScript' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, ObjectivePAs) == 0x0002C0, "Member 'ARObjectiveManager::ObjectivePAs' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, bAlwaysAllowMultiplyerObjectives) == 0x0002D0, "Member 'ARObjectiveManager::bAlwaysAllowMultiplyerObjectives' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, ChanceToGenerateRoomObjective) == 0x0002D4, "Member 'ARObjectiveManager::ChanceToGenerateRoomObjective' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, RoomObjectiveContributingPlayers) == 0x0002E0, "Member 'ARObjectiveManager::RoomObjectiveContributingPlayers' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, OnRoomObjectiveSegmentCompleted) == 0x0002F0, "Member 'ARObjectiveManager::OnRoomObjectiveSegmentCompleted' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, OnObjectiveStarted) == 0x000300, "Member 'ARObjectiveManager::OnObjectiveStarted' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, OnObjectiveRemoved) == 0x000310, "Member 'ARObjectiveManager::OnObjectiveRemoved' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, OnObjectiveEnded) == 0x000320, "Member 'ARObjectiveManager::OnObjectiveEnded' has a wrong offset!");
static_assert(offsetof(ARObjectiveManager, OnObjectiveUpdated) == 0x000330, "Member 'ARObjectiveManager::OnObjectiveUpdated' has a wrong offset!");

// Class RGame.ProximityCylinder
// 0x00E8 (0x0110 - 0x0028)
class UProximityCylinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(class AActor* Actor)> OnActorEnterProximity;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnActorExitProximity;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnInitialActorEnterProximity;                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnAllActorsExitProximity;                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x58];                                      // 0x0068(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           ActorsInProximity;                                 // 0x00C0(0x0050)(NativeAccessSpecifierPublic)

public:
	float GetCylinderHeight() const;
	float GetUnscaledCylinderRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityCylinder">();
	}
	static class UProximityCylinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityCylinder>();
	}
};
static_assert(alignof(UProximityCylinder) == 0x000008, "Wrong alignment on UProximityCylinder");
static_assert(sizeof(UProximityCylinder) == 0x000110, "Wrong size on UProximityCylinder");
static_assert(offsetof(UProximityCylinder, OnActorEnterProximity) == 0x000028, "Member 'UProximityCylinder::OnActorEnterProximity' has a wrong offset!");
static_assert(offsetof(UProximityCylinder, OnActorExitProximity) == 0x000038, "Member 'UProximityCylinder::OnActorExitProximity' has a wrong offset!");
static_assert(offsetof(UProximityCylinder, OnInitialActorEnterProximity) == 0x000048, "Member 'UProximityCylinder::OnInitialActorEnterProximity' has a wrong offset!");
static_assert(offsetof(UProximityCylinder, OnAllActorsExitProximity) == 0x000058, "Member 'UProximityCylinder::OnAllActorsExitProximity' has a wrong offset!");
static_assert(offsetof(UProximityCylinder, ActorsInProximity) == 0x0000C0, "Member 'UProximityCylinder::ActorsInProximity' has a wrong offset!");

// Class RGame.RBTTask_JumpTowards
// 0x0050 (0x00E8 - 0x0098)
class URBTTask_JumpTowards final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaxDist;                                           // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_JumpTowards">();
	}
	static class URBTTask_JumpTowards* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_JumpTowards>();
	}
};
static_assert(alignof(URBTTask_JumpTowards) == 0x000008, "Wrong alignment on URBTTask_JumpTowards");
static_assert(sizeof(URBTTask_JumpTowards) == 0x0000E8, "Wrong size on URBTTask_JumpTowards");
static_assert(offsetof(URBTTask_JumpTowards, Target) == 0x000098, "Member 'URBTTask_JumpTowards::Target' has a wrong offset!");
static_assert(offsetof(URBTTask_JumpTowards, MaxDist) == 0x0000C0, "Member 'URBTTask_JumpTowards::MaxDist' has a wrong offset!");

// Class RGame.DMActorProximityCylinderComponent
// 0x0010 (0x0330 - 0x0320)
class UDMActorProximityCylinderComponent final : public UDMActorProximityComponentBase
{
public:
	float                                         CylinderRadius;                                    // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderHeight;                                    // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProximityCylinder*                     ProximityCylinder;                                 // 0x0320(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPool;                                        // 0x0328(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetCylinderRadiusAndHeight(float* ReturnCylinderHeight, float* ReturnCylinderRadius);
	class UProximityCylinder* GetProximityCylinder();
	void UpdateProximityCylinderSize(const struct FVector& ScaleMulti);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DMActorProximityCylinderComponent">();
	}
	static class UDMActorProximityCylinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDMActorProximityCylinderComponent>();
	}
};
static_assert(alignof(UDMActorProximityCylinderComponent) == 0x000010, "Wrong alignment on UDMActorProximityCylinderComponent");
static_assert(sizeof(UDMActorProximityCylinderComponent) == 0x000330, "Wrong size on UDMActorProximityCylinderComponent");
static_assert(offsetof(UDMActorProximityCylinderComponent, CylinderRadius) == 0x000318, "Member 'UDMActorProximityCylinderComponent::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UDMActorProximityCylinderComponent, CylinderHeight) == 0x00031C, "Member 'UDMActorProximityCylinderComponent::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UDMActorProximityCylinderComponent, ProximityCylinder) == 0x000320, "Member 'UDMActorProximityCylinderComponent::ProximityCylinder' has a wrong offset!");
static_assert(offsetof(UDMActorProximityCylinderComponent, bCheckPool) == 0x000328, "Member 'UDMActorProximityCylinderComponent::bCheckPool' has a wrong offset!");

// Class RGame.RChallengeScript
// 0x0008 (0x0030 - 0x0028)
class URChallengeScript : public UObject
{
public:
	class ARPlayerController*                     PlayerController;                                  // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnApplicableRunStarted();
	void OnPlayerRegistered();
	void RunStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChallengeScript">();
	}
	static class URChallengeScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URChallengeScript>();
	}
};
static_assert(alignof(URChallengeScript) == 0x000008, "Wrong alignment on URChallengeScript");
static_assert(sizeof(URChallengeScript) == 0x000030, "Wrong size on URChallengeScript");
static_assert(offsetof(URChallengeScript, PlayerController) == 0x000028, "Member 'URChallengeScript::PlayerController' has a wrong offset!");

// Class RGame.RGScript
// 0x0098 (0x00C0 - 0x0028)
class URGScript : public UObject
{
public:
	uint8                                         Pad_28[0x11];                                      // 0x0028(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	EGScriptReplicationPolicy                     ReplicationPolicy;                                 // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Category;                                          // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ActiveFunctions;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGScriptActorInfo                      OwnerActorInfo;                                    // 0x0058(0x0030)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UGameplayTask*>                  ActiveTasks;                                       // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bActivated;                                        // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URGScript* Script, class FName Category, class FName ExecutionParam, int32 consumePriority)> OnFinishedExecution; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bStartWithTickScriptEnabled;                       // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickScriptInterval;                                // 0x00B4(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateScript();
	void BranchByNetRole(EGScriptNetRole* Branches);
	void DeactivateScript();
	void FinishExecution(class FName FunctionName, int32 consumePriority);
	void K2_ActivateScript();
	void K2_DeactivateScript();
	void K2_FinishCurrentExecution(int32 consumePriority);
	void K2_PreLevelTransition();
	void K2_TickScript(float DeltaTime);
	void OnRep_bActivated(bool bPreviousValue);
	void PreLevelTransition();
	void SetTickScriptEnabled(bool bShouldTickScript);
	void SetTickScriptInterval(float TickInterval);
	bool ShouldSkipExecution(class FName FunctionName);
	void TickScriptInterval_OnRep();

	class FName GetScriptFName() const;
	float GetTickScriptInterval() const;
	struct FGScriptActorInfo K2_GetCurrentActorInfo() const;
	class AController* K2_GetInstigatorController() const;
	class APawn* K2_GetInstigatorPawn() const;
	class APlayerController* K2_GetPlayerController() const;
	class URGScriptComponent* K2_GetRGScriptComponent() const;
	class USkeletalMeshComponent* K2_GetSkeletalmesh(class FName Tag) const;
	bool K2_IsInstigatorLocallyControlled() const;
	bool K2_IsScriptLocallyControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGScript">();
	}
	static class URGScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGScript>();
	}
};
static_assert(alignof(URGScript) == 0x000008, "Wrong alignment on URGScript");
static_assert(sizeof(URGScript) == 0x0000C0, "Wrong size on URGScript");
static_assert(offsetof(URGScript, ReplicationPolicy) == 0x000039, "Member 'URGScript::ReplicationPolicy' has a wrong offset!");
static_assert(offsetof(URGScript, Category) == 0x00003C, "Member 'URGScript::Category' has a wrong offset!");
static_assert(offsetof(URGScript, ActiveFunctions) == 0x000048, "Member 'URGScript::ActiveFunctions' has a wrong offset!");
static_assert(offsetof(URGScript, OwnerActorInfo) == 0x000058, "Member 'URGScript::OwnerActorInfo' has a wrong offset!");
static_assert(offsetof(URGScript, ActiveTasks) == 0x000088, "Member 'URGScript::ActiveTasks' has a wrong offset!");
static_assert(offsetof(URGScript, bActivated) == 0x000098, "Member 'URGScript::bActivated' has a wrong offset!");
static_assert(offsetof(URGScript, OnFinishedExecution) == 0x0000A0, "Member 'URGScript::OnFinishedExecution' has a wrong offset!");
static_assert(offsetof(URGScript, bStartWithTickScriptEnabled) == 0x0000B0, "Member 'URGScript::bStartWithTickScriptEnabled' has a wrong offset!");
static_assert(offsetof(URGScript, TickScriptInterval) == 0x0000B4, "Member 'URGScript::TickScriptInterval' has a wrong offset!");

// Class RGame.RStatusEffectGScript
// 0x0418 (0x04D8 - 0x00C0)
class URStatusEffectGScript : public URGScript
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRStatusEffectTickRecord               TickRecord;                                        // 0x00C8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         CurrentStackCount;                                 // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         EffectDamage;                                      // 0x00E0(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRMutableFloat                         EffectDuration;                                    // 0x0208(0x0128)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FRMutableFloat                         StatusEffectEffectiveness;                         // 0x0330(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxStackCount;                                     // 0x0458(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           EffectDestroyHandle;                               // 0x0460(0x0008)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AttachedParticles;                                 // 0x0468(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ExpirationTime;                                    // 0x0470(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URGScript*                              InstigatorScript;                                  // 0x0480(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDurationValue;                              // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasDispelled;                                     // 0x048C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48D[0x3];                                      // 0x048D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float NewDuration)> OnUpdateDuration;                              // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStacksChanged;                                   // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAlwaysStack;                                      // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRefresh;                                    // 0x04B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveStatusEffectOnDurationElapsed;              // 0x04B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B3[0x1];                                      // 0x04B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StacksToRemoveOnDurationElapsed;                   // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBlockingStatusEffect>          BlockingStatusEffects;                             // 0x04B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusEffectRank;                                  // 0x04D0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnBossInvulnerablePhases;                   // 0x04D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URStatusEffectGScript* AttachStatusEffectToPawn(TSubclassOf<class URStatusEffectGScript> StatusEffectClass, class ARPawnBase* Pawn, bool bStack, class URGScriptComponent* InstigatorScriptComponent, bool bSkipDeathCheck, int32 Rank, class URGScript* StatusEffectInstigatorScript);

	void AilmentAdded();
	void AilmentRemoved();
	class UNiagaraComponent* AttachParticlesToOwnerSkeletalMesh(class UNiagaraSystem* SystemTemplate);
	void CallDeactivateScript();
	void CleanupAttachedParticles();
	void DestroyStatusEffect();
	void Dispel();
	void Dispelled();
	void EffectDuration_OnRep();
	void ExtendRemainingDuration(float DeltaDuration);
	void K2_AilmentAdded();
	void K2_AilmentRemoved();
	void K2_Dispelled();
	void K2_PostHit();
	void OnRep_CurrentStackCount(int32 PrevStackCount);
	void OnRep_ExpirationTime();
	void OnUpdateDuration_Client(float NewDuration);
	void PauseDestroyHandle();
	void PostHit();
	void RefreshStatusEffect();
	void RemoveStack();
	void RemoveStatusEffectStack();
	void RemoveStatusEffectStacksOnDurationElapsed();
	void ResetEffectDuration();
	int32 SetCurrentStackCount(int32 _CurrentStackCount);
	void SetEffectDuration(float Duration);
	void SetMaxStackCount(int32 MaxStacks);
	void Stack();
	void UnpauseDestroyHandle();
	void UpdateStacks();

	int32 GetCurrentStackCount() const;
	float GetRemainingDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RStatusEffectGScript">();
	}
	static class URStatusEffectGScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URStatusEffectGScript>();
	}
};
static_assert(alignof(URStatusEffectGScript) == 0x000008, "Wrong alignment on URStatusEffectGScript");
static_assert(sizeof(URStatusEffectGScript) == 0x0004D8, "Wrong size on URStatusEffectGScript");
static_assert(offsetof(URStatusEffectGScript, TickRecord) == 0x0000C8, "Member 'URStatusEffectGScript::TickRecord' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, CurrentStackCount) == 0x0000D8, "Member 'URStatusEffectGScript::CurrentStackCount' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, EffectDamage) == 0x0000E0, "Member 'URStatusEffectGScript::EffectDamage' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, EffectDuration) == 0x000208, "Member 'URStatusEffectGScript::EffectDuration' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, StatusEffectEffectiveness) == 0x000330, "Member 'URStatusEffectGScript::StatusEffectEffectiveness' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, MaxStackCount) == 0x000458, "Member 'URStatusEffectGScript::MaxStackCount' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, EffectDestroyHandle) == 0x000460, "Member 'URStatusEffectGScript::EffectDestroyHandle' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, AttachedParticles) == 0x000468, "Member 'URStatusEffectGScript::AttachedParticles' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, ExpirationTime) == 0x000470, "Member 'URStatusEffectGScript::ExpirationTime' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, InstigatorScript) == 0x000480, "Member 'URStatusEffectGScript::InstigatorScript' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, DefaultDurationValue) == 0x000488, "Member 'URStatusEffectGScript::DefaultDurationValue' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, bWasDispelled) == 0x00048C, "Member 'URStatusEffectGScript::bWasDispelled' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, OnUpdateDuration) == 0x000490, "Member 'URStatusEffectGScript::OnUpdateDuration' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, OnStacksChanged) == 0x0004A0, "Member 'URStatusEffectGScript::OnStacksChanged' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, bAlwaysStack) == 0x0004B0, "Member 'URStatusEffectGScript::bAlwaysStack' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, bAlwaysRefresh) == 0x0004B1, "Member 'URStatusEffectGScript::bAlwaysRefresh' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, bRemoveStatusEffectOnDurationElapsed) == 0x0004B2, "Member 'URStatusEffectGScript::bRemoveStatusEffectOnDurationElapsed' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, StacksToRemoveOnDurationElapsed) == 0x0004B4, "Member 'URStatusEffectGScript::StacksToRemoveOnDurationElapsed' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, BlockingStatusEffects) == 0x0004B8, "Member 'URStatusEffectGScript::BlockingStatusEffects' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, Icon) == 0x0004C8, "Member 'URStatusEffectGScript::Icon' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, StatusEffectRank) == 0x0004D0, "Member 'URStatusEffectGScript::StatusEffectRank' has a wrong offset!");
static_assert(offsetof(URStatusEffectGScript, bRemoveOnBossInvulnerablePhases) == 0x0004D4, "Member 'URStatusEffectGScript::bRemoveOnBossInvulnerablePhases' has a wrong offset!");

// Class RGame.RStatusEffectAilmentGScript
// 0x0000 (0x04D8 - 0x04D8)
class URStatusEffectAilmentGScript : public URStatusEffectGScript
{
public:
	void InstantlyTickAilmentOnce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RStatusEffectAilmentGScript">();
	}
	static class URStatusEffectAilmentGScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URStatusEffectAilmentGScript>();
	}
};
static_assert(alignof(URStatusEffectAilmentGScript) == 0x000008, "Wrong alignment on URStatusEffectAilmentGScript");
static_assert(sizeof(URStatusEffectAilmentGScript) == 0x0004D8, "Wrong size on URStatusEffectAilmentGScript");

// Class RGame.ProximitySphere
// 0x00E8 (0x0110 - 0x0028)
class UProximitySphere final : public UObject
{
public:
	TMulticastInlineDelegate<void(class AActor* Actor)> OnActorEnterProximity;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnActorExitProximity;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnInitialActorEnterProximity;                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnAllActorsExitProximity;                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x58];                                      // 0x0068(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           ActorsInProximity;                                 // 0x00C0(0x0050)(NativeAccessSpecifierPublic)

public:
	float GetUnscaledSphereRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximitySphere">();
	}
	static class UProximitySphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximitySphere>();
	}
};
static_assert(alignof(UProximitySphere) == 0x000008, "Wrong alignment on UProximitySphere");
static_assert(sizeof(UProximitySphere) == 0x000110, "Wrong size on UProximitySphere");
static_assert(offsetof(UProximitySphere, OnActorEnterProximity) == 0x000028, "Member 'UProximitySphere::OnActorEnterProximity' has a wrong offset!");
static_assert(offsetof(UProximitySphere, OnActorExitProximity) == 0x000038, "Member 'UProximitySphere::OnActorExitProximity' has a wrong offset!");
static_assert(offsetof(UProximitySphere, OnInitialActorEnterProximity) == 0x000048, "Member 'UProximitySphere::OnInitialActorEnterProximity' has a wrong offset!");
static_assert(offsetof(UProximitySphere, OnAllActorsExitProximity) == 0x000058, "Member 'UProximitySphere::OnAllActorsExitProximity' has a wrong offset!");
static_assert(offsetof(UProximitySphere, ActorsInProximity) == 0x0000C0, "Member 'UProximitySphere::ActorsInProximity' has a wrong offset!");

// Class RGame.DMActorProximitySphereComponent
// 0x0020 (0x0340 - 0x0320)
class UDMActorProximitySphereComponent final : public UDMActorProximityComponentBase
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UProximitySphere*>               ProximitySpheres;                                  // 0x0320(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCheckPool;                                        // 0x0330(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0xF];                                      // 0x0331(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AActor*> GetActorsInProximitySphereAsArray(class UProximitySphere* ProximitySphere, TSubclassOf<class AActor> OptionalType);
	class AActor* GetClosestActorInProximitySphere(class UProximitySphere* ProximitySphere);
	class UProximitySphere* GetProximitySphere(float SphereRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DMActorProximitySphereComponent">();
	}
	static class UDMActorProximitySphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDMActorProximitySphereComponent>();
	}
};
static_assert(alignof(UDMActorProximitySphereComponent) == 0x000010, "Wrong alignment on UDMActorProximitySphereComponent");
static_assert(sizeof(UDMActorProximitySphereComponent) == 0x000340, "Wrong size on UDMActorProximitySphereComponent");
static_assert(offsetof(UDMActorProximitySphereComponent, ProximitySpheres) == 0x000320, "Member 'UDMActorProximitySphereComponent::ProximitySpheres' has a wrong offset!");
static_assert(offsetof(UDMActorProximitySphereComponent, bCheckPool) == 0x000330, "Member 'UDMActorProximitySphereComponent::bCheckPool' has a wrong offset!");

// Class RGame.RGWeaponMutatorScript
// 0x0010 (0x00D0 - 0x00C0)
class URGWeaponMutatorScript : public URGScript
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetMutatorDescription();
	int32 GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	void K2_OnBeginFire();
	void K2_OnBeginSecondaryFire();
	void K2_OnEndFire();
	void K2_OnEndSecondaryFire();
	void K2_OnEnemyKilled(class AActor* KilledActor);
	void K2_OnEquip();
	void K2_OnModPrimaryFired();
	void K2_OnModSecondaryFired();
	void K2_OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile);
	void K2_OnProjectileSpawnedClientDummy(const struct FVector& Direction);
	void K2_OnReload();
	void K2_OnReloadFinished();
	void K2_OnUnequip();
	void K2_PreModPrimaryFired();
	void K2_PreModSecondaryFired();
	void K2_PreProjectileSpawned();
	void OnBeginFire(int32 CurrentAmmo);
	void OnBeginSecondaryFire(int32 CurrentAmmo);
	void OnEndFire();
	void OnEndSecondaryFire();
	void OnEnemyKilled(class AActor* KilledActor);
	void OnEquip();
	void OnModPrimaryFired();
	void OnModSecondaryFired();
	void OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile);
	void OnProjectileSpawnedClientDummy(const struct FVector& Direction);
	void OnReload();
	void OnReloadFinished();
	void OnUnequip();
	void PreModPrimaryFired();
	void PreModSecondaryFired();
	void PreProjectileSpawned();

	class URBaseWeaponSettings* GetBaseWeaponSettings() const;
	class FText GetDescription() const;
	float GetFloatWeaponStat(EFloatWeaponStat Stat) const;
	class URGlobalWeaponModifiers* GetGlobalWeaponModifiers() const;
	int32 GetIntegerWeaponStat(EIntegerWeaponStat Stat) const;
	class URMutableWeaponSettings* GetMutableWeaponSettings() const;
	class ARWeapon* GetWeaponActor() const;
	class URGWeaponScript* GetWeaponScript() const;
	bool RollProcChance(int32 Chance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGWeaponMutatorScript">();
	}
	static class URGWeaponMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGWeaponMutatorScript>();
	}
};
static_assert(alignof(URGWeaponMutatorScript) == 0x000008, "Wrong alignment on URGWeaponMutatorScript");
static_assert(sizeof(URGWeaponMutatorScript) == 0x0000D0, "Wrong size on URGWeaponMutatorScript");

// Class RGame.RGWeaponCosmeticScript
// 0x0010 (0x00E0 - 0x00D0)
class URGWeaponCosmeticScript final : public URGWeaponMutatorScript
{
public:
	class URWeaponModPrimaryAsset*                WeaponModPrimaryAsset;                             // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnWeaponCosmeticEvent();
	void OnWeaponCosmeticEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGWeaponCosmeticScript">();
	}
	static class URGWeaponCosmeticScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGWeaponCosmeticScript>();
	}
};
static_assert(alignof(URGWeaponCosmeticScript) == 0x000008, "Wrong alignment on URGWeaponCosmeticScript");
static_assert(sizeof(URGWeaponCosmeticScript) == 0x0000E0, "Wrong size on URGWeaponCosmeticScript");
static_assert(offsetof(URGWeaponCosmeticScript, WeaponModPrimaryAsset) == 0x0000D0, "Member 'URGWeaponCosmeticScript::WeaponModPrimaryAsset' has a wrong offset!");

// Class RGame.DMCodingStandardActor
// 0x0020 (0x02C8 - 0x02A8)
class ADMCodingStandardActor final : public AActor
{
public:
	uint8                                         Pad_2A8[0x4];                                      // 0x02A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SomeConfigValue;                                   // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReplicatedRuntimeVariable;                        // 0x02C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoSomething_Client();
	void DoSomething_Multicast();
	void DoSomething_Server();
	void OnRep_bReplicatedRuntimeVariable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DMCodingStandardActor">();
	}
	static class ADMCodingStandardActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADMCodingStandardActor>();
	}
};
static_assert(alignof(ADMCodingStandardActor) == 0x000008, "Wrong alignment on ADMCodingStandardActor");
static_assert(sizeof(ADMCodingStandardActor) == 0x0002C8, "Wrong size on ADMCodingStandardActor");
static_assert(offsetof(ADMCodingStandardActor, SomeConfigValue) == 0x0002AC, "Member 'ADMCodingStandardActor::SomeConfigValue' has a wrong offset!");
static_assert(offsetof(ADMCodingStandardActor, SkeletalMesh) == 0x0002B0, "Member 'ADMCodingStandardActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ADMCodingStandardActor, bReplicatedRuntimeVariable) == 0x0002C0, "Member 'ADMCodingStandardActor::bReplicatedRuntimeVariable' has a wrong offset!");

// Class RGame.RAIController
// 0x0080 (0x0450 - 0x03D0)
class ARAIController final : public AAIController
{
public:
	class FName                                   PathingTypeEnumName;                               // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CombatPathingTypeEnumName;                         // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MovementTagName;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttackRangeName;                                   // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpecialAttackRangeName;                            // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RequireLOSForAttacksName;                          // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RequireLOSForSpecialsName;                         // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CombatMinDistanceName;                             // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RangedCombatGridSizeName;                          // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ReloadTimeName;                                    // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpecialRechargeTimeName;                           // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AreaAggroRangeName;                                // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FrontalAggroRangeName;                             // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VoxelNavigationEnumName;                           // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MinimumFlightHeightName;                           // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaximumFlightHeightName;                           // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void InitializeBehaviorTree(class AController* Controller, const struct FRAISettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAIController">();
	}
	static class ARAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARAIController>();
	}
};
static_assert(alignof(ARAIController) == 0x000008, "Wrong alignment on ARAIController");
static_assert(sizeof(ARAIController) == 0x000450, "Wrong size on ARAIController");
static_assert(offsetof(ARAIController, PathingTypeEnumName) == 0x0003D0, "Member 'ARAIController::PathingTypeEnumName' has a wrong offset!");
static_assert(offsetof(ARAIController, CombatPathingTypeEnumName) == 0x0003D8, "Member 'ARAIController::CombatPathingTypeEnumName' has a wrong offset!");
static_assert(offsetof(ARAIController, MovementTagName) == 0x0003E0, "Member 'ARAIController::MovementTagName' has a wrong offset!");
static_assert(offsetof(ARAIController, AttackRangeName) == 0x0003E8, "Member 'ARAIController::AttackRangeName' has a wrong offset!");
static_assert(offsetof(ARAIController, SpecialAttackRangeName) == 0x0003F0, "Member 'ARAIController::SpecialAttackRangeName' has a wrong offset!");
static_assert(offsetof(ARAIController, RequireLOSForAttacksName) == 0x0003F8, "Member 'ARAIController::RequireLOSForAttacksName' has a wrong offset!");
static_assert(offsetof(ARAIController, RequireLOSForSpecialsName) == 0x000400, "Member 'ARAIController::RequireLOSForSpecialsName' has a wrong offset!");
static_assert(offsetof(ARAIController, CombatMinDistanceName) == 0x000408, "Member 'ARAIController::CombatMinDistanceName' has a wrong offset!");
static_assert(offsetof(ARAIController, RangedCombatGridSizeName) == 0x000410, "Member 'ARAIController::RangedCombatGridSizeName' has a wrong offset!");
static_assert(offsetof(ARAIController, ReloadTimeName) == 0x000418, "Member 'ARAIController::ReloadTimeName' has a wrong offset!");
static_assert(offsetof(ARAIController, SpecialRechargeTimeName) == 0x000420, "Member 'ARAIController::SpecialRechargeTimeName' has a wrong offset!");
static_assert(offsetof(ARAIController, AreaAggroRangeName) == 0x000428, "Member 'ARAIController::AreaAggroRangeName' has a wrong offset!");
static_assert(offsetof(ARAIController, FrontalAggroRangeName) == 0x000430, "Member 'ARAIController::FrontalAggroRangeName' has a wrong offset!");
static_assert(offsetof(ARAIController, VoxelNavigationEnumName) == 0x000438, "Member 'ARAIController::VoxelNavigationEnumName' has a wrong offset!");
static_assert(offsetof(ARAIController, MinimumFlightHeightName) == 0x000440, "Member 'ARAIController::MinimumFlightHeightName' has a wrong offset!");
static_assert(offsetof(ARAIController, MaximumFlightHeightName) == 0x000448, "Member 'ARAIController::MaximumFlightHeightName' has a wrong offset!");

// Class RGame.RChallengeLogEntryWidget
// 0x0028 (0x02F8 - 0x02D0)
class URChallengeLogEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ChallengeIcon;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ChallengeName;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ChallengeDescription;                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           ChallengeProgressBar;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChallengeLogEntryWidget">();
	}
	static class URChallengeLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URChallengeLogEntryWidget>();
	}
};
static_assert(alignof(URChallengeLogEntryWidget) == 0x000008, "Wrong alignment on URChallengeLogEntryWidget");
static_assert(sizeof(URChallengeLogEntryWidget) == 0x0002F8, "Wrong size on URChallengeLogEntryWidget");
static_assert(offsetof(URChallengeLogEntryWidget, ChallengeIcon) == 0x0002D8, "Member 'URChallengeLogEntryWidget::ChallengeIcon' has a wrong offset!");
static_assert(offsetof(URChallengeLogEntryWidget, ChallengeName) == 0x0002E0, "Member 'URChallengeLogEntryWidget::ChallengeName' has a wrong offset!");
static_assert(offsetof(URChallengeLogEntryWidget, ChallengeDescription) == 0x0002E8, "Member 'URChallengeLogEntryWidget::ChallengeDescription' has a wrong offset!");
static_assert(offsetof(URChallengeLogEntryWidget, ChallengeProgressBar) == 0x0002F0, "Member 'URChallengeLogEntryWidget::ChallengeProgressBar' has a wrong offset!");

// Class RGame.RHealthbarWidget
// 0x0010 (0x02E0 - 0x02D0)
class URHealthbarWidget : public UUserWidget
{
public:
	TWeakObjectPtr<class URHealthComponent>       OwningHealthComponent;                             // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthBarDisplayMode                         HealthBarDisplayMode;                              // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArmorUpdated(class URHealthComponent* Component, float CurrentArmor, float Delta, const struct FHealCombatEvent& HealEvent);
	void OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnDamageTakenServerValidated(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnHealthUpdated(class URHealthComponent* Component, float currentHealth, float Delta, const struct FHealCombatEvent& HealEvent);
	void ReinitHealthbarWithNewTarget(class URHealthComponent* NewComponent);
	void SetHealthbarComponent(class URHealthComponent* Component);
	void SetName(const class FText& Name_0);
	void UpdateHealthBarVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHealthbarWidget">();
	}
	static class URHealthbarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHealthbarWidget>();
	}
};
static_assert(alignof(URHealthbarWidget) == 0x000008, "Wrong alignment on URHealthbarWidget");
static_assert(sizeof(URHealthbarWidget) == 0x0002E0, "Wrong size on URHealthbarWidget");
static_assert(offsetof(URHealthbarWidget, OwningHealthComponent) == 0x0002D0, "Member 'URHealthbarWidget::OwningHealthComponent' has a wrong offset!");
static_assert(offsetof(URHealthbarWidget, HealthBarDisplayMode) == 0x0002D8, "Member 'URHealthbarWidget::HealthBarDisplayMode' has a wrong offset!");

// Class RGame.RAIHelper
// 0x0020 (0x02C8 - 0x02A8)
class ARAIHelper final : public AActor
{
public:
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool FindAndCreatePatrolingPathWithClosestPoints(class APawn* Pawn, class FName Tag, struct FVector* OutLocation);
	static bool FindAndCreateSpecifiedPatrolingPath(class APawn* Pawn, class FName Tag, struct FVector* OutLocation);
	static bool GetClosestMoveToLocation(class APawn* Pawn, class FName Tag, struct FVector* OutLocation);
	static const class ARAIHelper* GetInstance(const class UObject* WorldContextObject);
	static bool GetRandomMoveToLocation(class APawn* Pawn, class FName Tag, struct FVector* OutLocation);
	static class ARNavigationManager* GetRNavigationManager(class UObject* WorldContextObject);
	static class ARNavigationManager* GetRNavigationManagerForActor(const class AActor* Actor);
	static class ARNavigationManager* GetRNavigationManagerForLocation(class UObject* WorldContextObject, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAIHelper">();
	}
	static class ARAIHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARAIHelper>();
	}
};
static_assert(alignof(ARAIHelper) == 0x000008, "Wrong alignment on ARAIHelper");
static_assert(sizeof(ARAIHelper) == 0x0002C8, "Wrong size on ARAIHelper");

// Class RGame.RAIMovementLocation
// 0x0010 (0x02B8 - 0x02A8)
class ARAIMovementLocation final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARAIMovementLocation*                   NextMovementLocation;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ARAIMovementLocation* GetNextMovementLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAIMovementLocation">();
	}
	static class ARAIMovementLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARAIMovementLocation>();
	}
};
static_assert(alignof(ARAIMovementLocation) == 0x000008, "Wrong alignment on ARAIMovementLocation");
static_assert(sizeof(ARAIMovementLocation) == 0x0002B8, "Wrong size on ARAIMovementLocation");
static_assert(offsetof(ARAIMovementLocation, SceneComponent) == 0x0002A8, "Member 'ARAIMovementLocation::SceneComponent' has a wrong offset!");
static_assert(offsetof(ARAIMovementLocation, NextMovementLocation) == 0x0002B0, "Member 'ARAIMovementLocation::NextMovementLocation' has a wrong offset!");

// Class RGame.RPathFollowingManager
// 0x0000 (0x0028 - 0x0028)
class URPathFollowingManager final : public UPathFollowingManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPathFollowingManager">();
	}
	static class URPathFollowingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPathFollowingManager>();
	}
};
static_assert(alignof(URPathFollowingManager) == 0x000008, "Wrong alignment on URPathFollowingManager");
static_assert(sizeof(URPathFollowingManager) == 0x000028, "Wrong size on URPathFollowingManager");

// Class RGame.RAIDataSettings
// 0x0068 (0x0098 - 0x0030)
class URAIDataSettings final : public UDataAsset
{
public:
	struct FRAISettings                           Settings;                                          // 0x0030(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAIDataSettings">();
	}
	static class URAIDataSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URAIDataSettings>();
	}
};
static_assert(alignof(URAIDataSettings) == 0x000008, "Wrong alignment on URAIDataSettings");
static_assert(sizeof(URAIDataSettings) == 0x000098, "Wrong size on URAIDataSettings");
static_assert(offsetof(URAIDataSettings, Settings) == 0x000030, "Member 'URAIDataSettings::Settings' has a wrong offset!");

// Class RGame.RPrimaryDataAsset
// 0x0040 (0x0070 - 0x0030)
class URPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetType                      AssetType;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AssetName;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AssetIcon;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartLocked;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GoldPrice;                                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FText GetDescription();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPrimaryDataAsset">();
	}
	static class URPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPrimaryDataAsset>();
	}
};
static_assert(alignof(URPrimaryDataAsset) == 0x000008, "Wrong alignment on URPrimaryDataAsset");
static_assert(sizeof(URPrimaryDataAsset) == 0x000070, "Wrong size on URPrimaryDataAsset");
static_assert(offsetof(URPrimaryDataAsset, AssetType) == 0x000040, "Member 'URPrimaryDataAsset::AssetType' has a wrong offset!");
static_assert(offsetof(URPrimaryDataAsset, AssetName) == 0x000048, "Member 'URPrimaryDataAsset::AssetName' has a wrong offset!");
static_assert(offsetof(URPrimaryDataAsset, SortPriority) == 0x000058, "Member 'URPrimaryDataAsset::SortPriority' has a wrong offset!");
static_assert(offsetof(URPrimaryDataAsset, AssetIcon) == 0x000060, "Member 'URPrimaryDataAsset::AssetIcon' has a wrong offset!");
static_assert(offsetof(URPrimaryDataAsset, bStartLocked) == 0x000068, "Member 'URPrimaryDataAsset::bStartLocked' has a wrong offset!");
static_assert(offsetof(URPrimaryDataAsset, GoldPrice) == 0x00006C, "Member 'URPrimaryDataAsset::GoldPrice' has a wrong offset!");

// Class RGame.RAnimationNotifyListener
// 0x0000 (0x0000 - 0x0000)
class IRAnimationNotifyListener final
{
public:
	void OnAnimationTriggerEvent(class FName EventName);
	void OnToggleEvent(class FName Socket, bool Bool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAnimationNotifyListener">();
	}
	static class IRAnimationNotifyListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRAnimationNotifyListener>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRAnimationNotifyListener) == 0x000001, "Wrong alignment on IRAnimationNotifyListener");
static_assert(sizeof(IRAnimationNotifyListener) == 0x000001, "Wrong size on IRAnimationNotifyListener");

// Class RGame.RGEnemyMutatorScript
// 0x0020 (0x00E0 - 0x00C0)
class URGEnemyMutatorScript final : public URGScript
{
public:
	class FText                                   DisplayName;                                       // 0x00C0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconTexture;                                       // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnAttack();
	void K2_OnDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent);
	void K2_OnDamageTaken();
	void K2_OnDeath();
	void K2_OnPreDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent);
	void OnAttack();
	void OnDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent);
	void OnDamageTaken();
	void OnDeath();
	void OnPreDamageDealt(const struct FDamageCombatEvent& DamageCombatEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGEnemyMutatorScript">();
	}
	static class URGEnemyMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGEnemyMutatorScript>();
	}
};
static_assert(alignof(URGEnemyMutatorScript) == 0x000008, "Wrong alignment on URGEnemyMutatorScript");
static_assert(sizeof(URGEnemyMutatorScript) == 0x0000E0, "Wrong size on URGEnemyMutatorScript");
static_assert(offsetof(URGEnemyMutatorScript, DisplayName) == 0x0000C0, "Member 'URGEnemyMutatorScript::DisplayName' has a wrong offset!");
static_assert(offsetof(URGEnemyMutatorScript, IconTexture) == 0x0000D0, "Member 'URGEnemyMutatorScript::IconTexture' has a wrong offset!");

// Class RGame.RAnimFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URAnimFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetMontageLength(const class ARPlayerPawn* PlayerPawn, const class FName MontageSection, bool Additive);
	static void PlaySynchedMontage(const class ARPlayerPawn* PlayerPawn, const class FName MontageSection, const float PlayRate, bool CharacterAdditive, bool ArmsAdditive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAnimFunctionLibrary">();
	}
	static class URAnimFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URAnimFunctionLibrary>();
	}
};
static_assert(alignof(URAnimFunctionLibrary) == 0x000008, "Wrong alignment on URAnimFunctionLibrary");
static_assert(sizeof(URAnimFunctionLibrary) == 0x000028, "Wrong size on URAnimFunctionLibrary");

// Class RGame.RAreaEffect
// 0x01A8 (0x0450 - 0x02A8)
class ARAreaEffect : public AActor
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AreaEffectName;                                    // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class URGAreaEffectScript>> AreaEffectScripts;                                // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ActorClassWhitelist;                               // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bReplicateActorsInArea;                            // 0x02F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReplicateEnterExitCalls;                          // 0x02F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2[0xE];                                      // 0x02F2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsInArea;                                      // 0x0300(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FRMutableFloat                         Lifetime;                                          // 0x0310(0x0128)(Edit, BlueprintVisible, Net, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActorsInAreaChanged;                             // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 AvatarActor;                                       // 0x0448(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddAreaEffectScript(TSubclassOf<class URGAreaEffectScript> AreaEffectScript);
	void CleanupAreaEffect_Multicast();
	void DestroyAreaEffect();
	TArray<class AActor*> GetActorsInArea();
	class URGScriptComponent* GetGScriptComponent();
	void OnActorEnterArea(class AActor* OtherActor);
	void OnActorExitArea(class AActor* OtherActor);
	void OnLifetimeExpired();
	void OnRep_ActorsInArea();
	void RestartAreaEffectDuration();

	TArray<class URGAreaEffectScript*> GetAreaEffectScripts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAreaEffect">();
	}
	static class ARAreaEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARAreaEffect>();
	}
};
static_assert(alignof(ARAreaEffect) == 0x000008, "Wrong alignment on ARAreaEffect");
static_assert(sizeof(ARAreaEffect) == 0x000450, "Wrong size on ARAreaEffect");
static_assert(offsetof(ARAreaEffect, AreaEffectName) == 0x0002B8, "Member 'ARAreaEffect::AreaEffectName' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, AreaEffectScripts) == 0x0002C0, "Member 'ARAreaEffect::AreaEffectScripts' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, ActorClassWhitelist) == 0x0002E0, "Member 'ARAreaEffect::ActorClassWhitelist' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, bReplicateActorsInArea) == 0x0002F0, "Member 'ARAreaEffect::bReplicateActorsInArea' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, bReplicateEnterExitCalls) == 0x0002F1, "Member 'ARAreaEffect::bReplicateEnterExitCalls' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, ActorsInArea) == 0x000300, "Member 'ARAreaEffect::ActorsInArea' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, Lifetime) == 0x000310, "Member 'ARAreaEffect::Lifetime' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, OnActorsInAreaChanged) == 0x000438, "Member 'ARAreaEffect::OnActorsInAreaChanged' has a wrong offset!");
static_assert(offsetof(ARAreaEffect, AvatarActor) == 0x000448, "Member 'ARAreaEffect::AvatarActor' has a wrong offset!");

// Class RGame.RChallengeLogWidget
// 0x0010 (0x02E0 - 0x02D0)
class URChallengeLogWidget final : public UUserWidget
{
public:
	class UTileView*                              ChallengeGrid;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URChallengeLogEntryWidget>  ChallengeLogEntryWidgetClass;                      // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChallengeLogWidget">();
	}
	static class URChallengeLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URChallengeLogWidget>();
	}
};
static_assert(alignof(URChallengeLogWidget) == 0x000008, "Wrong alignment on URChallengeLogWidget");
static_assert(sizeof(URChallengeLogWidget) == 0x0002E0, "Wrong size on URChallengeLogWidget");
static_assert(offsetof(URChallengeLogWidget, ChallengeGrid) == 0x0002D0, "Member 'URChallengeLogWidget::ChallengeGrid' has a wrong offset!");
static_assert(offsetof(URChallengeLogWidget, ChallengeLogEntryWidgetClass) == 0x0002D8, "Member 'URChallengeLogWidget::ChallengeLogEntryWidgetClass' has a wrong offset!");

// Class RGame.RGBossScript
// 0x0078 (0x0138 - 0x00C0)
class URGBossScript final : public URGScript
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QueueLength;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class URGBossAbilityScript>> AbilityPool;                                     // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FRBossAbilitySettings>          BossAbilityPool;                                   // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class URGBossAbilityScript>> AbilityQueue;                                    // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FBossPhase>                     Phases;                                            // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class URGBossAbilityScript*                   ActiveAbilityScript;                               // 0x0110(0x0008)(Edit, Net, ZeroConstructor, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IntermissionInvulnerabilityKey;                    // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCinematicInvulnerability;                      // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentPhase;                                      // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URGBossAbilityScript* NewScript)> OnActiveAbilityScriptChanged; // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static TArray<struct FRBossAbilitySettings> GetPoolFromDataTable(class UDataTable* DataTable, class FName Phase, EGetPoolOutcome* Branches, int32* DesiredQueueLength);

	void ClearAbilityQueue();
	void ClearStatusEffects_Multicast();
	TSubclassOf<class URGBossAbilityScript> DequeueAbility();
	void EnqueueAbility(TSubclassOf<class URGBossAbilityScript> AbilityScript);
	void EnqueueAbilityAt(TSubclassOf<class URGBossAbilityScript> AbilityScript, int32 Index_0);
	void EnterNextPhase();
	void ExecuteAbility(TSubclassOf<class URGBossAbilityScript> AbilityScript);
	void ExecuteNextAbility();
	TSubclassOf<class URGBossAbilityScript> GetAbilityToEnqueue();
	struct FBossPhase GetCurrentPhase();
	class FName GetCurrentPhaseName();
	void K2_OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void K2_OnEnterPhase(class FName Phase);
	void K2_OnFinishAbilityExecution();
	void K2_OnPreDamageTaken(class URHealthComponent* Component, float Damage);
	void K2_OnPreExecuteAbility();
	void Multicast_OnEnterPhase(class FName Phase);
	void OnCinematicEnded();
	void OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnEnterPhase(class FName Phase);
	void OnFinishAbilityExecution();
	void OnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnIntroCinematicEnd();
	void OnPreDamageTaken(class URHealthComponent* Component, float Damage);
	void OnPreExecuteAbility();
	void OnRep_ActiveAbilityScript();
	TSubclassOf<class URGBossAbilityScript> PeekAbilityQueue();
	void SetCurrentPhaseQueueLength(int32 NewLength);

	class URGBossAbilityScript* GetActiveAbilityScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGBossScript">();
	}
	static class URGBossScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGBossScript>();
	}
};
static_assert(alignof(URGBossScript) == 0x000008, "Wrong alignment on URGBossScript");
static_assert(sizeof(URGBossScript) == 0x000138, "Wrong size on URGBossScript");
static_assert(offsetof(URGBossScript, QueueLength) == 0x0000C8, "Member 'URGBossScript::QueueLength' has a wrong offset!");
static_assert(offsetof(URGBossScript, AbilityPool) == 0x0000D0, "Member 'URGBossScript::AbilityPool' has a wrong offset!");
static_assert(offsetof(URGBossScript, BossAbilityPool) == 0x0000E0, "Member 'URGBossScript::BossAbilityPool' has a wrong offset!");
static_assert(offsetof(URGBossScript, AbilityQueue) == 0x0000F0, "Member 'URGBossScript::AbilityQueue' has a wrong offset!");
static_assert(offsetof(URGBossScript, Phases) == 0x000100, "Member 'URGBossScript::Phases' has a wrong offset!");
static_assert(offsetof(URGBossScript, ActiveAbilityScript) == 0x000110, "Member 'URGBossScript::ActiveAbilityScript' has a wrong offset!");
static_assert(offsetof(URGBossScript, IntermissionInvulnerabilityKey) == 0x000118, "Member 'URGBossScript::IntermissionInvulnerabilityKey' has a wrong offset!");
static_assert(offsetof(URGBossScript, bHasCinematicInvulnerability) == 0x000120, "Member 'URGBossScript::bHasCinematicInvulnerability' has a wrong offset!");
static_assert(offsetof(URGBossScript, CurrentPhase) == 0x000124, "Member 'URGBossScript::CurrentPhase' has a wrong offset!");
static_assert(offsetof(URGBossScript, OnActiveAbilityScriptChanged) == 0x000128, "Member 'URGBossScript::OnActiveAbilityScriptChanged' has a wrong offset!");

// Class RGame.RArmsAnimInstance
// 0x0290 (0x0650 - 0x03C0)
class URArmsAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARPlayerPawn*                           PawnOwner;                                         // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARWeapon*                               CurrentWeapon;                                     // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARWeapon>                   CurrentWeaponClass;                                // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentBasePose;                                   // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentLocomotionSequence;                         // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentDetailSequence;                             // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LHandIKTransform;                                  // 0x03F0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RHandIKTransform;                                  // 0x0450(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LElbowIKTransform;                                 // 0x04B0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RElbowIKTransform;                                 // 0x0510(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LinearAcceleration;                                // 0x0570(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               AngularAcceleration;                               // 0x0588(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               AngularOffset;                                     // 0x05A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TranslationInterpSpeed;                            // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationInterpSpeed;                               // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OffsetDistanceScale;                               // 0x05C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOffsetDistance;                                 // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetAngleScale;                                  // 0x05E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousLinearVelocity;                            // 0x05F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuat                                  PreviousCamerRotation;                             // 0x0610(0x0020)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PawnVelocity;                                      // 0x0630(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeed;                                     // 0x0648(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRunning;                                        // 0x064C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsScoped;                                         // 0x064D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInAir;                                          // 0x064E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64F[0x1];                                      // 0x064F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RArmsAnimInstance">();
	}
	static class URArmsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URArmsAnimInstance>();
	}
};
static_assert(alignof(URArmsAnimInstance) == 0x000010, "Wrong alignment on URArmsAnimInstance");
static_assert(sizeof(URArmsAnimInstance) == 0x000650, "Wrong size on URArmsAnimInstance");
static_assert(offsetof(URArmsAnimInstance, PawnOwner) == 0x0003C0, "Member 'URArmsAnimInstance::PawnOwner' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, CurrentWeapon) == 0x0003C8, "Member 'URArmsAnimInstance::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, CurrentWeaponClass) == 0x0003D0, "Member 'URArmsAnimInstance::CurrentWeaponClass' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, CurrentBasePose) == 0x0003D8, "Member 'URArmsAnimInstance::CurrentBasePose' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, CurrentLocomotionSequence) == 0x0003E0, "Member 'URArmsAnimInstance::CurrentLocomotionSequence' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, CurrentDetailSequence) == 0x0003E8, "Member 'URArmsAnimInstance::CurrentDetailSequence' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, LHandIKTransform) == 0x0003F0, "Member 'URArmsAnimInstance::LHandIKTransform' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, RHandIKTransform) == 0x000450, "Member 'URArmsAnimInstance::RHandIKTransform' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, LElbowIKTransform) == 0x0004B0, "Member 'URArmsAnimInstance::LElbowIKTransform' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, RElbowIKTransform) == 0x000510, "Member 'URArmsAnimInstance::RElbowIKTransform' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, LinearAcceleration) == 0x000570, "Member 'URArmsAnimInstance::LinearAcceleration' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, AngularAcceleration) == 0x000588, "Member 'URArmsAnimInstance::AngularAcceleration' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, AngularOffset) == 0x0005A0, "Member 'URArmsAnimInstance::AngularOffset' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, TranslationInterpSpeed) == 0x0005B8, "Member 'URArmsAnimInstance::TranslationInterpSpeed' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, RotationInterpSpeed) == 0x0005BC, "Member 'URArmsAnimInstance::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, OffsetDistanceScale) == 0x0005C0, "Member 'URArmsAnimInstance::OffsetDistanceScale' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, MaxOffsetDistance) == 0x0005D8, "Member 'URArmsAnimInstance::MaxOffsetDistance' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, OffsetAngleScale) == 0x0005E0, "Member 'URArmsAnimInstance::OffsetAngleScale' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, PreviousLinearVelocity) == 0x0005F8, "Member 'URArmsAnimInstance::PreviousLinearVelocity' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, PreviousCamerRotation) == 0x000610, "Member 'URArmsAnimInstance::PreviousCamerRotation' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, PawnVelocity) == 0x000630, "Member 'URArmsAnimInstance::PawnVelocity' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, MovementSpeed) == 0x000648, "Member 'URArmsAnimInstance::MovementSpeed' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, bIsRunning) == 0x00064C, "Member 'URArmsAnimInstance::bIsRunning' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, bIsScoped) == 0x00064D, "Member 'URArmsAnimInstance::bIsScoped' has a wrong offset!");
static_assert(offsetof(URArmsAnimInstance, bIsInAir) == 0x00064E, "Member 'URArmsAnimInstance::bIsInAir' has a wrong offset!");

// Class RGame.RAssetLoader
// 0x0018 (0x02C0 - 0x02A8)
class ARAssetLoader final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     TablesToPreload;                                   // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class ARAssetLoader* GetAssetLoader(const class UObject* WorldContextObject);

	void LoadPrimaryGameAssets();
	void OnAreaChanged(class FName AreaName);
	void OnPreAreaChanged(class FName AreaName);
	void UnloadCurrentAreaAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAssetLoader">();
	}
	static class ARAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARAssetLoader>();
	}
};
static_assert(alignof(ARAssetLoader) == 0x000008, "Wrong alignment on ARAssetLoader");
static_assert(sizeof(ARAssetLoader) == 0x0002C0, "Wrong size on ARAssetLoader");
static_assert(offsetof(ARAssetLoader, TablesToPreload) == 0x0002B0, "Member 'ARAssetLoader::TablesToPreload' has a wrong offset!");

// Class RGame.RMutatorPrimaryAsset
// 0x00C8 (0x0138 - 0x0070)
class URMutatorPrimaryAsset : public URPrimaryDataAsset
{
public:
	class UTexture2D*                             SmallIcon;                                         // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MutatorType;                                       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignedOnly;                                     // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleInUI;                                      // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesSlotSpace;                                    // 0x0083(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDefaultEquippedAbility;                         // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepOnDeath;                                      // 0x0085(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUpgradable;                                     // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERGodBonusMutatorType                         GodBonusMutatorType;                               // 0x0087(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MutatorDescription;                                // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AdditionalMutatorDescription;                      // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AdvancedDescription;                               // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMutatorDescriptionVariables>   MutatorDescriptionVariables;                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class URMutatorPrimaryAsset*>          AutoEquipMutators;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MutatorTags;                                       // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ProcChanceType;                                    // 0x00DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProcChanceVariableName;                            // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RewardCategoryTags;                                // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EDamageSource                                 DamageSourceType;                                  // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillTreeIdName;                                   // 0x011C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkillTreeCostPerRank;                              // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void CopyVariableRankValues();
	void SetMutatorDescription(const class FText& Description);

	class FText GetMutatorName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutatorPrimaryAsset">();
	}
	static class URMutatorPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutatorPrimaryAsset>();
	}
};
static_assert(alignof(URMutatorPrimaryAsset) == 0x000008, "Wrong alignment on URMutatorPrimaryAsset");
static_assert(sizeof(URMutatorPrimaryAsset) == 0x000138, "Wrong size on URMutatorPrimaryAsset");
static_assert(offsetof(URMutatorPrimaryAsset, SmallIcon) == 0x000070, "Member 'URMutatorPrimaryAsset::SmallIcon' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, MutatorType) == 0x000078, "Member 'URMutatorPrimaryAsset::MutatorType' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bEnabled) == 0x000080, "Member 'URMutatorPrimaryAsset::bEnabled' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bAssignedOnly) == 0x000081, "Member 'URMutatorPrimaryAsset::bAssignedOnly' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bVisibleInUI) == 0x000082, "Member 'URMutatorPrimaryAsset::bVisibleInUI' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bUsesSlotSpace) == 0x000083, "Member 'URMutatorPrimaryAsset::bUsesSlotSpace' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bIsDefaultEquippedAbility) == 0x000084, "Member 'URMutatorPrimaryAsset::bIsDefaultEquippedAbility' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bKeepOnDeath) == 0x000085, "Member 'URMutatorPrimaryAsset::bKeepOnDeath' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, bIsUpgradable) == 0x000086, "Member 'URMutatorPrimaryAsset::bIsUpgradable' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, GodBonusMutatorType) == 0x000087, "Member 'URMutatorPrimaryAsset::GodBonusMutatorType' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, MutatorDescription) == 0x000088, "Member 'URMutatorPrimaryAsset::MutatorDescription' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, AdditionalMutatorDescription) == 0x000098, "Member 'URMutatorPrimaryAsset::AdditionalMutatorDescription' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, AdvancedDescription) == 0x0000A8, "Member 'URMutatorPrimaryAsset::AdvancedDescription' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, MutatorDescriptionVariables) == 0x0000B8, "Member 'URMutatorPrimaryAsset::MutatorDescriptionVariables' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, AutoEquipMutators) == 0x0000C8, "Member 'URMutatorPrimaryAsset::AutoEquipMutators' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, MutatorTags) == 0x0000D8, "Member 'URMutatorPrimaryAsset::MutatorTags' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, ProcChanceType) == 0x0000DC, "Member 'URMutatorPrimaryAsset::ProcChanceType' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, ProcChanceVariableName) == 0x0000E8, "Member 'URMutatorPrimaryAsset::ProcChanceVariableName' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, RewardCategoryTags) == 0x0000F8, "Member 'URMutatorPrimaryAsset::RewardCategoryTags' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, DamageSourceType) == 0x000118, "Member 'URMutatorPrimaryAsset::DamageSourceType' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, SkillTreeIdName) == 0x00011C, "Member 'URMutatorPrimaryAsset::SkillTreeIdName' has a wrong offset!");
static_assert(offsetof(URMutatorPrimaryAsset, SkillTreeCostPerRank) == 0x000128, "Member 'URMutatorPrimaryAsset::SkillTreeCostPerRank' has a wrong offset!");

// Class RGame.RCharacterMutatorPrimaryAsset
// 0x0038 (0x0170 - 0x0138)
class URCharacterMutatorPrimaryAsset : public URMutatorPrimaryAsset
{
public:
	bool                                          bIsSelectableActivatableAbility;                   // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSuitCharacterMutator;                           // 0x0139(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlessingMutator;                                // 0x013A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BackgroundImage;                                   // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftCharacterMutatorScript;                        // 0x0148(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCharacterMutatorPrimaryAsset">();
	}
	static class URCharacterMutatorPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCharacterMutatorPrimaryAsset>();
	}
};
static_assert(alignof(URCharacterMutatorPrimaryAsset) == 0x000008, "Wrong alignment on URCharacterMutatorPrimaryAsset");
static_assert(sizeof(URCharacterMutatorPrimaryAsset) == 0x000170, "Wrong size on URCharacterMutatorPrimaryAsset");
static_assert(offsetof(URCharacterMutatorPrimaryAsset, bIsSelectableActivatableAbility) == 0x000138, "Member 'URCharacterMutatorPrimaryAsset::bIsSelectableActivatableAbility' has a wrong offset!");
static_assert(offsetof(URCharacterMutatorPrimaryAsset, bIsSuitCharacterMutator) == 0x000139, "Member 'URCharacterMutatorPrimaryAsset::bIsSuitCharacterMutator' has a wrong offset!");
static_assert(offsetof(URCharacterMutatorPrimaryAsset, bIsBlessingMutator) == 0x00013A, "Member 'URCharacterMutatorPrimaryAsset::bIsBlessingMutator' has a wrong offset!");
static_assert(offsetof(URCharacterMutatorPrimaryAsset, BackgroundImage) == 0x000140, "Member 'URCharacterMutatorPrimaryAsset::BackgroundImage' has a wrong offset!");
static_assert(offsetof(URCharacterMutatorPrimaryAsset, SoftCharacterMutatorScript) == 0x000148, "Member 'URCharacterMutatorPrimaryAsset::SoftCharacterMutatorScript' has a wrong offset!");

// Class RGame.RCharacterTriggerMutatorPA
// 0x0010 (0x0180 - 0x0170)
class URCharacterTriggerMutatorPA final : public URCharacterMutatorPrimaryAsset
{
public:
	TArray<class URCharacterMutatorPrimaryAsset*> BehaviorMutators;                                  // 0x0170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCharacterTriggerMutatorPA">();
	}
	static class URCharacterTriggerMutatorPA* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCharacterTriggerMutatorPA>();
	}
};
static_assert(alignof(URCharacterTriggerMutatorPA) == 0x000008, "Wrong alignment on URCharacterTriggerMutatorPA");
static_assert(sizeof(URCharacterTriggerMutatorPA) == 0x000180, "Wrong size on URCharacterTriggerMutatorPA");
static_assert(offsetof(URCharacterTriggerMutatorPA, BehaviorMutators) == 0x000170, "Member 'URCharacterTriggerMutatorPA::BehaviorMutators' has a wrong offset!");

// Class RGame.RProjectileBaseScript
// 0x0018 (0x00D8 - 0x00C0)
class URProjectileBaseScript : public URGScript
{
public:
	bool                                          bStackStatusEffects;                               // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x17];                                      // 0x00C1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddProjectileEffect(TSubclassOf<class URGProjectileEffectScript> EffectClass);
	void K2_PostAddMutators();
	void K2_ProjectileDisabled();
	void PostAddMutators();
	void ProjectileDisabled();
	void SetStatusEffectsStack(bool bStack);

	class ARProjectileBase* GetOwningProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RProjectileBaseScript">();
	}
	static class URProjectileBaseScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URProjectileBaseScript>();
	}
};
static_assert(alignof(URProjectileBaseScript) == 0x000008, "Wrong alignment on URProjectileBaseScript");
static_assert(sizeof(URProjectileBaseScript) == 0x0000D8, "Wrong size on URProjectileBaseScript");
static_assert(offsetof(URProjectileBaseScript, bStackStatusEffects) == 0x0000C0, "Member 'URProjectileBaseScript::bStackStatusEffects' has a wrong offset!");

// Class RGame.RAssetManager
// 0x0008 (0x04D8 - 0x04D0)
class URAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class URDifficultyPrimaryAsset*> GetAllDifficultyPrimaryAssets();
	static TArray<class URMutatorPrimaryAsset*> GetAllMutatorPrimaryAssets(bool bAllowDisabled, bool bAllowAssignedOnly);
	static TArray<class URMutatorPrimaryAsset*> GetAllMutatorPrimaryAssetsRarityAndNameSorted(class ARLootTableManager* LootTableManager, bool bAllowDisabled, bool bAllowAssignedOnly);
	static TArray<class URRewardTablePrimaryAsset*> GetAllRewardTablePrimaryAssets();
	static TArray<class URSkillTreeCategoryPrimaryAsset*> GetAllSkillTreeCategoryPrimaryAssets();
	static class URAssetManager* GetAssetManager();
	static TArray<class URCharacterMutatorPrimaryAsset*> GetCharacterMutatorPrimaryAssets(bool bAllowDisabled);
	static TArray<struct FSoftObjectPath> GetMutatorPreloadBlueprintData(class UDataTable* Table);
	static TArray<struct FSoftObjectPath> GetMutatorPreloadPrimaryAssetData(class UDataTable* Table);
	static TArray<struct FSoftObjectPath> GetPreloadData(class UDataTable* Table);
	static TArray<class URPrimaryDataAsset*> GetPrimaryAssetsFromType(const struct FPrimaryAssetType& Type);
	static TArray<class URProjectileMutatorPrimaryAsset*> GetProjectileMutatorPrimaryAssets(bool bAllowDisabled);
	static TArray<class URCharacterMutatorPrimaryAsset*> GetSelectableActivatableCharacterMutatorPrimaryAssets();
	static class URTotemTablePrimaryAsset* GetTotemTablePrimaryAsset();
	static TArray<class URWeaponModPrimaryAsset*> GetWeaponModPrimaryAssets();
	static TArray<class URWeaponMutatorPrimaryAsset*> GetWeaponMutatorPrimaryAssets(bool bAllowDisabled);
	static TArray<class URWeaponPrimaryAsset*> GetWeaponPrimaryAssets();
	static bool IsAssetLoaded(const struct FSoftObjectPath& Path);
	static class UClass* LoadClassFromSoftClassPtr(TSoftClassPtr<class UClass> SoftClassPtr);
	static class UObject* LoadObjectFromSoftObjectPtr(TSoftObjectPtr<class UObject> SoftObjectPtr);
	static void RequestAsyncLoadAssets(const TArray<struct FSoftObjectPath>& Paths);
	static void RequestSyncLoadAssets(const TArray<struct FSoftObjectPath>& Paths);
	static void UnloadAssets(const TArray<struct FSoftObjectPath>& Paths);

	void LoadPrimaryGameAssets();
	void LoadPrimaryGlobalAssets();
	void UnloadPrimaryGameAssets();
	void UnloadPrimaryGlobalAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAssetManager">();
	}
	static class URAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URAssetManager>();
	}
};
static_assert(alignof(URAssetManager) == 0x000008, "Wrong alignment on URAssetManager");
static_assert(sizeof(URAssetManager) == 0x0004D8, "Wrong size on URAssetManager");

// Class RGame.RAudioMixingSubsystem
// 0x0048 (0x0078 - 0x0030)
class URAudioMixingSubsystem final : public UWorldSubsystem
{
public:
	class USoundControlBusMix*                    DefaultBaseMix;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBusMix*                    UserMix;                                           // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       MainVolumeControlBus;                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       MusicControlBus;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       SFXControlBus;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       VoiceControlBus;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       OtherPlayerVolumeControlBus;                       // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       OtherPlayerEnemyVolumeControlBus;                  // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundSubmix*                           SFXSubmix;                                         // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USoundSubmix* GetDefaultSFXSubmix();
	float GetNonLocalPlayerEnemyVolumeMultiplier(const bool bIsLocal);
	float GetNonLocalPlayerVolumeMultiplier(const bool bIsLocal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAudioMixingSubsystem">();
	}
	static class URAudioMixingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URAudioMixingSubsystem>();
	}
};
static_assert(alignof(URAudioMixingSubsystem) == 0x000008, "Wrong alignment on URAudioMixingSubsystem");
static_assert(sizeof(URAudioMixingSubsystem) == 0x000078, "Wrong size on URAudioMixingSubsystem");
static_assert(offsetof(URAudioMixingSubsystem, DefaultBaseMix) == 0x000030, "Member 'URAudioMixingSubsystem::DefaultBaseMix' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, UserMix) == 0x000038, "Member 'URAudioMixingSubsystem::UserMix' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, MainVolumeControlBus) == 0x000040, "Member 'URAudioMixingSubsystem::MainVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, MusicControlBus) == 0x000048, "Member 'URAudioMixingSubsystem::MusicControlBus' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, SFXControlBus) == 0x000050, "Member 'URAudioMixingSubsystem::SFXControlBus' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, VoiceControlBus) == 0x000058, "Member 'URAudioMixingSubsystem::VoiceControlBus' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, OtherPlayerVolumeControlBus) == 0x000060, "Member 'URAudioMixingSubsystem::OtherPlayerVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, OtherPlayerEnemyVolumeControlBus) == 0x000068, "Member 'URAudioMixingSubsystem::OtherPlayerEnemyVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioMixingSubsystem, SFXSubmix) == 0x000070, "Member 'URAudioMixingSubsystem::SFXSubmix' has a wrong offset!");

// Class RGame.RGTask
// 0x0010 (0x0078 - 0x0068)
class URGTask : public UGameplayTask
{
public:
	class URGScript*                              Script;                                            // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URGScriptComponent*                     RGScriptComponent;                                 // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CancelTask();
	void FreezeTask();
	void UnfreezeTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask">();
	}
	static class URGTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask>();
	}
};
static_assert(alignof(URGTask) == 0x000008, "Wrong alignment on URGTask");
static_assert(sizeof(URGTask) == 0x000078, "Wrong size on URGTask");
static_assert(offsetof(URGTask, Script) == 0x000068, "Member 'URGTask::Script' has a wrong offset!");
static_assert(offsetof(URGTask, RGScriptComponent) == 0x000070, "Member 'URGTask::RGScriptComponent' has a wrong offset!");

// Class RGame.RGTask_SpawnPlayerSound
// 0x00A0 (0x0118 - 0x0078)
class URGTask_SpawnPlayerSound final : public URGTask
{
public:
	TMulticastInlineDelegate<void(class UAudioComponent* SpawnedSound)> OnSoundSpawned;              // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x68];                                      // 0x00B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_SpawnPlayerSound* SpawnPlayerSound(class URGScript* OwningScript, class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_SpawnPlayerSound">();
	}
	static class URGTask_SpawnPlayerSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_SpawnPlayerSound>();
	}
};
static_assert(alignof(URGTask_SpawnPlayerSound) == 0x000008, "Wrong alignment on URGTask_SpawnPlayerSound");
static_assert(sizeof(URGTask_SpawnPlayerSound) == 0x000118, "Wrong size on URGTask_SpawnPlayerSound");
static_assert(offsetof(URGTask_SpawnPlayerSound, OnSoundSpawned) == 0x000078, "Member 'URGTask_SpawnPlayerSound::OnSoundSpawned' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnPlayerSound, OnFailed) == 0x0000A0, "Member 'URGTask_SpawnPlayerSound::OnFailed' has a wrong offset!");

// Class RGame.RAudioSettings
// 0x0178 (0x01B0 - 0x0038)
class URAudioSettings final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        DefaultControlBusMix;                              // 0x0038(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultSFXSubmix;                                  // 0x0058(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OtherPlayerVolumeControlBus;                       // 0x0078(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OtherPlayerEnemyVolumeControlBus;                  // 0x0098(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplierNonLocalPlayer;                    // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UserControlBusMix;                                 // 0x00C0(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MainVolumeControlBus;                              // 0x00E0(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicVolumeControlBus;                             // 0x0100(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SFXVolumeControlBus;                               // 0x0120(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VoiceVolumeControlBus;                             // 0x0140(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAttenuation>       Player2DAttenuationAsset;                          // 0x0160(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAttenuation>       Weapon2DAttenuationAsset;                          // 0x0188(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class USoundAttenuation* GetPlayer2DAttenuation();
	static class USoundAttenuation* GetWeapon2DAttenuation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAudioSettings">();
	}
	static class URAudioSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URAudioSettings>();
	}
};
static_assert(alignof(URAudioSettings) == 0x000008, "Wrong alignment on URAudioSettings");
static_assert(sizeof(URAudioSettings) == 0x0001B0, "Wrong size on URAudioSettings");
static_assert(offsetof(URAudioSettings, DefaultControlBusMix) == 0x000038, "Member 'URAudioSettings::DefaultControlBusMix' has a wrong offset!");
static_assert(offsetof(URAudioSettings, DefaultSFXSubmix) == 0x000058, "Member 'URAudioSettings::DefaultSFXSubmix' has a wrong offset!");
static_assert(offsetof(URAudioSettings, OtherPlayerVolumeControlBus) == 0x000078, "Member 'URAudioSettings::OtherPlayerVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioSettings, OtherPlayerEnemyVolumeControlBus) == 0x000098, "Member 'URAudioSettings::OtherPlayerEnemyVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioSettings, VolumeMultiplierNonLocalPlayer) == 0x0000B8, "Member 'URAudioSettings::VolumeMultiplierNonLocalPlayer' has a wrong offset!");
static_assert(offsetof(URAudioSettings, UserControlBusMix) == 0x0000C0, "Member 'URAudioSettings::UserControlBusMix' has a wrong offset!");
static_assert(offsetof(URAudioSettings, MainVolumeControlBus) == 0x0000E0, "Member 'URAudioSettings::MainVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioSettings, MusicVolumeControlBus) == 0x000100, "Member 'URAudioSettings::MusicVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioSettings, SFXVolumeControlBus) == 0x000120, "Member 'URAudioSettings::SFXVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioSettings, VoiceVolumeControlBus) == 0x000140, "Member 'URAudioSettings::VoiceVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URAudioSettings, Player2DAttenuationAsset) == 0x000160, "Member 'URAudioSettings::Player2DAttenuationAsset' has a wrong offset!");
static_assert(offsetof(URAudioSettings, Weapon2DAttenuationAsset) == 0x000188, "Member 'URAudioSettings::Weapon2DAttenuationAsset' has a wrong offset!");

// Class RGame.RAutomatedTestManager
// 0x0040 (0x02E8 - 0x02A8)
class ARAutomatedTestManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x28];                                     // 0x02A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAllTestsCompleted;                               // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxItterations;                                    // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARAutomatedTestManager* GetTestManager(const class UObject* WorldContextObject);

	void OnTestCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAutomatedTestManager">();
	}
	static class ARAutomatedTestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARAutomatedTestManager>();
	}
};
static_assert(alignof(ARAutomatedTestManager) == 0x000008, "Wrong alignment on ARAutomatedTestManager");
static_assert(sizeof(ARAutomatedTestManager) == 0x0002E8, "Wrong size on ARAutomatedTestManager");
static_assert(offsetof(ARAutomatedTestManager, OnAllTestsCompleted) == 0x0002D0, "Member 'ARAutomatedTestManager::OnAllTestsCompleted' has a wrong offset!");
static_assert(offsetof(ARAutomatedTestManager, MaxItterations) == 0x0002E0, "Member 'ARAutomatedTestManager::MaxItterations' has a wrong offset!");

// Class RGame.RCooldownEntryWidget
// 0x0000 (0x02D0 - 0x02D0)
class URCooldownEntryWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCooldownEntryWidget">();
	}
	static class URCooldownEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCooldownEntryWidget>();
	}
};
static_assert(alignof(URCooldownEntryWidget) == 0x000008, "Wrong alignment on URCooldownEntryWidget");
static_assert(sizeof(URCooldownEntryWidget) == 0x0002D0, "Wrong size on URCooldownEntryWidget");

// Class RGame.RGCharacterScript
// 0x0028 (0x00E8 - 0x00C0)
class URGCharacterScript : public URGScript
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URGScript* AbilityScript)> OnAbilityFiredAssignable;         // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URGScript* StatusEffectScript, float DeltaTime)> OnStatusEffectTickedAssignable; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void K2_OnAbilityActivate(int32 AbilityIndex);
	void K2_OnAbilityFired(class URGScript* AbilityScript);
	void K2_OnAbilityReleased(int32 AbilityIndex);
	void K2_OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void K2_OnDeath();
	void K2_OnEnemyKilled(class AActor* KilledActor);
	void K2_OnPreDamageTaken(class URHealthComponent* Component, float Damage, int32 DamageSourceMask);
	void K2_OnStatusEffectTicked(class URGScript* StatusEffectScript, float DeltaTime);
	void OnAbilityActivate(int32 AbilityIndex);
	void OnAbilityFired(class URGScript* AbilityScript);
	void OnAbilityReleased(int32 AbilityIndex);
	void OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnDeath();
	void OnEnemyKilled(class AActor* KilledActor);
	void OnPreDamageTaken(class URHealthComponent* Component, float Damage, int32 DamageSourceMask);
	void OnStatusEffectTicked(const struct FRStatusEffectTickRecord& StatusEffectTickRecord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGCharacterScript">();
	}
	static class URGCharacterScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGCharacterScript>();
	}
};
static_assert(alignof(URGCharacterScript) == 0x000008, "Wrong alignment on URGCharacterScript");
static_assert(sizeof(URGCharacterScript) == 0x0000E8, "Wrong size on URGCharacterScript");
static_assert(offsetof(URGCharacterScript, OnAbilityFiredAssignable) == 0x0000C8, "Member 'URGCharacterScript::OnAbilityFiredAssignable' has a wrong offset!");
static_assert(offsetof(URGCharacterScript, OnStatusEffectTickedAssignable) == 0x0000D8, "Member 'URGCharacterScript::OnStatusEffectTickedAssignable' has a wrong offset!");

// Class RGame.RGCharacterMutatorScript
// 0x0020 (0x0108 - 0x00E8)
class URGCharacterMutatorScript : public URGCharacterScript
{
public:
	float                                         InternalProcChanceResetTime;                       // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x1C];                                      // 0x00EC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHealthBonus();
	void ApplyStatusEffects();
	class FText GetMutatorDescription();
	int32 GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	void K2_ApplyStatusEffects();
	void K2_OnDetonate();
	void K2_OnHit();
	void K2_PostDetonate();
	void K2_PostHit();
	void K2_PreHit();
	void OnDetonate();
	void OnHit();
	void PostDetonate();
	void PostHit();
	void PreHit();
	bool RollAbilityProcChance(float* OutProcChance, const int32 TriggeringMutatorRank);
	bool RollChance(const int32 Chance);
	bool RollProcChance(const int32 Chance, float* OutProcChance);

	class FText GetDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGCharacterMutatorScript">();
	}
	static class URGCharacterMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGCharacterMutatorScript>();
	}
};
static_assert(alignof(URGCharacterMutatorScript) == 0x000008, "Wrong alignment on URGCharacterMutatorScript");
static_assert(sizeof(URGCharacterMutatorScript) == 0x000108, "Wrong size on URGCharacterMutatorScript");
static_assert(offsetof(URGCharacterMutatorScript, InternalProcChanceResetTime) == 0x0000E8, "Member 'URGCharacterMutatorScript::InternalProcChanceResetTime' has a wrong offset!");

// Class RGame.RChatLogEntryWidget
// 0x0000 (0x02D0 - 0x02D0)
class URChatLogEntryWidget : public UUserWidget
{
public:
	void SetMessage(const struct FRChatLogMessage& IncomingMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChatLogEntryWidget">();
	}
	static class URChatLogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URChatLogEntryWidget>();
	}
};
static_assert(alignof(URChatLogEntryWidget) == 0x000008, "Wrong alignment on URChatLogEntryWidget");
static_assert(sizeof(URChatLogEntryWidget) == 0x0002D0, "Wrong size on URChatLogEntryWidget");

// Class RGame.RGCharBehaviorMutatorScript
// 0x0008 (0x0110 - 0x0108)
class URGCharBehaviorMutatorScript : public URGCharacterMutatorScript
{
public:
	class URPlayerGScriptComponent*               CachedRPlayerGScriptComponent;                     // 0x0108(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool HasBehaviorMutator(class URMutatorPrimaryAsset* BehaviorMutatorPA);
	void RunAbilityBehavior(class AActor* TriggeringActor, int32 DamageSourceMask, float HealthDamage, class AActor* OptionalAvatarActor);
	void RunMeleeBehavior();
	void RunPrimaryFireBehavior(float HealthDamage);
	void RunSecondaryFireBehavior(class AActor* TriggeringActor, float HealthDamage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGCharBehaviorMutatorScript">();
	}
	static class URGCharBehaviorMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGCharBehaviorMutatorScript>();
	}
};
static_assert(alignof(URGCharBehaviorMutatorScript) == 0x000008, "Wrong alignment on URGCharBehaviorMutatorScript");
static_assert(sizeof(URGCharBehaviorMutatorScript) == 0x000110, "Wrong size on URGCharBehaviorMutatorScript");
static_assert(offsetof(URGCharBehaviorMutatorScript, CachedRPlayerGScriptComponent) == 0x000108, "Member 'URGCharBehaviorMutatorScript::CachedRPlayerGScriptComponent' has a wrong offset!");

// Class RGame.RGFrozenDamageAilment
// 0x0010 (0x04E8 - 0x04D8)
class URGFrozenDamageAilment : public URStatusEffectAilmentGScript
{
public:
	class URMutatorPrimaryAsset*                  FrostPassive6MutatorPA;                            // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalShredDamagePercentagePerSecondVarIndex;       // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageSources;                                     // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGFrozenDamageAilment">();
	}
	static class URGFrozenDamageAilment* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGFrozenDamageAilment>();
	}
};
static_assert(alignof(URGFrozenDamageAilment) == 0x000008, "Wrong alignment on URGFrozenDamageAilment");
static_assert(sizeof(URGFrozenDamageAilment) == 0x0004E8, "Wrong size on URGFrozenDamageAilment");
static_assert(offsetof(URGFrozenDamageAilment, FrostPassive6MutatorPA) == 0x0004D8, "Member 'URGFrozenDamageAilment::FrostPassive6MutatorPA' has a wrong offset!");
static_assert(offsetof(URGFrozenDamageAilment, TotalShredDamagePercentagePerSecondVarIndex) == 0x0004E0, "Member 'URGFrozenDamageAilment::TotalShredDamagePercentagePerSecondVarIndex' has a wrong offset!");
static_assert(offsetof(URGFrozenDamageAilment, DamageSources) == 0x0004E4, "Member 'URGFrozenDamageAilment::DamageSources' has a wrong offset!");

// Class RGame.RBehaviorScriptBlood
// 0x0018 (0x0128 - 0x0110)
class URBehaviorScriptBlood : public URGCharBehaviorMutatorScript
{
public:
	class URMutatorPrimaryAsset*                  BloodPassive4PA;                                   // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageIncreaseVarIndex;                            // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NativeBaseMaxHealth;                               // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DrainDamageSources;                                // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeRunBehavior(const float DrainDamage, class AActor* TriggeringActor, class AActor* AvatarActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBehaviorScriptBlood">();
	}
	static class URBehaviorScriptBlood* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBehaviorScriptBlood>();
	}
};
static_assert(alignof(URBehaviorScriptBlood) == 0x000008, "Wrong alignment on URBehaviorScriptBlood");
static_assert(sizeof(URBehaviorScriptBlood) == 0x000128, "Wrong size on URBehaviorScriptBlood");
static_assert(offsetof(URBehaviorScriptBlood, BloodPassive4PA) == 0x000110, "Member 'URBehaviorScriptBlood::BloodPassive4PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptBlood, DamageIncreaseVarIndex) == 0x000118, "Member 'URBehaviorScriptBlood::DamageIncreaseVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptBlood, NativeBaseMaxHealth) == 0x00011C, "Member 'URBehaviorScriptBlood::NativeBaseMaxHealth' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptBlood, DrainDamageSources) == 0x000120, "Member 'URBehaviorScriptBlood::DrainDamageSources' has a wrong offset!");

// Class RGame.RBehaviorScriptDefender
// 0x0040 (0x0150 - 0x0110)
class URBehaviorScriptDefender : public URGCharBehaviorMutatorScript
{
public:
	class URMutatorPrimaryAsset*                  DefenderGodPassiveMutatorPA;                       // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxGaugeVarIndex;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BarrierDurationVarIndex;                           // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMutatorPrimaryAsset*                  DefenderPassive1PA;                                // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BarrierDurationIncreasePercentageVarIndex;         // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  DefenderPassive4PA;                                // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IncreasedGainPercentageVarIndex;                   // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  DefenderPassive6PA;                                // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNativePassive6Enabled;                            // 0x0148(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NativeCurrentBarrierGauge;                         // 0x014C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NativeRunBehavior(class AActor* TriggeringActor, const int32 BarrierGain);
	void NativeToggleShieldFX(const bool bActive);
	void OnRep_NativeCurrentBarrierGauge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBehaviorScriptDefender">();
	}
	static class URBehaviorScriptDefender* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBehaviorScriptDefender>();
	}
};
static_assert(alignof(URBehaviorScriptDefender) == 0x000008, "Wrong alignment on URBehaviorScriptDefender");
static_assert(sizeof(URBehaviorScriptDefender) == 0x000150, "Wrong size on URBehaviorScriptDefender");
static_assert(offsetof(URBehaviorScriptDefender, DefenderGodPassiveMutatorPA) == 0x000110, "Member 'URBehaviorScriptDefender::DefenderGodPassiveMutatorPA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, MaxGaugeVarIndex) == 0x000118, "Member 'URBehaviorScriptDefender::MaxGaugeVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, BarrierDurationVarIndex) == 0x00011C, "Member 'URBehaviorScriptDefender::BarrierDurationVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, DefenderPassive1PA) == 0x000120, "Member 'URBehaviorScriptDefender::DefenderPassive1PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, BarrierDurationIncreasePercentageVarIndex) == 0x000128, "Member 'URBehaviorScriptDefender::BarrierDurationIncreasePercentageVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, DefenderPassive4PA) == 0x000130, "Member 'URBehaviorScriptDefender::DefenderPassive4PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, IncreasedGainPercentageVarIndex) == 0x000138, "Member 'URBehaviorScriptDefender::IncreasedGainPercentageVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, DefenderPassive6PA) == 0x000140, "Member 'URBehaviorScriptDefender::DefenderPassive6PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, bNativePassive6Enabled) == 0x000148, "Member 'URBehaviorScriptDefender::bNativePassive6Enabled' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptDefender, NativeCurrentBarrierGauge) == 0x00014C, "Member 'URBehaviorScriptDefender::NativeCurrentBarrierGauge' has a wrong offset!");

// Class RGame.RGTask_WaitLoop
// 0x0050 (0x00C8 - 0x0078)
class URGTask_WaitLoop : public URGTask
{
public:
	TMulticastInlineDelegate<void(int32 Index)>   LoopBody;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelled;                                       // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_WaitLoop* WaitLoop(class URGScript* OwningScript, float TimeBetween, int32 Count, bool FinishImmediatelyIfCountIsZero);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_WaitLoop">();
	}
	static class URGTask_WaitLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_WaitLoop>();
	}
};
static_assert(alignof(URGTask_WaitLoop) == 0x000008, "Wrong alignment on URGTask_WaitLoop");
static_assert(sizeof(URGTask_WaitLoop) == 0x0000C8, "Wrong size on URGTask_WaitLoop");
static_assert(offsetof(URGTask_WaitLoop, LoopBody) == 0x000078, "Member 'URGTask_WaitLoop::LoopBody' has a wrong offset!");
static_assert(offsetof(URGTask_WaitLoop, OnFinish) == 0x000088, "Member 'URGTask_WaitLoop::OnFinish' has a wrong offset!");
static_assert(offsetof(URGTask_WaitLoop, OnCancelled) == 0x000098, "Member 'URGTask_WaitLoop::OnCancelled' has a wrong offset!");

// Class RGame.RGTask_WaitLoop_Windburst
// 0x0030 (0x00F8 - 0x00C8)
class URGTask_WaitLoop_Windburst final : public URGTask_WaitLoop
{
public:
	TMulticastInlineDelegate<void(int32 Index, const struct FVector& Location, class ARNPCPawnBase* Target)> LoopBodyWindburst; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_WaitLoop_Windburst* WaitLoop_Windburst(class URGScript* OwningScript, float TimeBetween, int32 Count, const struct FVector& Location, class ARNPCPawnBase* TargetActor, bool FinishImmediatelyIfCountIsZero);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_WaitLoop_Windburst">();
	}
	static class URGTask_WaitLoop_Windburst* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_WaitLoop_Windburst>();
	}
};
static_assert(alignof(URGTask_WaitLoop_Windburst) == 0x000008, "Wrong alignment on URGTask_WaitLoop_Windburst");
static_assert(sizeof(URGTask_WaitLoop_Windburst) == 0x0000F8, "Wrong size on URGTask_WaitLoop_Windburst");
static_assert(offsetof(URGTask_WaitLoop_Windburst, LoopBodyWindburst) == 0x0000C8, "Member 'URGTask_WaitLoop_Windburst::LoopBodyWindburst' has a wrong offset!");

// Class RGame.RBehaviorScriptFortune
// 0x0090 (0x01A0 - 0x0110)
class URBehaviorScriptFortune : public URGCharBehaviorMutatorScript
{
public:
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  FortuneGodPassivePA;                               // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoldToDamageMultiplierPercentageVarIndex;          // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  FortunePassive3PA;                                 // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoldPercentageVarIndex;                            // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  FortunePassive4PA;                                 // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Passive4ChanceVarIndex;                            // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  FortunePassive6PA;                                 // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Passive6ChanceVarIndex;                            // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Passive6MaxRangeVarIndex;                          // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Passive6DiminishingPenalty;                        // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  FortunePassive7PA;                                 // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Passive7ChanceVarIndex;                            // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SphereRadius;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetriggerDelay;                                    // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoldburstDamageSources;                            // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      CachedPlayerController;                            // 0x0178(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARGameState*                            CachedRGameState;                                  // 0x0180(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 NativeTriggeringActor;                             // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 NativeOriginActor;                                 // 0x0190(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNativeUsingSphereInsteadOfDirectHit;              // 0x0198(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckFortunePassive6();
	float GetDamageBasedOnGold();
	float GetFortunePassive3Multiplier();
	bool GetFortunePassive4Effect();
	void NativeRunBehavior(class AActor* TriggeringActor, class AActor* OriginActor);
	void RunFortunePassive6();
	void SpawnVisuals();
	bool UseSphereInsteadOfDirectHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBehaviorScriptFortune">();
	}
	static class URBehaviorScriptFortune* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBehaviorScriptFortune>();
	}
};
static_assert(alignof(URBehaviorScriptFortune) == 0x000008, "Wrong alignment on URBehaviorScriptFortune");
static_assert(sizeof(URBehaviorScriptFortune) == 0x0001A0, "Wrong size on URBehaviorScriptFortune");
static_assert(offsetof(URBehaviorScriptFortune, FortuneGodPassivePA) == 0x000118, "Member 'URBehaviorScriptFortune::FortuneGodPassivePA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, GoldToDamageMultiplierPercentageVarIndex) == 0x000120, "Member 'URBehaviorScriptFortune::GoldToDamageMultiplierPercentageVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, FortunePassive3PA) == 0x000128, "Member 'URBehaviorScriptFortune::FortunePassive3PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, GoldPercentageVarIndex) == 0x000130, "Member 'URBehaviorScriptFortune::GoldPercentageVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, FortunePassive4PA) == 0x000138, "Member 'URBehaviorScriptFortune::FortunePassive4PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, Passive4ChanceVarIndex) == 0x000140, "Member 'URBehaviorScriptFortune::Passive4ChanceVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, FortunePassive6PA) == 0x000148, "Member 'URBehaviorScriptFortune::FortunePassive6PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, Passive6ChanceVarIndex) == 0x000150, "Member 'URBehaviorScriptFortune::Passive6ChanceVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, Passive6MaxRangeVarIndex) == 0x000154, "Member 'URBehaviorScriptFortune::Passive6MaxRangeVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, Passive6DiminishingPenalty) == 0x000158, "Member 'URBehaviorScriptFortune::Passive6DiminishingPenalty' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, FortunePassive7PA) == 0x000160, "Member 'URBehaviorScriptFortune::FortunePassive7PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, Passive7ChanceVarIndex) == 0x000168, "Member 'URBehaviorScriptFortune::Passive7ChanceVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, SphereRadius) == 0x00016C, "Member 'URBehaviorScriptFortune::SphereRadius' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, RetriggerDelay) == 0x000170, "Member 'URBehaviorScriptFortune::RetriggerDelay' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, GoldburstDamageSources) == 0x000174, "Member 'URBehaviorScriptFortune::GoldburstDamageSources' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, CachedPlayerController) == 0x000178, "Member 'URBehaviorScriptFortune::CachedPlayerController' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, CachedRGameState) == 0x000180, "Member 'URBehaviorScriptFortune::CachedRGameState' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, NativeTriggeringActor) == 0x000188, "Member 'URBehaviorScriptFortune::NativeTriggeringActor' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, NativeOriginActor) == 0x000190, "Member 'URBehaviorScriptFortune::NativeOriginActor' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFortune, bNativeUsingSphereInsteadOfDirectHit) == 0x000198, "Member 'URBehaviorScriptFortune::bNativeUsingSphereInsteadOfDirectHit' has a wrong offset!");

// Class RGame.RBehaviorScriptFrost
// 0x0010 (0x0120 - 0x0110)
class URBehaviorScriptFrost : public URGCharBehaviorMutatorScript
{
public:
	TSubclassOf<class URStatusEffectGScript>      ChillStatusEffectClass;                            // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCharacterMutatorPrimaryAsset*         FrostPassive3MutatorPA;                            // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NativeRunBehavior(class AActor* TriggeringActor, const int32 StackIncrease);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBehaviorScriptFrost">();
	}
	static class URBehaviorScriptFrost* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBehaviorScriptFrost>();
	}
};
static_assert(alignof(URBehaviorScriptFrost) == 0x000008, "Wrong alignment on URBehaviorScriptFrost");
static_assert(sizeof(URBehaviorScriptFrost) == 0x000120, "Wrong size on URBehaviorScriptFrost");
static_assert(offsetof(URBehaviorScriptFrost, ChillStatusEffectClass) == 0x000110, "Member 'URBehaviorScriptFrost::ChillStatusEffectClass' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptFrost, FrostPassive3MutatorPA) == 0x000118, "Member 'URBehaviorScriptFrost::FrostPassive3MutatorPA' has a wrong offset!");

// Class RGame.RBehaviorScriptOcean
// 0x0028 (0x0138 - 0x0110)
class URBehaviorScriptOcean : public URGCharBehaviorMutatorScript
{
public:
	float                                         SpawnForwardOffset;                                // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnPolarOffsetMin;                               // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnPolarOffsetMax;                               // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HalfConeAngleMin;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HalfConeAngleMax;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOceanPassiveProjectile>        OceanPassiveProjectiles;                           // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void AddSpawnableProjectileClasses(class AActor* SpawnedTentacleActor);
	bool HasSpawnedNumMaxTentacles();
	void NativeRunBehavior(class AActor* TriggeringActor, const float TriggerDamage);
	struct FVector PollPolarOffsetLocation(const float CurrentAngleMin, const float CurrentAngleMax, int32 CurrentIteration);
	void SpawnTentacle(const struct FVector& Location, const float TriggerDamage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBehaviorScriptOcean">();
	}
	static class URBehaviorScriptOcean* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBehaviorScriptOcean>();
	}
};
static_assert(alignof(URBehaviorScriptOcean) == 0x000008, "Wrong alignment on URBehaviorScriptOcean");
static_assert(sizeof(URBehaviorScriptOcean) == 0x000138, "Wrong size on URBehaviorScriptOcean");
static_assert(offsetof(URBehaviorScriptOcean, SpawnForwardOffset) == 0x000110, "Member 'URBehaviorScriptOcean::SpawnForwardOffset' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptOcean, SpawnPolarOffsetMin) == 0x000114, "Member 'URBehaviorScriptOcean::SpawnPolarOffsetMin' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptOcean, SpawnPolarOffsetMax) == 0x000118, "Member 'URBehaviorScriptOcean::SpawnPolarOffsetMax' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptOcean, HalfConeAngleMin) == 0x00011C, "Member 'URBehaviorScriptOcean::HalfConeAngleMin' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptOcean, HalfConeAngleMax) == 0x000120, "Member 'URBehaviorScriptOcean::HalfConeAngleMax' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptOcean, OceanPassiveProjectiles) == 0x000128, "Member 'URBehaviorScriptOcean::OceanPassiveProjectiles' has a wrong offset!");

// Class RGame.RBTTask_FindNextFlyToLocation
// 0x0008 (0x00A0 - 0x0098)
class URBTTask_FindNextFlyToLocation final : public UBTTask_BlackboardBase
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_FindNextFlyToLocation">();
	}
	static class URBTTask_FindNextFlyToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_FindNextFlyToLocation>();
	}
};
static_assert(alignof(URBTTask_FindNextFlyToLocation) == 0x000008, "Wrong alignment on URBTTask_FindNextFlyToLocation");
static_assert(sizeof(URBTTask_FindNextFlyToLocation) == 0x0000A0, "Wrong size on URBTTask_FindNextFlyToLocation");

// Class RGame.RBehaviorScriptSpirit
// 0x0038 (0x0148 - 0x0110)
class URBehaviorScriptSpirit : public URGCharBehaviorMutatorScript
{
public:
	class URMutatorPrimaryAsset*                  SpiritPassiveMutatorPA;                            // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxGaugeVarIndex;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  SpiritMajorPA;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FullGaugeChancePercentageVarIndex;                 // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  SpiritPassive5PA;                                  // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpiritGaugePercentIncreaseVarIndex;                // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NativeCurrentSpiritGauge;                          // 0x013C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 NativeAvatarActor;                                 // 0x0140(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NativeActivateSpiritSpawning(class AActor* TriggerTarget, float TriggerDamage);
	void NativeAddGaugeExternal(const int32 ExtraGauge);
	void NativeRunBehavior(class AActor* TargetActor, const float OrbDamage, class AActor* AvatarActor);
	void NativeUpdateSpiritGaugeVisuals();
	void OnRep_NativeCurrentSpiritGauge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBehaviorScriptSpirit">();
	}
	static class URBehaviorScriptSpirit* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBehaviorScriptSpirit>();
	}
};
static_assert(alignof(URBehaviorScriptSpirit) == 0x000008, "Wrong alignment on URBehaviorScriptSpirit");
static_assert(sizeof(URBehaviorScriptSpirit) == 0x000148, "Wrong size on URBehaviorScriptSpirit");
static_assert(offsetof(URBehaviorScriptSpirit, SpiritPassiveMutatorPA) == 0x000110, "Member 'URBehaviorScriptSpirit::SpiritPassiveMutatorPA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, MaxGaugeVarIndex) == 0x000118, "Member 'URBehaviorScriptSpirit::MaxGaugeVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, SpiritMajorPA) == 0x000120, "Member 'URBehaviorScriptSpirit::SpiritMajorPA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, FullGaugeChancePercentageVarIndex) == 0x000128, "Member 'URBehaviorScriptSpirit::FullGaugeChancePercentageVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, SpiritPassive5PA) == 0x000130, "Member 'URBehaviorScriptSpirit::SpiritPassive5PA' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, SpiritGaugePercentIncreaseVarIndex) == 0x000138, "Member 'URBehaviorScriptSpirit::SpiritGaugePercentIncreaseVarIndex' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, NativeCurrentSpiritGauge) == 0x00013C, "Member 'URBehaviorScriptSpirit::NativeCurrentSpiritGauge' has a wrong offset!");
static_assert(offsetof(URBehaviorScriptSpirit, NativeAvatarActor) == 0x000140, "Member 'URBehaviorScriptSpirit::NativeAvatarActor' has a wrong offset!");

// Class RGame.RCommonActivatableWidget
// 0x0018 (0x0438 - 0x0420)
class URCommonActivatableWidget : public UCommonActivatableWidget
{
public:
	TArray<class UCommonActionWidget*>            CachedActionWidgets;                               // 0x0420(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bHideKeyboardActionWidgets;                        // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCommonInputMode                             ActivatedInputMode;                                // 0x0431(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidesHUD;                                         // 0x0432(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExcludeFromStackClear;                            // 0x0433(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPopWithEscape;                                 // 0x0434(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCustomPopBehaviour;                            // 0x0435(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_436[0x2];                                      // 0x0436(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FocusDesiredFocusWidget();
	TArray<class UCommonActionWidget*> GetExcludedActionWidgets();
	void OnWidgetPopped();
	void OnWidgetPoppedCustomBehaviour();
	void PopWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCommonActivatableWidget">();
	}
	static class URCommonActivatableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCommonActivatableWidget>();
	}
};
static_assert(alignof(URCommonActivatableWidget) == 0x000008, "Wrong alignment on URCommonActivatableWidget");
static_assert(sizeof(URCommonActivatableWidget) == 0x000438, "Wrong size on URCommonActivatableWidget");
static_assert(offsetof(URCommonActivatableWidget, CachedActionWidgets) == 0x000420, "Member 'URCommonActivatableWidget::CachedActionWidgets' has a wrong offset!");
static_assert(offsetof(URCommonActivatableWidget, bHideKeyboardActionWidgets) == 0x000430, "Member 'URCommonActivatableWidget::bHideKeyboardActionWidgets' has a wrong offset!");
static_assert(offsetof(URCommonActivatableWidget, ActivatedInputMode) == 0x000431, "Member 'URCommonActivatableWidget::ActivatedInputMode' has a wrong offset!");
static_assert(offsetof(URCommonActivatableWidget, bHidesHUD) == 0x000432, "Member 'URCommonActivatableWidget::bHidesHUD' has a wrong offset!");
static_assert(offsetof(URCommonActivatableWidget, bExcludeFromStackClear) == 0x000433, "Member 'URCommonActivatableWidget::bExcludeFromStackClear' has a wrong offset!");
static_assert(offsetof(URCommonActivatableWidget, bCanPopWithEscape) == 0x000434, "Member 'URCommonActivatableWidget::bCanPopWithEscape' has a wrong offset!");
static_assert(offsetof(URCommonActivatableWidget, bHasCustomPopBehaviour) == 0x000435, "Member 'URCommonActivatableWidget::bHasCustomPopBehaviour' has a wrong offset!");

// Class RGame.RCommonLootSelectScreen
// 0x0048 (0x0480 - 0x0438)
class URCommonLootSelectScreen : public URCommonActivatableWidget
{
public:
	struct FGameplayTag                           LootSelectionType;                                 // 0x0438(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRLootSelectionOption>          LootOptions;                                       // 0x0440(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class URLootOptionWidget*>             LootOptionWidgets;                                 // 0x0450(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRLootSelectionOption& LootSelectionOption)> OnLootOptionSelected; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<struct FRLootSelectionOption>& NewLootOptions)> OnLootOptionsChanged; // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void ShowLootOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCommonLootSelectScreen">();
	}
	static class URCommonLootSelectScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCommonLootSelectScreen>();
	}
};
static_assert(alignof(URCommonLootSelectScreen) == 0x000008, "Wrong alignment on URCommonLootSelectScreen");
static_assert(sizeof(URCommonLootSelectScreen) == 0x000480, "Wrong size on URCommonLootSelectScreen");
static_assert(offsetof(URCommonLootSelectScreen, LootSelectionType) == 0x000438, "Member 'URCommonLootSelectScreen::LootSelectionType' has a wrong offset!");
static_assert(offsetof(URCommonLootSelectScreen, LootOptions) == 0x000440, "Member 'URCommonLootSelectScreen::LootOptions' has a wrong offset!");
static_assert(offsetof(URCommonLootSelectScreen, LootOptionWidgets) == 0x000450, "Member 'URCommonLootSelectScreen::LootOptionWidgets' has a wrong offset!");
static_assert(offsetof(URCommonLootSelectScreen, OnLootOptionSelected) == 0x000460, "Member 'URCommonLootSelectScreen::OnLootOptionSelected' has a wrong offset!");
static_assert(offsetof(URCommonLootSelectScreen, OnLootOptionsChanged) == 0x000470, "Member 'URCommonLootSelectScreen::OnLootOptionsChanged' has a wrong offset!");

// Class RGame.RChallengeGridItem
// 0x0048 (0x0070 - 0x0028)
class URChallengeGridItem final : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayDescription;                                // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayRewardName;                                 // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCompletionCount;                            // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCompletionCount;                           // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChallengeId;                                       // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChallengeGridItem">();
	}
	static class URChallengeGridItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URChallengeGridItem>();
	}
};
static_assert(alignof(URChallengeGridItem) == 0x000008, "Wrong alignment on URChallengeGridItem");
static_assert(sizeof(URChallengeGridItem) == 0x000070, "Wrong size on URChallengeGridItem");
static_assert(offsetof(URChallengeGridItem, DisplayName) == 0x000028, "Member 'URChallengeGridItem::DisplayName' has a wrong offset!");
static_assert(offsetof(URChallengeGridItem, DisplayDescription) == 0x000038, "Member 'URChallengeGridItem::DisplayDescription' has a wrong offset!");
static_assert(offsetof(URChallengeGridItem, DisplayRewardName) == 0x000048, "Member 'URChallengeGridItem::DisplayRewardName' has a wrong offset!");
static_assert(offsetof(URChallengeGridItem, Icon) == 0x000058, "Member 'URChallengeGridItem::Icon' has a wrong offset!");
static_assert(offsetof(URChallengeGridItem, CurrentCompletionCount) == 0x000060, "Member 'URChallengeGridItem::CurrentCompletionCount' has a wrong offset!");
static_assert(offsetof(URChallengeGridItem, RequiredCompletionCount) == 0x000064, "Member 'URChallengeGridItem::RequiredCompletionCount' has a wrong offset!");
static_assert(offsetof(URChallengeGridItem, ChallengeId) == 0x000068, "Member 'URChallengeGridItem::ChallengeId' has a wrong offset!");

// Class RGame.RNPCPawnBase
// 0x0120 (0x47E8 - 0x46C8)
class ARNPCPawnBase : public ARPawnBase
{
public:
	uint8                                         Pad_46C8[0x28];                                    // 0x46C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class URGScriptComponent*                     GScriptOwnerComponent;                             // 0x46F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URNPCPawnMovementComponent*             NPCMovementComponent;                              // 0x46F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URGScript>                  NPCScript;                                         // 0x4700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnemyLevel;                                        // 0x4708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470C[0x4];                                     // 0x470C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             EnemyScalingTable;                                 // 0x4710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EnemyDisplayName;                                  // 0x4718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bEvaluateThreatTargetsBetweenAttacks;              // 0x4728(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEvaluateThreatTargetsBetweenSpecials;             // 0x4729(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEvaluateThreatAfterAllActions;                    // 0x472A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnterRagdollModeOnDeath;                          // 0x472B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkeletalMeshBlockOnDeath;                         // 0x472C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_472D[0x3];                                     // 0x472D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          OnDeathPhysAsset;                                  // 0x4730(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterToSpawnManagerOnBeginPlay;                // 0x4738(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClearScriptsOnDeath;                              // 0x4739(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_473A[0x2];                                     // 0x473A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHealthCoeff;                                    // 0x473C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URGScript>               RepNPCScript;                                      // 0x4740(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4748[0x10];                                    // 0x4748(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldSpawnLoot;                                  // 0x4758(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4759[0x3];                                     // 0x4759(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillTreeExecuteThreasholdOverride;                // 0x475C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDisplayHealthBar;                           // 0x4760(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthBarDisplayMode                         NPCHealthBarDisplayMode;                           // 0x4761(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4762[0x6];                                     // 0x4762(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NPCHealthBarOffset;                                // 0x4768(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URHealthbarWidget>       OwningHealthbar;                                   // 0x4780(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     SoulFragmentActorClass;                            // 0x4788(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              NumSoulFragmentsDropped;                           // 0x4790(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CachedOverlayMaterial;                             // 0x47A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             EnemyLootTable;                                    // 0x47A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LootAmount;                                        // 0x47B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LootSpawnDistance;                                 // 0x47C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootSpawnDelay;                                    // 0x47D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootPhysicsSimulationDuration;                     // 0x47D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOnlyOneLootDrop;                             // 0x47D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47D9[0x3];                                     // 0x47D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnemyId;                                           // 0x47DC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47E4[0x4];                                     // 0x47E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCachedOverlayMaterial();
	void CacheCurrentOverlayMaterial();
	void EvaluateThreatTargets();
	void ForceKillNPC();
	float GetMeleeExecutaionPercentageRange();
	void OnDamageDealt(class ARPawnBase* Pawn, const struct FDamageCombatEvent& DamageEventData);
	void OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEvent);
	void OnDeath(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData);
	void OnFinishedRunningScriptFunction(const class FName& Category, const class FName& Function);
	void OnPlayerLeftGame(class APlayerState* LeavingPlayerState);
	void OnPreDamageDealt(class ARPawnBase* Pawn, class AActor* DamagedActor, bool bWasCritical, int32 DamageSourceMask);
	void OnPreDamageTaken(class URHealthComponent* Component, float Damage, int32 DamageSourceMask);
	void OnRep_NPCScript();
	void PostNPCScriptAdded();
	void ReceiveOnDamageDealt();
	void ReceiveOnDamageTaken();
	void ReceiveOnDeath();
	void ReceiveOnPreDamageDealt();
	void ReceiveOnPreDamageTaken();
	void ReceivePostNPCScriptAdded();
	void SetEvaluateThreatAfterAllActions(bool bNewValue);
	void SetEvaluateThreatTargetsBetweenAttacks(bool bNewValue);
	void SetEvaluateThreatTargetsBetweenSpecials(bool bNewValue);
	void SpawnLoot();
	void TryAddThreatTarget(class APlayerController* Player);

	float GetMaxHealthCoefficient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNPCPawnBase">();
	}
	static class ARNPCPawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARNPCPawnBase>();
	}
};
static_assert(alignof(ARNPCPawnBase) == 0x000008, "Wrong alignment on ARNPCPawnBase");
static_assert(sizeof(ARNPCPawnBase) == 0x0047E8, "Wrong size on ARNPCPawnBase");
static_assert(offsetof(ARNPCPawnBase, GScriptOwnerComponent) == 0x0046F0, "Member 'ARNPCPawnBase::GScriptOwnerComponent' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, NPCMovementComponent) == 0x0046F8, "Member 'ARNPCPawnBase::NPCMovementComponent' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, NPCScript) == 0x004700, "Member 'ARNPCPawnBase::NPCScript' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, EnemyLevel) == 0x004708, "Member 'ARNPCPawnBase::EnemyLevel' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, EnemyScalingTable) == 0x004710, "Member 'ARNPCPawnBase::EnemyScalingTable' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, EnemyDisplayName) == 0x004718, "Member 'ARNPCPawnBase::EnemyDisplayName' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bEvaluateThreatTargetsBetweenAttacks) == 0x004728, "Member 'ARNPCPawnBase::bEvaluateThreatTargetsBetweenAttacks' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bEvaluateThreatTargetsBetweenSpecials) == 0x004729, "Member 'ARNPCPawnBase::bEvaluateThreatTargetsBetweenSpecials' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bEvaluateThreatAfterAllActions) == 0x00472A, "Member 'ARNPCPawnBase::bEvaluateThreatAfterAllActions' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bEnterRagdollModeOnDeath) == 0x00472B, "Member 'ARNPCPawnBase::bEnterRagdollModeOnDeath' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bSkeletalMeshBlockOnDeath) == 0x00472C, "Member 'ARNPCPawnBase::bSkeletalMeshBlockOnDeath' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, OnDeathPhysAsset) == 0x004730, "Member 'ARNPCPawnBase::OnDeathPhysAsset' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bRegisterToSpawnManagerOnBeginPlay) == 0x004738, "Member 'ARNPCPawnBase::bRegisterToSpawnManagerOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bClearScriptsOnDeath) == 0x004739, "Member 'ARNPCPawnBase::bClearScriptsOnDeath' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, MaxHealthCoeff) == 0x00473C, "Member 'ARNPCPawnBase::MaxHealthCoeff' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, RepNPCScript) == 0x004740, "Member 'ARNPCPawnBase::RepNPCScript' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bShouldSpawnLoot) == 0x004758, "Member 'ARNPCPawnBase::bShouldSpawnLoot' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, SkillTreeExecuteThreasholdOverride) == 0x00475C, "Member 'ARNPCPawnBase::SkillTreeExecuteThreasholdOverride' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bShouldDisplayHealthBar) == 0x004760, "Member 'ARNPCPawnBase::bShouldDisplayHealthBar' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, NPCHealthBarDisplayMode) == 0x004761, "Member 'ARNPCPawnBase::NPCHealthBarDisplayMode' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, NPCHealthBarOffset) == 0x004768, "Member 'ARNPCPawnBase::NPCHealthBarOffset' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, OwningHealthbar) == 0x004780, "Member 'ARNPCPawnBase::OwningHealthbar' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, SoulFragmentActorClass) == 0x004788, "Member 'ARNPCPawnBase::SoulFragmentActorClass' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, NumSoulFragmentsDropped) == 0x004790, "Member 'ARNPCPawnBase::NumSoulFragmentsDropped' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, CachedOverlayMaterial) == 0x0047A0, "Member 'ARNPCPawnBase::CachedOverlayMaterial' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, EnemyLootTable) == 0x0047A8, "Member 'ARNPCPawnBase::EnemyLootTable' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, LootAmount) == 0x0047B0, "Member 'ARNPCPawnBase::LootAmount' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, LootSpawnDistance) == 0x0047C0, "Member 'ARNPCPawnBase::LootSpawnDistance' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, LootSpawnDelay) == 0x0047D0, "Member 'ARNPCPawnBase::LootSpawnDelay' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, LootPhysicsSimulationDuration) == 0x0047D4, "Member 'ARNPCPawnBase::LootPhysicsSimulationDuration' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, bForceOnlyOneLootDrop) == 0x0047D8, "Member 'ARNPCPawnBase::bForceOnlyOneLootDrop' has a wrong offset!");
static_assert(offsetof(ARNPCPawnBase, EnemyId) == 0x0047DC, "Member 'ARNPCPawnBase::EnemyId' has a wrong offset!");

// Class RGame.RGProjectileScript
// 0x0008 (0x00E0 - 0x00D8)
class URGProjectileScript : public URProjectileBaseScript
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyStatusEffects();
	void K2_ApplyStatusEffects();
	void K2_OnHit();
	void K2_PostHit();
	void K2_PreHit();
	void OnHit();
	void PostHit();
	void PreHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGProjectileScript">();
	}
	static class URGProjectileScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGProjectileScript>();
	}
};
static_assert(alignof(URGProjectileScript) == 0x000008, "Wrong alignment on URGProjectileScript");
static_assert(sizeof(URGProjectileScript) == 0x0000E0, "Wrong size on URGProjectileScript");

// Class RGame.RGRocketScript
// 0x0008 (0x00E8 - 0x00E0)
class URGRocketScript : public URGProjectileScript
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnDetonate();
	void K2_PostDetonate();
	void K2_PreDetonate();
	void OnDetonate();
	void PostDetonate();
	void PreDetonate();

	class ARRocket* GetOwningRocket() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGRocketScript">();
	}
	static class URGRocketScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGRocketScript>();
	}
};
static_assert(alignof(URGRocketScript) == 0x000008, "Wrong alignment on URGRocketScript");
static_assert(sizeof(URGRocketScript) == 0x0000E8, "Wrong size on URGRocketScript");

// Class RGame.RBossPawnBase
// 0x0048 (0x4830 - 0x47E8)
class ARBossPawnBase : public ARNPCPawnBase
{
public:
	class URHealthbarWidget*                      BossHealthbarWidget;                               // 0x47E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   BossName;                                          // 0x47F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ARPlayerPawn*                           PlayerTarget;                                      // 0x4800(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URGBossScript*                          BossScript;                                        // 0x4808(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetupSpawnAreaSegmentOnBeginPlay;                 // 0x4810(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4811[0x3];                                     // 0x4811(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AREnemySpawnAreaSegment> BossSpawnAreaSegment;                              // 0x4814(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatActivated;                                  // 0x481C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_481D[0x3];                                     // 0x481D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFinishAbilityExecution;                          // 0x4820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnAllPlayersDead();
	void OnCombatActivatedUpdated();
	void OnCurrentTargetDowned(class ARPlayerPawn* Player);
	void OnCurrentTargetKilled(class ARPlayerPawn* Player);
	void OnRep_CombatActivated();
	void PushHealthBarWidget_Multicast();
	void SetNewPlayerTarget_Multicast(class ARPlayerPawn* NewTarget, bool bSkipRotationClear);
	void SkipToTorakaSecretPhase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBossPawnBase">();
	}
	static class ARBossPawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARBossPawnBase>();
	}
};
static_assert(alignof(ARBossPawnBase) == 0x000008, "Wrong alignment on ARBossPawnBase");
static_assert(sizeof(ARBossPawnBase) == 0x004830, "Wrong size on ARBossPawnBase");
static_assert(offsetof(ARBossPawnBase, BossHealthbarWidget) == 0x0047E8, "Member 'ARBossPawnBase::BossHealthbarWidget' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, BossName) == 0x0047F0, "Member 'ARBossPawnBase::BossName' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, PlayerTarget) == 0x004800, "Member 'ARBossPawnBase::PlayerTarget' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, BossScript) == 0x004808, "Member 'ARBossPawnBase::BossScript' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, bSetupSpawnAreaSegmentOnBeginPlay) == 0x004810, "Member 'ARBossPawnBase::bSetupSpawnAreaSegmentOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, BossSpawnAreaSegment) == 0x004814, "Member 'ARBossPawnBase::BossSpawnAreaSegment' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, bCombatActivated) == 0x00481C, "Member 'ARBossPawnBase::bCombatActivated' has a wrong offset!");
static_assert(offsetof(ARBossPawnBase, OnFinishAbilityExecution) == 0x004820, "Member 'ARBossPawnBase::OnFinishAbilityExecution' has a wrong offset!");

// Class RGame.RBossPawn_Golemancer
// 0x0038 (0x4868 - 0x4830)
class ARBossPawn_Golemancer final : public ARBossPawnBase
{
public:
	TArray<class ARGolemancerPlatform*>           EdgePlatforms;                                     // 0x4830(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class ARGolemancerPylon*                      LeftPylon;                                         // 0x4840(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARGolemancerPylon*                      RightPylon;                                        // 0x4848(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARAIMovementLocation*                   IntermissionPosition;                              // 0x4850(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AREnemySpawnArea*                       LeftSpawnArea;                                     // 0x4858(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AREnemySpawnArea*                       RightSpawnArea;                                    // 0x4860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class AActor*> GetRandomPlatforms(const int32 MinimumFreePlatformsRequired, const int32 NumberOfPlatformsToChoose);
	void PlayCoreOverloadTimeline(const float From, const float To, const float Duration);
	void SetRandomTarget();
	void ToggleBodyDamageEmissive(const int32 EncounterPhase);
	void ToggleHammerTrailVisibility(const bool bNewVisibility);
	void ToggleHandGlow(const bool bIsRighthand, const bool bNewVisibility);
	void ToggleImmunityShieldVisibility(const bool bNewVisibility);
	void ToggleSocketFXVisibility(const bool bNewVisibility);
	void ToggleWhirlwindVisuals(const bool bNewVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBossPawn_Golemancer">();
	}
	static class ARBossPawn_Golemancer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARBossPawn_Golemancer>();
	}
};
static_assert(alignof(ARBossPawn_Golemancer) == 0x000008, "Wrong alignment on ARBossPawn_Golemancer");
static_assert(sizeof(ARBossPawn_Golemancer) == 0x004868, "Wrong size on ARBossPawn_Golemancer");
static_assert(offsetof(ARBossPawn_Golemancer, EdgePlatforms) == 0x004830, "Member 'ARBossPawn_Golemancer::EdgePlatforms' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Golemancer, LeftPylon) == 0x004840, "Member 'ARBossPawn_Golemancer::LeftPylon' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Golemancer, RightPylon) == 0x004848, "Member 'ARBossPawn_Golemancer::RightPylon' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Golemancer, IntermissionPosition) == 0x004850, "Member 'ARBossPawn_Golemancer::IntermissionPosition' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Golemancer, LeftSpawnArea) == 0x004858, "Member 'ARBossPawn_Golemancer::LeftSpawnArea' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Golemancer, RightSpawnArea) == 0x004860, "Member 'ARBossPawn_Golemancer::RightSpawnArea' has a wrong offset!");

// Class RGame.RBTTask_MoveTo
// 0x0248 (0x02E0 - 0x0098)
class URBTTask_MoveTo final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 FlightLocationKey;                                 // 0x0098(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FlightResultKey;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 KeyToFlipFlopWhenTaskExits;                        // 0x00E8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MovementType;                                      // 0x0110(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MinimumHeightRequired;                             // 0x0138(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaximumFlyHeight;                                  // 0x0160(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HasValidActivePath;                                // 0x0188(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CombatRange;                                       // 0x01B0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 AllowJumping;                                      // 0x01D8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaxJumpDistance;                                   // 0x0200(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUsePathingOffset;                                 // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumProximityRequired;                          // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceExpectedToMovePerTick;                     // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeStuckAtLocation;                            // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDisengageWhenStuck;                            // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              NavigationEQS;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecalcPathOnDestinationChanged : 1;               // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecalculatePathTolerance;                          // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRNavigationQueryParams                NavigationQueryParams;                             // 0x0250(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBT_MoveToTarget_DebugParams           DebugParams;                                       // 0x0270(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class ARNavigationManager*                    NavigationManager;                                 // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleportToDestinationUponFailure;                 // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeBeforeTeleport;                             // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x50];                                     // 0x0290(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pathfinding_OnDynamicCollisionAlert(const struct FRNavigationDynamicCollisionPayload& Data);
	void Pathfinding_OnFinish(const struct FRNavigationQueryData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_MoveTo">();
	}
	static class URBTTask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_MoveTo>();
	}
};
static_assert(alignof(URBTTask_MoveTo) == 0x000008, "Wrong alignment on URBTTask_MoveTo");
static_assert(sizeof(URBTTask_MoveTo) == 0x0002E0, "Wrong size on URBTTask_MoveTo");
static_assert(offsetof(URBTTask_MoveTo, FlightLocationKey) == 0x000098, "Member 'URBTTask_MoveTo::FlightLocationKey' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, FlightResultKey) == 0x0000C0, "Member 'URBTTask_MoveTo::FlightResultKey' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, KeyToFlipFlopWhenTaskExits) == 0x0000E8, "Member 'URBTTask_MoveTo::KeyToFlipFlopWhenTaskExits' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MovementType) == 0x000110, "Member 'URBTTask_MoveTo::MovementType' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MinimumHeightRequired) == 0x000138, "Member 'URBTTask_MoveTo::MinimumHeightRequired' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MaximumFlyHeight) == 0x000160, "Member 'URBTTask_MoveTo::MaximumFlyHeight' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, HasValidActivePath) == 0x000188, "Member 'URBTTask_MoveTo::HasValidActivePath' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, CombatRange) == 0x0001B0, "Member 'URBTTask_MoveTo::CombatRange' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, AllowJumping) == 0x0001D8, "Member 'URBTTask_MoveTo::AllowJumping' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MaxJumpDistance) == 0x000200, "Member 'URBTTask_MoveTo::MaxJumpDistance' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, bUsePathingOffset) == 0x000228, "Member 'URBTTask_MoveTo::bUsePathingOffset' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MinimumProximityRequired) == 0x00022C, "Member 'URBTTask_MoveTo::MinimumProximityRequired' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, DistanceExpectedToMovePerTick) == 0x000230, "Member 'URBTTask_MoveTo::DistanceExpectedToMovePerTick' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MaxTimeStuckAtLocation) == 0x000234, "Member 'URBTTask_MoveTo::MaxTimeStuckAtLocation' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, bUseDisengageWhenStuck) == 0x000238, "Member 'URBTTask_MoveTo::bUseDisengageWhenStuck' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, NavigationEQS) == 0x000240, "Member 'URBTTask_MoveTo::NavigationEQS' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, RecalculatePathTolerance) == 0x00024C, "Member 'URBTTask_MoveTo::RecalculatePathTolerance' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, NavigationQueryParams) == 0x000250, "Member 'URBTTask_MoveTo::NavigationQueryParams' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, DebugParams) == 0x000270, "Member 'URBTTask_MoveTo::DebugParams' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, NavigationManager) == 0x000280, "Member 'URBTTask_MoveTo::NavigationManager' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, bTeleportToDestinationUponFailure) == 0x000288, "Member 'URBTTask_MoveTo::bTeleportToDestinationUponFailure' has a wrong offset!");
static_assert(offsetof(URBTTask_MoveTo, MaxTimeBeforeTeleport) == 0x00028C, "Member 'URBTTask_MoveTo::MaxTimeBeforeTeleport' has a wrong offset!");

// Class RGame.RGameState
// 0x0C28 (0x0F28 - 0x0300)
class ARGameState : public AGameStateBase
{
public:
	class URGScriptComponent*                     GlobalScriptComponent;                             // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCharacterSlot>                CharacterSlots;                                    // 0x0308(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class APlayerState* PlayerState)> OnPlayerLeft;                    // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerState* PlayerState)> OnPlayerJoined;                  // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bWaitingForLastPlayer;                             // 0x0338(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x57];                                     // 0x0339(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnLoadingScreenPushed;                             // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 CurrentNodeId)> OnMidRunLoadingScreenPopped;                 // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* DownedActor)> OnPlayerDowned;                        // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* DownedActor)> OnPlayerDownedEnd;                     // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* ActorUsedOn)> OnKeyUsed;                             // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartRun;                                        // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool RunFailed)> OnFinishRun;                                      // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinalBossKilled;                                 // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInRun;                                          // 0x0410(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunStartTimeStamp;                                 // 0x0414(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         GoldSpawnAmountMultiplier;                         // 0x0418(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PlayerCount;                                       // 0x0540(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyCoefficient;                             // 0x0544(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingLootPlayerHealthThreshold;                  // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x14];                                     // 0x054C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRDifficultyAssignedPointsData> DifficultyAssignedPointsData;                      // 0x0560(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRDifficultyValues                     DifficultyValues;                                  // 0x0570(0x0828)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	int32                                         DebugRoomDifficultyOverride;                       // 0x0D98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9C[0x4];                                      // 0x0D9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                LoadingScreenRef;                                  // 0x0DA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyFactor;                                  // 0x0DA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DAC[0x4];                                      // 0x0DAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HealthPerNodeCurve;                                // 0x0DB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HealthPerPlayerCurve;                              // 0x0DB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      VoiceQueryFloatDatabase;                           // 0x0DC0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                VoiceQueryFNameDatabase;                           // 0x0E10(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UDataTable*                             VoiceDataTable;                                    // 0x0E60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E68[0xB0];                                     // 0x0E68(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPlayerFrameUpdated;                              // 0x0F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class ARGameState* GetRGameState(const class UObject* WorldContextObject);

	void AddGoldToPlayer(class APlayerController* PlayerController, const int32 Delta);
	void AddPortalChoiceNodeId(const int32 NodeID);
	void ApplyPlayerCosmetics(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const class FString& RWeaponCosmeticPath);
	void ApplyPlayerCosmetics_Multicast(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const class FString& RWeaponCosmeticPath);
	void BroadcastOnFinalBossKilled();
	void BroadcastOnKeyUsed_Multicast(class AActor* ActorUsedOn);
	void BroadcastOnLoadingScreenPushed();
	void BroadcastOnMidRunLoadingScreenPopped_Multicast(const int32 CurrentNodeId);
	void BroadcastOnMidRunLoadingScreenPopped_Server(const int32 CurrentNodeId);
	void Debug_SetRoomDifficulty(int32 SetLevelsCompleted);
	void EnableBossHealAltarModified(bool Enabled);
	void EnableBossModifiedMoveKit(bool Enabled);
	void EnableEnemyMeleeKillOnly(bool Enabled);
	void EnableGoldGainForPlayer(class APlayerController* PlayerController, bool bNewEnabled);
	void EnableHealAltarSyringesModified(bool Enabled);
	void EnableKillAllElites(bool Enabled);
	void EnableLastEnemyModified(bool Enabled);
	float GetDifficultySettingFactor();
	int32 GetDifficultyTreeAssignedPoints(class FName Key);
	class URGScriptComponent* GetGlobalScriptComponent();
	float GetHealthPerNodeAtValue(float Value);
	float GetHealthPerPlayerAtValue(float Value);
	struct FVector4 GetHueShift(class APlayerState* PlayerState);
	int32 GetNumDifficultyTreeAssignedPoints();
	int32 GetNumDisconnectedPlayers();
	int32 GetPlayerGold(class APlayerController* PlayerController);
	TArray<class ARPlayerPawn*> GetPlayerPawns();
	int32 GetRoomDifficulty();
	struct FRRunStats GetRunStats();
	void OnFinishRun_Multicast(bool RunFailed);
	void OnLevelCompleted_Multicast();
	void OnRep_CharacterSlots();
	void OnSegmentCompleted_Multicast();
	void OnSessionUserInviteAcceptedEOS(const struct FBlueprintSessionResult& Session, bool bWasSuccesful);
	void OnSessionUserInviteAcceptedSteam(const class FString& SessionId);
	void OnStartRun_Multicast();
	void PlayerFinishMidRunLoading(class APlayerState* PlayerState);
	void PlayerJoined_Multicast(class APlayerState* PlayerState, const class FText& Message);
	void PlayerLeft_Multicast(class APlayerState* PlayerState);
	void PushMidRunLoadingScreen();
	void PushMidRunLoadingScreen_Multicast();
	void ResetPlayerRunStats(class ARPlayerPawn* RPlayerPawn);
	void ResetStats();
	void SendChatMessage(const struct FRChatLogMessage& NewMessage);
	void SetDifficultyTreeAssignedPoints(class FName Key, int32 Points, const bool SaveToSaveGame);
	void SetIsInRun(bool IsInRun);
	void UpdatePlayerClothes(class ARPlayerPawn* RPlayerPawn, class UStaticMesh* NewHeadMesh, const struct FVector4& Color);
	void UpdatePlayerCosmetics(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameState">();
	}
	static class ARGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGameState>();
	}
};
static_assert(alignof(ARGameState) == 0x000008, "Wrong alignment on ARGameState");
static_assert(sizeof(ARGameState) == 0x000F28, "Wrong size on ARGameState");
static_assert(offsetof(ARGameState, GlobalScriptComponent) == 0x000300, "Member 'ARGameState::GlobalScriptComponent' has a wrong offset!");
static_assert(offsetof(ARGameState, CharacterSlots) == 0x000308, "Member 'ARGameState::CharacterSlots' has a wrong offset!");
static_assert(offsetof(ARGameState, OnPlayerLeft) == 0x000318, "Member 'ARGameState::OnPlayerLeft' has a wrong offset!");
static_assert(offsetof(ARGameState, OnPlayerJoined) == 0x000328, "Member 'ARGameState::OnPlayerJoined' has a wrong offset!");
static_assert(offsetof(ARGameState, bWaitingForLastPlayer) == 0x000338, "Member 'ARGameState::bWaitingForLastPlayer' has a wrong offset!");
static_assert(offsetof(ARGameState, OnLoadingScreenPushed) == 0x000390, "Member 'ARGameState::OnLoadingScreenPushed' has a wrong offset!");
static_assert(offsetof(ARGameState, OnMidRunLoadingScreenPopped) == 0x0003A0, "Member 'ARGameState::OnMidRunLoadingScreenPopped' has a wrong offset!");
static_assert(offsetof(ARGameState, OnPlayerDowned) == 0x0003B0, "Member 'ARGameState::OnPlayerDowned' has a wrong offset!");
static_assert(offsetof(ARGameState, OnPlayerDownedEnd) == 0x0003C0, "Member 'ARGameState::OnPlayerDownedEnd' has a wrong offset!");
static_assert(offsetof(ARGameState, OnKeyUsed) == 0x0003D0, "Member 'ARGameState::OnKeyUsed' has a wrong offset!");
static_assert(offsetof(ARGameState, OnStartRun) == 0x0003E0, "Member 'ARGameState::OnStartRun' has a wrong offset!");
static_assert(offsetof(ARGameState, OnFinishRun) == 0x0003F0, "Member 'ARGameState::OnFinishRun' has a wrong offset!");
static_assert(offsetof(ARGameState, OnFinalBossKilled) == 0x000400, "Member 'ARGameState::OnFinalBossKilled' has a wrong offset!");
static_assert(offsetof(ARGameState, bIsInRun) == 0x000410, "Member 'ARGameState::bIsInRun' has a wrong offset!");
static_assert(offsetof(ARGameState, RunStartTimeStamp) == 0x000414, "Member 'ARGameState::RunStartTimeStamp' has a wrong offset!");
static_assert(offsetof(ARGameState, GoldSpawnAmountMultiplier) == 0x000418, "Member 'ARGameState::GoldSpawnAmountMultiplier' has a wrong offset!");
static_assert(offsetof(ARGameState, PlayerCount) == 0x000540, "Member 'ARGameState::PlayerCount' has a wrong offset!");
static_assert(offsetof(ARGameState, DifficultyCoefficient) == 0x000544, "Member 'ARGameState::DifficultyCoefficient' has a wrong offset!");
static_assert(offsetof(ARGameState, HealingLootPlayerHealthThreshold) == 0x000548, "Member 'ARGameState::HealingLootPlayerHealthThreshold' has a wrong offset!");
static_assert(offsetof(ARGameState, DifficultyAssignedPointsData) == 0x000560, "Member 'ARGameState::DifficultyAssignedPointsData' has a wrong offset!");
static_assert(offsetof(ARGameState, DifficultyValues) == 0x000570, "Member 'ARGameState::DifficultyValues' has a wrong offset!");
static_assert(offsetof(ARGameState, DebugRoomDifficultyOverride) == 0x000D98, "Member 'ARGameState::DebugRoomDifficultyOverride' has a wrong offset!");
static_assert(offsetof(ARGameState, LoadingScreenRef) == 0x000DA0, "Member 'ARGameState::LoadingScreenRef' has a wrong offset!");
static_assert(offsetof(ARGameState, DifficultyFactor) == 0x000DA8, "Member 'ARGameState::DifficultyFactor' has a wrong offset!");
static_assert(offsetof(ARGameState, HealthPerNodeCurve) == 0x000DB0, "Member 'ARGameState::HealthPerNodeCurve' has a wrong offset!");
static_assert(offsetof(ARGameState, HealthPerPlayerCurve) == 0x000DB8, "Member 'ARGameState::HealthPerPlayerCurve' has a wrong offset!");
static_assert(offsetof(ARGameState, VoiceQueryFloatDatabase) == 0x000DC0, "Member 'ARGameState::VoiceQueryFloatDatabase' has a wrong offset!");
static_assert(offsetof(ARGameState, VoiceQueryFNameDatabase) == 0x000E10, "Member 'ARGameState::VoiceQueryFNameDatabase' has a wrong offset!");
static_assert(offsetof(ARGameState, VoiceDataTable) == 0x000E60, "Member 'ARGameState::VoiceDataTable' has a wrong offset!");
static_assert(offsetof(ARGameState, OnPlayerFrameUpdated) == 0x000F18, "Member 'ARGameState::OnPlayerFrameUpdated' has a wrong offset!");

// Class RGame.RBossPawn_Unglu
// 0x0040 (0x4870 - 0x4830)
class ARBossPawn_Unglu final : public ARBossPawnBase
{
public:
	class ARUngluMovementSpline*                  MovementSpline;                                    // 0x4830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARAIMovementLocation*>           ChargeBlastLocations;                              // 0x4838(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class ARAIMovementLocation*                   ChargeBlastSpawnLocation;                          // 0x4848(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARAIMovementLocation*>           StationaryBeamLocations;                           // 0x4850(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARAIMovementLocation*>           StationaryBeamCloneLocations;                      // 0x4860(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class ARAIMovementLocation* GetClosestChargeBlastLocation();
	class ARAIMovementLocation* GetClosestStationaryBeamLocation();
	class ARAIMovementLocation* GetRandomStationaryBeamCloneLocation();
	void SetRandomTarget();
	void SetRandomTarget_Multicast();
	void TriggerEnemySpawning();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBossPawn_Unglu">();
	}
	static class ARBossPawn_Unglu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARBossPawn_Unglu>();
	}
};
static_assert(alignof(ARBossPawn_Unglu) == 0x000008, "Wrong alignment on ARBossPawn_Unglu");
static_assert(sizeof(ARBossPawn_Unglu) == 0x004870, "Wrong size on ARBossPawn_Unglu");
static_assert(offsetof(ARBossPawn_Unglu, MovementSpline) == 0x004830, "Member 'ARBossPawn_Unglu::MovementSpline' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Unglu, ChargeBlastLocations) == 0x004838, "Member 'ARBossPawn_Unglu::ChargeBlastLocations' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Unglu, ChargeBlastSpawnLocation) == 0x004848, "Member 'ARBossPawn_Unglu::ChargeBlastSpawnLocation' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Unglu, StationaryBeamLocations) == 0x004850, "Member 'ARBossPawn_Unglu::StationaryBeamLocations' has a wrong offset!");
static_assert(offsetof(ARBossPawn_Unglu, StationaryBeamCloneLocations) == 0x004860, "Member 'ARBossPawn_Unglu::StationaryBeamCloneLocations' has a wrong offset!");

// Class RGame.RBoxVisualizerComponent
// 0x0068 (0x0108 - 0x00A0)
class URBoxVisualizerComponent final : public UActorComponent
{
public:
	struct FColor                                 BoxColor;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxLineThickness;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayHandles;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCenter;                                  // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxCenter;                                         // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   BoxExtents;                                        // 0x00C8(0x0038)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawFilledBox;                                    // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBoxCenter(const struct FVector& NewCenter);
	void SetBoxExtents(const struct FBox& NewExtents);

	struct FBox GetBox() const;
	struct FVector GetBoxCenter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBoxVisualizerComponent">();
	}
	static class URBoxVisualizerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBoxVisualizerComponent>();
	}
};
static_assert(alignof(URBoxVisualizerComponent) == 0x000008, "Wrong alignment on URBoxVisualizerComponent");
static_assert(sizeof(URBoxVisualizerComponent) == 0x000108, "Wrong size on URBoxVisualizerComponent");
static_assert(offsetof(URBoxVisualizerComponent, BoxColor) == 0x0000A0, "Member 'URBoxVisualizerComponent::BoxColor' has a wrong offset!");
static_assert(offsetof(URBoxVisualizerComponent, BoxLineThickness) == 0x0000A4, "Member 'URBoxVisualizerComponent::BoxLineThickness' has a wrong offset!");
static_assert(offsetof(URBoxVisualizerComponent, bDisplayHandles) == 0x0000A8, "Member 'URBoxVisualizerComponent::bDisplayHandles' has a wrong offset!");
static_assert(offsetof(URBoxVisualizerComponent, bUseCustomCenter) == 0x0000A9, "Member 'URBoxVisualizerComponent::bUseCustomCenter' has a wrong offset!");
static_assert(offsetof(URBoxVisualizerComponent, BoxCenter) == 0x0000B0, "Member 'URBoxVisualizerComponent::BoxCenter' has a wrong offset!");
static_assert(offsetof(URBoxVisualizerComponent, BoxExtents) == 0x0000C8, "Member 'URBoxVisualizerComponent::BoxExtents' has a wrong offset!");
static_assert(offsetof(URBoxVisualizerComponent, bDrawFilledBox) == 0x000100, "Member 'URBoxVisualizerComponent::bDrawFilledBox' has a wrong offset!");

// Class RGame.RGWeaponTask
// 0x0000 (0x0078 - 0x0078)
class URGWeaponTask : public URGTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGWeaponTask">();
	}
	static class URGWeaponTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGWeaponTask>();
	}
};
static_assert(alignof(URGWeaponTask) == 0x000008, "Wrong alignment on URGWeaponTask");
static_assert(sizeof(URGWeaponTask) == 0x000078, "Wrong size on URGWeaponTask");

// Class RGame.RGTask_CanFire
// 0x0020 (0x0098 - 0x0078)
class URGTask_CanFire final : public URGWeaponTask
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URGTask_CanFire* CanFire(class URGScript* OwningScript);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_CanFire">();
	}
	static class URGTask_CanFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_CanFire>();
	}
};
static_assert(alignof(URGTask_CanFire) == 0x000008, "Wrong alignment on URGTask_CanFire");
static_assert(sizeof(URGTask_CanFire) == 0x000098, "Wrong size on URGTask_CanFire");
static_assert(offsetof(URGTask_CanFire, onSuccess) == 0x000078, "Member 'URGTask_CanFire::onSuccess' has a wrong offset!");
static_assert(offsetof(URGTask_CanFire, OnFail) == 0x000088, "Member 'URGTask_CanFire::OnFail' has a wrong offset!");

// Class RGame.RBreakableActor
// 0x0048 (0x02F0 - 0x02A8)
class ARBreakableActor final : public AActor
{
public:
	class USceneComponent*                        SceneRoot;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   UnbrokenMesh;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHealthComponent*                      HealthComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleFragmentsInEditor;                         // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LingeringTime;                                     // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseForceMultiplier;                            // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularImpulseForceMultiplier;                     // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLinearFalloff;                                 // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadialRadius;                                      // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialForceMultiplier;                             // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           FragmentArray;                                     // 0x02E0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void DestroyMesh(class URHealthComponent* AffectedHealthComponent, const struct FDamageCombatEvent& DamageEventData);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnFragmentSleep(class UPrimitiveComponent* InComp, class FName InBoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBreakableActor">();
	}
	static class ARBreakableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARBreakableActor>();
	}
};
static_assert(alignof(ARBreakableActor) == 0x000008, "Wrong alignment on ARBreakableActor");
static_assert(sizeof(ARBreakableActor) == 0x0002F0, "Wrong size on ARBreakableActor");
static_assert(offsetof(ARBreakableActor, SceneRoot) == 0x0002A8, "Member 'ARBreakableActor::SceneRoot' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, UnbrokenMesh) == 0x0002B0, "Member 'ARBreakableActor::UnbrokenMesh' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, HealthComponent) == 0x0002B8, "Member 'ARBreakableActor::HealthComponent' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, bVisibleFragmentsInEditor) == 0x0002C0, "Member 'ARBreakableActor::bVisibleFragmentsInEditor' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, LingeringTime) == 0x0002C4, "Member 'ARBreakableActor::LingeringTime' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, ImpulseForceMultiplier) == 0x0002C8, "Member 'ARBreakableActor::ImpulseForceMultiplier' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, AngularImpulseForceMultiplier) == 0x0002CC, "Member 'ARBreakableActor::AngularImpulseForceMultiplier' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, bUseLinearFalloff) == 0x0002D0, "Member 'ARBreakableActor::bUseLinearFalloff' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, RadialRadius) == 0x0002D4, "Member 'ARBreakableActor::RadialRadius' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, RadialForceMultiplier) == 0x0002D8, "Member 'ARBreakableActor::RadialForceMultiplier' has a wrong offset!");
static_assert(offsetof(ARBreakableActor, FragmentArray) == 0x0002E0, "Member 'ARBreakableActor::FragmentArray' has a wrong offset!");

// Class RGame.RChallengeManager
// 0x0048 (0x02F0 - 0x02A8)
class ARChallengeManager final : public AActor
{
public:
	class UDataTable*                             ChallengeTable;                                    // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARPlayerController*                     PlayerController;                                  // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URChallengeScript*>              activeChallenges;                                  // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRChallenge& Challenge)> OnChallengeCompletedEvent;   // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   SoulFragmentsRewardText;                           // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bSimulateAllMutatorsUnlocked;                      // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARChallengeManager* GetChallengeManager(const class UObject* WorldContextObject);
	static class FText ParseChallengeDescription(const class UObject* WorldContextObject, const class FName ChallengeId);

	bool ChallengeExists(class FName ChallengeId);
	class URChallengeGridItem* CreateChallengeGridItem(const struct FRChallenge& Challenge);
	TArray<struct FRChallenge> GetAllChallenges();
	struct FRChallenge GetChallengeByChallengeScript(const class URChallengeScript* ChallengeScript);
	int32 GetChallengeCompletionCount(class FName ChallengeId);
	TArray<class URChallengeGridItem*> GetChallengeGridItems(bool bExcludeCompleted, float CompletionRatioThreshold);
	bool GetChallengeRewardAssets(class FName ChallengeId, class URPrimaryDataAsset** OutReward, int32* OutSoulFragmentsReward);
	void GetChallengeWithMutatorRewardCompletionCount(class URMutatorPrimaryAsset* MutatorPrimaryAsset, int32* CurrentCompletionCount, int32* MaxCompletionCount);
	class FText GetChallengeWithMutatorRewardDescription(class URMutatorPrimaryAsset* MutatorPrimaryAsset);
	class FText GetChallengeWithMutatorRewardName(class URMutatorPrimaryAsset* MutatorPrimaryAsset);
	bool IsChallengeCompleted(class FName ChallengeId);
	bool IsChallengeWithMutatorRewardCompleted(class URMutatorPrimaryAsset* MutatorPrimaryAsset);
	void OnChallengeCompleted(const class FName ChallengeId);
	void ProgressChallenge(class FName ChallengeId, bool ForceFullCompletion, int32 ProgressAmount, bool bSkipLobbyCheck, bool bSkipDeathCheck);
	void RegisterPlayer(class ARPlayerController* InPlayerController);
	void ResetChallenge(const class FName ChallengeId);
	void ResetSteamAchievements();
	void SetChallengeCompletionCount(class FName ChallengeId, int32 CompletionCount);
	void SimulateAllMutatorsUnlocked();

	struct FRChallenge FindChallengeById(const class FString& ChallengeId) const;
	struct FRChallenge GetChallengeByRewardAsset(const class URPrimaryDataAsset* RPrimaryDataAsset) const;
	struct FRChallenge GetChallengeByTag(const struct FGameplayTag& ChallengeTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChallengeManager">();
	}
	static class ARChallengeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARChallengeManager>();
	}
};
static_assert(alignof(ARChallengeManager) == 0x000008, "Wrong alignment on ARChallengeManager");
static_assert(sizeof(ARChallengeManager) == 0x0002F0, "Wrong size on ARChallengeManager");
static_assert(offsetof(ARChallengeManager, ChallengeTable) == 0x0002A8, "Member 'ARChallengeManager::ChallengeTable' has a wrong offset!");
static_assert(offsetof(ARChallengeManager, PlayerController) == 0x0002B0, "Member 'ARChallengeManager::PlayerController' has a wrong offset!");
static_assert(offsetof(ARChallengeManager, activeChallenges) == 0x0002B8, "Member 'ARChallengeManager::activeChallenges' has a wrong offset!");
static_assert(offsetof(ARChallengeManager, OnChallengeCompletedEvent) == 0x0002C8, "Member 'ARChallengeManager::OnChallengeCompletedEvent' has a wrong offset!");
static_assert(offsetof(ARChallengeManager, SoulFragmentsRewardText) == 0x0002D8, "Member 'ARChallengeManager::SoulFragmentsRewardText' has a wrong offset!");
static_assert(offsetof(ARChallengeManager, bSimulateAllMutatorsUnlocked) == 0x0002E8, "Member 'ARChallengeManager::bSimulateAllMutatorsUnlocked' has a wrong offset!");

// Class RGame.RBreakablesManager
// 0x0078 (0x0320 - 0x02A8)
class ARBreakablesManager : public AActor
{
public:
	TSubclassOf<class ARFieldSystemActor>         FieldSystemActorToSpawn;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultPotCrumbleForceProjectile;                  // 0x02B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultPotCrumbleForceArea;                        // 0x02C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultPotCrumbleForceLesserArea;                  // 0x02E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultPotCrumbleForceCollision;                   // 0x02F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFieldSystemActorInfo>          ActorPool;                                         // 0x0310(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class ARBreakablesManager* GetBreakablesManager(const class UObject* WorldContextObject);

	int32 GetActorsInPool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBreakablesManager">();
	}
	static class ARBreakablesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARBreakablesManager>();
	}
};
static_assert(alignof(ARBreakablesManager) == 0x000008, "Wrong alignment on ARBreakablesManager");
static_assert(sizeof(ARBreakablesManager) == 0x000320, "Wrong size on ARBreakablesManager");
static_assert(offsetof(ARBreakablesManager, FieldSystemActorToSpawn) == 0x0002A8, "Member 'ARBreakablesManager::FieldSystemActorToSpawn' has a wrong offset!");
static_assert(offsetof(ARBreakablesManager, DefaultPotCrumbleForceProjectile) == 0x0002B0, "Member 'ARBreakablesManager::DefaultPotCrumbleForceProjectile' has a wrong offset!");
static_assert(offsetof(ARBreakablesManager, DefaultPotCrumbleForceArea) == 0x0002C8, "Member 'ARBreakablesManager::DefaultPotCrumbleForceArea' has a wrong offset!");
static_assert(offsetof(ARBreakablesManager, DefaultPotCrumbleForceLesserArea) == 0x0002E0, "Member 'ARBreakablesManager::DefaultPotCrumbleForceLesserArea' has a wrong offset!");
static_assert(offsetof(ARBreakablesManager, DefaultPotCrumbleForceCollision) == 0x0002F8, "Member 'ARBreakablesManager::DefaultPotCrumbleForceCollision' has a wrong offset!");
static_assert(offsetof(ARBreakablesManager, ActorPool) == 0x000310, "Member 'ARBreakablesManager::ActorPool' has a wrong offset!");

// Class RGame.RDecalManger
// 0x0048 (0x02F0 - 0x02A8)
class ARDecalManger final : public AActor
{
public:
	int32                                         MaxDecals;                                         // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         BulletHoleDecalSystemAsset;                        // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x38];                                     // 0x02B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARDecalManger* GetDecalManager(const class UObject* WorldContextObject);

	void RegisterDecal(class UDecalComponent* NewDecal);
	void RegisterNiagaraDecal(const class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Forward);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDecalManger">();
	}
	static class ARDecalManger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDecalManger>();
	}
};
static_assert(alignof(ARDecalManger) == 0x000008, "Wrong alignment on ARDecalManger");
static_assert(sizeof(ARDecalManger) == 0x0002F0, "Wrong size on ARDecalManger");
static_assert(offsetof(ARDecalManger, MaxDecals) == 0x0002A8, "Member 'ARDecalManger::MaxDecals' has a wrong offset!");
static_assert(offsetof(ARDecalManger, BulletHoleDecalSystemAsset) == 0x0002B0, "Member 'ARDecalManger::BulletHoleDecalSystemAsset' has a wrong offset!");

// Class RGame.RBTDecorator_BlackboardBase
// 0x0008 (0x0098 - 0x0090)
class URBTDecorator_BlackboardBase : public UBTDecorator_BlackboardBase
{
public:
	EBTBlackboardAbortMode                        AbortRequestMode;                                  // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExecutionInterval;                                 // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_BlackboardBase">();
	}
	static class URBTDecorator_BlackboardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_BlackboardBase>();
	}
};
static_assert(alignof(URBTDecorator_BlackboardBase) == 0x000008, "Wrong alignment on URBTDecorator_BlackboardBase");
static_assert(sizeof(URBTDecorator_BlackboardBase) == 0x000098, "Wrong size on URBTDecorator_BlackboardBase");
static_assert(offsetof(URBTDecorator_BlackboardBase, AbortRequestMode) == 0x000090, "Member 'URBTDecorator_BlackboardBase::AbortRequestMode' has a wrong offset!");
static_assert(offsetof(URBTDecorator_BlackboardBase, ExecutionInterval) == 0x000094, "Member 'URBTDecorator_BlackboardBase::ExecutionInterval' has a wrong offset!");

// Class RGame.RChatLog
// 0x0000 (0x02D0 - 0x02D0)
class URChatLog : public UUserWidget
{
public:
	static void AddChatLogEntryToLocalPlayer(class APlayerController* PlayerController, const struct FRChatLogMessage& Message);

	void AddChatLogEntry(const struct FRChatLogMessage& IncomingMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChatLog">();
	}
	static class URChatLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<URChatLog>();
	}
};
static_assert(alignof(URChatLog) == 0x000008, "Wrong alignment on URChatLog");
static_assert(sizeof(URChatLog) == 0x0002D0, "Wrong size on URChatLog");

// Class RGame.RBTDecorator_CanNavigateTo
// 0x0148 (0x01E0 - 0x0098)
class URBTDecorator_CanNavigateTo final : public URBTDecorator_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MovementType;                                      // 0x00E8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HasValidActivePath;                                // 0x0110(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 AllowJumping;                                      // 0x0138(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MaxJumpDistance;                                   // 0x0160(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 AttackRange;                                       // 0x0188(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FRNavigationQueryParams                QueryParams;                                       // 0x01B0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRNavigationDebugParams                DebugParams;                                       // 0x01D0(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ECanNavigateToQueryType                       PathQueryType;                                     // 0x01DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_CanNavigateTo">();
	}
	static class URBTDecorator_CanNavigateTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_CanNavigateTo>();
	}
};
static_assert(alignof(URBTDecorator_CanNavigateTo) == 0x000008, "Wrong alignment on URBTDecorator_CanNavigateTo");
static_assert(sizeof(URBTDecorator_CanNavigateTo) == 0x0001E0, "Wrong size on URBTDecorator_CanNavigateTo");
static_assert(offsetof(URBTDecorator_CanNavigateTo, BlackboardKeyA) == 0x000098, "Member 'URBTDecorator_CanNavigateTo::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, BlackboardKeyB) == 0x0000C0, "Member 'URBTDecorator_CanNavigateTo::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, MovementType) == 0x0000E8, "Member 'URBTDecorator_CanNavigateTo::MovementType' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, HasValidActivePath) == 0x000110, "Member 'URBTDecorator_CanNavigateTo::HasValidActivePath' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, AllowJumping) == 0x000138, "Member 'URBTDecorator_CanNavigateTo::AllowJumping' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, MaxJumpDistance) == 0x000160, "Member 'URBTDecorator_CanNavigateTo::MaxJumpDistance' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, AttackRange) == 0x000188, "Member 'URBTDecorator_CanNavigateTo::AttackRange' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, QueryParams) == 0x0001B0, "Member 'URBTDecorator_CanNavigateTo::QueryParams' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, DebugParams) == 0x0001D0, "Member 'URBTDecorator_CanNavigateTo::DebugParams' has a wrong offset!");
static_assert(offsetof(URBTDecorator_CanNavigateTo, PathQueryType) == 0x0001DC, "Member 'URBTDecorator_CanNavigateTo::PathQueryType' has a wrong offset!");

// Class RGame.ROceanGodTentacle
// 0x0000 (0x02A8 - 0x02A8)
class AROceanGodTentacle : public AActor
{
public:
	void AddSpawnableProjectileClass(class UClass* NewProjectileClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ROceanGodTentacle">();
	}
	static class AROceanGodTentacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AROceanGodTentacle>();
	}
};
static_assert(alignof(AROceanGodTentacle) == 0x000008, "Wrong alignment on AROceanGodTentacle");
static_assert(sizeof(AROceanGodTentacle) == 0x0002A8, "Wrong size on AROceanGodTentacle");

// Class RGame.RBTDecorator_Cooldown
// 0x0000 (0x0090 - 0x0090)
class URBTDecorator_Cooldown final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_Cooldown">();
	}
	static class URBTDecorator_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_Cooldown>();
	}
};
static_assert(alignof(URBTDecorator_Cooldown) == 0x000008, "Wrong alignment on URBTDecorator_Cooldown");
static_assert(sizeof(URBTDecorator_Cooldown) == 0x000090, "Wrong size on URBTDecorator_Cooldown");

// Class RGame.RBTTask_SetTargetRotation
// 0x0028 (0x00C0 - 0x0098)
class URBTTask_SetTargetRotation final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_SetTargetRotation">();
	}
	static class URBTTask_SetTargetRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_SetTargetRotation>();
	}
};
static_assert(alignof(URBTTask_SetTargetRotation) == 0x000008, "Wrong alignment on URBTTask_SetTargetRotation");
static_assert(sizeof(URBTTask_SetTargetRotation) == 0x0000C0, "Wrong size on URBTTask_SetTargetRotation");
static_assert(offsetof(URBTTask_SetTargetRotation, Target) == 0x000098, "Member 'URBTTask_SetTargetRotation::Target' has a wrong offset!");

// Class RGame.RBTDecorator_Distance
// 0x0030 (0x00C8 - 0x0098)
class URBTDecorator_Distance final : public URBTDecorator_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 MaxDistance;                                       // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxDistanceValue;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_Distance">();
	}
	static class URBTDecorator_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_Distance>();
	}
};
static_assert(alignof(URBTDecorator_Distance) == 0x000008, "Wrong alignment on URBTDecorator_Distance");
static_assert(sizeof(URBTDecorator_Distance) == 0x0000C8, "Wrong size on URBTDecorator_Distance");
static_assert(offsetof(URBTDecorator_Distance, MaxDistance) == 0x000098, "Member 'URBTDecorator_Distance::MaxDistance' has a wrong offset!");
static_assert(offsetof(URBTDecorator_Distance, MaxDistanceValue) == 0x0000C0, "Member 'URBTDecorator_Distance::MaxDistanceValue' has a wrong offset!");

// Class RGame.RGCharacterStatCharmScript
// 0x0018 (0x0120 - 0x0108)
class URGCharacterStatCharmScript final : public URGCharacterMutatorScript
{
public:
	ERewardRarity                                 MutatorRarity;                                     // 0x0108(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatCharmStat>                 StatCharmStats;                                    // 0x0110(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class FText GetStatCharmDescription();
	void SwapStatCharm(class ARPickupableItem* OldStatCharmActorRef, const struct FTransform& SpawnTransform, ERewardRarity NewRarity, const TArray<struct FStatCharmStat>& NewMutatorStats);
	void SwapStatCharm_Multicast(class ARPickupableItem* OldStatCharmActorRef, const struct FTransform& SpawnTransform, ERewardRarity NewRarity, const TArray<struct FStatCharmStat>& NewMutatorStats);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGCharacterStatCharmScript">();
	}
	static class URGCharacterStatCharmScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGCharacterStatCharmScript>();
	}
};
static_assert(alignof(URGCharacterStatCharmScript) == 0x000008, "Wrong alignment on URGCharacterStatCharmScript");
static_assert(sizeof(URGCharacterStatCharmScript) == 0x000120, "Wrong size on URGCharacterStatCharmScript");
static_assert(offsetof(URGCharacterStatCharmScript, MutatorRarity) == 0x000108, "Member 'URGCharacterStatCharmScript::MutatorRarity' has a wrong offset!");
static_assert(offsetof(URGCharacterStatCharmScript, StatCharmStats) == 0x000110, "Member 'URGCharacterStatCharmScript::StatCharmStats' has a wrong offset!");

// Class RGame.RBTDecorator_HasUsableAttack
// 0x0000 (0x0098 - 0x0098)
class URBTDecorator_HasUsableAttack final : public URBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_HasUsableAttack">();
	}
	static class URBTDecorator_HasUsableAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_HasUsableAttack>();
	}
};
static_assert(alignof(URBTDecorator_HasUsableAttack) == 0x000008, "Wrong alignment on URBTDecorator_HasUsableAttack");
static_assert(sizeof(URBTDecorator_HasUsableAttack) == 0x000098, "Wrong size on URBTDecorator_HasUsableAttack");

// Class RGame.RBTDecorator_LineOfSightCheck
// 0x0008 (0x00A0 - 0x0098)
class URBTDecorator_LineOfSightCheck final : public URBTDecorator_BlackboardBase
{
public:
	bool                                          DebugDraw;                                         // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_LineOfSightCheck">();
	}
	static class URBTDecorator_LineOfSightCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_LineOfSightCheck>();
	}
};
static_assert(alignof(URBTDecorator_LineOfSightCheck) == 0x000008, "Wrong alignment on URBTDecorator_LineOfSightCheck");
static_assert(sizeof(URBTDecorator_LineOfSightCheck) == 0x0000A0, "Wrong size on URBTDecorator_LineOfSightCheck");
static_assert(offsetof(URBTDecorator_LineOfSightCheck, DebugDraw) == 0x000098, "Member 'URBTDecorator_LineOfSightCheck::DebugDraw' has a wrong offset!");

// Class RGame.RGTask_SpawnExplosion
// 0x0090 (0x0108 - 0x0078)
class URGTask_SpawnExplosion final : public URGTask
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FHitResult>& HitResults, float ActualExplosionRadius)> OnExplosion; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinished;                                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x60];                                      // 0x00A8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_SpawnExplosion* SpawnExplosion(class URGScript* OwningScript, const struct FVector& Origin, float Radius, const TArray<class AActor*>& IgnoreActors, float BaseDamage, int32 DamageSources, bool bRunHitSequenceOnExplode, bool bExplosionTracesForObstacles, bool bIsCriticalOverride, class ARProjectileBase* OptionalProjectile, bool bWeakspotOverride, bool bForceFullServerAuth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_SpawnExplosion">();
	}
	static class URGTask_SpawnExplosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_SpawnExplosion>();
	}
};
static_assert(alignof(URGTask_SpawnExplosion) == 0x000008, "Wrong alignment on URGTask_SpawnExplosion");
static_assert(sizeof(URGTask_SpawnExplosion) == 0x000108, "Wrong size on URGTask_SpawnExplosion");
static_assert(offsetof(URGTask_SpawnExplosion, OnExplosion) == 0x000078, "Member 'URGTask_SpawnExplosion::OnExplosion' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnExplosion, OnFail) == 0x000088, "Member 'URGTask_SpawnExplosion::OnFail' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnExplosion, OnFinished) == 0x000098, "Member 'URGTask_SpawnExplosion::OnFinished' has a wrong offset!");

// Class RGame.RBTDecorator_ValidateCombatTar
// 0x0000 (0x0098 - 0x0098)
class URBTDecorator_ValidateCombatTar final : public URBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_ValidateCombatTar">();
	}
	static class URBTDecorator_ValidateCombatTar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_ValidateCombatTar>();
	}
};
static_assert(alignof(URBTDecorator_ValidateCombatTar) == 0x000008, "Wrong alignment on URBTDecorator_ValidateCombatTar");
static_assert(sizeof(URBTDecorator_ValidateCombatTar) == 0x000098, "Wrong size on URBTDecorator_ValidateCombatTar");

// Class RGame.RBTDecorator_ValidateEQSResult
// 0x0028 (0x00C0 - 0x0098)
class URBTDecorator_ValidateEQSResult final : public URBTDecorator_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 TargetLocation;                                    // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTDecorator_ValidateEQSResult">();
	}
	static class URBTDecorator_ValidateEQSResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTDecorator_ValidateEQSResult>();
	}
};
static_assert(alignof(URBTDecorator_ValidateEQSResult) == 0x000008, "Wrong alignment on URBTDecorator_ValidateEQSResult");
static_assert(sizeof(URBTDecorator_ValidateEQSResult) == 0x0000C0, "Wrong size on URBTDecorator_ValidateEQSResult");
static_assert(offsetof(URBTDecorator_ValidateEQSResult, TargetLocation) == 0x000098, "Member 'URBTDecorator_ValidateEQSResult::TargetLocation' has a wrong offset!");

// Class RGame.RBTTask_ClearTargetRotation
// 0x0000 (0x0098 - 0x0098)
class URBTTask_ClearTargetRotation final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_ClearTargetRotation">();
	}
	static class URBTTask_ClearTargetRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_ClearTargetRotation>();
	}
};
static_assert(alignof(URBTTask_ClearTargetRotation) == 0x000008, "Wrong alignment on URBTTask_ClearTargetRotation");
static_assert(sizeof(URBTTask_ClearTargetRotation) == 0x000098, "Wrong size on URBTTask_ClearTargetRotation");

// Class RGame.RBTTask_EnterCombat
// 0x0028 (0x00C0 - 0x0098)
class URBTTask_EnterCombat final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 TargetPawn;                                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_EnterCombat">();
	}
	static class URBTTask_EnterCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_EnterCombat>();
	}
};
static_assert(alignof(URBTTask_EnterCombat) == 0x000008, "Wrong alignment on URBTTask_EnterCombat");
static_assert(sizeof(URBTTask_EnterCombat) == 0x0000C0, "Wrong size on URBTTask_EnterCombat");
static_assert(offsetof(URBTTask_EnterCombat, TargetPawn) == 0x000098, "Member 'URBTTask_EnterCombat::TargetPawn' has a wrong offset!");

// Class RGame.RBTTask_FindNextMovementLocation
// 0x0068 (0x0100 - 0x0098)
class URBTTask_FindNextMovementLocation final : public UBTTask_BlackboardBase
{
public:
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 MovementTag;                                       // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MovementType;                                      // 0x00D8(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTTask_FindNextMovementLocation">();
	}
	static class URBTTask_FindNextMovementLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTTask_FindNextMovementLocation>();
	}
};
static_assert(alignof(URBTTask_FindNextMovementLocation) == 0x000008, "Wrong alignment on URBTTask_FindNextMovementLocation");
static_assert(sizeof(URBTTask_FindNextMovementLocation) == 0x000100, "Wrong size on URBTTask_FindNextMovementLocation");
static_assert(offsetof(URBTTask_FindNextMovementLocation, MovementTag) == 0x0000B0, "Member 'URBTTask_FindNextMovementLocation::MovementTag' has a wrong offset!");
static_assert(offsetof(URBTTask_FindNextMovementLocation, MovementType) == 0x0000D8, "Member 'URBTTask_FindNextMovementLocation::MovementType' has a wrong offset!");

// Class RGame.RChestManager
// 0x0020 (0x02C8 - 0x02A8)
class ARChestManager final : public AActor
{
public:
	TSubclassOf<class ARLootableContainer>        ChestTypeToSpawn;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATargetPoint*>                   ChestSpawnLocations;                               // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ChanceToSpawnChest;                                // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxChestAmount;                                    // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RChestManager">();
	}
	static class ARChestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARChestManager>();
	}
};
static_assert(alignof(ARChestManager) == 0x000008, "Wrong alignment on ARChestManager");
static_assert(sizeof(ARChestManager) == 0x0002C8, "Wrong size on ARChestManager");
static_assert(offsetof(ARChestManager, ChestTypeToSpawn) == 0x0002A8, "Member 'ARChestManager::ChestTypeToSpawn' has a wrong offset!");
static_assert(offsetof(ARChestManager, ChestSpawnLocations) == 0x0002B0, "Member 'ARChestManager::ChestSpawnLocations' has a wrong offset!");
static_assert(offsetof(ARChestManager, ChanceToSpawnChest) == 0x0002C0, "Member 'ARChestManager::ChanceToSpawnChest' has a wrong offset!");
static_assert(offsetof(ARChestManager, MaxChestAmount) == 0x0002C4, "Member 'ARChestManager::MaxChestAmount' has a wrong offset!");

// Class RGame.RCinematicPlayer
// 0x0058 (0x0300 - 0x02A8)
class ARCinematicPlayer final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              CinematicFinished;                                 // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDMActorProximityBoxComponent*          ActorProximityBoxComponent;                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGenericLevelSequence;                          // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         Sequence;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SequenceOrigin;                                    // 0x02D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   SequencePlayer;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOverlapTrigger;                                // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsConsumed;                                       // 0x02F9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEnterArea(class AActor* OtherActor);
	void OnCinematicFinished();
	void OnRep_bIsConsumed(bool NewValue);
	void PlayCinematic_Multicast(bool bBlockPlayer, bool bHideHud, const bool bHidePlayerWeapon, const bool bHideEntirePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCinematicPlayer">();
	}
	static class ARCinematicPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCinematicPlayer>();
	}
};
static_assert(alignof(ARCinematicPlayer) == 0x000008, "Wrong alignment on ARCinematicPlayer");
static_assert(sizeof(ARCinematicPlayer) == 0x000300, "Wrong size on ARCinematicPlayer");
static_assert(offsetof(ARCinematicPlayer, CinematicFinished) == 0x0002A8, "Member 'ARCinematicPlayer::CinematicFinished' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, ActorProximityBoxComponent) == 0x0002B8, "Member 'ARCinematicPlayer::ActorProximityBoxComponent' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, bUseGenericLevelSequence) == 0x0002C0, "Member 'ARCinematicPlayer::bUseGenericLevelSequence' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, Sequence) == 0x0002C8, "Member 'ARCinematicPlayer::Sequence' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, SequenceOrigin) == 0x0002D0, "Member 'ARCinematicPlayer::SequenceOrigin' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, SequenceActor) == 0x0002E8, "Member 'ARCinematicPlayer::SequenceActor' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, SequencePlayer) == 0x0002F0, "Member 'ARCinematicPlayer::SequencePlayer' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, bUseOverlapTrigger) == 0x0002F8, "Member 'ARCinematicPlayer::bUseOverlapTrigger' has a wrong offset!");
static_assert(offsetof(ARCinematicPlayer, bIsConsumed) == 0x0002F9, "Member 'ARCinematicPlayer::bIsConsumed' has a wrong offset!");

// Class RGame.RClientPredictionScene
// 0x00C8 (0x0370 - 0x02A8)
class ARClientPredictionScene final : public AActor
{
public:
	uint8                                         Pad_2A8[0xC8];                                     // 0x02A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RClientPredictionScene">();
	}
	static class ARClientPredictionScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARClientPredictionScene>();
	}
};
static_assert(alignof(ARClientPredictionScene) == 0x000008, "Wrong alignment on ARClientPredictionScene");
static_assert(sizeof(ARClientPredictionScene) == 0x000370, "Wrong size on ARClientPredictionScene");

// Class RGame.RClientPredictionTestPawn
// 0x0118 (0x0440 - 0x0328)
class ARClientPredictionTestPawn final : public APawn
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRTestPawnMovementState                PawnMovementState;                                 // 0x0348(0x0070)(BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	struct FRTestPawnMovementInput                PawnMovementInput;                                 // 0x03B8(0x0068)(BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	float                                         BaseTurnRate;                                      // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeed;                                     // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FClientPredictionTestSmoothingData     Smoothing;                                         // 0x042C(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerDash(uint32 EventId, float Power);
	void ServerSetInput(const struct FRTestPawnMovementInput& NewInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RClientPredictionTestPawn">();
	}
	static class ARClientPredictionTestPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARClientPredictionTestPawn>();
	}
};
static_assert(alignof(ARClientPredictionTestPawn) == 0x000008, "Wrong alignment on ARClientPredictionTestPawn");
static_assert(sizeof(ARClientPredictionTestPawn) == 0x000440, "Wrong size on ARClientPredictionTestPawn");
static_assert(offsetof(ARClientPredictionTestPawn, CapsuleComponent) == 0x000330, "Member 'ARClientPredictionTestPawn::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ARClientPredictionTestPawn, PawnMovementState) == 0x000348, "Member 'ARClientPredictionTestPawn::PawnMovementState' has a wrong offset!");
static_assert(offsetof(ARClientPredictionTestPawn, PawnMovementInput) == 0x0003B8, "Member 'ARClientPredictionTestPawn::PawnMovementInput' has a wrong offset!");
static_assert(offsetof(ARClientPredictionTestPawn, BaseTurnRate) == 0x000420, "Member 'ARClientPredictionTestPawn::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ARClientPredictionTestPawn, BaseLookUpRate) == 0x000424, "Member 'ARClientPredictionTestPawn::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ARClientPredictionTestPawn, MovementSpeed) == 0x000428, "Member 'ARClientPredictionTestPawn::MovementSpeed' has a wrong offset!");
static_assert(offsetof(ARClientPredictionTestPawn, Smoothing) == 0x00042C, "Member 'ARClientPredictionTestPawn::Smoothing' has a wrong offset!");

// Class RGame.RCombatEventManager
// 0x0090 (0x0338 - 0x02A8)
class ARCombatEventManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClientPredictDamage;                              // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageClientPredictionMode                   DamageClientPredictionMode;                        // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DynamicClientPredictionPingThreshold;              // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogProcessedEvents;                               // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FDamageCombatEvent& EventData)> OnDamageEvent;        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDamageCombatEvent& EventData)> OnDamageEventServerValidated; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FReviveStartedCombatEvent& EventData)> OnReviveStartedEvent; // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHealCombatEvent& EventData)> OnHealEvent;            // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FSetHealthCombatEvent& EventData)> OnSetHealthEvent;  // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FSetArmorCombatEvent& EventData)> OnSetArmorEvent;    // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FSetBarrierCombatEvent& EventData)> OnSetBarrierEvent; // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class ARCombatEventManager* GetCombatEventManager(const class UObject* WorldContextObject);
	static bool IsDamageClientPredictionActiveForLocalPlayer(const class UObject* WorldContextObject);
	static bool IsDamageClientPredictionActiveForPlayer(const class APlayerController* PlayerController);

	void ProcessCombatEvents_Multicast(const TArray<struct FCombatEventReplication>& Events);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCombatEventManager">();
	}
	static class ARCombatEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCombatEventManager>();
	}
};
static_assert(alignof(ARCombatEventManager) == 0x000008, "Wrong alignment on ARCombatEventManager");
static_assert(sizeof(ARCombatEventManager) == 0x000338, "Wrong size on ARCombatEventManager");
static_assert(offsetof(ARCombatEventManager, bClientPredictDamage) == 0x0002B8, "Member 'ARCombatEventManager::bClientPredictDamage' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, DamageClientPredictionMode) == 0x0002B9, "Member 'ARCombatEventManager::DamageClientPredictionMode' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, DynamicClientPredictionPingThreshold) == 0x0002BC, "Member 'ARCombatEventManager::DynamicClientPredictionPingThreshold' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, bLogProcessedEvents) == 0x0002C0, "Member 'ARCombatEventManager::bLogProcessedEvents' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnDamageEvent) == 0x0002C8, "Member 'ARCombatEventManager::OnDamageEvent' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnDamageEventServerValidated) == 0x0002D8, "Member 'ARCombatEventManager::OnDamageEventServerValidated' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnReviveStartedEvent) == 0x0002E8, "Member 'ARCombatEventManager::OnReviveStartedEvent' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnHealEvent) == 0x0002F8, "Member 'ARCombatEventManager::OnHealEvent' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnSetHealthEvent) == 0x000308, "Member 'ARCombatEventManager::OnSetHealthEvent' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnSetArmorEvent) == 0x000318, "Member 'ARCombatEventManager::OnSetArmorEvent' has a wrong offset!");
static_assert(offsetof(ARCombatEventManager, OnSetBarrierEvent) == 0x000328, "Member 'ARCombatEventManager::OnSetBarrierEvent' has a wrong offset!");

// Class RGame.RCommonHUDWidget
// 0x0000 (0x02F8 - 0x02F8)
class URCommonHUDWidget : public UCommonUserWidget
{
public:
	void ClearWidgetStack();
	class UCommonActivatableWidgetStack* GetWidgetStack();
	bool IsWidgetStackEmpty(const bool bExcludeNonInputWidgets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCommonHUDWidget">();
	}
	static class URCommonHUDWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCommonHUDWidget>();
	}
};
static_assert(alignof(URCommonHUDWidget) == 0x000008, "Wrong alignment on URCommonHUDWidget");
static_assert(sizeof(URCommonHUDWidget) == 0x0002F8, "Wrong size on URCommonHUDWidget");

// Class RGame.RCommonRoomObjectiveWidget
// 0x0020 (0x0318 - 0x02F8)
class URCommonRoomObjectiveWidget : public UCommonUserWidget
{
public:
	class FText                                   ObjectiveTitle;                                    // 0x02F8(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   ObjectiveCompletedTitle;                           // 0x0308(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void OnRoomObjectiveCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnRoomObjectiveCompletedEvent(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnRoomObjectiveSpawnAreaSegmentCompleted(class AREnemySpawnAreaSegment* Segment);
	void OnRoomObjectiveUpdated(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment, float AmountCompleted, float AmountRequired);
	void OnRoomObjectiveUpdatedEvent(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment, float AmountCompleted, float AmountRequired);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCommonRoomObjectiveWidget">();
	}
	static class URCommonRoomObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCommonRoomObjectiveWidget>();
	}
};
static_assert(alignof(URCommonRoomObjectiveWidget) == 0x000008, "Wrong alignment on URCommonRoomObjectiveWidget");
static_assert(sizeof(URCommonRoomObjectiveWidget) == 0x000318, "Wrong size on URCommonRoomObjectiveWidget");
static_assert(offsetof(URCommonRoomObjectiveWidget, ObjectiveTitle) == 0x0002F8, "Member 'URCommonRoomObjectiveWidget::ObjectiveTitle' has a wrong offset!");
static_assert(offsetof(URCommonRoomObjectiveWidget, ObjectiveCompletedTitle) == 0x000308, "Member 'URCommonRoomObjectiveWidget::ObjectiveCompletedTitle' has a wrong offset!");

// Class RGame.RCooldownWidget
// 0x0000 (0x02D0 - 0x02D0)
class URCooldownWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCooldownWidget">();
	}
	static class URCooldownWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCooldownWidget>();
	}
};
static_assert(alignof(URCooldownWidget) == 0x000008, "Wrong alignment on URCooldownWidget");
static_assert(sizeof(URCooldownWidget) == 0x0002D0, "Wrong size on URCooldownWidget");

// Class RGame.RCosmeticCategoryPrimaryAsset
// 0x0020 (0x0090 - 0x0070)
class URCosmeticCategoryPrimaryAsset final : public URPrimaryDataAsset
{
public:
	TArray<struct FPlayerCosmeticOption>          CosmeticOptions;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                OptionEntryContentWidgetClass;                     // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDragAndDrop;                                 // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCosmeticCategoryPrimaryAsset">();
	}
	static class URCosmeticCategoryPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCosmeticCategoryPrimaryAsset>();
	}
};
static_assert(alignof(URCosmeticCategoryPrimaryAsset) == 0x000008, "Wrong alignment on URCosmeticCategoryPrimaryAsset");
static_assert(sizeof(URCosmeticCategoryPrimaryAsset) == 0x000090, "Wrong size on URCosmeticCategoryPrimaryAsset");
static_assert(offsetof(URCosmeticCategoryPrimaryAsset, CosmeticOptions) == 0x000070, "Member 'URCosmeticCategoryPrimaryAsset::CosmeticOptions' has a wrong offset!");
static_assert(offsetof(URCosmeticCategoryPrimaryAsset, OptionEntryContentWidgetClass) == 0x000080, "Member 'URCosmeticCategoryPrimaryAsset::OptionEntryContentWidgetClass' has a wrong offset!");
static_assert(offsetof(URCosmeticCategoryPrimaryAsset, bAllowDragAndDrop) == 0x000088, "Member 'URCosmeticCategoryPrimaryAsset::bAllowDragAndDrop' has a wrong offset!");

// Class RGame.RCrosshair
// 0x0050 (0x0320 - 0x02D0)
class URCrosshair : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrosshairScale;                                    // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairScaleMax;                                 // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairScaleMin;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentSpread;                                     // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetSpread;                                      // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMovingMultiplier;                            // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdjustSpeed;                                       // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrunkAim;                                         // 0x02F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x23];                                     // 0x02F5(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           SubCrosshairCanvas;                                // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class URSubCrosshair* AddSubCrosshair(class APlayerController* WorldContextObject, TSubclassOf<class URSubCrosshair> SubCrosshairClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCrosshair">();
	}
	static class URCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCrosshair>();
	}
};
static_assert(alignof(URCrosshair) == 0x000008, "Wrong alignment on URCrosshair");
static_assert(sizeof(URCrosshair) == 0x000320, "Wrong size on URCrosshair");
static_assert(offsetof(URCrosshair, CrosshairScale) == 0x0002D8, "Member 'URCrosshair::CrosshairScale' has a wrong offset!");
static_assert(offsetof(URCrosshair, CrosshairScaleMax) == 0x0002DC, "Member 'URCrosshair::CrosshairScaleMax' has a wrong offset!");
static_assert(offsetof(URCrosshair, CrosshairScaleMin) == 0x0002E0, "Member 'URCrosshair::CrosshairScaleMin' has a wrong offset!");
static_assert(offsetof(URCrosshair, CurrentSpread) == 0x0002E4, "Member 'URCrosshair::CurrentSpread' has a wrong offset!");
static_assert(offsetof(URCrosshair, TargetSpread) == 0x0002E8, "Member 'URCrosshair::TargetSpread' has a wrong offset!");
static_assert(offsetof(URCrosshair, PlayerMovingMultiplier) == 0x0002EC, "Member 'URCrosshair::PlayerMovingMultiplier' has a wrong offset!");
static_assert(offsetof(URCrosshair, AdjustSpeed) == 0x0002F0, "Member 'URCrosshair::AdjustSpeed' has a wrong offset!");
static_assert(offsetof(URCrosshair, bDrunkAim) == 0x0002F4, "Member 'URCrosshair::bDrunkAim' has a wrong offset!");
static_assert(offsetof(URCrosshair, SubCrosshairCanvas) == 0x000318, "Member 'URCrosshair::SubCrosshairCanvas' has a wrong offset!");

// Class RGame.RDangerZoneManager
// 0x0018 (0x02C0 - 0x02A8)
class ARDangerZoneManager final : public AActor
{
public:
	float                                         VisibleAngleOffset;                                // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDangerousActor>                DangerousActors;                                   // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class ARDangerZoneManager* GetDangerZoneManager(const class UObject* WorldContextObject);

	void RegisterDangerousActor(class AActor* DangerousActor, float Radius, float CloseDangerRadius, bool bCriticalDanger);
	void RegisterDangerousLocation(const struct FVector& DangerousLocation, float Radius, float CloseDangerRadius, bool bCriticalDanger);
	void SetCriticalDangerActor(class AActor* Actor, bool bCriticalDanger);
	void UnRegisterDangerousActor(class AActor* ActorToUnRegister);
	void UnRegisterDangerousLocation(const struct FVector& DangerousLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDangerZoneManager">();
	}
	static class ARDangerZoneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDangerZoneManager>();
	}
};
static_assert(alignof(ARDangerZoneManager) == 0x000008, "Wrong alignment on ARDangerZoneManager");
static_assert(sizeof(ARDangerZoneManager) == 0x0002C0, "Wrong size on ARDangerZoneManager");
static_assert(offsetof(ARDangerZoneManager, VisibleAngleOffset) == 0x0002A8, "Member 'ARDangerZoneManager::VisibleAngleOffset' has a wrong offset!");
static_assert(offsetof(ARDangerZoneManager, DangerousActors) == 0x0002B0, "Member 'ARDangerZoneManager::DangerousActors' has a wrong offset!");

// Class RGame.RDebugFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URDebugFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BlueprintDrawDebugBoxTraceMulti(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, EDrawDebugTrace DrawDebugType, bool bHit, const TArray<struct FHitResult>& OutHits, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void LogGScriptsForAllPlayers(const class UObject* WorldContextObject);
	static void LogMovementSpeedModifierCoefficientsForAllPlayers(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDebugFunctionLibrary">();
	}
	static class URDebugFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URDebugFunctionLibrary>();
	}
};
static_assert(alignof(URDebugFunctionLibrary) == 0x000008, "Wrong alignment on URDebugFunctionLibrary");
static_assert(sizeof(URDebugFunctionLibrary) == 0x000028, "Wrong size on URDebugFunctionLibrary");

// Class RGame.RDifficultyPrimaryAsset
// 0x0060 (0x00D0 - 0x0070)
class URDifficultyPrimaryAsset final : public URPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   SoftDifficultyScriptClass;                         // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DifficultyDescription;                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ExtraDifficultyDescription;                        // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRDifficultyTierVariables>      DifficultyTierVariables;                           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   DifficultyIdName;                                  // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetNumTiers();
	class FText ParseDescription(int32 Tier);
	class FText ParseExtraDescription(int32 Tier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDifficultyPrimaryAsset">();
	}
	static class URDifficultyPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URDifficultyPrimaryAsset>();
	}
};
static_assert(alignof(URDifficultyPrimaryAsset) == 0x000008, "Wrong alignment on URDifficultyPrimaryAsset");
static_assert(sizeof(URDifficultyPrimaryAsset) == 0x0000D0, "Wrong size on URDifficultyPrimaryAsset");
static_assert(offsetof(URDifficultyPrimaryAsset, SoftDifficultyScriptClass) == 0x000070, "Member 'URDifficultyPrimaryAsset::SoftDifficultyScriptClass' has a wrong offset!");
static_assert(offsetof(URDifficultyPrimaryAsset, DifficultyDescription) == 0x000098, "Member 'URDifficultyPrimaryAsset::DifficultyDescription' has a wrong offset!");
static_assert(offsetof(URDifficultyPrimaryAsset, ExtraDifficultyDescription) == 0x0000A8, "Member 'URDifficultyPrimaryAsset::ExtraDifficultyDescription' has a wrong offset!");
static_assert(offsetof(URDifficultyPrimaryAsset, DifficultyTierVariables) == 0x0000B8, "Member 'URDifficultyPrimaryAsset::DifficultyTierVariables' has a wrong offset!");
static_assert(offsetof(URDifficultyPrimaryAsset, DifficultyIdName) == 0x0000C8, "Member 'URDifficultyPrimaryAsset::DifficultyIdName' has a wrong offset!");

// Class RGame.RDifficultyTree
// 0x0008 (0x02B0 - 0x02A8)
class ARDifficultyTree final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDifficultyTree">();
	}
	static class ARDifficultyTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDifficultyTree>();
	}
};
static_assert(alignof(ARDifficultyTree) == 0x000008, "Wrong alignment on ARDifficultyTree");
static_assert(sizeof(ARDifficultyTree) == 0x0002B0, "Wrong size on ARDifficultyTree");

// Class RGame.RDoor
// 0x0030 (0x02D8 - 0x02A8)
class ARDoor : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequireKey;                                       // 0x02B0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClosed;                                         // 0x02B1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTransition;                                     // 0x02B2(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3[0x5];                                      // 0x02B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFinishedClosing;                                 // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorOpened;                                      // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallDoorOpened();
	void OnIsClosedUpdated();
	void OnNextLevelsFinishedShowing();
	void OnRep_IsClosed();
	void OnRep_RequireKey();
	void OnRequiredKeyUpdated();
	void StartClosing();
	void StartOpening();

	void DoorFinishedClosing() const;
	void GetBlueprintVariables(struct FRDoorBlueprintVariables* Result) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDoor">();
	}
	static class ARDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDoor>();
	}
};
static_assert(alignof(ARDoor) == 0x000008, "Wrong alignment on ARDoor");
static_assert(sizeof(ARDoor) == 0x0002D8, "Wrong size on ARDoor");
static_assert(offsetof(ARDoor, bRequireKey) == 0x0002B0, "Member 'ARDoor::bRequireKey' has a wrong offset!");
static_assert(offsetof(ARDoor, bIsClosed) == 0x0002B1, "Member 'ARDoor::bIsClosed' has a wrong offset!");
static_assert(offsetof(ARDoor, bInTransition) == 0x0002B2, "Member 'ARDoor::bInTransition' has a wrong offset!");
static_assert(offsetof(ARDoor, OnFinishedClosing) == 0x0002B8, "Member 'ARDoor::OnFinishedClosing' has a wrong offset!");
static_assert(offsetof(ARDoor, OnDoorOpened) == 0x0002C8, "Member 'ARDoor::OnDoorOpened' has a wrong offset!");

// Class RGame.RDrawDebugBoxComponent
// 0x0050 (0x00F0 - 0x00A0)
class URDrawDebugBoxComponent final : public UActorComponent
{
public:
	struct FColor                                 BoxColor;                                          // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxLineThickness;                                  // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCenter;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomExtents;                                 // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxCenter;                                         // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtents;                                        // 0x00C8(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetBoxCenter() const;
	struct FVector GetBoxExtents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDrawDebugBoxComponent">();
	}
	static class URDrawDebugBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URDrawDebugBoxComponent>();
	}
};
static_assert(alignof(URDrawDebugBoxComponent) == 0x000008, "Wrong alignment on URDrawDebugBoxComponent");
static_assert(sizeof(URDrawDebugBoxComponent) == 0x0000F0, "Wrong size on URDrawDebugBoxComponent");
static_assert(offsetof(URDrawDebugBoxComponent, BoxColor) == 0x0000A0, "Member 'URDrawDebugBoxComponent::BoxColor' has a wrong offset!");
static_assert(offsetof(URDrawDebugBoxComponent, BoxLineThickness) == 0x0000A4, "Member 'URDrawDebugBoxComponent::BoxLineThickness' has a wrong offset!");
static_assert(offsetof(URDrawDebugBoxComponent, bUseCustomCenter) == 0x0000A8, "Member 'URDrawDebugBoxComponent::bUseCustomCenter' has a wrong offset!");
static_assert(offsetof(URDrawDebugBoxComponent, bUseCustomExtents) == 0x0000A9, "Member 'URDrawDebugBoxComponent::bUseCustomExtents' has a wrong offset!");
static_assert(offsetof(URDrawDebugBoxComponent, BoxCenter) == 0x0000B0, "Member 'URDrawDebugBoxComponent::BoxCenter' has a wrong offset!");
static_assert(offsetof(URDrawDebugBoxComponent, BoxExtents) == 0x0000C8, "Member 'URDrawDebugBoxComponent::BoxExtents' has a wrong offset!");

// Class RGame.RDummy
// 0x0010 (0x02B8 - 0x02A8)
class ARDummy : public AActor
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHealthComponent*                      HealthComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UCapsuleComponent* GetCapsuleComponent() const;
	class URHealthComponent* GetHealthComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDummy">();
	}
	static class ARDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDummy>();
	}
};
static_assert(alignof(ARDummy) == 0x000008, "Wrong alignment on ARDummy");
static_assert(sizeof(ARDummy) == 0x0002B8, "Wrong size on ARDummy");
static_assert(offsetof(ARDummy, CapsuleComponent) == 0x0002A8, "Member 'ARDummy::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ARDummy, HealthComponent) == 0x0002B0, "Member 'ARDummy::HealthComponent' has a wrong offset!");

// Class RGame.RDummyTotem
// 0x0010 (0x02C8 - 0x02B8)
class ARDummyTotem final : public ARDummy
{
public:
	class ARAreaEffect*                           AttachedAreaEffect;                                // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERTotemType                                   TotemType;                                         // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMobile;                                         // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDummyTotem">();
	}
	static class ARDummyTotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDummyTotem>();
	}
};
static_assert(alignof(ARDummyTotem) == 0x000008, "Wrong alignment on ARDummyTotem");
static_assert(sizeof(ARDummyTotem) == 0x0002C8, "Wrong size on ARDummyTotem");
static_assert(offsetof(ARDummyTotem, AttachedAreaEffect) == 0x0002B8, "Member 'ARDummyTotem::AttachedAreaEffect' has a wrong offset!");
static_assert(offsetof(ARDummyTotem, TotemType) == 0x0002C0, "Member 'ARDummyTotem::TotemType' has a wrong offset!");
static_assert(offsetof(ARDummyTotem, bIsMobile) == 0x0002C1, "Member 'ARDummyTotem::bIsMobile' has a wrong offset!");

// Class RGame.RGameMode
// 0x0000 (0x0340 - 0x0340)
class ARGameMode : public AGameModeBase
{
public:
	bool InitPingBeacon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameMode">();
	}
	static class ARGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGameMode>();
	}
};
static_assert(alignof(ARGameMode) == 0x000008, "Wrong alignment on ARGameMode");
static_assert(sizeof(ARGameMode) == 0x000340, "Wrong size on ARGameMode");

// Class RGame.RGameGameMode
// 0x0058 (0x0398 - 0x0340)
class ARGameGameMode : public ARGameMode
{
public:
	TArray<class APlayerController*>              AliveControllers;                                  // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class APlayerController*>              DeadControllers;                                   // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class APlayerController*>              DownedControllers;                                 // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool GameWon)>  OnGameEnded;                                       // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllPlayerControllersDead;                        // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	float ReevaluateDifficultyCoefficient();

	const TArray<class APlayerController*> GetAliveControllersArray() const;
	const TArray<class APlayerController*> GetDeadControllersArray() const;
	const TArray<class APlayerController*> GetDownedControllersArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameGameMode">();
	}
	static class ARGameGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGameGameMode>();
	}
};
static_assert(alignof(ARGameGameMode) == 0x000008, "Wrong alignment on ARGameGameMode");
static_assert(sizeof(ARGameGameMode) == 0x000398, "Wrong size on ARGameGameMode");
static_assert(offsetof(ARGameGameMode, AliveControllers) == 0x000340, "Member 'ARGameGameMode::AliveControllers' has a wrong offset!");
static_assert(offsetof(ARGameGameMode, DeadControllers) == 0x000350, "Member 'ARGameGameMode::DeadControllers' has a wrong offset!");
static_assert(offsetof(ARGameGameMode, DownedControllers) == 0x000360, "Member 'ARGameGameMode::DownedControllers' has a wrong offset!");
static_assert(offsetof(ARGameGameMode, OnGameEnded) == 0x000378, "Member 'ARGameGameMode::OnGameEnded' has a wrong offset!");
static_assert(offsetof(ARGameGameMode, OnAllPlayerControllersDead) == 0x000388, "Member 'ARGameGameMode::OnAllPlayerControllersDead' has a wrong offset!");

// Class RGame.RDungeonGameMode
// 0x0070 (0x0408 - 0x0398)
class ARDungeonGameMode final : public ARGameGameMode
{
public:
	uint8                                         Pad_398[0x11];                                     // 0x0398(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldUseElevatorSequence;                        // 0x03A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)> OnSegmentCompleted; // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerDisconnect;                                // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLobbyElevatorSequenceStart;                      // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLobbyElevatorSequenceStartMulticast;             // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUngluTeleportSequenceStarted;                    // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bWaitingForLobby;                                  // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARDungeonGameMode* GetRDungeonGameMode(const class UObject* WorldContextObject);

	void ClearVoteTimer();
	void FinishWaitingForPlayers();
	void OnAllSegmentsCompleted();
	void OnFinalBossKilled();
	void OnSegmentCompleted_Internal(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void ReturnToLobby();
	void StartWaitingForPlayers(class ARGamePlayerController* GamePlayerController);
	void StopWaitingForPlayer(class ARGamePlayerController* GamePlayerController);
	void TravelToLevel(const TArray<class FName>& LevelId, class FName LightingLevelId, const TArray<class FName>& ConnectorLevels, bool bBlockingLoading, class FName TargetPlayerStartTag);
	void TravelToLobby(class FName TargetPlayerStartTag);
	void TravelToNextLevel();
	void TravelToSameLevel();
	void VoteToProceedPortal();
	void VoteToProceedShortcut(class ARGamePlayerController* VotingPlayer);

	void StartLobbyElevatorSequence() const;
	void StartUngluTeleportSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RDungeonGameMode">();
	}
	static class ARDungeonGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARDungeonGameMode>();
	}
};
static_assert(alignof(ARDungeonGameMode) == 0x000008, "Wrong alignment on ARDungeonGameMode");
static_assert(sizeof(ARDungeonGameMode) == 0x000408, "Wrong size on ARDungeonGameMode");
static_assert(offsetof(ARDungeonGameMode, bShouldUseElevatorSequence) == 0x0003A9, "Member 'ARDungeonGameMode::bShouldUseElevatorSequence' has a wrong offset!");
static_assert(offsetof(ARDungeonGameMode, OnSegmentCompleted) == 0x0003B0, "Member 'ARDungeonGameMode::OnSegmentCompleted' has a wrong offset!");
static_assert(offsetof(ARDungeonGameMode, OnPlayerDisconnect) == 0x0003C0, "Member 'ARDungeonGameMode::OnPlayerDisconnect' has a wrong offset!");
static_assert(offsetof(ARDungeonGameMode, OnLobbyElevatorSequenceStart) == 0x0003D0, "Member 'ARDungeonGameMode::OnLobbyElevatorSequenceStart' has a wrong offset!");
static_assert(offsetof(ARDungeonGameMode, OnLobbyElevatorSequenceStartMulticast) == 0x0003E0, "Member 'ARDungeonGameMode::OnLobbyElevatorSequenceStartMulticast' has a wrong offset!");
static_assert(offsetof(ARDungeonGameMode, OnUngluTeleportSequenceStarted) == 0x0003F0, "Member 'ARDungeonGameMode::OnUngluTeleportSequenceStarted' has a wrong offset!");
static_assert(offsetof(ARDungeonGameMode, bWaitingForLobby) == 0x000400, "Member 'ARDungeonGameMode::bWaitingForLobby' has a wrong offset!");

// Class RGame.REffectsManager
// 0x0080 (0x0328 - 0x02A8)
class AREffectsManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x30];                                     // 0x02A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class UNiagaraComponent>> TrackedNiagaraComponents;                          // 0x02D8(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static void DestroyOrReleaseNiagaraSystem(class UNiagaraComponent* NiagaraComponent);
	static bool GetIsNiagaraPoolingEnabled();
	static ENCPoolMethod GetShouldAutoPoolNiagara();
	static ENCPoolMethod GetShouldManualReleaseNiagara();
	static void PlayReplicatedNiagara(const class UObject* WorldContextObject, class UNiagaraSystem* SystemTemplate, const TArray<struct FNiagaraFloatParam>& FloatParams, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bPreCullCheck);
	static void PlayReplicatedNiagaraAtActorLocation(const class UObject* WorldContextObject, class UNiagaraSystem* SystemTemplate, const TArray<struct FNiagaraFloatParam>& FloatParams, class AActor* Actor, const struct FRotator& Rotation, const struct FVector& Scale, bool bPreCullCheck, const struct FVector& LocationOffset);
	static void PlayReplicatedSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, const TArray<struct FAudioParameter>& AudioParams, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings);
	static void PlayReplicatedSoundAtActorLocation(const class UObject* WorldContextObject, class USoundBase* Sound, class AActor* Actor, const TArray<struct FAudioParameter>& AudioParams, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, const struct FVector& LocationOffset);
	static void PlayReplicatedSoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const TArray<struct FAudioParameter>& AudioParams, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings);
	static void TrackNiagaraComponent(const class UObject* WorldContextObject, class UNiagaraComponent* NiagaraComponent);

	void PlayBatchedEffects_Multicast(const TArray<struct FNiagaraSpawnRequest>& Niagara, const TArray<struct FSoundSpawnRequest>& Sounds, const TArray<struct FSound2DSpawnRequest>& Sounds2D);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REffectsManager">();
	}
	static class AREffectsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREffectsManager>();
	}
};
static_assert(alignof(AREffectsManager) == 0x000008, "Wrong alignment on AREffectsManager");
static_assert(sizeof(AREffectsManager) == 0x000328, "Wrong size on AREffectsManager");
static_assert(offsetof(AREffectsManager, TrackedNiagaraComponents) == 0x0002D8, "Member 'AREffectsManager::TrackedNiagaraComponents' has a wrong offset!");

// Class RGame.REnemyAnimInstance
// 0x04C0 (0x0880 - 0x03C0)
class UREnemyAnimInstance : public UAnimInstance
{
public:
	class USkeletalMeshComponent*                 OwningSkeletalMesh;                                // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AREnemyPawnBase*                        PawnOwner;                                         // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIState                                      AIState;                                           // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERPawnMovementMode                            MovementState;                                     // 0x03C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementDirection                            MovementDirection;                                 // 0x03CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CB[0xD];                                      // 0x03CB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x03D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeVelocityDirection;                         // 0x03F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeAcceleration;                              // 0x0408(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelativeAccelerationSize;                          // 0x0420(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x0424(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVelocityBlend                         VelocityBlend;                                     // 0x0428(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLeanAmount                            LeanAmount;                                        // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DiagonalScaleAmount;                               // 0x0440(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkRunBlend;                                      // 0x0444(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrideBlendTarget;                                 // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrideBlend;                                       // 0x044C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimatedRunSpeed;                                  // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimatedWalkSpeed;                                 // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               DirectionalYaw;                                    // 0x0460(0x0020)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousVelocity;                                  // 0x0480(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKTraceAboveFoot;                                  // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKTraceBelowFoot;                                  // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootHeight;                                        // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0xC];                                      // 0x04A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LFootTransformOffset;                              // 0x04B0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RFootTransformOffset;                              // 0x0510(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LFootLockTransform;                                // 0x0570(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LFootLockAlpha;                                    // 0x05D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RFootLockTransform;                                // 0x05E0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RFootLockAlpha;                                    // 0x0640(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_644[0xC];                                      // 0x0644(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PelvisIKTransform;                                 // 0x0650(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisOffsetMultiplier;                            // 0x06B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B4[0x4];                                      // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HeadIKTarget;                                      // 0x06B8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadIKRotation;                                    // 0x06D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CombatTargetTransform;                             // 0x06F0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0750(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasTarget;                                        // 0x0758(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_759[0x7];                                      // 0x0759(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LHandIKTransform;                                  // 0x0760(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LElbowLocation;                                    // 0x07C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RHandIKTransform;                                  // 0x07E0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RElbowLocation;                                    // 0x0840(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DiagonalScaleCurve;                                // 0x0858(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StrideBlendCurve;                                  // 0x0860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           YawOffsetFB;                                       // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           YawOffsetLR;                                       // 0x0870(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemyAnimInstance">();
	}
	static class UREnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREnemyAnimInstance>();
	}
};
static_assert(alignof(UREnemyAnimInstance) == 0x000010, "Wrong alignment on UREnemyAnimInstance");
static_assert(sizeof(UREnemyAnimInstance) == 0x000880, "Wrong size on UREnemyAnimInstance");
static_assert(offsetof(UREnemyAnimInstance, OwningSkeletalMesh) == 0x0003B8, "Member 'UREnemyAnimInstance::OwningSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, PawnOwner) == 0x0003C0, "Member 'UREnemyAnimInstance::PawnOwner' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, AIState) == 0x0003C8, "Member 'UREnemyAnimInstance::AIState' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, MovementState) == 0x0003C9, "Member 'UREnemyAnimInstance::MovementState' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, MovementDirection) == 0x0003CA, "Member 'UREnemyAnimInstance::MovementDirection' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, Velocity) == 0x0003D8, "Member 'UREnemyAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RelativeVelocityDirection) == 0x0003F0, "Member 'UREnemyAnimInstance::RelativeVelocityDirection' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RelativeAcceleration) == 0x000408, "Member 'UREnemyAnimInstance::RelativeAcceleration' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RelativeAccelerationSize) == 0x000420, "Member 'UREnemyAnimInstance::RelativeAccelerationSize' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, bIsMoving) == 0x000424, "Member 'UREnemyAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, VelocityBlend) == 0x000428, "Member 'UREnemyAnimInstance::VelocityBlend' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, LeanAmount) == 0x000438, "Member 'UREnemyAnimInstance::LeanAmount' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, DiagonalScaleAmount) == 0x000440, "Member 'UREnemyAnimInstance::DiagonalScaleAmount' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, WalkRunBlend) == 0x000444, "Member 'UREnemyAnimInstance::WalkRunBlend' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, StrideBlendTarget) == 0x000448, "Member 'UREnemyAnimInstance::StrideBlendTarget' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, StrideBlend) == 0x00044C, "Member 'UREnemyAnimInstance::StrideBlend' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, PlayRate) == 0x000450, "Member 'UREnemyAnimInstance::PlayRate' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, AnimatedRunSpeed) == 0x000454, "Member 'UREnemyAnimInstance::AnimatedRunSpeed' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, AnimatedWalkSpeed) == 0x000458, "Member 'UREnemyAnimInstance::AnimatedWalkSpeed' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, DirectionalYaw) == 0x000460, "Member 'UREnemyAnimInstance::DirectionalYaw' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, PreviousVelocity) == 0x000480, "Member 'UREnemyAnimInstance::PreviousVelocity' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, IKTraceAboveFoot) == 0x000498, "Member 'UREnemyAnimInstance::IKTraceAboveFoot' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, IKTraceBelowFoot) == 0x00049C, "Member 'UREnemyAnimInstance::IKTraceBelowFoot' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, FootHeight) == 0x0004A0, "Member 'UREnemyAnimInstance::FootHeight' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, LFootTransformOffset) == 0x0004B0, "Member 'UREnemyAnimInstance::LFootTransformOffset' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RFootTransformOffset) == 0x000510, "Member 'UREnemyAnimInstance::RFootTransformOffset' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, LFootLockTransform) == 0x000570, "Member 'UREnemyAnimInstance::LFootLockTransform' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, LFootLockAlpha) == 0x0005D0, "Member 'UREnemyAnimInstance::LFootLockAlpha' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RFootLockTransform) == 0x0005E0, "Member 'UREnemyAnimInstance::RFootLockTransform' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RFootLockAlpha) == 0x000640, "Member 'UREnemyAnimInstance::RFootLockAlpha' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, PelvisIKTransform) == 0x000650, "Member 'UREnemyAnimInstance::PelvisIKTransform' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, PelvisOffsetMultiplier) == 0x0006B0, "Member 'UREnemyAnimInstance::PelvisOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, HeadIKTarget) == 0x0006B8, "Member 'UREnemyAnimInstance::HeadIKTarget' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, HeadIKRotation) == 0x0006D0, "Member 'UREnemyAnimInstance::HeadIKRotation' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, CombatTargetTransform) == 0x0006F0, "Member 'UREnemyAnimInstance::CombatTargetTransform' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, TargetActor) == 0x000750, "Member 'UREnemyAnimInstance::TargetActor' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, bHasTarget) == 0x000758, "Member 'UREnemyAnimInstance::bHasTarget' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, LHandIKTransform) == 0x000760, "Member 'UREnemyAnimInstance::LHandIKTransform' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, LElbowLocation) == 0x0007C0, "Member 'UREnemyAnimInstance::LElbowLocation' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RHandIKTransform) == 0x0007E0, "Member 'UREnemyAnimInstance::RHandIKTransform' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, RElbowLocation) == 0x000840, "Member 'UREnemyAnimInstance::RElbowLocation' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, DiagonalScaleCurve) == 0x000858, "Member 'UREnemyAnimInstance::DiagonalScaleCurve' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, StrideBlendCurve) == 0x000860, "Member 'UREnemyAnimInstance::StrideBlendCurve' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, YawOffsetFB) == 0x000868, "Member 'UREnemyAnimInstance::YawOffsetFB' has a wrong offset!");
static_assert(offsetof(UREnemyAnimInstance, YawOffsetLR) == 0x000870, "Member 'UREnemyAnimInstance::YawOffsetLR' has a wrong offset!");

// Class RGame.REnemyPawnBase
// 0x05E8 (0x4DD0 - 0x47E8)
class AREnemyPawnBase : public ARNPCPawnBase
{
public:
	uint8                                         Pad_47E8[0x10];                                    // 0x47E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardComponent*                   MyBlackboard;                                      // 0x47F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRAISettings                           InitializedAISettings;                             // 0x4800(0x0068)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_4868[0x2C];                                    // 0x4868(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StunStacks;                                        // 0x4894(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedGlobalAnimRateScale;                         // 0x4898(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489C[0x4C];                                    // 0x489C(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRAISettings                           OverriddenAISettings;                              // 0x48E8(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class URAIDataSettings*                       AISettings;                                        // 0x4950(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIState                                      AIState;                                           // 0x4958(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsElite;                                          // 0x4959(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStrafeWhilstAttacking;                      // 0x495A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanDodge;                                         // 0x495B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnedByOtherAI;                                 // 0x495C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterOnBeginPlay;                              // 0x495D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_495E[0x2];                                     // 0x495E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class URGEnemyMutatorScript>> EnemyMutators;                                  // 0x4960(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         MaxHealthPerEnemyMutator;                          // 0x4970(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugActivateMutatorsOnBeginPlay;                 // 0x4974(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4975[0x3];                                     // 0x4975(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         AttackSpeedMultiplier;                             // 0x4978(0x0128)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRAIAttackSettings>             AttackScripts;                                     // 0x4AA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsFriendly;                                       // 0x4AB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGhost;                                          // 0x4AB1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AB2[0x2];                                     // 0x4AB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitCombatRange;                                   // 0x4AB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowJumping;                                     // 0x4AB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AB9[0x3];                                     // 0x4AB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxJumpDistance;                                   // 0x4ABC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangedHomingMultiplier;                            // 0x4AC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RangedFireFromBone;                                // 0x4AC4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomSpreadMinMaxDegreePitch;                     // 0x4ACC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomSpreadMinMaxDegreeYaw;                       // 0x4AD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtraProjectileSpreadMinMaxDegreePitch;            // 0x4AD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtraProjectileSpreadMinMaxDegreeYaw;              // 0x4AD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EvaluateThreatTargetsDelay;                        // 0x4ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThreatEvaluationRange;                             // 0x4AE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThreatRangeMaxMultiplier;                          // 0x4AE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStunImmunity;                                     // 0x4AE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreezeImmunity;                                   // 0x4AE9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AEA[0x2];                                     // 0x4AEA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunStacksCooldown;                                // 0x4AEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunReductionMultiplier;                           // 0x4AF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunDurationMultiplier;                            // 0x4AF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExecutionHealthThreshold;                          // 0x4AF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AFC[0x1];                                     // 0x4AFC(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldSpawnResources;                             // 0x4AFD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAICombatPathingType                          FlyingPreFrozenPathingType;                        // 0x4AFE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AFF[0x1];                                     // 0x4AFF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableInteger                       HealthDropChance;                                  // 0x4B00(0x0120)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   CachedLineOfSightBone;                             // 0x4C20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FlyingCollisionExceptions;                         // 0x4C28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C2C[0x4];                                     // 0x4C2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CharacterMontage;                                  // 0x4C30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          SpawnAnimation;                                    // 0x4C38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoldToDrop;                                        // 0x4C40(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLarge;                                          // 0x4C44(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C45[0x3];                                     // 0x4C45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ARPawnBase*                             CurrentCombatTarget;                               // 0x4C48(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentCombatTargetLocked;                        // 0x4C50(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnLandedAnimationBlocked;                         // 0x4C51(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C52[0x6];                                     // 0x4C52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         CooldownReductionMultiplier;                       // 0x4C58(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ExtraAttacksToPerform;                             // 0x4D80(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraProjectilesToFire;                            // 0x4D84(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpCurve;                                         // 0x4D88(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AREnemyPawnBase* Enemy)> OnEnemyPawnKilled;                  // 0x4D90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AREnemyPawnBase* Enemy, class AActor* HitActor, class ARProjectileBase* ProjectileActor)> OnEnemyProjectileHit; // 0x4DA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<class AActor*>& HitActors, class AREnemyPawnBase* Enemy, const struct FVector& Location, float AttackRadius)> OnEnemyAreaAttack; // 0x4DB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARProjectileBase* Projectile)> OnEnemyProjectileSpawned;     // 0x4DC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ActivateMutators();
	void AddAndActivateMutator(TSubclassOf<class URGEnemyMutatorScript> NewMutator);
	void AddFlyingCollisionException();
	void AddMutator(TSubclassOf<class URGEnemyMutatorScript> NewMutator);
	bool CheckValidMontageSection(class UAnimMontage* Montage, class FName Section);
	void CurrentCombatTarget_OnRep();
	void DoSpecial();
	void EnterCombat(class AController* Target);
	void EnterSearchingState(class APlayerController* PreDeterminedTarget);
	TArray<class ARProjectileBase*> FireProjectileAtTarget(TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FVector& FireFromLocation, const struct FRotator& RotatorOffset, float Damage, float ProjectileLifeSpan, struct FVector* OutTargetLocation, struct FRotator* OutTargetRotation, class AActor* CustomTarget, const struct FVector& CustomTargetLocation, bool bUseRandomSpread, bool bUsePrediction);
	void FrozenReset_Multicast();
	struct FRAISettings GetAISettings();
	EAIState GetAIState();
	struct FRMutableFloat GetAttackSpeedModifier();
	class FName GetCachedLineOfSightBone();
	class ARPawnBase* GetCurrentCombatTarget();
	class UAnimMontage* GetDefaultCharacterMontage();
	bool GetIsCurrentlyCCd();
	bool GetIsCurrentlyFrozen();
	bool GetIsElite();
	bool GetIsFlying();
	bool GetIsFriendly();
	bool GetIsGhost();
	TArray<TSubclassOf<class URGEnemyMutatorScript>> GetMutators();
	class URGEnemyAttackScript* GetRandomUsableAttack(bool bSkipLimitations);
	struct FVector GetRangedTargetLocation();
	bool HasLoS(bool bDebugDraw, class AActor* CustomTarget);
	bool HasUsableAttack();
	bool IsBelowExecutionHealthThreshold(const float ThresholdModifier);
	void OnCurrentEnemyTargetKilled(class AREnemyPawnBase* Enemy);
	void OnCurrentPlayerTargetKilled(class ARPlayerPawn* Player);
	void OnCurrentTargetDowned(class ARPlayerPawn* Player);
	void OnJumped_Multicast();
	void OnKnockbacked();
	void OnKnockbackEnded();
	void OnLandedOnGround();
	void OverrideAISettings(const struct FRAISettings& NewAISettings);
	TArray<class AActor*> PerformAreaAttack(const TArray<class AActor*>& IgnoredActors, const struct FVector& TargetLocation, float Damage, float AttackRadius, int32 DamageSources);
	TArray<class AActor*> PerformConeAttack(const TArray<class AActor*>& IgnoredActors, const struct FVector& TargetLocation, const struct FVector& TargetDirection, float Damage, float AttackRadius, float AttackHalfAngle, int32 DamageSources);
	void PerformDodge_Multicast(float Direction);
	void PlayMontage_Multicast(class UAnimMontage* Montage, class FName Section);
	void ReceiveDoSpecial();
	void ReceiveOnEnterCombat();
	void ReceiveOnSilenceStarted();
	void ReceiveOnSilenceStopped();
	void RemoveFlyingCollisionException();
	void SetAIFrozen(float freezeDuration);
	void SetAIRooted(float rootDuration);
	void SetAISilenced(float silenceDuration);
	void SetAIState(EAIState NewState);
	void SetAIStunned(float stunDuration, float* actualStunDuration, bool bShorterDurationOverrides, bool bIgnoreStunImmunity);
	void SetAllAttacksBlocked(bool bNewValue);
	void SetCachedLineOfSightBonee(const class FName NewCachedLineOfSightBone);
	void SetCCImmune(bool bNewValue);
	void SetCurrentCombatTarget(class APawn* NewTarget);
	void SetCurrentCombatTargetLocked(bool bNewLock);
	void SetForcedSpawnMovementLocation(const struct FVector& ForcedSpawnMovementLocation);
	void SetIsElite(bool bNewIsElite);
	void SetIsFriendly(bool bNewFriendlyStatus, float FriendlyEnemyDamageMultiplier);
	void SetIsGhost(bool bNewGhostStatus);
	void SetMaxSpeed_Multicast(float NewMaxSpeed);
	void SetMutators(const TArray<TSubclassOf<class URGEnemyMutatorScript>>& NewMutators);
	void SetOnLandedAnimationBlocked(bool bNewBlock);
	void SetRuntimePhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit);
	void SetSpawnedByAI(bool bNewSpawnedByOtherAI);
	void SetStunImmune(bool bNewValue);
	void SetupLocationChecker(class AREnemySpawnAreaSegment* Segment);
	void StartFlying();
	void StartJump_Multicast(const struct FVector& TargetLocation);
	void StartLerp_Multicast(const struct FVector& TargetLocation);
	void StopFlying();
	bool ValidateResourceCondition(class URGEnemyAttackScript* Script);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemyPawnBase">();
	}
	static class AREnemyPawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemyPawnBase>();
	}
};
static_assert(alignof(AREnemyPawnBase) == 0x000008, "Wrong alignment on AREnemyPawnBase");
static_assert(sizeof(AREnemyPawnBase) == 0x004DD0, "Wrong size on AREnemyPawnBase");
static_assert(offsetof(AREnemyPawnBase, MyBlackboard) == 0x0047F8, "Member 'AREnemyPawnBase::MyBlackboard' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, InitializedAISettings) == 0x004800, "Member 'AREnemyPawnBase::InitializedAISettings' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, StunStacks) == 0x004894, "Member 'AREnemyPawnBase::StunStacks' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, CachedGlobalAnimRateScale) == 0x004898, "Member 'AREnemyPawnBase::CachedGlobalAnimRateScale' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, OverriddenAISettings) == 0x0048E8, "Member 'AREnemyPawnBase::OverriddenAISettings' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, AISettings) == 0x004950, "Member 'AREnemyPawnBase::AISettings' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, AIState) == 0x004958, "Member 'AREnemyPawnBase::AIState' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bIsElite) == 0x004959, "Member 'AREnemyPawnBase::bIsElite' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bShouldStrafeWhilstAttacking) == 0x00495A, "Member 'AREnemyPawnBase::bShouldStrafeWhilstAttacking' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bCanDodge) == 0x00495B, "Member 'AREnemyPawnBase::bCanDodge' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bSpawnedByOtherAI) == 0x00495C, "Member 'AREnemyPawnBase::bSpawnedByOtherAI' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bRegisterOnBeginPlay) == 0x00495D, "Member 'AREnemyPawnBase::bRegisterOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, EnemyMutators) == 0x004960, "Member 'AREnemyPawnBase::EnemyMutators' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, MaxHealthPerEnemyMutator) == 0x004970, "Member 'AREnemyPawnBase::MaxHealthPerEnemyMutator' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bDebugActivateMutatorsOnBeginPlay) == 0x004974, "Member 'AREnemyPawnBase::bDebugActivateMutatorsOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, AttackSpeedMultiplier) == 0x004978, "Member 'AREnemyPawnBase::AttackSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, AttackScripts) == 0x004AA0, "Member 'AREnemyPawnBase::AttackScripts' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bIsFriendly) == 0x004AB0, "Member 'AREnemyPawnBase::bIsFriendly' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bIsGhost) == 0x004AB1, "Member 'AREnemyPawnBase::bIsGhost' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, InitCombatRange) == 0x004AB4, "Member 'AREnemyPawnBase::InitCombatRange' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bAllowJumping) == 0x004AB8, "Member 'AREnemyPawnBase::bAllowJumping' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, MaxJumpDistance) == 0x004ABC, "Member 'AREnemyPawnBase::MaxJumpDistance' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, RangedHomingMultiplier) == 0x004AC0, "Member 'AREnemyPawnBase::RangedHomingMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, RangedFireFromBone) == 0x004AC4, "Member 'AREnemyPawnBase::RangedFireFromBone' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, RandomSpreadMinMaxDegreePitch) == 0x004ACC, "Member 'AREnemyPawnBase::RandomSpreadMinMaxDegreePitch' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, RandomSpreadMinMaxDegreeYaw) == 0x004AD0, "Member 'AREnemyPawnBase::RandomSpreadMinMaxDegreeYaw' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ExtraProjectileSpreadMinMaxDegreePitch) == 0x004AD4, "Member 'AREnemyPawnBase::ExtraProjectileSpreadMinMaxDegreePitch' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ExtraProjectileSpreadMinMaxDegreeYaw) == 0x004AD8, "Member 'AREnemyPawnBase::ExtraProjectileSpreadMinMaxDegreeYaw' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, EvaluateThreatTargetsDelay) == 0x004ADC, "Member 'AREnemyPawnBase::EvaluateThreatTargetsDelay' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ThreatEvaluationRange) == 0x004AE0, "Member 'AREnemyPawnBase::ThreatEvaluationRange' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ThreatRangeMaxMultiplier) == 0x004AE4, "Member 'AREnemyPawnBase::ThreatRangeMaxMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bStunImmunity) == 0x004AE8, "Member 'AREnemyPawnBase::bStunImmunity' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bFreezeImmunity) == 0x004AE9, "Member 'AREnemyPawnBase::bFreezeImmunity' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, StunStacksCooldown) == 0x004AEC, "Member 'AREnemyPawnBase::StunStacksCooldown' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, StunReductionMultiplier) == 0x004AF0, "Member 'AREnemyPawnBase::StunReductionMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, StunDurationMultiplier) == 0x004AF4, "Member 'AREnemyPawnBase::StunDurationMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ExecutionHealthThreshold) == 0x004AF8, "Member 'AREnemyPawnBase::ExecutionHealthThreshold' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bShouldSpawnResources) == 0x004AFD, "Member 'AREnemyPawnBase::bShouldSpawnResources' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, FlyingPreFrozenPathingType) == 0x004AFE, "Member 'AREnemyPawnBase::FlyingPreFrozenPathingType' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, HealthDropChance) == 0x004B00, "Member 'AREnemyPawnBase::HealthDropChance' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, CachedLineOfSightBone) == 0x004C20, "Member 'AREnemyPawnBase::CachedLineOfSightBone' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, FlyingCollisionExceptions) == 0x004C28, "Member 'AREnemyPawnBase::FlyingCollisionExceptions' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, CharacterMontage) == 0x004C30, "Member 'AREnemyPawnBase::CharacterMontage' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, SpawnAnimation) == 0x004C38, "Member 'AREnemyPawnBase::SpawnAnimation' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, GoldToDrop) == 0x004C40, "Member 'AREnemyPawnBase::GoldToDrop' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bIsLarge) == 0x004C44, "Member 'AREnemyPawnBase::bIsLarge' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, CurrentCombatTarget) == 0x004C48, "Member 'AREnemyPawnBase::CurrentCombatTarget' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bCurrentCombatTargetLocked) == 0x004C50, "Member 'AREnemyPawnBase::bCurrentCombatTargetLocked' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, bOnLandedAnimationBlocked) == 0x004C51, "Member 'AREnemyPawnBase::bOnLandedAnimationBlocked' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, CooldownReductionMultiplier) == 0x004C58, "Member 'AREnemyPawnBase::CooldownReductionMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ExtraAttacksToPerform) == 0x004D80, "Member 'AREnemyPawnBase::ExtraAttacksToPerform' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, ExtraProjectilesToFire) == 0x004D84, "Member 'AREnemyPawnBase::ExtraProjectilesToFire' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, JumpCurve) == 0x004D88, "Member 'AREnemyPawnBase::JumpCurve' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, OnEnemyPawnKilled) == 0x004D90, "Member 'AREnemyPawnBase::OnEnemyPawnKilled' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, OnEnemyProjectileHit) == 0x004DA0, "Member 'AREnemyPawnBase::OnEnemyProjectileHit' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, OnEnemyAreaAttack) == 0x004DB0, "Member 'AREnemyPawnBase::OnEnemyAreaAttack' has a wrong offset!");
static_assert(offsetof(AREnemyPawnBase, OnEnemyProjectileSpawned) == 0x004DC0, "Member 'AREnemyPawnBase::OnEnemyProjectileSpawned' has a wrong offset!");

// Class RGame.RProjectileBase
// 0x0310 (0x05B8 - 0x02A8)
class ARProjectileBase : public AActor
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpawnAtMuzzle;                                    // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisualInterpSpeed;                                 // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInterpolation;                              // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DataTag;                                           // 0x02C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileSpawnerType                        ProjectileSpawner;                                 // 0x02CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x1B];                                     // 0x02CD(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseProjectileMutators;                            // 0x02E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0xF];                                      // 0x02E9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ARWeapon>                OwningWeapon;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URProjectileBaseScript>  ProjectileScript;                                  // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProjectileName;                                    // 0x0328(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URGScriptComponent>      OwningScriptComponent;                             // 0x0330(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActive;                                           // 0x0338(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URProjectileMovementComponent*          ProjectileMovementComponent;                       // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             CachedHitResult;                                   // 0x0358(0x0100)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHitResult>                     CachedHitsInDetonation;                            // 0x0458(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FRMutableFloat                         BaseDamage;                                        // 0x0468(0x0128)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         BaseCriticalMultiplier;                            // 0x0590(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCriticalOverride;                               // 0x0594(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWeakspotOverride;                               // 0x0595(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_596[0x2];                                      // 0x0596(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseEffectiveRange;                                // 0x0598(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59C[0x1];                                      // 0x059C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBounceOnPawns;                                 // 0x059D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayNativeOverlapFX;                              // 0x059E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59F[0x1];                                      // 0x059F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PassThroughsRemaining;                             // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisablePiercing;                                  // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ARProjectileBase* Projectile)> OnProjectilePierce;           // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static void HitSequence(class URGScriptComponent* ROwningScriptComponent, const struct FHitResult& Hit, float Damage, int32 DamageSources, class ARProjectileBase* OptionalProjectile, bool bCriticalOverride, bool bCallHitEvents, bool bIgnoreClientAuthFlow, bool bDamageClientPrediction, bool bWeakspotOverride);

	void CacheHitResult(const struct FHitResult& Hit);
	void CacheHitResults(const TArray<struct FHitResult>& Hits);
	void DestroyProjectile();
	void DisableProjectile();
	void IgnoreCollisionWithActor(class AActor* Actor, bool bBlockTwoWay);
	void OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnProjectileHasBeenActivated();
	void OnRep_bActive();
	void OnRep_OwningWeapon();
	void ResetCollisionsToIgnore();
	void ResetIgnoreCollisionWithActor(class AActor* Actor, bool bResetTwoWay);
	void SetAvatarActor(class AActor* NewAvatarActor);
	void SetBaseCriticalMultiplier(float newBaseCriticalMultiplier);
	void SetBaseDamage(float newBaseDamage);
	void SetBaseEffectiveRange(float newBaseEffectiveRange);
	void SetProjectileSpawnerType(EProjectileSpawnerType NewType);
	void SetVisualStartLocation(const struct FVector& WorldLocation);

	class AActor* GetAvatarActor() const;
	const struct FHitResult GetCachedHitResult() const;
	float GetOnHitDamage(bool* bWasCritical) const;
	float GetOnHitDamageWithMultipliers(bool* bWasCritical) const;
	class URGScriptComponent* GetOwningGScriptComponent() const;
	class ARPawnBase* GetOwningPawn() const;
	class FName GetProjectileName() const;
	class URProjectileBaseScript* GetProjectileScript() const;
	EProjectileSpawnerType GetProjectileSpawnerType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RProjectileBase">();
	}
	static class ARProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARProjectileBase>();
	}
};
static_assert(alignof(ARProjectileBase) == 0x000008, "Wrong alignment on ARProjectileBase");
static_assert(sizeof(ARProjectileBase) == 0x0005B8, "Wrong size on ARProjectileBase");
static_assert(offsetof(ARProjectileBase, bSpawnAtMuzzle) == 0x0002B8, "Member 'ARProjectileBase::bSpawnAtMuzzle' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, VisualInterpSpeed) == 0x0002BC, "Member 'ARProjectileBase::VisualInterpSpeed' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bIgnoreInterpolation) == 0x0002C0, "Member 'ARProjectileBase::bIgnoreInterpolation' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, DataTag) == 0x0002C4, "Member 'ARProjectileBase::DataTag' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, ProjectileSpawner) == 0x0002CC, "Member 'ARProjectileBase::ProjectileSpawner' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bUseProjectileMutators) == 0x0002E8, "Member 'ARProjectileBase::bUseProjectileMutators' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, OwningWeapon) == 0x0002F8, "Member 'ARProjectileBase::OwningWeapon' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, ProjectileScript) == 0x000300, "Member 'ARProjectileBase::ProjectileScript' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, ProjectileName) == 0x000328, "Member 'ARProjectileBase::ProjectileName' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, OwningScriptComponent) == 0x000330, "Member 'ARProjectileBase::OwningScriptComponent' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bActive) == 0x000338, "Member 'ARProjectileBase::bActive' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, SphereComponent) == 0x000340, "Member 'ARProjectileBase::SphereComponent' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, StaticMeshComponent) == 0x000348, "Member 'ARProjectileBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, ProjectileMovementComponent) == 0x000350, "Member 'ARProjectileBase::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, CachedHitResult) == 0x000358, "Member 'ARProjectileBase::CachedHitResult' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, CachedHitsInDetonation) == 0x000458, "Member 'ARProjectileBase::CachedHitsInDetonation' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, BaseDamage) == 0x000468, "Member 'ARProjectileBase::BaseDamage' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, BaseCriticalMultiplier) == 0x000590, "Member 'ARProjectileBase::BaseCriticalMultiplier' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bIsCriticalOverride) == 0x000594, "Member 'ARProjectileBase::bIsCriticalOverride' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bIsWeakspotOverride) == 0x000595, "Member 'ARProjectileBase::bIsWeakspotOverride' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, BaseEffectiveRange) == 0x000598, "Member 'ARProjectileBase::BaseEffectiveRange' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bCanBounceOnPawns) == 0x00059D, "Member 'ARProjectileBase::bCanBounceOnPawns' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bPlayNativeOverlapFX) == 0x00059E, "Member 'ARProjectileBase::bPlayNativeOverlapFX' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, PassThroughsRemaining) == 0x0005A0, "Member 'ARProjectileBase::PassThroughsRemaining' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, bDisablePiercing) == 0x0005A4, "Member 'ARProjectileBase::bDisablePiercing' has a wrong offset!");
static_assert(offsetof(ARProjectileBase, OnProjectilePierce) == 0x0005A8, "Member 'ARProjectileBase::OnProjectilePierce' has a wrong offset!");

// Class RGame.RProjectile
// 0x0020 (0x05D8 - 0x05B8)
class ARProjectile : public ARProjectileBase
{
public:
	int32                                         BouncesRemaining;                                  // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDummy;                                          // 0x05BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URGProjectileScript>        ProjectileClass;                                   // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnProjectileBounced;                               // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void PredictProjectileMovementCurve(const class UObject* WorldContextObject, TSubclassOf<class ARProjectile> InProjectileClass, TArray<struct FProjectileSimulationResult>* outResults, struct FVector* outImpactLocation, const struct FVector& StartLocation, const struct FRotator& StartRotation, float iterationTime, int32 MaxIterations);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RProjectile">();
	}
	static class ARProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARProjectile>();
	}
};
static_assert(alignof(ARProjectile) == 0x000008, "Wrong alignment on ARProjectile");
static_assert(sizeof(ARProjectile) == 0x0005D8, "Wrong size on ARProjectile");
static_assert(offsetof(ARProjectile, BouncesRemaining) == 0x0005B8, "Member 'ARProjectile::BouncesRemaining' has a wrong offset!");
static_assert(offsetof(ARProjectile, bIsDummy) == 0x0005BC, "Member 'ARProjectile::bIsDummy' has a wrong offset!");
static_assert(offsetof(ARProjectile, ProjectileClass) == 0x0005C0, "Member 'ARProjectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(ARProjectile, OnProjectileBounced) == 0x0005C8, "Member 'ARProjectile::OnProjectileBounced' has a wrong offset!");

// Class RGame.REnemyProjectile
// 0x0000 (0x05D8 - 0x05D8)
class AREnemyProjectile final : public ARProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemyProjectile">();
	}
	static class AREnemyProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemyProjectile>();
	}
};
static_assert(alignof(AREnemyProjectile) == 0x000008, "Wrong alignment on AREnemyProjectile");
static_assert(sizeof(AREnemyProjectile) == 0x0005D8, "Wrong size on AREnemyProjectile");

// Class RGame.REnemyResourceManager
// 0x0068 (0x0310 - 0x02A8)
class AREnemyResourceManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUpdateExecutableEnemies;                         // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         EnemyAttackResourceMultiplier;                     // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EnemyAttackResourceRegenMultiplier;                // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPylonActor>                    PylonActors;                                       // 0x02D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AREnemyResourceManager* GetEnemyResourceManager(const class UObject* WorldContextObject);

	bool AttackGroupHasEnoughResources(const struct FGameplayTag& AttackGroupTag, float Cost);
	struct FPylonActor GetClosestPylonActorToLocation(const struct FVector& Location, float MaxDistance);
	TArray<class ARNPCPawnBase*> GetExecutableEnemies();
	void OnRunStarted();
	void RegenAttackGroups();
	void RegisterExecutableEnemy(class ARNPCPawnBase* Enemy);
	void RegisterPylonActor(class AActor* PylonActorToRegister, float Radius);
	void UnregisterExecutableEnemy(class ARNPCPawnBase* Enemy);
	void UnregisterPylonActor(class AActor* PylonActorToUnRegister);
	void UseAttackGroupResources(const struct FGameplayTag& AttackGroupTag, float Cost);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemyResourceManager">();
	}
	static class AREnemyResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemyResourceManager>();
	}
};
static_assert(alignof(AREnemyResourceManager) == 0x000008, "Wrong alignment on AREnemyResourceManager");
static_assert(sizeof(AREnemyResourceManager) == 0x000310, "Wrong size on AREnemyResourceManager");
static_assert(offsetof(AREnemyResourceManager, OnUpdateExecutableEnemies) == 0x0002C0, "Member 'AREnemyResourceManager::OnUpdateExecutableEnemies' has a wrong offset!");
static_assert(offsetof(AREnemyResourceManager, EnemyAttackResourceMultiplier) == 0x0002D0, "Member 'AREnemyResourceManager::EnemyAttackResourceMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyResourceManager, EnemyAttackResourceRegenMultiplier) == 0x0002D4, "Member 'AREnemyResourceManager::EnemyAttackResourceRegenMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemyResourceManager, PylonActors) == 0x0002D8, "Member 'AREnemyResourceManager::PylonActors' has a wrong offset!");

// Class RGame.REnemySpawnArea
// 0x0028 (0x02D0 - 0x02A8)
class AREnemySpawnArea final : public AActor
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    MoveToLocation;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComponent;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDynamic;                                        // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpawnHandmade;                                 // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMove;                                        // 0x02CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLaunch;                                      // 0x02CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemySpawnArea">();
	}
	static class AREnemySpawnArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemySpawnArea>();
	}
};
static_assert(alignof(AREnemySpawnArea) == 0x000008, "Wrong alignment on AREnemySpawnArea");
static_assert(sizeof(AREnemySpawnArea) == 0x0002D0, "Wrong size on AREnemySpawnArea");
static_assert(offsetof(AREnemySpawnArea, MoveToLocation) == 0x0002B8, "Member 'AREnemySpawnArea::MoveToLocation' has a wrong offset!");
static_assert(offsetof(AREnemySpawnArea, BoxComponent) == 0x0002C0, "Member 'AREnemySpawnArea::BoxComponent' has a wrong offset!");
static_assert(offsetof(AREnemySpawnArea, bIsDynamic) == 0x0002C8, "Member 'AREnemySpawnArea::bIsDynamic' has a wrong offset!");
static_assert(offsetof(AREnemySpawnArea, bCanSpawnHandmade) == 0x0002C9, "Member 'AREnemySpawnArea::bCanSpawnHandmade' has a wrong offset!");
static_assert(offsetof(AREnemySpawnArea, bForceMove) == 0x0002CA, "Member 'AREnemySpawnArea::bForceMove' has a wrong offset!");
static_assert(offsetof(AREnemySpawnArea, bForceLaunch) == 0x0002CB, "Member 'AREnemySpawnArea::bForceLaunch' has a wrong offset!");

// Class RGame.REnemySpawnAreaSegment
// 0x01A8 (0x0450 - 0x02A8)
class AREnemySpawnAreaSegment final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AREnemySpawnArea>        CurrentSpawnAreaInUse;                             // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x2A];                                     // 0x02B8(0x002A)(Fixing Size After Last Property [ Dumper-7 ])
	ERoomObjectiveType                            RoomObjectiveType;                                 // 0x02E2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E3[0x5];                                      // 0x02E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ARObjectiveManager*                     CachedObjectiveManager;                            // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x1C];                                     // 0x02F0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIndex;                                        // 0x030C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDMActorProximityBoxComponent*          ActorProximityBoxComponent;                        // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnemySpawningType                            EnemySpawningType;                                 // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRSegmentSettings>              SpawnSettings;                                     // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bActivateOnOverlap;                                // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivateOnStart;                                  // 0x0339(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33A[0x6];                                      // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ARDoor*                                 EntryDoor;                                         // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARDoor*                                 ExitDoor;                                          // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenPriorities;                            // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AREnemySpawnAreaSegment> SegmentToStartOnCompletion;                        // 0x0354(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceForDynamicSpawning;                     // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeOverriden;                                   // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideEnemyLimits;                              // 0x0361(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0x6];                                      // 0x0362(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OverridenEnemyAmountLimits;                        // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugMaxAmount;                                    // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bActivated;                                        // 0x0380(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0381(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBossSegment;                                    // 0x0382(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnedBonusEnemy;                             // 0x0383(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRSegmentObjectiveSettings             SegmentObjectiveSettings;                          // 0x0388(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class URGObjectiveScript*                     SegmentObjectiveScript;                            // 0x03C0(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ARNPCPawnBase>>   SpawnedEnemies;                                    // 0x03C8(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ARNPCPawnBase>>   SpawnedElites;                                     // 0x03D8(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ObjectiveTag;                                      // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AssociatedDoorIndicatorActor;                      // 0x0410(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FixedEnemyLootSpawnPosition;                       // 0x0418(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         RoomObjectiveObjects;                              // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARPlayerPawn*>                   PlayersInSegment;                                  // 0x0430(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSegmentObjectiveSet;                             // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddCurrentSpawnAreaSegment_Multicast();
	void ForceCompleteSegment();
	bool GetAllEnemiesDefeated();
	TArray<class ARNPCPawnBase*> GetEnemies();
	TArray<class APlayerController*> GetPlayersInArea();
	bool HasSegmentObjectiveEnded();
	void OnActorEnterArea(class AActor* OtherActor);
	void OnEntryDoorFinishedClosing();
	void OnFinishRun(bool RunFailed);
	void OnNextLevelsFinishedShowing();
	void OnPreLevelChanged();
	void OnStarted_Multicast();
	void SpawnRoomObjectiveEnemyWave(int32 WaveSizeOverride);
	void StartSegment(class AActor* OtherActor);
	void StopSpawning();

	ERoomObjectiveType GetRoomObjectiveType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemySpawnAreaSegment">();
	}
	static class AREnemySpawnAreaSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemySpawnAreaSegment>();
	}
};
static_assert(alignof(AREnemySpawnAreaSegment) == 0x000008, "Wrong alignment on AREnemySpawnAreaSegment");
static_assert(sizeof(AREnemySpawnAreaSegment) == 0x000450, "Wrong size on AREnemySpawnAreaSegment");
static_assert(offsetof(AREnemySpawnAreaSegment, CurrentSpawnAreaInUse) == 0x0002B0, "Member 'AREnemySpawnAreaSegment::CurrentSpawnAreaInUse' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, RoomObjectiveType) == 0x0002E2, "Member 'AREnemySpawnAreaSegment::RoomObjectiveType' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, CachedObjectiveManager) == 0x0002E8, "Member 'AREnemySpawnAreaSegment::CachedObjectiveManager' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, LevelIndex) == 0x00030C, "Member 'AREnemySpawnAreaSegment::LevelIndex' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, ActorProximityBoxComponent) == 0x000318, "Member 'AREnemySpawnAreaSegment::ActorProximityBoxComponent' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, EnemySpawningType) == 0x000320, "Member 'AREnemySpawnAreaSegment::EnemySpawningType' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, SpawnSettings) == 0x000328, "Member 'AREnemySpawnAreaSegment::SpawnSettings' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bActivateOnOverlap) == 0x000338, "Member 'AREnemySpawnAreaSegment::bActivateOnOverlap' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bActivateOnStart) == 0x000339, "Member 'AREnemySpawnAreaSegment::bActivateOnStart' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, EntryDoor) == 0x000340, "Member 'AREnemySpawnAreaSegment::EntryDoor' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, ExitDoor) == 0x000348, "Member 'AREnemySpawnAreaSegment::ExitDoor' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, DelayBetweenPriorities) == 0x000350, "Member 'AREnemySpawnAreaSegment::DelayBetweenPriorities' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, SegmentToStartOnCompletion) == 0x000354, "Member 'AREnemySpawnAreaSegment::SegmentToStartOnCompletion' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, MinDistanceForDynamicSpawning) == 0x00035C, "Member 'AREnemySpawnAreaSegment::MinDistanceForDynamicSpawning' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bCanBeOverriden) == 0x000360, "Member 'AREnemySpawnAreaSegment::bCanBeOverriden' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bOverrideEnemyLimits) == 0x000361, "Member 'AREnemySpawnAreaSegment::bOverrideEnemyLimits' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, OverridenEnemyAmountLimits) == 0x000368, "Member 'AREnemySpawnAreaSegment::OverridenEnemyAmountLimits' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, DebugMaxAmount) == 0x000378, "Member 'AREnemySpawnAreaSegment::DebugMaxAmount' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bActivated) == 0x000380, "Member 'AREnemySpawnAreaSegment::bActivated' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bCompleted) == 0x000381, "Member 'AREnemySpawnAreaSegment::bCompleted' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bIsBossSegment) == 0x000382, "Member 'AREnemySpawnAreaSegment::bIsBossSegment' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, bHasSpawnedBonusEnemy) == 0x000383, "Member 'AREnemySpawnAreaSegment::bHasSpawnedBonusEnemy' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, SegmentObjectiveSettings) == 0x000388, "Member 'AREnemySpawnAreaSegment::SegmentObjectiveSettings' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, SegmentObjectiveScript) == 0x0003C0, "Member 'AREnemySpawnAreaSegment::SegmentObjectiveScript' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, SpawnedEnemies) == 0x0003C8, "Member 'AREnemySpawnAreaSegment::SpawnedEnemies' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, SpawnedElites) == 0x0003D8, "Member 'AREnemySpawnAreaSegment::SpawnedElites' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, ObjectiveTag) == 0x0003F8, "Member 'AREnemySpawnAreaSegment::ObjectiveTag' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, AssociatedDoorIndicatorActor) == 0x000410, "Member 'AREnemySpawnAreaSegment::AssociatedDoorIndicatorActor' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, FixedEnemyLootSpawnPosition) == 0x000418, "Member 'AREnemySpawnAreaSegment::FixedEnemyLootSpawnPosition' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, RoomObjectiveObjects) == 0x000420, "Member 'AREnemySpawnAreaSegment::RoomObjectiveObjects' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, PlayersInSegment) == 0x000430, "Member 'AREnemySpawnAreaSegment::PlayersInSegment' has a wrong offset!");
static_assert(offsetof(AREnemySpawnAreaSegment, OnSegmentObjectiveSet) == 0x000440, "Member 'AREnemySpawnAreaSegment::OnSegmentObjectiveSet' has a wrong offset!");

// Class RGame.REnemySpawnDecoy
// 0x0000 (0x0328 - 0x0328)
class AREnemySpawnDecoy : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemySpawnDecoy">();
	}
	static class AREnemySpawnDecoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemySpawnDecoy>();
	}
};
static_assert(alignof(AREnemySpawnDecoy) == 0x000008, "Wrong alignment on AREnemySpawnDecoy");
static_assert(sizeof(AREnemySpawnDecoy) == 0x000328, "Wrong size on AREnemySpawnDecoy");

// Class RGame.REnemySpawnManager
// 0x02E0 (0x0588 - 0x02A8)
class AREnemySpawnManager : public AActor
{
public:
	float                                         DifficultlyLevelMultiplier;                        // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x14];                                     // 0x02AC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AREnemySpawnAreaSegment>> CurrentSpawnAreaSegments;                  // 0x02C0(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x110];                                    // 0x02D0(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ARNPCPawnBase>>   PostRegisteredEnemies;                             // 0x03E0(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          GloballySpawnedTargets;                            // 0x03F0(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         EnemyMutatorRetryAttempts;                         // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SpawnDelayDuration;                                // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToSpawnHandmade;                             // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MaxSpawningPlayerMultiplier;                       // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyAmountPlayerMultiplier;                       // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyAmountDifficultyMultiplier;                   // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDifficulty;                                    // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             EnemyInfoDT;                                       // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultRoomObjectiveWaveSize;                      // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomObjectiveFillerSpawningInterval;               // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomObjectiveWaveSpawningInterval;                 // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAllEnemiesDefeated;                              // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllSegmentsCompleted;                            // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 NewValue)> OnAliveEnemiesNumUpdated;                         // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARNPCPawnBase* EnemyPawn)> OnEnemyKilled;                    // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEliteEnemySpawned;                               // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEliteEnemyKilled;                                // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)> OnSegmentCompleted; // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment)> OnSegmentStarted; // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFirstSegmentInNodeStarted;                       // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLastSegmentInNodeCompleted;                      // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AREnemySpawnAreaSegment*>        EnemySpawnAreaSegmentsInNode;                      // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment, class ARPlayerPawn* EnteringPlayerPawn)> OnPlayerEnterSpawnAreaSegment; // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DifficultyMultiplierOverride;                      // 0x0510(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRSpawnDataModifierEntry               EnemySpawnDataModifiers;                           // 0x0518(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARNPCPawnBase* EnemyPawn)> OnEnemySpawned;                   // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void AddToGloballySpawnedTargets(class AActor* ActorToAdd);
	static class AREnemySpawnManager* GetSpawnManager(const class UObject* WorldContextObject);
	static void RemoveFromGloballySpawnedTargets(class AActor* ActorToRemove);

	bool AllSegmentsInCurrentNodeCompleted();
	bool AllSegmentsInCurrentRoomCompleted();
	bool AnySegmentInCurrentNodeCompleted();
	void BroadcastOnCurrentSegmentsCompleted();
	void BroadcastOnEliteEnemyKilled();
	void BroadcastOnEliteEnemySpawned();
	void BroadcastOnEnemyKilled_Multicast(class ARNPCPawnBase* EnemyPawn);
	int32 GetCurrentAliveEnemies(bool bIncludePostRegisteredEnemies);
	class AREnemySpawnAreaSegment* GetCurrentSpawnAreaSegment();
	TArray<class AREnemySpawnAreaSegment*> GetCurrentSpawnAreaSegments();
	struct FREnemyMutatorSet GetEnemyMutatorSetByEnemyMutatorClass(TSubclassOf<class URGEnemyMutatorScript> EnemyMutatorClass);
	TArray<struct FREnemyMutatorSet> GetRandomEnemyMutatorSets(int32 NumMutatorSets);
	TArray<struct FREnemyMutatorSet> GetRandomUsableMutatorSetsForEnemy(class AREnemyPawnBase* Enemy, const int32 NumMutatorSets);
	struct FVector GetRandomValidLocationInBoundingSpawnArea(class AREnemySpawnArea* SpawnArea, class UBoxComponent* SpawnAreaBox, int32 CurrentAttempts, int32 FullRetryAttempts, TSubclassOf<class AREnemyPawnBase> EnemyToSpawn, bool bAllowFailsafeCenterSpawn);
	int32 GetRemainingEnemies();
	int32 GetRemainingEnemiesToSpawn();
	void HandleSpawnFailure(const TArray<class AREnemySpawnAreaSegment*>& CurrentSegments, bool bIsElite);
	bool IsAnyEncounterActive();
	bool IsEnemyMutatorSetUsableForEnemy(const struct FREnemyMutatorSet& EnemyMutatorSet, class AREnemyPawnBase* Enemy);
	void OnEnemySpawnEffects_Multicast(const class UObject* WorldContextObject, class UClass* EnemyClass, float SpawnDuration, const struct FTransform& SpawnTransform);
	void OnFinalBossKilled();
	void OnFinishRun(bool RunFailed);
	void OnLastSegmentInNodeCompleted_Multicast();
	void OnPreLevelChanged();
	void ReceiveOnEnemySpawnPrimed(class UClass* EnemyClass, float SpawnDuration, const struct FTransform& SpawnTransform);
	void RegisterSpawnedEnemy(class ARNPCPawnBase* EnemyPawn);
	void SegmentCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void SegmentStarted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	bool StartSpawningEnemyWithEffects(class FName EnemySpawnTag, class AREnemySpawnArea* SpawnArea, TArray<TWeakObjectPtr<class ARNPCPawnBase>>* SpawnedEnemiesList, bool bIsElite, int32 RetryAttempts, bool bAllowFailsafeCenterSpawn);
	void TryForceSpawningEnemy(class FName EnemySpawnTag, class AREnemySpawnArea* SpawnArea, class AREnemySpawnAreaSegment* SpawnAreaSegment);
	void TryForceSpawningEnemyCurrentSegment(class FName EnemySpawnTag, const struct FVector& Location, float MaxDistanceForSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnemySpawnManager">();
	}
	static class AREnemySpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AREnemySpawnManager>();
	}
};
static_assert(alignof(AREnemySpawnManager) == 0x000008, "Wrong alignment on AREnemySpawnManager");
static_assert(sizeof(AREnemySpawnManager) == 0x000588, "Wrong size on AREnemySpawnManager");
static_assert(offsetof(AREnemySpawnManager, DifficultlyLevelMultiplier) == 0x0002A8, "Member 'AREnemySpawnManager::DifficultlyLevelMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, CurrentSpawnAreaSegments) == 0x0002C0, "Member 'AREnemySpawnManager::CurrentSpawnAreaSegments' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, PostRegisteredEnemies) == 0x0003E0, "Member 'AREnemySpawnManager::PostRegisteredEnemies' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, GloballySpawnedTargets) == 0x0003F0, "Member 'AREnemySpawnManager::GloballySpawnedTargets' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, EnemyMutatorRetryAttempts) == 0x000400, "Member 'AREnemySpawnManager::EnemyMutatorRetryAttempts' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, SpawnDelayDuration) == 0x000408, "Member 'AREnemySpawnManager::SpawnDelayDuration' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, ChanceToSpawnHandmade) == 0x000418, "Member 'AREnemySpawnManager::ChanceToSpawnHandmade' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, MaxSpawningPlayerMultiplier) == 0x000420, "Member 'AREnemySpawnManager::MaxSpawningPlayerMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, EnemyAmountPlayerMultiplier) == 0x000428, "Member 'AREnemySpawnManager::EnemyAmountPlayerMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, EnemyAmountDifficultyMultiplier) == 0x00042C, "Member 'AREnemySpawnManager::EnemyAmountDifficultyMultiplier' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, BaseDifficulty) == 0x000430, "Member 'AREnemySpawnManager::BaseDifficulty' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, EnemyInfoDT) == 0x000438, "Member 'AREnemySpawnManager::EnemyInfoDT' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, DefaultRoomObjectiveWaveSize) == 0x000440, "Member 'AREnemySpawnManager::DefaultRoomObjectiveWaveSize' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, RoomObjectiveFillerSpawningInterval) == 0x000444, "Member 'AREnemySpawnManager::RoomObjectiveFillerSpawningInterval' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, RoomObjectiveWaveSpawningInterval) == 0x000448, "Member 'AREnemySpawnManager::RoomObjectiveWaveSpawningInterval' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnAllEnemiesDefeated) == 0x000450, "Member 'AREnemySpawnManager::OnAllEnemiesDefeated' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnAllSegmentsCompleted) == 0x000460, "Member 'AREnemySpawnManager::OnAllSegmentsCompleted' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnAliveEnemiesNumUpdated) == 0x000470, "Member 'AREnemySpawnManager::OnAliveEnemiesNumUpdated' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnEnemyKilled) == 0x000480, "Member 'AREnemySpawnManager::OnEnemyKilled' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnEliteEnemySpawned) == 0x000490, "Member 'AREnemySpawnManager::OnEliteEnemySpawned' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnEliteEnemyKilled) == 0x0004A0, "Member 'AREnemySpawnManager::OnEliteEnemyKilled' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnSegmentCompleted) == 0x0004B0, "Member 'AREnemySpawnManager::OnSegmentCompleted' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnSegmentStarted) == 0x0004C0, "Member 'AREnemySpawnManager::OnSegmentStarted' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnFirstSegmentInNodeStarted) == 0x0004D0, "Member 'AREnemySpawnManager::OnFirstSegmentInNodeStarted' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnLastSegmentInNodeCompleted) == 0x0004E0, "Member 'AREnemySpawnManager::OnLastSegmentInNodeCompleted' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, EnemySpawnAreaSegmentsInNode) == 0x0004F0, "Member 'AREnemySpawnManager::EnemySpawnAreaSegmentsInNode' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnPlayerEnterSpawnAreaSegment) == 0x000500, "Member 'AREnemySpawnManager::OnPlayerEnterSpawnAreaSegment' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, DifficultyMultiplierOverride) == 0x000510, "Member 'AREnemySpawnManager::DifficultyMultiplierOverride' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, EnemySpawnDataModifiers) == 0x000518, "Member 'AREnemySpawnManager::EnemySpawnDataModifiers' has a wrong offset!");
static_assert(offsetof(AREnemySpawnManager, OnEnemySpawned) == 0x000578, "Member 'AREnemySpawnManager::OnEnemySpawned' has a wrong offset!");

// Class RGame.REnvQueryTest_FilterSelf
// 0x0000 (0x01F8 - 0x01F8)
class UREnvQueryTest_FilterSelf final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnvQueryTest_FilterSelf">();
	}
	static class UREnvQueryTest_FilterSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREnvQueryTest_FilterSelf>();
	}
};
static_assert(alignof(UREnvQueryTest_FilterSelf) == 0x000008, "Wrong alignment on UREnvQueryTest_FilterSelf");
static_assert(sizeof(UREnvQueryTest_FilterSelf) == 0x0001F8, "Wrong size on UREnvQueryTest_FilterSelf");

// Class RGame.REnvQueryTest_Navigation
// 0x0008 (0x0200 - 0x01F8)
class UREnvQueryTest_Navigation final : public UEnvQueryTest
{
public:
	ERVoxelNavigationType                         VoxelNavigationType;                               // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REnvQueryTest_Navigation">();
	}
	static class UREnvQueryTest_Navigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREnvQueryTest_Navigation>();
	}
};
static_assert(alignof(UREnvQueryTest_Navigation) == 0x000008, "Wrong alignment on UREnvQueryTest_Navigation");
static_assert(sizeof(UREnvQueryTest_Navigation) == 0x000200, "Wrong size on UREnvQueryTest_Navigation");
static_assert(offsetof(UREnvQueryTest_Navigation, VoxelNavigationType) == 0x0001F8, "Member 'UREnvQueryTest_Navigation::VoxelNavigationType' has a wrong offset!");

// Class RGame.RFieldSystemActor
// 0x0048 (0x02F8 - 0x02B0)
class ARFieldSystemActor : public AFieldSystemActor
{
public:
	class URadialVector*                          RadialVectorComponent;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCullingField*                          CullingFieldComponent;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOperatorField*                         CullingOperatorFieldcomponent;                     // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOperatorField*                         ForceOperatorFieldcomponent;                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNoiseField*                            NoiseFieldComponent;                               // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URadialFalloff*                         ForceFalloffComponent;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URadialFalloff*                         CullingFalloffComponent;                           // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrainMagnitude;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFieldRadius;                                // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialForce;                                       // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnApplyTransientfields(const struct FVector& FieldLocation, const float FieldRadius);
	void TriggerTransientFields_Multicast(const struct FVector& FieldLocation, const float FieldRadius);
	void TriggerTransientFieldsActorHitDelegateWrapper(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void TriggerTransientFieldsEnemyAreaAttackDelegateWrapper(const TArray<class AActor*>& HitActors, class AREnemyPawnBase* Enemy, const struct FVector& Location, float AttackRadius);
	void TriggerTransientFieldsEnemyProjectileDelegateWrapper(class AREnemyPawnBase* EnemyPawn, class AActor* HitActor, class ARProjectileBase* ProjectileActor);
	void TriggerTransientFieldsPlayerAreaAttackDelegateWrapper(class ARPlayerPawn* Player, const TArray<struct FHitResult>& Hits);
	void TriggerTransientFieldsPlayerLesserAreaAttackDelegateWrapper(class ARPlayerPawn* Player, const TArray<struct FHitResult>& Hits);
	void TriggerTransientFieldsPlayerProjectileDelegateWrapper(class ARPlayerPawn* PlayerPawn, class AActor* HitActor, class ARProjectileBase* ProjectileActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RFieldSystemActor">();
	}
	static class ARFieldSystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARFieldSystemActor>();
	}
};
static_assert(alignof(ARFieldSystemActor) == 0x000008, "Wrong alignment on ARFieldSystemActor");
static_assert(sizeof(ARFieldSystemActor) == 0x0002F8, "Wrong size on ARFieldSystemActor");
static_assert(offsetof(ARFieldSystemActor, RadialVectorComponent) == 0x0002B0, "Member 'ARFieldSystemActor::RadialVectorComponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, CullingFieldComponent) == 0x0002B8, "Member 'ARFieldSystemActor::CullingFieldComponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, CullingOperatorFieldcomponent) == 0x0002C0, "Member 'ARFieldSystemActor::CullingOperatorFieldcomponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, ForceOperatorFieldcomponent) == 0x0002C8, "Member 'ARFieldSystemActor::ForceOperatorFieldcomponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, NoiseFieldComponent) == 0x0002D0, "Member 'ARFieldSystemActor::NoiseFieldComponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, ForceFalloffComponent) == 0x0002D8, "Member 'ARFieldSystemActor::ForceFalloffComponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, CullingFalloffComponent) == 0x0002E0, "Member 'ARFieldSystemActor::CullingFalloffComponent' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, StrainMagnitude) == 0x0002E8, "Member 'ARFieldSystemActor::StrainMagnitude' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, DefaultFieldRadius) == 0x0002EC, "Member 'ARFieldSystemActor::DefaultFieldRadius' has a wrong offset!");
static_assert(offsetof(ARFieldSystemActor, RadialForce) == 0x0002F0, "Member 'ARFieldSystemActor::RadialForce' has a wrong offset!");

// Class RGame.RFloatingTextManager
// 0x00B0 (0x0358 - 0x02A8)
class ARFloatingTextManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FRFloatingTextQueue> FloatingTextQueueMap;                           // 0x02B0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UObject*, struct FRFloatingTextTypeWidgetMap> FloatingTextObjectTypeMap;              // 0x0300(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARFloatingTextManager* GetFloatingTextManager(const class UObject* WorldContextObject);

	void RemoveFloatingTextByType(class URFloatingTextWidget* FloatingText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RFloatingTextManager">();
	}
	static class ARFloatingTextManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARFloatingTextManager>();
	}
};
static_assert(alignof(ARFloatingTextManager) == 0x000008, "Wrong alignment on ARFloatingTextManager");
static_assert(sizeof(ARFloatingTextManager) == 0x000358, "Wrong size on ARFloatingTextManager");
static_assert(offsetof(ARFloatingTextManager, FloatingTextQueueMap) == 0x0002B0, "Member 'ARFloatingTextManager::FloatingTextQueueMap' has a wrong offset!");
static_assert(offsetof(ARFloatingTextManager, FloatingTextObjectTypeMap) == 0x000300, "Member 'ARFloatingTextManager::FloatingTextObjectTypeMap' has a wrong offset!");

// Class RGame.RFloatingTextSettings
// 0x0010 (0x0040 - 0x0030)
class URFloatingTextSettings final : public UDataAsset
{
public:
	TArray<struct FRFloatingTextSetting>          Settings;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RFloatingTextSettings">();
	}
	static class URFloatingTextSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URFloatingTextSettings>();
	}
};
static_assert(alignof(URFloatingTextSettings) == 0x000008, "Wrong alignment on URFloatingTextSettings");
static_assert(sizeof(URFloatingTextSettings) == 0x000040, "Wrong size on URFloatingTextSettings");
static_assert(offsetof(URFloatingTextSettings, Settings) == 0x000030, "Member 'URFloatingTextSettings::Settings' has a wrong offset!");

// Class RGame.RFloatingTextWidget
// 0x0030 (0x0300 - 0x02D0)
class URFloatingTextWidget final : public UUserWidget
{
public:
	class AActor*                                 CumulativeDamageTarget;                            // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             FloatingText;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Owner;                                             // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERFloatingTextType                            FloatingTextType;                                  // 0x02E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ImmunteText;                                       // 0x02F0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class URFloatingTextWidget* PushFloatingTextAtLocation(class UObject* WorldContextObject, const struct FVector& Location, const class FText& Text, ERFloatingTextType Type, class AActor* TargetActor);
	static void QueueFloatingText(class UObject* WorldContextObject, const struct FVector& Location, const class FText& Text, ERFloatingTextType Type, bool bSkipDelay);

	void RefreshText(const class FText& NewText, const struct FVector& NewWorldPosition);
	void SetAnimationDuration(float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RFloatingTextWidget">();
	}
	static class URFloatingTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URFloatingTextWidget>();
	}
};
static_assert(alignof(URFloatingTextWidget) == 0x000008, "Wrong alignment on URFloatingTextWidget");
static_assert(sizeof(URFloatingTextWidget) == 0x000300, "Wrong size on URFloatingTextWidget");
static_assert(offsetof(URFloatingTextWidget, CumulativeDamageTarget) == 0x0002D0, "Member 'URFloatingTextWidget::CumulativeDamageTarget' has a wrong offset!");
static_assert(offsetof(URFloatingTextWidget, FloatingText) == 0x0002D8, "Member 'URFloatingTextWidget::FloatingText' has a wrong offset!");
static_assert(offsetof(URFloatingTextWidget, Owner) == 0x0002E0, "Member 'URFloatingTextWidget::Owner' has a wrong offset!");
static_assert(offsetof(URFloatingTextWidget, FloatingTextType) == 0x0002E8, "Member 'URFloatingTextWidget::FloatingTextType' has a wrong offset!");
static_assert(offsetof(URFloatingTextWidget, ImmunteText) == 0x0002F0, "Member 'URFloatingTextWidget::ImmunteText' has a wrong offset!");

// Class RGame.RGAbilityCharacterMutatorScript
// 0x0D60 (0x0E68 - 0x0108)
class URGAbilityCharacterMutatorScript : public URGCharacterMutatorScript
{
public:
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilityName;                                       // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityIndex;                                      // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x016C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCancelReload;                                  // 0x0174(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         InputCooldown;                                     // 0x0178(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          IsChargeUp;                                        // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         ChargeUpTime;                                      // 0x02A8(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         ChargePercentageRequiredToFire;                    // 0x03D0(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              ChargeUpPercentageSweetSpotInterval;               // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TriggerProcChanceByRank;                           // 0x0508(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TimeAtChargeUpStart;                               // 0x0518(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeAtFire;                                        // 0x051C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         EffectDuration;                                    // 0x0520(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         EffectAmount;                                      // 0x0648(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         StacksRemaining;                                   // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_774[0x4];                                      // 0x0774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableInteger                       MaxStacks;                                         // 0x0778(0x0120)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableInteger                       StacksRestoredOnAllEnemiesDefeated;                // 0x0898(0x0120)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableInteger                       StacksRestoredOnRecharge;                          // 0x09B8(0x0120)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         StacksRechargeCooldown;                            // 0x0AD8(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableInteger                       StacksRequiredOnUse;                               // 0x0C00(0x0120)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         AbilityProcChanceMultiplier;                       // 0x0D20(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, int32 NumStacksRemaining)> OnStacksUpdated; // 0x0E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript)> OnCooldownFinished; // 0x0E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddAbilityBlocker(const class FName Key);
	bool BPCanFireAbility();
	void BroadcastOnCooldownFinished(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript);
	void BroadcastOnCooldownFinished_Server(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript);
	void BroadcastOnStacksUpdated(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, const int32 NumStacksRemaining);
	void BroadcastOnStackUpdated_Multicast(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, const int32 NumStacksRemaining);
	void BroadcastOnStackUpdated_Server(class URGAbilityCharacterMutatorScript* RGAbilityCharacterMutatorScript, const int32 NumStacksRemaining);
	bool CanFireAbility(int32 InputAbilityIndex);
	void ClearAbilityBlockers();
	void FireAbility();
	void FireAbility_Multicast();
	void FireAbility_Server();
	float GetChargePercentage();
	bool IsAbilityEnabled();
	bool IsInputCooldownReady();
	bool IsInSweetSpotInterval();
	void OnAbilityDisabled();
	void OnAbilityEnabled();
	void RemoveAbilityBlocker(const class FName Key);

	class URGWeaponScript* GetWeaponScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGAbilityCharacterMutatorScript">();
	}
	static class URGAbilityCharacterMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGAbilityCharacterMutatorScript>();
	}
};
static_assert(alignof(URGAbilityCharacterMutatorScript) == 0x000008, "Wrong alignment on URGAbilityCharacterMutatorScript");
static_assert(sizeof(URGAbilityCharacterMutatorScript) == 0x000E68, "Wrong size on URGAbilityCharacterMutatorScript");
static_assert(offsetof(URGAbilityCharacterMutatorScript, AbilityName) == 0x000160, "Member 'URGAbilityCharacterMutatorScript::AbilityName' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, AbilityIndex) == 0x000168, "Member 'URGAbilityCharacterMutatorScript::AbilityIndex' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, InputTag) == 0x00016C, "Member 'URGAbilityCharacterMutatorScript::InputTag' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, bCanCancelReload) == 0x000174, "Member 'URGAbilityCharacterMutatorScript::bCanCancelReload' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, InputCooldown) == 0x000178, "Member 'URGAbilityCharacterMutatorScript::InputCooldown' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, IsChargeUp) == 0x0002A0, "Member 'URGAbilityCharacterMutatorScript::IsChargeUp' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, ChargeUpTime) == 0x0002A8, "Member 'URGAbilityCharacterMutatorScript::ChargeUpTime' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, ChargePercentageRequiredToFire) == 0x0003D0, "Member 'URGAbilityCharacterMutatorScript::ChargePercentageRequiredToFire' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, ChargeUpPercentageSweetSpotInterval) == 0x0004F8, "Member 'URGAbilityCharacterMutatorScript::ChargeUpPercentageSweetSpotInterval' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, TriggerProcChanceByRank) == 0x000508, "Member 'URGAbilityCharacterMutatorScript::TriggerProcChanceByRank' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, TimeAtChargeUpStart) == 0x000518, "Member 'URGAbilityCharacterMutatorScript::TimeAtChargeUpStart' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, TimeAtFire) == 0x00051C, "Member 'URGAbilityCharacterMutatorScript::TimeAtFire' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, EffectDuration) == 0x000520, "Member 'URGAbilityCharacterMutatorScript::EffectDuration' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, EffectAmount) == 0x000648, "Member 'URGAbilityCharacterMutatorScript::EffectAmount' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, StacksRemaining) == 0x000770, "Member 'URGAbilityCharacterMutatorScript::StacksRemaining' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, MaxStacks) == 0x000778, "Member 'URGAbilityCharacterMutatorScript::MaxStacks' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, StacksRestoredOnAllEnemiesDefeated) == 0x000898, "Member 'URGAbilityCharacterMutatorScript::StacksRestoredOnAllEnemiesDefeated' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, StacksRestoredOnRecharge) == 0x0009B8, "Member 'URGAbilityCharacterMutatorScript::StacksRestoredOnRecharge' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, StacksRechargeCooldown) == 0x000AD8, "Member 'URGAbilityCharacterMutatorScript::StacksRechargeCooldown' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, StacksRequiredOnUse) == 0x000C00, "Member 'URGAbilityCharacterMutatorScript::StacksRequiredOnUse' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, AbilityProcChanceMultiplier) == 0x000D20, "Member 'URGAbilityCharacterMutatorScript::AbilityProcChanceMultiplier' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, OnStacksUpdated) == 0x000E48, "Member 'URGAbilityCharacterMutatorScript::OnStacksUpdated' has a wrong offset!");
static_assert(offsetof(URGAbilityCharacterMutatorScript, OnCooldownFinished) == 0x000E58, "Member 'URGAbilityCharacterMutatorScript::OnCooldownFinished' has a wrong offset!");

// Class RGame.RGameFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URGameFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorHasAnyStatusEffectFromInstigator(class AActor* Actor, class URGScriptComponent* InstigatorScriptComponent);
	static bool ActorHasStatusEffect(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass);
	static bool ActorHasStatusEffectFromInstigator(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass, class URGScriptComponent* InstigatorScriptComponent);
	static class FString AddHighlightToTextWithKeywords(const class FString& Text, const class FString& HighlightStyle);
	static void AddMutableFloatCoefficient(struct FRMutableFloat& MutableFloat, class FName Key, float Val);
	static void AddMutableFloatPostAdditive(struct FRMutableFloat& MutableFloat, class FName Key, float Val);
	static void AddMutableFloatPreAdditive(struct FRMutableFloat& MutableFloat, class FName Key, float Val);
	static void AddMutableIntegerCoefficient(struct FRMutableInteger& MutableInteger, class FName Key, float Val);
	static void AddMutableIntegerPostAdditive(struct FRMutableInteger& MutableInteger, class FName Key, int32 Val);
	static void AddMutableIntegerPreAdditive(struct FRMutableInteger& MutableInteger, class FName Key, int32 Val);
	static bool AnalyzeFocusEvent(const struct FFocusEvent& FocusEvent);
	static class FString AnalyzeGeometry(const struct FGeometry& Geometry);
	static class AActor* ApplyLightningEffectDamage(const class UObject* WorldContextObject, int32 LightingBouncesLeft, class AActor* OriginActor, class AActor* DamageCauser, class AController* InstigatedByController, const TArray<class AActor*>& IgnoreActors, class UNiagaraSystem* LightningNiagaraSystem, class USoundBase* LightningHitSound, TSubclassOf<class AActor> AffectedActorClasses, float LightningDamage, float DamageRadius, float DamageFalloffPerBounce, float BounceDelay, class URGScriptComponent* InstigatorScriptComponent, const struct FRLightningDamageCombatEventData& LightningDamageCombatEventData, bool bDamageClientPrediction);
	static TArray<class AActor*> ApplyRadialDamage(const class UObject* WorldContextObject, const struct FVector& Origin, class AActor* DamageCauser, class AController* InstigatedByController, const TArray<class AActor*>& IgnoreActors, TSubclassOf<class AActor> AffectedActorClasses, float BaseDamage, float DamageRadius, bool bTraceForObstacles, int32 DamageSources, bool bDamageClientPrediction, class AActor* AvatarActor);
	static bool AreObjectsInSameRoom(const class AActor* FirstObject, const class AActor* SecondObject, const struct FBox& LevelGenerationSettingsBox);
	static void Array_Random_Cached(const TArray<int32>& TargetArray, int32* OutItem, int32* OutIndex);
	static bool CheckDamageSource(int32 BitMask, EDamageSource DamageSource);
	static struct FRotator CombineRotatorWithEuler(const struct FRotator& Rotator, const struct FVector& Euler);
	static float ConvertFNameToFloat(const class FName Target);
	static class UObject* CreateBlueprintAsset(class UClass* Parent, const class FString& Name_0, const class FString& PackagePath);
	static bool DamageSourceMaskHasFlag(int32 Mask, int32 FlagsToCheck);
	static void DumpMutableFloatToLog(const class UObject* WorldContextObject, struct FRMutableFloat& MutableFloat);
	static void FadeInWithoutRestart(class UAudioComponent* AudioComponent, const float FadeInDuration, const float FadeVolumeLevel, const EAudioFaderCurve FadeCurve);
	static void FilterForAliveAndVulnerableActorsFromActors(TArray<class AActor*>& ActorsToFilter);
	static class UActorComponent* FindDefaultComponentByClass(const TSubclassOf<class AActor> InActorClass, const TSubclassOf<class UActorComponent> InComponentClass);
	static bool GamepadLostFocusByMouseEvent(class APlayerController* PlayerController, const struct FFocusEvent& FocusEvent);
	static class FString GetActivatableAbilityKeybindName(int32 AbilityIndex);
	static struct FGameplayTagContainer GetActorGameplayTags(class AActor* Actor);
	static TArray<class AActor*> GetActorsOfClassInsideRadius(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FVector& Location, float Radius);
	static class URStatusEffectGScript* GetActorStatusEffect(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass);
	static int32 GetActorStatusEffectAmount(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass);
	static class URStatusEffectGScript* GetActorStatusEffectFromInstigator(class AActor* Actor, TSoftClassPtr<class UClass> StatusEffectClass, class URGScriptComponent* InstigatorScriptComponent);
	static TArray<class AActor*> GetAliveActorsFromActors(const TArray<class AActor*>& ActorsToFilter);
	static TArray<class AActor*> GetAliveAndVulnerableActorsFromActors(const TArray<class AActor*>& ActorsToFilter);
	static TArray<class AActor*> GetAllAliveEnemyPawnsInLevel(const class UObject* WorldContextObject, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections);
	static TArray<class AActor*> GetAllAliveEnemyPawnsInLevelSortedByDistanceFromLocation(const class UObject* WorldContextObject, const struct FVector& Location, bool bDescendingSort, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections);
	static TArray<class AActor*> GetAllAliveEnemyPawnsInRadius(const class UObject* WorldContextObject, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, const struct FVector& Location, float Radius, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections);
	static TArray<struct FHitResult> GetAllHitsInRadius(const class UObject* WorldContextObject, const struct FVector& Origin, const class AActor* OriginActor, const TArray<class AActor*>& IgnoreActors, const TSubclassOf<class AActor> AffectedActorClass, float Radius, bool bTraceForObstacles);
	static TArray<class FString> GetAllKeywords(const bool bAllowVariants);
	static TArray<class ARPawnBase*> GetAllPawnsInRadius(const class UObject* WorldContextObject, const struct FVector& Origin, const class AActor* OriginActor, const TArray<class AActor*>& IgnoreActors, float Radius, bool bTraceForObstacles);
	static TArray<class ARPlayerPawn*> GetAllPlayerPawnsInLevel(const class UObject* WorldContextObject);
	static float GetChanceBasedOnGold(class AController* Controller, const float GoldEquivalentToMaxChance);
	static float GetChargeValueFromPlayers(const TArray<class AActor*>& PlayerActors);
	static class AActor* GetClosestActorToLocation(const struct FVector& Location, const TArray<class AActor*>& Actors, float* OutDistance);
	static struct FVector GetClosestPointOnSkeletalMeshToWorldLocation(const class AActor* Target, const struct FVector& Location, class FName* HitBone, bool bRequireVisibleSkelMesh, bool bReturnActorBoundsIfNoSkelMesh);
	static float GetCoefficientsValueByKey(struct FRMutableFloat& MutableFloat, class FName Key);
	static struct FSlateBrush GetCommonInputKeyBrush(const class UObject* WorldContextObject, const struct FKey& Key);
	static void GetCurrentLookAtTargetForPlayerController(const class UObject* WorldContextObject, class ARGamePlayerController* PlayerController, const TArray<EObjectTypeQuery>& ObjectTypes, struct FHitResult* OutHit, float TraceRadiusSize, float TraceLength);
	static TArray<struct FVector2D> GetDashedLinePoints(const struct FVector2D& PointA, const struct FVector2D& PointB, float DashLength);
	static float GetDifficultyValueByArrayIndex(const class UObject* WorldContextObject, class URDifficultyPrimaryAsset* RDifficultyPrimaryAsset, const int32 Tier, const int32 ArrayIndex);
	static int32 GetDirectDamageBitmask();
	static struct FEmoteDataTableRow GetEmoteDataTableRowByTag(class UDataTable* Table, const struct FGameplayTag& Tag);
	static struct FREnemyTableRow GetEnemyInfoById(const class UObject* WorldContextObject, class FName EnemyId);
	static class ARGamePlayerController* GetFirstLocalGamePlayerController(const class UObject* WorldContextObject);
	static ERFloatingTextType GetFloatingTextTypeFromDamageBitMask(int32 Mask);
	static class FName GetFName(const class UObject* Target);
	static struct FGameplayTag GetFocusCause(const struct FFocusEvent& FocusEvent);
	static class UObject* GetFromSoftObjectPtr(TSoftObjectPtr<class UObject> SoftObjectPtr);
	static struct FSurfaceTypeFX GetFXFromSurfaceTable(const class UDataTable* SurfaceFXTable, const EPhysicalSurface SurfaceType, bool* RowFound);
	static class URGScriptComponent* GetGlobalScriptComponent(const class UObject* WorldContext);
	static class FName GetGScriptCategoryFromActor(class AActor* Actor);
	static class URGScriptComponent* GetGScriptComponentFromActor(class AActor* Actor);
	static struct FRKeyboardLayoutRow GetKeyboardLayoutInfo(const class UObject* WorldContextObject);
	static class FString GetKeywordInfo(const class FString& Keyword);
	static class FString GetKeywordsInfoText(const class FString& InText, const bool bAllowKeywordVariants);
	static struct FLightSettingsRow GetLightSettingsDataTableRowByTag(class UDataTable* Table, const struct FGameplayTag& Tag);
	static float GetMutableFloatBaseValue(struct FRMutableFloat& MutableFloat);
	static float GetMutableFloatCurrentValue(struct FRMutableFloat& MutableFloat);
	static void GetMutableFloatValue(struct FRMutableFloat& MutableFloat, float* OutValue);
	static float GetMutableIntegerBaseValue(struct FRMutableInteger& MutableInteger);
	static int32 GetMutableIntegerCurrentValue(struct FRMutableInteger& MutableInteger);
	static float GetMutatorValueByArrayIndex(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 Rank, const int32 ArrayIndex);
	static float GetMutatorValueByVariableName(const class UObject* WorldContextObject, const class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const class FString& VariableName, const int32 Rank);
	static float GetMutatorValueFromActorInfoInstigatorScriptComponent(const struct FGScriptActorInfo& GScriptActorInfo, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 MutatorDescriptionVariableArrayIndex);
	static TArray<struct FMutatorDescriptionVariables> GetMutatorVariables(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	static struct FMutatorDescriptionVariables GetMutatorVariablesByVariableName(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const class FString& VariableName);
	static class FName GetNameWithHighestValueFromMap(const TMap<class FName, int32>& Map, int32 DefaultHighestValue, class FName DefaultName);
	static float GetNormalizedRandom();
	static int32 GetNumCompletedOverworldNodesInCurrentArea(const class UObject* WorldContextObject);
	static int32 GetNumEquippedMutatorsInGodCategory(class URGScriptComponent* RGScriptComponent, const struct FGameplayTag& GodCategoryTag);
	static class UObject* GetObjectFromClassReference(class UClass* Class_0);
	static float GetPlayerAbilityProcChance(class APawn* PlayerPawn, const int32 Rank);
	static TArray<class URMutatorPrimaryAsset*> GetPlayerEquippedMutatorsSorted(class ARPlayerPawn* RPlayerPawn);
	static float GetPostAdditivesValueByKey(struct FRMutableFloat& MutableFloat, class FName Key);
	static int32 GetPostAdditivesValueByKeyInteger(struct FRMutableInteger& MutableInteger, class FName Key);
	static class FString GetProjectVersion();
	static class AActor* GetRandomAliveEnemyPawnInLevel(const class UObject* WorldContextObject, const TArray<class ARNPCPawnBase*>& IgnoredEnemies, bool bExcludeBosses, bool bIncludeDummys, bool bIncludeGlobalTargets, bool bIncludeGeometryCollections);
	static class APlayerController* GetRandomAlivePlayerController(const class UObject* WorldContextObject);
	static int32 GetRandomIntWithWeight(const TMap<int32, float>& IntegersAndWeightMap);
	static class APlayerController* GetRandomPlayerController(const class UObject* WorldContextObject);
	static TArray<struct FRLootSelectionOption> GetRandomUpgradeableMutatorOptions(const TArray<struct FRLootSelectionOption>& PrevLootOptions, class APlayerController* PlayerController, const int32 NumOptions);
	static struct FMatrix GetRenderMatrix(const class UObject* WorldContextObject, const class UPrimitiveComponent* Component);
	static struct FVector GetSafeNormalAndMagnitude(const float Tolerance, const struct FVector& Vector, float* MagnitudeOut);
	static struct FSurfaceTypeSFX GetSFXFromSurfaceTable(const class UDataTable* SurfaceSFXTable, const EPhysicalSurface SurfaceType, bool* RowFound);
	static class FString GetVisibilityAsString(const class UWidget* Widget);
	static struct FVoiceOverTableRow GetVoiceOverDataTableRowByTag(class UDataTable* Table, const struct FGameplayTag& Tag);
	static TArray<class AActor*> GetVulnerableActorsFromActors(const TArray<class AActor*>& ActorsToFilter);
	static bool HasPlayerEverCompletedCurrentArea(const class UObject* WorldContextObject);
	static struct FLinearColor HueShift(const struct FLinearColor& Color, float HueShiftPercentage);
	static bool IsActorAnEnemy(class AActor* Actor);
	static bool IsDirectDamage(int32 Mask);
	static bool IsHitResultWeakspotHit(const struct FHitResult& HitResult);
	static bool IsInLastOverworldArea(const class UObject* WorldContextObject);
	static bool IsInsideOrOnBox(const struct FBox& Box, const struct FVector& Vector);
	static bool IsLocalControllerWithNullCheck(class AController* Controller);
	static bool IsLocallyControlledPawnWithNullCheck(class APawn* Pawn);
	static bool IsMoviePlayerRunning();
	static bool IsMutatorVariablePercentValueInText(const class UObject* WorldContextObject, const class FString& VariableName, const class FString& Text);
	static bool IsObjectInSameRoomAsPlayer(const class AActor* Object, const class APlayerController* PlayerController, const struct FBox& LevelGenerationSettingsBox);
	static bool IsOverworldNodeCompleted(const class UObject* WorldContextObject, const int32 NodeID);
	static bool IsSingleplayer(class UObject* WorldContextObject);
	static bool IsTargetWithinCone(const struct FVector& ConeOrigin, const struct FVector& ConeDirection, float ConeHalfAngle, const struct FVector& TargetLocation);
	static bool IsTearingDownWorld(class APlayerController* PlayerController);
	static bool IsVectorInsideFrustum(const struct FMatrix& Sides, const struct FVector& Vector, const float Radius);
	static bool IsWithEditor();
	static class UDecalComponent* LineTraceAndSpawnDecal(const class UObject* WorldContextObject, const struct FVector& LineTraceStart, const struct FVector& LineTraceEnd, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector2D& DecalMinMaxLifetime, float DecalFadeoutTime, bool* LineTraceHit, struct FHitResult* OutHit);
	static int32 MakeDamageSourceBitMask(int32 Mask);
	static float MutateFloat(struct FRMutableFloat& MutableFloat, float Value);
	static float NegativeModuloFloat(float X, float M);
	static int32 NegativeModuloInt(int32 X, int32 M);
	static void OpenConsole(class UObject* WorldContextObject);
	static class FText ParseMutatorDescription(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 MutatorRank, const bool bUseAdvancedDescription);
	static struct FVector PointWithPolarOffset(const struct FVector& Origin, float Distance, float Angle);
	static void RecreatePhysicsStateOnSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent);
	static void RemoveMutableFloatCoefficient(struct FRMutableFloat& MutableFloat, class FName Key);
	static void RemoveMutableFloatPostAdditive(struct FRMutableFloat& MutableFloat, class FName Key);
	static void RemoveMutableFloatPreAdditive(struct FRMutableFloat& MutableFloat, class FName Key);
	static void RemoveMutableIntegerCoefficient(struct FRMutableInteger& MutableInteger, class FName Key);
	static void RemoveMutableIntegerPostAdditive(struct FRMutableInteger& MutableInteger, class FName Key);
	static void RemoveMutableIntegerPreAdditive(struct FRMutableInteger& MutableInteger, class FName Key);
	static void ResetMeshToDefaultMaterials(class UPrimitiveComponent* MeshComponent);
	static void ResetMutableFloat(struct FRMutableFloat& MutableFloat);
	static void ResetMutableInteger(struct FRMutableInteger& MutableInteger);
	static struct FRotator RInterpToShortestPath(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed, bool bConstantSpeed, bool bUseShortestPath);
	static void SetActorIsEditorOnly(class AActor* Actor, bool bIsEditorOnly);
	static class UAudioComponent* SetAudioComponentSettingsMultiplayer(const class UObject* WorldContextObject, class UAudioComponent* AudioComponent, const class AController* OptionalController, const class APawn* OptionalPlayerPawn, const bool bIsPlayerSound);
	static void SetCosmeticMaterialParameters(const class UObject* WorldContextObject, const TArray<class UMeshComponent*>& MeshComponents, class UMaterialInstance* NewMI);
	static void SetLightPropertiesByTag(const struct FGameplayTag& Tag, class AActor* LightActor);
	static struct FTimerHandle SetOneOffTimer(TDelegate<void()> Delegate, float Time, bool bLooping);
	static void SetSoundWaveSettingsFromOtherSound(class USoundWave* SoundWave, const class USoundWave* TemplateSound);
	static void SetSoundWaveSettingsFromTemplate(class USoundWave* NewMetaSoundWave, const class USoundCue* TemplateSoundCue);
	static void SetStencilMask(class UPrimitiveComponent* Component, bool renderDepth, int32 stencilValue);
	static bool ShouldExcludeComponentFromRenderMatrix(const class ARGamePlayerController* PlayerController, const class UPrimitiveComponent* Component);
	static bool ShouldShowExtendedInfo(class APawn* Pawn, const struct FGameplayTag& ShowExtendedInfoTag);
	static void SortAbilitiesByIndex(TArray<class URGAbilityCharacterMutatorScript*>& Abilities);
	static void SortActorsByDistance(TArray<class AActor*>& Actors, const struct FVector& Origin);
	static void SortAndReapplyActivatableAbilities(class URPlayerGScriptComponent* PlayerGScriptComponent);
	static void SortHitsByDistance(TArray<struct FHitResult>& Hits);
	static class UDecalComponent* SpawnDecalFromHitResult(const class UObject* WorldContextObject, const struct FHitResult& HitResult, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector2D& DecalMinMaxLifetime, float DecalFadeoutTime);
	static void SpawnGold(const class UObject* WorldContextObject, int32 TotalValue, const struct FVector& Location, int32 FractionValue);
	static void SpawnHitEffect(const class UObject* WorldContextObject, const struct FHitResult& HitResult, const class AController* Controller, const class UDataTable* SurfaceFXTableOverride, const class UDataTable* SurfaceSFXTableOverride);
	static void SpawnHitEffectsOnPawn(const class UObject* WorldContextObject, class FName VFXTag, const struct FHitResult& HitResult, bool WasCritical);
	static class UNiagaraComponent* SpawnSystemAttached(TSubclassOf<class URNiagaraComponent> RNiagaraComponentClass, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, ENCPoolMethod PoolingMethod, bool bAutoDestroy, bool bAutoActivate, bool bPreCullCheck);
	static void StartLoadingScreen(bool bPlayUntilStopped, float PlayTime, bool bForceStart);
	static void StopLoadingScreen();
	static void UnlockAllAbilities(const class UObject* WorldContextObject);
	static void UnlockAllLockedContent(const class UObject* WorldContextObject);
	static void UnlockAllMutators(const class UObject* WorldContextObject);
	static void UnlockAllWeaponMods(const class UObject* WorldContextObject);
	static void WriteRunStatsToTextFile(const struct FRPlayerStats& Stats, const int32 RunIndex, const class FString& PlayerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameFunctionLibrary">();
	}
	static class URGameFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGameFunctionLibrary>();
	}
};
static_assert(alignof(URGameFunctionLibrary) == 0x000008, "Wrong alignment on URGameFunctionLibrary");
static_assert(sizeof(URGameFunctionLibrary) == 0x000028, "Wrong size on URGameFunctionLibrary");

// Class RGame.RGameHud
// 0x0010 (0x0448 - 0x0438)
class URGameHud : public URCommonActivatableWidget
{
public:
	class UCanvasPanel*                           Canvas;                                            // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URChatLog*                              ChatLogWidget;                                     // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class URChatLog* GetChatLogWidget();
	class UUserWidget* GetWaitingForPlayersWidget();
	bool IsWaitingForPlayersWidgetVisible();
	void ReinitBossHealthWidget(class ARBossPawnBase* BossPawn);
	void SetBarrierGaugeBlocked();
	void SetBarrierGaugeMaxReached();
	void SetBarrierGaugeReset();
	void SetBarrierGaugeVisibility(ESlateVisibility BarrierGaugeVisibility);
	void SetChargeUpBarVisibility(ESlateVisibility ChargeUpBarVilibility);
	void SetCrosshairCooldownIndicatorVisibility(ESlateVisibility CrosshairIndicatorVisibility);
	void SetOverheatBarVisibility(ESlateVisibility OverheatBarVilibility);
	void SetPreventBossHealthbarRemovalOnDeath(bool bShouldPrevent);
	void SetReviveAvailabilityVisibility(ESlateVisibility InVisibility);
	void SetSpiritGaugeMaxReached();
	void SetSpiritGaugeReset();
	void SetSpiritGaugeVisibility(ESlateVisibility SpiritGaugeVisibility);
	void SetTimerBarVisibility(ESlateVisibility InVisibility);
	void UpdateBarrierGaugePercent(float Threshold);
	void UpdateBossHealthWidget(class ARBossPawnBase* BossPawn, ESlateVisibility BossHealthVisibility);
	void UpdateChargeUpProgressBarPercent(float Threshold);
	void UpdateReviveAvailability(bool isConsumed);
	void UpdateSpiritGaugePercent(float Threshold);
	void UpdateTimerBarPercentage(float PercentageLeft);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameHud">();
	}
	static class URGameHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGameHud>();
	}
};
static_assert(alignof(URGameHud) == 0x000008, "Wrong alignment on URGameHud");
static_assert(sizeof(URGameHud) == 0x000448, "Wrong size on URGameHud");
static_assert(offsetof(URGameHud, Canvas) == 0x000438, "Member 'URGameHud::Canvas' has a wrong offset!");
static_assert(offsetof(URGameHud, ChatLogWidget) == 0x000440, "Member 'URGameHud::ChatLogWidget' has a wrong offset!");

// Class RGame.RGameInstance
// 0x0050 (0x0210 - 0x01C0)
class URGameInstance final : public UGameInstance
{
public:
	class URSaveGame*                             CurrentSaveGame;                                   // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URSaveGame* CurrentSaveGame)> OnCurrentSaveGameChanged;      // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadPrimaryGameAssets;                           // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 SessionId;                                         // 0x01E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildInfo;                                         // 0x01F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetEOSStats(const TArray<class FString>& StatNames);
	void SetJoinablePresence(bool bJoinable);
	void UpdateEOSStats(const class FString& StatName, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameInstance">();
	}
	static class URGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGameInstance>();
	}
};
static_assert(alignof(URGameInstance) == 0x000008, "Wrong alignment on URGameInstance");
static_assert(sizeof(URGameInstance) == 0x000210, "Wrong size on URGameInstance");
static_assert(offsetof(URGameInstance, CurrentSaveGame) == 0x0001C0, "Member 'URGameInstance::CurrentSaveGame' has a wrong offset!");
static_assert(offsetof(URGameInstance, OnCurrentSaveGameChanged) == 0x0001C8, "Member 'URGameInstance::OnCurrentSaveGameChanged' has a wrong offset!");
static_assert(offsetof(URGameInstance, OnLoadPrimaryGameAssets) == 0x0001D8, "Member 'URGameInstance::OnLoadPrimaryGameAssets' has a wrong offset!");
static_assert(offsetof(URGameInstance, SessionId) == 0x0001E8, "Member 'URGameInstance::SessionId' has a wrong offset!");
static_assert(offsetof(URGameInstance, BuildInfo) == 0x0001F8, "Member 'URGameInstance::BuildInfo' has a wrong offset!");

// Class RGame.RGamePlayerCameraManager
// 0x0000 (0x25A0 - 0x25A0)
class ARGamePlayerCameraManager final : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGamePlayerCameraManager">();
	}
	static class ARGamePlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGamePlayerCameraManager>();
	}
};
static_assert(alignof(ARGamePlayerCameraManager) == 0x000010, "Wrong alignment on ARGamePlayerCameraManager");
static_assert(sizeof(ARGamePlayerCameraManager) == 0x0025A0, "Wrong size on ARGamePlayerCameraManager");

// Class RGame.RPlayerController
// 0x00A0 (0x08F8 - 0x0858)
class ARPlayerController : public APlayerController
{
public:
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x0858(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class URCommonHUDWidget>          HUDClass;                                          // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                NotificationScreenClass;                           // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTabMenuOpen;                                      // 0x0870(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_871[0xF];                                      // 0x0871(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class URNotificationScreenWidget*             NotificationScreenWidget;                          // 0x0880(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<struct FDangerousActor>& DangerousActors)> OnDangerousActorsUpdated; // 0x0888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool CanInteract)> OnCanInteract;                                  // 0x0898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerController* RPlayerController, class URMutatorPrimaryAsset* RMutatorPrimaryAsset)> OnPlayerPickupMutator; // 0x08A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerController* RPlayerController, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 Rank)> OnPlayerDroppedMutator; // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerPickedUpItem;                              // 0x08C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* ActorInteractedWith)> OnPlayerInteract;              // 0x08D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 NumPointsAssigned, int32 NumMaxPoints)> OnPlayerSkillTreeUpdated; // 0x08E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BroadcastOnPlayerDroppedMutator(class ARPlayerController* RPlayerController, class URMutatorPrimaryAsset* RMutatorPrimaryAsset, const int32 Rank);
	void BroadcastOnPlayerPickedUpItem();
	void GamepadIconSchemeUpdated(EGamepadIconScheme NewIconScheme);
	class URCommonHUDWidget* GetHUDWidget();
	void SetClientControlRotation(const struct FRotator& Rotator);
	void UpdatePostProcessGamma(float NewValue);
	void UpdatePostProcessSettings();

	void BroadcastOnPlayerSkillTreeUpdated(const int32 NumPointsAssigned, const int32 NumMaxPoints) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerController">();
	}
	static class ARPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPlayerController>();
	}
};
static_assert(alignof(ARPlayerController) == 0x000008, "Wrong alignment on ARPlayerController");
static_assert(sizeof(ARPlayerController) == 0x0008F8, "Wrong size on ARPlayerController");
static_assert(offsetof(ARPlayerController, PostProcessVolume) == 0x000858, "Member 'ARPlayerController::PostProcessVolume' has a wrong offset!");
static_assert(offsetof(ARPlayerController, HUDClass) == 0x000860, "Member 'ARPlayerController::HUDClass' has a wrong offset!");
static_assert(offsetof(ARPlayerController, NotificationScreenClass) == 0x000868, "Member 'ARPlayerController::NotificationScreenClass' has a wrong offset!");
static_assert(offsetof(ARPlayerController, bTabMenuOpen) == 0x000870, "Member 'ARPlayerController::bTabMenuOpen' has a wrong offset!");
static_assert(offsetof(ARPlayerController, NotificationScreenWidget) == 0x000880, "Member 'ARPlayerController::NotificationScreenWidget' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnDangerousActorsUpdated) == 0x000888, "Member 'ARPlayerController::OnDangerousActorsUpdated' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnCanInteract) == 0x000898, "Member 'ARPlayerController::OnCanInteract' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnPlayerPickupMutator) == 0x0008A8, "Member 'ARPlayerController::OnPlayerPickupMutator' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnPlayerDroppedMutator) == 0x0008B8, "Member 'ARPlayerController::OnPlayerDroppedMutator' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnPlayerPickedUpItem) == 0x0008C8, "Member 'ARPlayerController::OnPlayerPickedUpItem' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnPlayerInteract) == 0x0008D8, "Member 'ARPlayerController::OnPlayerInteract' has a wrong offset!");
static_assert(offsetof(ARPlayerController, OnPlayerSkillTreeUpdated) == 0x0008E8, "Member 'ARPlayerController::OnPlayerSkillTreeUpdated' has a wrong offset!");

// Class RGame.RGamePlayerController
// 0x0358 (0x0C50 - 0x08F8)
class ARGamePlayerController final : public ARPlayerController
{
public:
	uint8                                         Pad_8F8[0x28];                                     // 0x08F8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentSameTargetTimer;                            // 0x0920(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_924[0x14];                                     // 0x0924(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class URPlayerInteractComponent*              InteractComponent;                                 // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URCommonHUDWidget>          GameHudClass;                                      // 0x0940(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URSpectateHud>              SpectateHudClass;                                  // 0x0948(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                DeathScreenClass;                                  // 0x0950(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                GameOverScreenClass;                               // 0x0958(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                DownedScreenClass;                                 // 0x0960(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSpectateHud*                          SpectateHud;                                       // 0x0968(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FGameplayTag>              CurrentPlayerEmotes;                               // 0x0970(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(float CastTime, float CurrentCastTime)> OnCastStarted;             // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnCastFinished;                                    // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnCastInterrupted;                                 // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AREnemyPawnBase>         CurrentlyTracedExecutableEnemy;                    // 0x09F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URGameHud*                              GameHud;                                           // 0x09F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWaitingForOtherPlayers;                         // 0x0A00(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A01[0x3];                                      // 0x0A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APawn>                   ControlledPlayerPawn;                              // 0x0A04(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0C[0x4];                                      // 0x0A0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URMutatorPrimaryAsset*>          StartMutatorsNotRequiringAWeapon;                  // 0x0A10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRLoadout                              DefaultStartLoadout;                               // 0x0A20(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class URMutatorPrimaryAsset*>          MutatorsToEquipOnBeginPlay;                        // 0x0A60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ARSpectatorPawn>            SpectatorPawnClass;                                // 0x0A70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Delta, float NewTotal)> OnGoldReceived;                      // 0x0A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Delta, int32 NewTotal)> OnKeyReceived;                       // 0x0A88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEnemyExecutionActivate;                          // 0x0A98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 TimeLeft)> OnVoteToProceedTick;                              // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 NumVotes, int32 NumPlayers, int32 TimeLeft)> OnVoteToProceed; // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHeldWidgetShown;                                 // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHeldWidgetRemoved;                               // 0x0AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URGameplayTagRelationshipMapping*       TagRelationshipMapping;                            // 0x0AE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF0[0x20];                                     // 0x0AF0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DownedScreen;                                      // 0x0B10(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyExecutionTraceTimerTickInterval;              // 0x0B18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              EnemyExecutionTraceObjectType;                     // 0x0B1C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1D[0x3];                                      // 0x0B1D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      EnemyExecutionTraceBlockers;                       // 0x0B20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         EnemyExecutionTraceRadiusSize;                     // 0x0B30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyExecutionTraceDistance;                       // 0x0B34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyTimeToTriggerDodge;                           // 0x0B38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3C[0x4];                                      // 0x0B3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           QuartzClocks;                                      // 0x0B40(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            InteractInput;                                     // 0x0B50(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinishedWaitingForPlayers;                       // 0x0B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStopWaitingForPlayers;                           // 0x0B88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& ChosenGodCategoryName, const TArray<class FString>& DiscardedGodCategoryNames, const class FString& ChosenGodMutatorName, const TArray<class FString>& DiscardedGodMutatorNames)> OnPlayerChoseGodCategoryMutator; // 0x0B98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& PurchasedItemName, int32 PurchasedItemCost, const TArray<class AActor*>& NotPurchasedItems)> OnPlayerPurchaseItem; // 0x0BA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnOpenLogBook;                                     // 0x0BB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCloseLogBook;                                    // 0x0BC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnExitWorkbench;                                   // 0x0BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHealUsed;                                        // 0x0BE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasServerLoadout;                                 // 0x0BF8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF9[0x7];                                      // 0x0BF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRLoadout                              ServerLoadout;                                     // 0x0C00(0x0040)(Net, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRDisconnectedPlayerData& PlayerData)> OnReconnectDoneServer; // 0x0C40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddCrosshair(class ARWeapon* Weapon);
	void AddHealthBonus_Server(class URPlayerGScriptComponent* GScriptComponent, const class URCharacterMutatorPrimaryAsset* HealthBonusMutatorPA);
	void ApplyCorruptedNodeDifficultyEffect_Server();
	void ApplyPlayerCosmetics(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const int32 EmoteSlot, const class URWeaponCosmeticPrimaryAsset* RWeaponCosmeticPA);
	void ApplyPlayerCosmetics_Server(class ARPlayerPawn* RPlayerPawn, const struct FPlayerCosmeticOption& CosmeticOptionData, const class FString& RWeaponCosmeticPath);
	void AttachWeaponToController(class URWeaponPrimaryAsset* WeaponClass, const TArray<class URWeaponModPrimaryAsset*>& WeaponMods, const bool bSaveToLoadout);
	void BroadcastOnCloseLogbook();
	void BroadcastOnEnemyExecutionActivate();
	void BroadcastOnExitWorkbench();
	void BroadcastOnFinishedWaitingForPlayers();
	void BroadcastOnHealUsed();
	void BroadcastOnHeldWidgetRemoved();
	void BroadcastOnHeldWidgetShown();
	void BroadcastOnOpenLogbook();
	void BroadcastOnPlayerChoseGodCategoryMutator(const class FString& ChosenGodCategoryName, const TArray<class FString>& DiscardedGodCategoryNames, const class FString& ChosenGodMutatorName, const TArray<class FString>& DiscardedGodMutatorNames);
	void BroadcastOnPlayerPurchaseItem(const class FString& PurchasedItemName, int32 PurchasedItemCost, const TArray<class AActor*>& NotPurchasedItems);
	void BroadcastOnStopWaitingForPlayers();
	void ClientPushFloatingTextAtLocation(const struct FVector& Location, ERFloatingTextType Type, int32 Value);
	void ClientQueueFloatingTextAtLocation(const struct FVector& Location, ERFloatingTextType Type, int32 Value, bool bSkipDelay);
	void EquipStartLoadout(const bool bIsRespawning);
	void FinishedMidRunLoading_Server();
	void FinishWaitingForPlayer_Client();
	void HealActor_Server(class URHealthComponent* HealthComp, class AActor* _Instigator, class AActor* ActorToHeal, EHealType HealType, float Value);
	void HeartbeatPing_Server();
	void HeartbeatPong_Client();
	void K2_OnPawnHealthDepleted(class URHealthComponent* Component);
	void K2_PushGameOverScreen();
	void KeyUsed_Server(class AActor* ActorUsedOn);
	void KillPawn();
	void OnCastFinished_Client();
	void OnCastInterrupted_Client();
	void OnCastStarted_Client(float CastTime, float CurrentCastTime);
	void OnCommonInputTypeChanged(ECommonInputType InputType);
	void OnCrosshairAlignmentChanged(ECrosshairAlignmentOption NewOption);
	void OnGameEnded_Client(bool GameWon);
	void OnGameEnded_Server(bool GameWon);
	void OnInteract_Server();
	void OnPawnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData);
	void OnPlayerJoined(class APlayerState* JoiningPlayerState);
	void OnPlayerRespawned_Multicast();
	void OnPushDeathScreen();
	void OnRespawnPlayer();
	void OnTabKeyDown();
	void OnTabKeyUp();
	void OnUserInputDeviceChange(EInputDeviceConnectionState NewConnectionState, const struct FPlatformUserId& PlatformUserId, const struct FInputDeviceId& InputDeviceId);
	void PlayEmoteSong(const class USoundBase* EmoteSong);
	void PlayEmoteSong_Server(const class USoundBase* EmoteSong);
	void PlayEmoteSongImplementation(const class USoundBase* EmoteSong);
	void PlayerJoined_Server(class ARGameState* RGameState, class APlayerState* InPlayerState, const class FText& Message);
	void ProceedFromDeathScreen();
	void ProceedFromDeathScreen_Server();
	void ProceedFromEndOfRunScreen(const bool bRunFailed);
	void ProceedFromEndOfRunScreen_Server(const bool bRunFailed);
	void PushDeathScreen_Client();
	void ReconnectDone_Server();
	void ReconnectPlayerStateSync_Client(const TArray<struct FRPlayerStateSync>& SyncData);
	void RemoveDownedScreen();
	void RestartCosmeticsTempTimer();
	void RevivePawn();
	void RunPauseBehavior();
	void RunRoutedObjectBehaviour_Server(class UObject* RoutedObject);
	void RunRoutedObjectBehaviourByName_Server(class UObject* RoutedObject, class FName BehaviourName);
	void RunRoutedObjectBehaviourWithData_Server(class UObject* RoutedObject, const struct FRoutedObjectData& RoutedData);
	void SelectOverworldNode(const int32 PlayerId, const int32 SelectedNodeId);
	void SelectOverworldNode_Server(const int32 PlayerId, const int32 SelectedNodeId);
	void ServerAttachWeaponToController(class URWeaponPrimaryAsset* WeaponClass, const TArray<class URWeaponModPrimaryAsset*>& WeaponMods);
	void ServerDestroyCharm(class ARPickupableCharm* CharmToDestroy);
	void ServerSendChatMessage(const struct FRChatLogMessage& MessageToSend);
	void ServerSetCrosshairDirectionAndOffset(const struct FVector& CrosshairDirection, const struct FVector& LocalOffset);
	void SetChestState_Server(class ARLootableContainer* Chest, EChestState ChestState);
	void SetCurrentHealth_Server(class URHealthComponent* HealthComp, float Value);
	void SetDamageEventReward_Server(class URGObjectiveScript* ObjectiveScript, bool bSuccessful);
	void SetEquippedLoadout_Server(const struct FRLoadout& Loadout);
	void SetHealAltarSelection_Server(class ARHealAltar* HealAltar, bool bConsumed);
	void SetLootOptionOnLootableContainer_Server(class ARLootableContainer* LootableContainer, const TArray<struct FRLootSelectionOption>& LootOption, bool bHasChosenLoot);
	void SetMerchantPlinthOption_Server(class ARMerchantPlinth* MerchantPlinth, const TArray<struct FRLootSelectionOption>& MutatorLootSelection, EPlinthRewardType RewardType, class URMutatorPrimaryAsset* PrimaryAsset, bool bLooted, class URMutatorRewardCategoryDataAsset* GodCategory, bool bClearPlinth);
	void SetNodeSpawnPointCharmReward_Server(class ARNodeRewardSpawnPoint* NodeRewardSpawnPoint, class URMutatorPrimaryAsset* CharmPrimaryAsset, bool bCharmPickedUp);
	void SetPlayerCorruptedNodeChoiceVote_Server(class APlayerState* InPlayerState, class URNodeChoicePrimaryAsset* VotedNodeChoicePA, class URNodeChoicePrimaryAsset* VotedNodeChoiceRewardPA);
	void SetPlayerEmote(const int32 Slot, const struct FGameplayTag& EmoteTag);
	void SetSacrificeAltarInteractionCost_Server(class ARLootableContainer* SacrificeAltar, int32 InteractionCost);
	void SetWishingWellInteractionCost_Server(class ARLootableContainer* WishingWell, int32 InteractionCost, int32 UsesLeft);
	void ShowDownedScreen();
	void SpawnAndPossessSpectatorPawn();
	void StartWaitingForPlayer_Client();
	void StartWaitingForPlayers();
	void StartWaitingForPlayersLobby();
	void StopWaitingForMe();
	void SwapHudVisibility(bool bShowSpectateHud);
	void SwapPickupableCharm(class URMutatorPrimaryAsset* MutatorAsset, int32 MutatorRank, class ARPickupableMutator* PickupableMutator);
	void SwapPickupableMutator(class URMutatorPrimaryAsset* MutatorAsset, int32 MutatorRank, class ARPickupableMutator* PickupableMutator, const struct FMutatorContainer& AttachedMutators);
	void SwapStatCharmMutator(class URGCharacterStatCharmScript* StatCharmMutator, class ARPickupableItem* OldStatCharmActor, const struct FTransform& SpawnTransform, ERewardRarity NewRarity, const TArray<struct FStatCharmStat>& NewMutatorStats);
	void TriggerHit_Server(const struct FHitResult& Hit, float BaseDamage, int32 DamageSources, class URGWeaponScript* WeaponScript, uint32 ProjectileId, bool bIsCriticalOverride, bool bCallHitEvents, bool bDamageClientPrediction, class URGScript* NonWeaponContext, bool bWeakspotOverride, uint8 HitSequenceFlags);

	void BroadcastOnVoteToProceed(const int32 NumVotes, const int32 NumPlayers, const int32 TimeLeft) const;
	void BroadcastOnVoteToProceed_Client(const int32 NumVotes, const int32 NumPlayers, const int32 TimeLeft) const;
	void BroadcastOnVoteToProceedTick_Client(const int32 TimeLeft) const;
	void BroadcastOnVoteToProceedTimerTick(const int32 TimeLeft) const;
	class APawn* GetControlledPlayerPawn() const;
	class URGWeaponScript* GetCurrentlyEquippedOveriddingWeaponScript() const;
	TMap<int32, struct FGameplayTag> GetCurrentPlayerEmotes() const;
	class URGameHud* GetGameHud() const;
	struct FGameplayTagContainer GetGameplayTags() const;
	int32 GetNumMaxMutatorCategories() const;
	class URSpectateHud* GetSpectateHud() const;
	class URGWeaponScript* GetWeaponOverridingWeaponScript(class ARWeapon* Weapon) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGamePlayerController">();
	}
	static class ARGamePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGamePlayerController>();
	}
};
static_assert(alignof(ARGamePlayerController) == 0x000008, "Wrong alignment on ARGamePlayerController");
static_assert(sizeof(ARGamePlayerController) == 0x000C50, "Wrong size on ARGamePlayerController");
static_assert(offsetof(ARGamePlayerController, CurrentSameTargetTimer) == 0x000920, "Member 'ARGamePlayerController::CurrentSameTargetTimer' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, InteractComponent) == 0x000938, "Member 'ARGamePlayerController::InteractComponent' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, GameHudClass) == 0x000940, "Member 'ARGamePlayerController::GameHudClass' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, SpectateHudClass) == 0x000948, "Member 'ARGamePlayerController::SpectateHudClass' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, DeathScreenClass) == 0x000950, "Member 'ARGamePlayerController::DeathScreenClass' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, GameOverScreenClass) == 0x000958, "Member 'ARGamePlayerController::GameOverScreenClass' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, DownedScreenClass) == 0x000960, "Member 'ARGamePlayerController::DownedScreenClass' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, SpectateHud) == 0x000968, "Member 'ARGamePlayerController::SpectateHud' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, CurrentPlayerEmotes) == 0x000970, "Member 'ARGamePlayerController::CurrentPlayerEmotes' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnCastStarted) == 0x0009C0, "Member 'ARGamePlayerController::OnCastStarted' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnCastFinished) == 0x0009D0, "Member 'ARGamePlayerController::OnCastFinished' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnCastInterrupted) == 0x0009E0, "Member 'ARGamePlayerController::OnCastInterrupted' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, CurrentlyTracedExecutableEnemy) == 0x0009F0, "Member 'ARGamePlayerController::CurrentlyTracedExecutableEnemy' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, GameHud) == 0x0009F8, "Member 'ARGamePlayerController::GameHud' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, bIsWaitingForOtherPlayers) == 0x000A00, "Member 'ARGamePlayerController::bIsWaitingForOtherPlayers' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, ControlledPlayerPawn) == 0x000A04, "Member 'ARGamePlayerController::ControlledPlayerPawn' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, StartMutatorsNotRequiringAWeapon) == 0x000A10, "Member 'ARGamePlayerController::StartMutatorsNotRequiringAWeapon' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, DefaultStartLoadout) == 0x000A20, "Member 'ARGamePlayerController::DefaultStartLoadout' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, MutatorsToEquipOnBeginPlay) == 0x000A60, "Member 'ARGamePlayerController::MutatorsToEquipOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, SpectatorPawnClass) == 0x000A70, "Member 'ARGamePlayerController::SpectatorPawnClass' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnGoldReceived) == 0x000A78, "Member 'ARGamePlayerController::OnGoldReceived' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnKeyReceived) == 0x000A88, "Member 'ARGamePlayerController::OnKeyReceived' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnEnemyExecutionActivate) == 0x000A98, "Member 'ARGamePlayerController::OnEnemyExecutionActivate' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnVoteToProceedTick) == 0x000AA8, "Member 'ARGamePlayerController::OnVoteToProceedTick' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnVoteToProceed) == 0x000AB8, "Member 'ARGamePlayerController::OnVoteToProceed' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnHeldWidgetShown) == 0x000AC8, "Member 'ARGamePlayerController::OnHeldWidgetShown' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnHeldWidgetRemoved) == 0x000AD8, "Member 'ARGamePlayerController::OnHeldWidgetRemoved' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, TagRelationshipMapping) == 0x000AE8, "Member 'ARGamePlayerController::TagRelationshipMapping' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, DownedScreen) == 0x000B10, "Member 'ARGamePlayerController::DownedScreen' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, EnemyExecutionTraceTimerTickInterval) == 0x000B18, "Member 'ARGamePlayerController::EnemyExecutionTraceTimerTickInterval' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, EnemyExecutionTraceObjectType) == 0x000B1C, "Member 'ARGamePlayerController::EnemyExecutionTraceObjectType' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, EnemyExecutionTraceBlockers) == 0x000B20, "Member 'ARGamePlayerController::EnemyExecutionTraceBlockers' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, EnemyExecutionTraceRadiusSize) == 0x000B30, "Member 'ARGamePlayerController::EnemyExecutionTraceRadiusSize' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, EnemyExecutionTraceDistance) == 0x000B34, "Member 'ARGamePlayerController::EnemyExecutionTraceDistance' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, EnemyTimeToTriggerDodge) == 0x000B38, "Member 'ARGamePlayerController::EnemyTimeToTriggerDodge' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, QuartzClocks) == 0x000B40, "Member 'ARGamePlayerController::QuartzClocks' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, InteractInput) == 0x000B50, "Member 'ARGamePlayerController::InteractInput' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnFinishedWaitingForPlayers) == 0x000B78, "Member 'ARGamePlayerController::OnFinishedWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnStopWaitingForPlayers) == 0x000B88, "Member 'ARGamePlayerController::OnStopWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnPlayerChoseGodCategoryMutator) == 0x000B98, "Member 'ARGamePlayerController::OnPlayerChoseGodCategoryMutator' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnPlayerPurchaseItem) == 0x000BA8, "Member 'ARGamePlayerController::OnPlayerPurchaseItem' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnOpenLogBook) == 0x000BB8, "Member 'ARGamePlayerController::OnOpenLogBook' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnCloseLogBook) == 0x000BC8, "Member 'ARGamePlayerController::OnCloseLogBook' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnExitWorkbench) == 0x000BD8, "Member 'ARGamePlayerController::OnExitWorkbench' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnHealUsed) == 0x000BE8, "Member 'ARGamePlayerController::OnHealUsed' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, bHasServerLoadout) == 0x000BF8, "Member 'ARGamePlayerController::bHasServerLoadout' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, ServerLoadout) == 0x000C00, "Member 'ARGamePlayerController::ServerLoadout' has a wrong offset!");
static_assert(offsetof(ARGamePlayerController, OnReconnectDoneServer) == 0x000C40, "Member 'ARGamePlayerController::OnReconnectDoneServer' has a wrong offset!");

// Class RGame.RGameplayTagAssetInterface
// 0x0000 (0x0000 - 0x0000)
class IRGameplayTagAssetInterface final
{
public:
	void AddGameplayTag(const struct FGameplayTag& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameplayTagAssetInterface">();
	}
	static class IRGameplayTagAssetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRGameplayTagAssetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRGameplayTagAssetInterface) == 0x000001, "Wrong alignment on IRGameplayTagAssetInterface");
static_assert(sizeof(IRGameplayTagAssetInterface) == 0x000001, "Wrong size on IRGameplayTagAssetInterface");

// Class RGame.RGameplayTagRelationshipMapping
// 0x0010 (0x0040 - 0x0030)
class URGameplayTagRelationshipMapping final : public UDataAsset
{
public:
	TArray<struct FRAbilityTagRelationship>       AbilityTagRelationships;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	bool HasTag(const struct FGameplayTag& Tag, const struct FGameplayTagContainer& ActiveTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameplayTagRelationshipMapping">();
	}
	static class URGameplayTagRelationshipMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGameplayTagRelationshipMapping>();
	}
};
static_assert(alignof(URGameplayTagRelationshipMapping) == 0x000008, "Wrong alignment on URGameplayTagRelationshipMapping");
static_assert(sizeof(URGameplayTagRelationshipMapping) == 0x000040, "Wrong size on URGameplayTagRelationshipMapping");
static_assert(offsetof(URGameplayTagRelationshipMapping, AbilityTagRelationships) == 0x000030, "Member 'URGameplayTagRelationshipMapping::AbilityTagRelationships' has a wrong offset!");

// Class RGame.RGameUserSettings
// 0x01C8 (0x0310 - 0x0148)
class URGameUserSettings final : public UGameUserSettings
{
public:
	class USoundControlBusMix*                    UserAudioMix;                                      // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundControlBus*                       MainVolumeControlBus;                              // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundControlBus*                       MusicControlBus;                                   // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundControlBus*                       SFXControlBus;                                     // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundControlBus*                       VoiceControlBus;                                   // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasLoadedUserAudioMix;                            // 0x0170(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MasterAudioVolume;                                 // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MusicAudioVolume;                                  // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SFXAudioVolume;                                    // 0x017C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoiceAudioVolume;                                  // 0x0180(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMuteWhenUnfocused;                                // 0x0184(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBinauralAudio;                                    // 0x0185(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowSubtitles;                                    // 0x0186(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAlternateMusicList;                            // 0x0187(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimSensitivity;                                    // 0x0188(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScopedAimSensitivity;                              // 0x018C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControllerXSensitivity;                            // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControllerYSensitivity;                            // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControllerScopedXSensitivity;                      // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControllerScopedYSensitivity;                      // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertYAxisAiming;                                // 0x01A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertXAxisAiming;                                // 0x01A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A2[0x2];                                      // 0x01A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldOfView;                                       // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDamageNumbersOption                          DamageNumbersOption;                               // 0x01A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrosshairAlignmentOption                     CrosshairAlignmentOption;                          // 0x01A9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDashIndicator;                                // 0x01AA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowHealthBars;                                   // 0x01AB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowPlayerHUD;                                    // 0x01AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowCrosshair;                                    // 0x01AD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowPlayerNames;                                  // 0x01AE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHoldToScope;                                      // 0x01AF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsControllerVibrationEnabled;                     // 0x01B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerformCameraShakes;                              // 0x01B1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowEnemyHealthNumbers;                           // 0x01B2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B3[0x5];                                      // 0x01B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameLanguage;                                      // 0x01B8(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGamepadIconScheme                            GamepadIconScheme;                                 // 0x01C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gamma;                                             // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LockForegroundMaxFramerate;                        // 0x01D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForegroundMaxFramerate;                            // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackgroundMaxFramerate;                            // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AntiAliasingMethod;                                // 0x01DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GlobalIlluminationMethod;                          // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenPercentage;                                  // 0x01E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MotionBlurEnabled;                                 // 0x01E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DepthOfFieldEnabled;                               // 0x01E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EA[0x6];                                      // 0x01EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistStrength;                                 // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableLanguageFiltering;                         // 0x01F4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowTelemetryDataCollection;                     // 0x01F5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasShownTelemetryConsentScreen;                   // 0x01F6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F7[0x1];                                      // 0x01F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float NewValue)> OnFieldOfViewUpdated;                             // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float NewValue)> OnGammaUpdated;                                   // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnShowHealthBarsUpdated;                           // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnShowHUDUpdated;                                  // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnShowCrosshairUpdated;                            // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnShowPlayerNamesUpdated;                          // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnShowSubtitlesUpdated;                            // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnShowDashIndicatorUpdated;                        // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewValue)> OnAllowTelemetryDataCollectionUpdated;             // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ECrosshairAlignmentOption NewOption)> OnCrosshairAlignmentChanged; // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EGamepadIconScheme NewIconScheme)> OnGamepadIconSchemeChanged;     // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInputtingKeyBinding;                            // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            KeybindingSettingsUserWidget;                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            GamepadBindingSettingsUserWidget;                  // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastSelectedResolution;                            // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInputBindingChanged;                             // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGraphicsSettingsChanged;                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCultureChanged;                                  // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnResolutionChanged;                               // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URGameUserSettings* GetRGameUserSettings();

	void BroadcastOnCultureChanged();
	void BroadcastOnGraphicsSettingsChanged();
	float GetAimAssistStrength();
	bool GetHasShownTelemetryConsentScreen();
	void OpenComboBox(class UComboBoxString* ComboBox);
	void ResetDisplaySettings();
	void ResetGameplaySettings();
	void ResetGraphicsSettings();
	void ResetSettings();
	void ResetSoundSettings();
	void SetAAMethod(int32 NewValue);
	void SetAimAssistStrength(const float NewStrength);
	void SetAimSensitivity(float NewValue);
	void SetAllowTelemetryDataCollection(const bool bNewAllow);
	void SetAlternateMusicList(bool NewValue);
	void SetBackgroundMaxFramerate(float NewValue);
	void SetBinauralAudio(bool NewValue);
	void SetControllerScopedXSensitivity(float NewValue);
	void SetControllerScopedYSensitivity(float NewValue);
	void SetControllerVibrationEnabled(bool NewValue);
	void SetControllerXSensitivity(float NewValue);
	void SetControllerYSensitivity(float NewValue);
	void SetCrosshairAlignment(ECrosshairAlignmentOption NewCrosshairAlignmentOption);
	void SetDepthOfFieldEnabled(bool bNewValue, bool bSetOnlyConfigValue);
	void SetDisableLanguageFiltering(bool bNewDisabled);
	void SetFieldOfView(float NewValue);
	void SetForegroundMaxFramerate(float NewValue);
	void SetGameLanguage(const class FString& NewValue);
	void SetGamepadIconScheme(EGamepadIconScheme NewValue);
	void SetGamma(float NewValue);
	void SetGlobalIlluminationMethod(int32 NewValue);
	void SetHasShownTelemetryConsentScreen(const bool bNewHasShown);
	void SetHoldToScope(bool NewValue);
	void SetInvertedXAxisAiming(bool NewValue);
	void SetInvertedYAxisAiming(bool NewValue);
	void SetLockForegroundMaxFramerate(bool NewValue);
	void SetMasterVolume(float NewValue);
	void SetMotionBlurEnabled(bool bNewValue);
	void SetMusicVolume(float NewValue);
	void SetMuteWhenUnfocused(bool NewValue);
	void SetPerformCameraShakes(bool NewValue);
	void SetScopedAimSensitivity(float NewValue);
	void SetScreenPercentage(float NewValue);
	void SetSFXVolume(float NewValue);
	void SetShowCrosshair(bool NewValue);
	void SetShowDamageNumbers(EDamageNumbersOption NewDamageNumbersOption);
	void SetShowDashIndicator(const bool NewValue);
	void SetShowEnemyHealthNumbers(bool NewValue);
	void SetShowHealthBars(bool NewValue);
	void SetShowPlayerHUD(bool NewValue);
	void SetShowPlayerNames(bool NewValue);
	void SetShowSubtitles(bool NewValue);
	void SetVoiceVolume(float NewValue);
	void UpdateScalabilityQualityLevels();
	void UpdateScreenResolution(const struct FIntPoint& NewValue);

	int32 GetAAType() const;
	float GetAimSensitivity() const;
	bool GetAllowTelemetryDataCollection() const;
	float GetBackgroundMaxFramerate() const;
	bool GetBinauralAudio() const;
	float GetControllerScopedXSensitivity() const;
	float GetControllerScopedYSensitivity() const;
	float GetControllerXSensitivity() const;
	float GetControllerYSensitivity() const;
	ECrosshairAlignmentOption GetCrosshairAlignmentOption() const;
	bool GetDepthOfFieldEnabled() const;
	bool GetDisableLanguageFiltering() const;
	float GetFieldOfView() const;
	float GetForegroundMaxFramerate() const;
	class FString GetGameLanguage() const;
	EGamepadIconScheme GetGamepadIconScheme() const;
	float GetGamma() const;
	int32 GetGIType() const;
	bool GetHoldToScope() const;
	bool GetInvertXAxis() const;
	bool GetInvertYAxis() const;
	bool GetIsControllerVibrationEnabled() const;
	bool GetLockForegroundMaxFramerate() const;
	float GetMasterAudioVolume() const;
	bool GetMotionBlurEnabled() const;
	float GetMusicAudioVolume() const;
	bool GetMuteWhenUnfocused() const;
	bool GetPerformCameraShakes() const;
	float GetScopedAimSensitivity() const;
	float GetScreenPercentage() const;
	float GetSFXAudioVolume() const;
	bool GetShowCrosshair() const;
	EDamageNumbersOption GetShowDamageNumbers() const;
	bool GetShowDashIndicator() const;
	bool GetShowEnemyHealthNumbers() const;
	bool GetShowHealthBars() const;
	bool GetShowPlayerHUD() const;
	bool GetShowPlayerNames() const;
	bool GetShowSubtitles() const;
	bool GetUseAlternateMusicList() const;
	float GetVoiceAudioVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameUserSettings">();
	}
	static class URGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGameUserSettings>();
	}
};
static_assert(alignof(URGameUserSettings) == 0x000008, "Wrong alignment on URGameUserSettings");
static_assert(sizeof(URGameUserSettings) == 0x000310, "Wrong size on URGameUserSettings");
static_assert(offsetof(URGameUserSettings, UserAudioMix) == 0x000148, "Member 'URGameUserSettings::UserAudioMix' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, MainVolumeControlBus) == 0x000150, "Member 'URGameUserSettings::MainVolumeControlBus' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, MusicControlBus) == 0x000158, "Member 'URGameUserSettings::MusicControlBus' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, SFXControlBus) == 0x000160, "Member 'URGameUserSettings::SFXControlBus' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, VoiceControlBus) == 0x000168, "Member 'URGameUserSettings::VoiceControlBus' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bHasLoadedUserAudioMix) == 0x000170, "Member 'URGameUserSettings::bHasLoadedUserAudioMix' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, MasterAudioVolume) == 0x000174, "Member 'URGameUserSettings::MasterAudioVolume' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, MusicAudioVolume) == 0x000178, "Member 'URGameUserSettings::MusicAudioVolume' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, SFXAudioVolume) == 0x00017C, "Member 'URGameUserSettings::SFXAudioVolume' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, VoiceAudioVolume) == 0x000180, "Member 'URGameUserSettings::VoiceAudioVolume' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bMuteWhenUnfocused) == 0x000184, "Member 'URGameUserSettings::bMuteWhenUnfocused' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bBinauralAudio) == 0x000185, "Member 'URGameUserSettings::bBinauralAudio' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowSubtitles) == 0x000186, "Member 'URGameUserSettings::bShowSubtitles' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bUseAlternateMusicList) == 0x000187, "Member 'URGameUserSettings::bUseAlternateMusicList' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, AimSensitivity) == 0x000188, "Member 'URGameUserSettings::AimSensitivity' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ScopedAimSensitivity) == 0x00018C, "Member 'URGameUserSettings::ScopedAimSensitivity' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ControllerXSensitivity) == 0x000190, "Member 'URGameUserSettings::ControllerXSensitivity' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ControllerYSensitivity) == 0x000194, "Member 'URGameUserSettings::ControllerYSensitivity' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ControllerScopedXSensitivity) == 0x000198, "Member 'URGameUserSettings::ControllerScopedXSensitivity' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ControllerScopedYSensitivity) == 0x00019C, "Member 'URGameUserSettings::ControllerScopedYSensitivity' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bInvertYAxisAiming) == 0x0001A0, "Member 'URGameUserSettings::bInvertYAxisAiming' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bInvertXAxisAiming) == 0x0001A1, "Member 'URGameUserSettings::bInvertXAxisAiming' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, FieldOfView) == 0x0001A4, "Member 'URGameUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, DamageNumbersOption) == 0x0001A8, "Member 'URGameUserSettings::DamageNumbersOption' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, CrosshairAlignmentOption) == 0x0001A9, "Member 'URGameUserSettings::CrosshairAlignmentOption' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowDashIndicator) == 0x0001AA, "Member 'URGameUserSettings::bShowDashIndicator' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowHealthBars) == 0x0001AB, "Member 'URGameUserSettings::bShowHealthBars' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowPlayerHUD) == 0x0001AC, "Member 'URGameUserSettings::bShowPlayerHUD' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowCrosshair) == 0x0001AD, "Member 'URGameUserSettings::bShowCrosshair' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowPlayerNames) == 0x0001AE, "Member 'URGameUserSettings::bShowPlayerNames' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bHoldToScope) == 0x0001AF, "Member 'URGameUserSettings::bHoldToScope' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bIsControllerVibrationEnabled) == 0x0001B0, "Member 'URGameUserSettings::bIsControllerVibrationEnabled' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bPerformCameraShakes) == 0x0001B1, "Member 'URGameUserSettings::bPerformCameraShakes' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bShowEnemyHealthNumbers) == 0x0001B2, "Member 'URGameUserSettings::bShowEnemyHealthNumbers' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, GameLanguage) == 0x0001B8, "Member 'URGameUserSettings::GameLanguage' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, GamepadIconScheme) == 0x0001C8, "Member 'URGameUserSettings::GamepadIconScheme' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, Gamma) == 0x0001CC, "Member 'URGameUserSettings::Gamma' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, LockForegroundMaxFramerate) == 0x0001D0, "Member 'URGameUserSettings::LockForegroundMaxFramerate' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ForegroundMaxFramerate) == 0x0001D4, "Member 'URGameUserSettings::ForegroundMaxFramerate' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, BackgroundMaxFramerate) == 0x0001D8, "Member 'URGameUserSettings::BackgroundMaxFramerate' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, AntiAliasingMethod) == 0x0001DC, "Member 'URGameUserSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, GlobalIlluminationMethod) == 0x0001E0, "Member 'URGameUserSettings::GlobalIlluminationMethod' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, ScreenPercentage) == 0x0001E4, "Member 'URGameUserSettings::ScreenPercentage' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, MotionBlurEnabled) == 0x0001E8, "Member 'URGameUserSettings::MotionBlurEnabled' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, DepthOfFieldEnabled) == 0x0001E9, "Member 'URGameUserSettings::DepthOfFieldEnabled' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, AimAssistStrength) == 0x0001F0, "Member 'URGameUserSettings::AimAssistStrength' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bDisableLanguageFiltering) == 0x0001F4, "Member 'URGameUserSettings::bDisableLanguageFiltering' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bAllowTelemetryDataCollection) == 0x0001F5, "Member 'URGameUserSettings::bAllowTelemetryDataCollection' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bHasShownTelemetryConsentScreen) == 0x0001F6, "Member 'URGameUserSettings::bHasShownTelemetryConsentScreen' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnFieldOfViewUpdated) == 0x0001F8, "Member 'URGameUserSettings::OnFieldOfViewUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnGammaUpdated) == 0x000208, "Member 'URGameUserSettings::OnGammaUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnShowHealthBarsUpdated) == 0x000218, "Member 'URGameUserSettings::OnShowHealthBarsUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnShowHUDUpdated) == 0x000228, "Member 'URGameUserSettings::OnShowHUDUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnShowCrosshairUpdated) == 0x000238, "Member 'URGameUserSettings::OnShowCrosshairUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnShowPlayerNamesUpdated) == 0x000248, "Member 'URGameUserSettings::OnShowPlayerNamesUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnShowSubtitlesUpdated) == 0x000258, "Member 'URGameUserSettings::OnShowSubtitlesUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnShowDashIndicatorUpdated) == 0x000268, "Member 'URGameUserSettings::OnShowDashIndicatorUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnAllowTelemetryDataCollectionUpdated) == 0x000278, "Member 'URGameUserSettings::OnAllowTelemetryDataCollectionUpdated' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnCrosshairAlignmentChanged) == 0x000288, "Member 'URGameUserSettings::OnCrosshairAlignmentChanged' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnGamepadIconSchemeChanged) == 0x000298, "Member 'URGameUserSettings::OnGamepadIconSchemeChanged' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, bIsInputtingKeyBinding) == 0x0002A8, "Member 'URGameUserSettings::bIsInputtingKeyBinding' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, KeybindingSettingsUserWidget) == 0x0002B0, "Member 'URGameUserSettings::KeybindingSettingsUserWidget' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, GamepadBindingSettingsUserWidget) == 0x0002B8, "Member 'URGameUserSettings::GamepadBindingSettingsUserWidget' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, LastSelectedResolution) == 0x0002C0, "Member 'URGameUserSettings::LastSelectedResolution' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnInputBindingChanged) == 0x0002D0, "Member 'URGameUserSettings::OnInputBindingChanged' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnGraphicsSettingsChanged) == 0x0002E0, "Member 'URGameUserSettings::OnGraphicsSettingsChanged' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnCultureChanged) == 0x0002F0, "Member 'URGameUserSettings::OnCultureChanged' has a wrong offset!");
static_assert(offsetof(URGameUserSettings, OnResolutionChanged) == 0x000300, "Member 'URGameUserSettings::OnResolutionChanged' has a wrong offset!");

// Class RGame.RGAreaEffectScript
// 0x0008 (0x00C8 - 0x00C0)
class URGAreaEffectScript : public URGScript
{
public:
	uint8                                         Pad_C0[0x2];                                       // 0x00C0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EAreaEffectTickMode                           TickMode;                                          // 0x00C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AActor*> GetActorsInArea();
	TArray<class ARNPCPawnBase*> GetAliveNPCPawnsInArea();
	TArray<class ARPawnBase*> GetAlivePawnsInArea();
	void K2_OnEnter(class AActor* Actor);
	void K2_OnExit(class AActor* Actor);
	void OnActorsInAreaChanged();
	void OnEnter(class AActor* Actor);
	void OnExit(class AActor* Actor);

	class ARAreaEffect* GetOwningAreaEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGAreaEffectScript">();
	}
	static class URGAreaEffectScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGAreaEffectScript>();
	}
};
static_assert(alignof(URGAreaEffectScript) == 0x000008, "Wrong alignment on URGAreaEffectScript");
static_assert(sizeof(URGAreaEffectScript) == 0x0000C8, "Wrong size on URGAreaEffectScript");
static_assert(offsetof(URGAreaEffectScript, TickMode) == 0x0000C2, "Member 'URGAreaEffectScript::TickMode' has a wrong offset!");

// Class RGame.RGBossAbilityScript
// 0x0018 (0x00D8 - 0x00C0)
class URGBossAbilityScript final : public URGScript
{
public:
	TMulticastInlineDelegate<void()>              OnFinishExecution;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelAbilityExecution();
	void EnterNextPhase();
	void FinishAbilityExecution();
	bool IsMainAbilityScript();
	void K2_OnAnimationTriggerEvent(class FName Event);
	void Multicast_CancelAbilityExecution();
	void OnAnimationTriggerEvent(class FName Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGBossAbilityScript">();
	}
	static class URGBossAbilityScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGBossAbilityScript>();
	}
};
static_assert(alignof(URGBossAbilityScript) == 0x000008, "Wrong alignment on URGBossAbilityScript");
static_assert(sizeof(URGBossAbilityScript) == 0x0000D8, "Wrong size on URGBossAbilityScript");
static_assert(offsetof(URGBossAbilityScript, OnFinishExecution) == 0x0000C0, "Member 'URGBossAbilityScript::OnFinishExecution' has a wrong offset!");

// Class RGame.RGBurningAilment
// 0x0010 (0x04E8 - 0x04D8)
class URGBurningAilment : public URStatusEffectAilmentGScript
{
public:
	class URCharacterMutatorPrimaryAsset*         FirePassive1MutatorPA;                             // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URGBurningAilment>          BurningClass;                                      // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class AActor*> GetFirePassive1SpreadTargets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGBurningAilment">();
	}
	static class URGBurningAilment* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGBurningAilment>();
	}
};
static_assert(alignof(URGBurningAilment) == 0x000008, "Wrong alignment on URGBurningAilment");
static_assert(sizeof(URGBurningAilment) == 0x0004E8, "Wrong size on URGBurningAilment");
static_assert(offsetof(URGBurningAilment, FirePassive1MutatorPA) == 0x0004D8, "Member 'URGBurningAilment::FirePassive1MutatorPA' has a wrong offset!");
static_assert(offsetof(URGBurningAilment, BurningClass) == 0x0004E0, "Member 'URGBurningAilment::BurningClass' has a wrong offset!");

// Class RGame.RGCharSkillTreeMutatorScript
// 0x0028 (0x0130 - 0x0108)
class URGCharSkillTreeMutatorScript final : public URGCharacterMutatorScript
{
public:
	TSoftObjectPtr<class URMutatorPrimaryAsset>   SoftAssociatedMutatorPA;                           // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void RefreshSkillTreeMutator(const int32 MutatorRank);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGCharSkillTreeMutatorScript">();
	}
	static class URGCharSkillTreeMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGCharSkillTreeMutatorScript>();
	}
};
static_assert(alignof(URGCharSkillTreeMutatorScript) == 0x000008, "Wrong alignment on URGCharSkillTreeMutatorScript");
static_assert(sizeof(URGCharSkillTreeMutatorScript) == 0x000130, "Wrong size on URGCharSkillTreeMutatorScript");
static_assert(offsetof(URGCharSkillTreeMutatorScript, SoftAssociatedMutatorPA) == 0x000108, "Member 'URGCharSkillTreeMutatorScript::SoftAssociatedMutatorPA' has a wrong offset!");

// Class RGame.RGDefaultProjectileScript
// 0x0028 (0x0108 - 0x00E0)
class URGDefaultProjectileScript : public URGProjectileScript
{
public:
	int32                                         WeaponPrimaryFireDefaultDamageSources;             // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WeaponSecondaryFireDefaultDamageSources;           // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnEffectsOnHit;                                // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             SurfaceFXTableOverride;                            // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SurfaceSFXTableOverride;                           // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageSourceBitmask;                               // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGDefaultProjectileScript">();
	}
	static class URGDefaultProjectileScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGDefaultProjectileScript>();
	}
};
static_assert(alignof(URGDefaultProjectileScript) == 0x000008, "Wrong alignment on URGDefaultProjectileScript");
static_assert(sizeof(URGDefaultProjectileScript) == 0x000108, "Wrong size on URGDefaultProjectileScript");
static_assert(offsetof(URGDefaultProjectileScript, WeaponPrimaryFireDefaultDamageSources) == 0x0000E0, "Member 'URGDefaultProjectileScript::WeaponPrimaryFireDefaultDamageSources' has a wrong offset!");
static_assert(offsetof(URGDefaultProjectileScript, WeaponSecondaryFireDefaultDamageSources) == 0x0000E4, "Member 'URGDefaultProjectileScript::WeaponSecondaryFireDefaultDamageSources' has a wrong offset!");
static_assert(offsetof(URGDefaultProjectileScript, bSpawnEffectsOnHit) == 0x0000E8, "Member 'URGDefaultProjectileScript::bSpawnEffectsOnHit' has a wrong offset!");
static_assert(offsetof(URGDefaultProjectileScript, SurfaceFXTableOverride) == 0x0000F0, "Member 'URGDefaultProjectileScript::SurfaceFXTableOverride' has a wrong offset!");
static_assert(offsetof(URGDefaultProjectileScript, SurfaceSFXTableOverride) == 0x0000F8, "Member 'URGDefaultProjectileScript::SurfaceSFXTableOverride' has a wrong offset!");
static_assert(offsetof(URGDefaultProjectileScript, DamageSourceBitmask) == 0x000100, "Member 'URGDefaultProjectileScript::DamageSourceBitmask' has a wrong offset!");

// Class RGame.RGEnemyAttackScript
// 0x0050 (0x0110 - 0x00C0)
class URGEnemyAttackScript final : public URGScript
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRangeToAttack;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireLOSForAttack;                              // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresSpecialCondition;                         // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlocked;                                          // 0x00DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresResources;                                // 0x00DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ResourceTag;                                       // 0x00DC(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceCost;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AttackTarget;                                      // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceFinishAttackExecution();
	class FName GetCategoryName();
	void K2_OnAttack();
	void K2_OnCombatTargetChanged();
	void K2_OnDeath();
	void K2_OnFrozen();
	void K2_OnInterrupted();
	void K2_OnStunned();
	void K2_OnUnfrozen();
	void K2_OnUnstunned();
	void OnAttack(class AActor* Target);
	void OnCombatTargetChanged();
	void OnDeath();
	void OnFrozen();
	void OnInterrupted();
	void OnStunned();
	void OnUnfrozen();
	void OnUnstunned();
	void StartCooldown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGEnemyAttackScript">();
	}
	static class URGEnemyAttackScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGEnemyAttackScript>();
	}
};
static_assert(alignof(URGEnemyAttackScript) == 0x000008, "Wrong alignment on URGEnemyAttackScript");
static_assert(sizeof(URGEnemyAttackScript) == 0x000110, "Wrong size on URGEnemyAttackScript");
static_assert(offsetof(URGEnemyAttackScript, Cooldown) == 0x0000C8, "Member 'URGEnemyAttackScript::Cooldown' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, AttackRange) == 0x0000CC, "Member 'URGEnemyAttackScript::AttackRange' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, MinRangeToAttack) == 0x0000D0, "Member 'URGEnemyAttackScript::MinRangeToAttack' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, Damage) == 0x0000D4, "Member 'URGEnemyAttackScript::Damage' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, bRequireLOSForAttack) == 0x0000D8, "Member 'URGEnemyAttackScript::bRequireLOSForAttack' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, bRequiresSpecialCondition) == 0x0000D9, "Member 'URGEnemyAttackScript::bRequiresSpecialCondition' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, bBlocked) == 0x0000DA, "Member 'URGEnemyAttackScript::bBlocked' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, bRequiresResources) == 0x0000DB, "Member 'URGEnemyAttackScript::bRequiresResources' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, ResourceTag) == 0x0000DC, "Member 'URGEnemyAttackScript::ResourceTag' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, ResourceCost) == 0x0000E4, "Member 'URGEnemyAttackScript::ResourceCost' has a wrong offset!");
static_assert(offsetof(URGEnemyAttackScript, AttackTarget) == 0x0000F0, "Member 'URGEnemyAttackScript::AttackTarget' has a wrong offset!");

// Class RGame.RGEnemyScript
// 0x0010 (0x00D0 - 0x00C0)
class URGEnemyScript : public URGScript
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnAttack();
	void K2_OnCombatTargetChanged();
	void K2_OnDeath();
	void K2_OnFrozen();
	void K2_OnInterrupted();
	void K2_OnSpecial();
	void K2_OnStunned();
	void K2_OnUnfrozen();
	void K2_OnUnstunned();
	void OnAttack();
	void OnCombatTargetChanged();
	void OnDeath();
	void OnFrozen();
	void OnInterrupted();
	void OnSpecial();
	void OnStunned();
	void OnUnfrozen();
	void OnUnstunned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGEnemyScript">();
	}
	static class URGEnemyScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGEnemyScript>();
	}
};
static_assert(alignof(URGEnemyScript) == 0x000008, "Wrong alignment on URGEnemyScript");
static_assert(sizeof(URGEnemyScript) == 0x0000D0, "Wrong size on URGEnemyScript");

// Class RGame.RGeometryCollectionActor
// 0x0010 (0x02C8 - 0x02B8)
class ARGeometryCollectionActor : public AGeometryCollectionActor
{
public:
	bool                                          bRemoveActorOnBreak;                               // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DespawnBias;                                       // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHasBroken();
	void HandleBreakEvent(const struct FChaosBreakEvent& BreakEvent);
	void K2_OnMeshBroken(const struct FChaosBreakEvent& BreakEvent);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGeometryCollectionActor">();
	}
	static class ARGeometryCollectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGeometryCollectionActor>();
	}
};
static_assert(alignof(ARGeometryCollectionActor) == 0x000008, "Wrong alignment on ARGeometryCollectionActor");
static_assert(sizeof(ARGeometryCollectionActor) == 0x0002C8, "Wrong size on ARGeometryCollectionActor");
static_assert(offsetof(ARGeometryCollectionActor, bRemoveActorOnBreak) == 0x0002B8, "Member 'ARGeometryCollectionActor::bRemoveActorOnBreak' has a wrong offset!");
static_assert(offsetof(ARGeometryCollectionActor, DespawnBias) == 0x0002BC, "Member 'ARGeometryCollectionActor::DespawnBias' has a wrong offset!");

// Class RGame.RGFrostPassive3CharacterMutator
// 0x0018 (0x0120 - 0x0108)
class URGFrostPassive3CharacterMutator : public URGCharacterMutatorScript
{
public:
	class URMutatorPrimaryAsset*                  MutatorPA;                                         // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BuildUpMultiplier;                                 // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetFrostPassive3Multiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGFrostPassive3CharacterMutator">();
	}
	static class URGFrostPassive3CharacterMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGFrostPassive3CharacterMutator>();
	}
};
static_assert(alignof(URGFrostPassive3CharacterMutator) == 0x000008, "Wrong alignment on URGFrostPassive3CharacterMutator");
static_assert(sizeof(URGFrostPassive3CharacterMutator) == 0x000120, "Wrong size on URGFrostPassive3CharacterMutator");
static_assert(offsetof(URGFrostPassive3CharacterMutator, MutatorPA) == 0x000108, "Member 'URGFrostPassive3CharacterMutator::MutatorPA' has a wrong offset!");
static_assert(offsetof(URGFrostPassive3CharacterMutator, BuildUpMultiplier) == 0x000110, "Member 'URGFrostPassive3CharacterMutator::BuildUpMultiplier' has a wrong offset!");

// Class RGame.RGFrozenSlipperyStatusEffect
// 0x0018 (0x04F0 - 0x04D8)
class URGFrozenSlipperyStatusEffect : public URStatusEffectGScript
{
public:
	class URMutatorPrimaryAsset*                  FrostPassive8MutatorPA;                            // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCharacterMutatorPrimaryAsset*         FrostPassive3MutatorPA;                            // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URStatusEffectGScript>      ChillClass;                                        // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoAoeSlam(const TArray<class URStatusEffectGScript*>& Instigators, const struct FVector& Origin, float* OutMaxRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGFrozenSlipperyStatusEffect">();
	}
	static class URGFrozenSlipperyStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGFrozenSlipperyStatusEffect>();
	}
};
static_assert(alignof(URGFrozenSlipperyStatusEffect) == 0x000008, "Wrong alignment on URGFrozenSlipperyStatusEffect");
static_assert(sizeof(URGFrozenSlipperyStatusEffect) == 0x0004F0, "Wrong size on URGFrozenSlipperyStatusEffect");
static_assert(offsetof(URGFrozenSlipperyStatusEffect, FrostPassive8MutatorPA) == 0x0004D8, "Member 'URGFrozenSlipperyStatusEffect::FrostPassive8MutatorPA' has a wrong offset!");
static_assert(offsetof(URGFrozenSlipperyStatusEffect, FrostPassive3MutatorPA) == 0x0004E0, "Member 'URGFrozenSlipperyStatusEffect::FrostPassive3MutatorPA' has a wrong offset!");
static_assert(offsetof(URGFrozenSlipperyStatusEffect, ChillClass) == 0x0004E8, "Member 'URGFrozenSlipperyStatusEffect::ChillClass' has a wrong offset!");

// Class RGame.RGGrenadeScript
// 0x0008 (0x00E8 - 0x00E0)
class URGGrenadeScript : public URGProjectileScript
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnBounce();
	void K2_OnDetonate();
	void K2_PostDetonate();
	void K2_PreDetonate();
	void OnBounce();
	void OnDetonate();
	void PostDetonate();
	void PreDetonate();

	class ARGrenade* GetOwningGrenade() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGGrenadeScript">();
	}
	static class URGGrenadeScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGGrenadeScript>();
	}
};
static_assert(alignof(URGGrenadeScript) == 0x000008, "Wrong alignment on URGGrenadeScript");
static_assert(sizeof(URGGrenadeScript) == 0x0000E8, "Wrong size on URGGrenadeScript");

// Class RGame.RGIceShardsProjectileScript
// 0x0098 (0x0178 - 0x00E0)
class URGIceShardsProjectileScript : public URGProjectileScript
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URStatusEffectGScript>      ChillStatusEffectClass;                            // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NativePreHomingVelocityDamping;                    // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNativePastHomingDelay;                            // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NativeHomingTargetLocation;                        // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NativePreHomingLocation;                           // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageSources;                                     // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  FrostGodPassiveMutatorPA;                          // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 NormalEnemyHealthPercentageBurstDamage;            // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EliteEnemyHealthPercentageBurstDamage;             // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BossEnemyHealthPercentageBurstDamage;              // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCharacterMutatorPrimaryAsset*         FrostPassive3MutatorPA;                            // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMutatorPrimaryAsset*                  FrostPassive7MutatorPA;                            // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGIceShardsProjectileScript">();
	}
	static class URGIceShardsProjectileScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGIceShardsProjectileScript>();
	}
};
static_assert(alignof(URGIceShardsProjectileScript) == 0x000008, "Wrong alignment on URGIceShardsProjectileScript");
static_assert(sizeof(URGIceShardsProjectileScript) == 0x000178, "Wrong size on URGIceShardsProjectileScript");
static_assert(offsetof(URGIceShardsProjectileScript, ChillStatusEffectClass) == 0x0000E8, "Member 'URGIceShardsProjectileScript::ChillStatusEffectClass' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, NativePreHomingVelocityDamping) == 0x0000F0, "Member 'URGIceShardsProjectileScript::NativePreHomingVelocityDamping' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, bNativePastHomingDelay) == 0x0000F4, "Member 'URGIceShardsProjectileScript::bNativePastHomingDelay' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, NativeHomingTargetLocation) == 0x0000F8, "Member 'URGIceShardsProjectileScript::NativeHomingTargetLocation' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, NativePreHomingLocation) == 0x000110, "Member 'URGIceShardsProjectileScript::NativePreHomingLocation' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, DamageSources) == 0x000128, "Member 'URGIceShardsProjectileScript::DamageSources' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, FrostGodPassiveMutatorPA) == 0x000130, "Member 'URGIceShardsProjectileScript::FrostGodPassiveMutatorPA' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, NormalEnemyHealthPercentageBurstDamage) == 0x000138, "Member 'URGIceShardsProjectileScript::NormalEnemyHealthPercentageBurstDamage' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, EliteEnemyHealthPercentageBurstDamage) == 0x000148, "Member 'URGIceShardsProjectileScript::EliteEnemyHealthPercentageBurstDamage' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, BossEnemyHealthPercentageBurstDamage) == 0x000158, "Member 'URGIceShardsProjectileScript::BossEnemyHealthPercentageBurstDamage' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, FrostPassive3MutatorPA) == 0x000168, "Member 'URGIceShardsProjectileScript::FrostPassive3MutatorPA' has a wrong offset!");
static_assert(offsetof(URGIceShardsProjectileScript, FrostPassive7MutatorPA) == 0x000170, "Member 'URGIceShardsProjectileScript::FrostPassive7MutatorPA' has a wrong offset!");

// Class RGame.RGObjectiveScript
// 0x0050 (0x0110 - 0x00C0)
class URGObjectiveScript : public URGScript
{
public:
	TArray<class AActor*>                         SpecificActorsToKill;                              // 0x00C0(0x0010)(BlueprintVisible, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class URPrimaryDataAsset*>             AssociatedDataAssets;                              // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class URGScript*>                      AssociatedScripts;                                 // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ObjectiveTag;                                      // 0x00F4(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URGObjectiveScript* ObjectiveScript)> OnSpecificActorsToKillSet; // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void EndObjective(bool bCompleted);
	void SetHasObjectiveEnded(bool bNewHasEnded);
	void SetResultForController(bool bSuccesful, class APlayerController* PlayerController);
	void UpdateObjective(const class FText& UpdateInfo);

	class FText GetProgressionText() const;
	bool HasObjectiveEnded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGObjectiveScript">();
	}
	static class URGObjectiveScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGObjectiveScript>();
	}
};
static_assert(alignof(URGObjectiveScript) == 0x000008, "Wrong alignment on URGObjectiveScript");
static_assert(sizeof(URGObjectiveScript) == 0x000110, "Wrong size on URGObjectiveScript");
static_assert(offsetof(URGObjectiveScript, SpecificActorsToKill) == 0x0000C0, "Member 'URGObjectiveScript::SpecificActorsToKill' has a wrong offset!");
static_assert(offsetof(URGObjectiveScript, AssociatedDataAssets) == 0x0000D0, "Member 'URGObjectiveScript::AssociatedDataAssets' has a wrong offset!");
static_assert(offsetof(URGObjectiveScript, AssociatedScripts) == 0x0000E0, "Member 'URGObjectiveScript::AssociatedScripts' has a wrong offset!");
static_assert(offsetof(URGObjectiveScript, ObjectiveTag) == 0x0000F4, "Member 'URGObjectiveScript::ObjectiveTag' has a wrong offset!");
static_assert(offsetof(URGObjectiveScript, OnSpecificActorsToKillSet) == 0x000100, "Member 'URGObjectiveScript::OnSpecificActorsToKillSet' has a wrong offset!");

// Class RGame.RGoldManager
// 0x0068 (0x0310 - 0x02A8)
class ARGoldManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x40];                                     // 0x02A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         GoldSpawnNiagaraSystem;                            // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           ParameterCollection;                               // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             GoldSpawnSound;                                    // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             GoldPickupSound;                                   // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddGoldDelay;                                      // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARGoldManager* GetGoldManager(const class UObject* WorldContextObject);

	void OnPreLevelChanged();
	void SpawnGold(class APawn* Player, bool bBurst, int32 Amount, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGoldManager">();
	}
	static class ARGoldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGoldManager>();
	}
};
static_assert(alignof(ARGoldManager) == 0x000008, "Wrong alignment on ARGoldManager");
static_assert(sizeof(ARGoldManager) == 0x000310, "Wrong size on ARGoldManager");
static_assert(offsetof(ARGoldManager, GoldSpawnNiagaraSystem) == 0x0002E8, "Member 'ARGoldManager::GoldSpawnNiagaraSystem' has a wrong offset!");
static_assert(offsetof(ARGoldManager, ParameterCollection) == 0x0002F0, "Member 'ARGoldManager::ParameterCollection' has a wrong offset!");
static_assert(offsetof(ARGoldManager, GoldSpawnSound) == 0x0002F8, "Member 'ARGoldManager::GoldSpawnSound' has a wrong offset!");
static_assert(offsetof(ARGoldManager, GoldPickupSound) == 0x000300, "Member 'ARGoldManager::GoldPickupSound' has a wrong offset!");
static_assert(offsetof(ARGoldManager, AddGoldDelay) == 0x000308, "Member 'ARGoldManager::AddGoldDelay' has a wrong offset!");

// Class RGame.RGolemancerPlatform
// 0x0008 (0x02B0 - 0x02A8)
class ARGolemancerPlatform final : public AActor
{
public:
	bool                                          bOverlapsEnabled;                                  // 0x02A8(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlipTile(class ARGolemancerPlatform* FlipSourceActor);
	class UStaticMeshComponent* GetPlatformMesh();
	void PrimeTileExplosion(const float Duration);
	void SetOnFire();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGolemancerPlatform">();
	}
	static class ARGolemancerPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGolemancerPlatform>();
	}
};
static_assert(alignof(ARGolemancerPlatform) == 0x000008, "Wrong alignment on ARGolemancerPlatform");
static_assert(sizeof(ARGolemancerPlatform) == 0x0002B0, "Wrong size on ARGolemancerPlatform");
static_assert(offsetof(ARGolemancerPlatform, bOverlapsEnabled) == 0x0002A8, "Member 'ARGolemancerPlatform::bOverlapsEnabled' has a wrong offset!");

// Class RGame.RGolemancerPylon
// 0x0068 (0x4850 - 0x47E8)
class ARGolemancerPylon final : public ARNPCPawnBase
{
public:
	bool                                          bIsActive;                                         // 0x47E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47E9[0x7];                                     // 0x47E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARPawnBase*                             BossPawn;                                          // 0x47F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetHueShift;                                    // 0x47F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           TargetPointLightColor;                             // 0x47FC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           StartPointLightColor;                              // 0x480C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481C[0x4];                                     // 0x481C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x4820(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HiddenLocation;                                    // 0x4838(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivationChanged();
	void OnRep_bIsActive();
	void SetIsActive(const bool bNewIsActive);

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGolemancerPylon">();
	}
	static class ARGolemancerPylon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGolemancerPylon>();
	}
};
static_assert(alignof(ARGolemancerPylon) == 0x000008, "Wrong alignment on ARGolemancerPylon");
static_assert(sizeof(ARGolemancerPylon) == 0x004850, "Wrong size on ARGolemancerPylon");
static_assert(offsetof(ARGolemancerPylon, bIsActive) == 0x0047E8, "Member 'ARGolemancerPylon::bIsActive' has a wrong offset!");
static_assert(offsetof(ARGolemancerPylon, BossPawn) == 0x0047F0, "Member 'ARGolemancerPylon::BossPawn' has a wrong offset!");
static_assert(offsetof(ARGolemancerPylon, TargetHueShift) == 0x0047F8, "Member 'ARGolemancerPylon::TargetHueShift' has a wrong offset!");
static_assert(offsetof(ARGolemancerPylon, TargetPointLightColor) == 0x0047FC, "Member 'ARGolemancerPylon::TargetPointLightColor' has a wrong offset!");
static_assert(offsetof(ARGolemancerPylon, StartPointLightColor) == 0x00480C, "Member 'ARGolemancerPylon::StartPointLightColor' has a wrong offset!");
static_assert(offsetof(ARGolemancerPylon, StartLocation) == 0x004820, "Member 'ARGolemancerPylon::StartLocation' has a wrong offset!");
static_assert(offsetof(ARGolemancerPylon, HiddenLocation) == 0x004838, "Member 'ARGolemancerPylon::HiddenLocation' has a wrong offset!");

// Class RGame.RGPlasmaLauncherRocketScript
// 0x0030 (0x0118 - 0x00E8)
class URGPlasmaLauncherRocketScript final : public URGRocketScript
{
public:
	class URMutatorPrimaryAsset*                  ExplosiveValveMutatorPA;                           // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMutatorPrimaryAsset*                  ThickOilMutatorPA;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ThickOilAreaEffectDurationMutatorValueArrayIndex;  // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARAreaEffect>               ThickOilAreaEffectClass;                           // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageSources;                                     // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WeaponPrimaryFireDefaultDamageSources;             // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WeaponSecondaryFireDefaultDamageSources;           // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGPlasmaLauncherRocketScript">();
	}
	static class URGPlasmaLauncherRocketScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGPlasmaLauncherRocketScript>();
	}
};
static_assert(alignof(URGPlasmaLauncherRocketScript) == 0x000008, "Wrong alignment on URGPlasmaLauncherRocketScript");
static_assert(sizeof(URGPlasmaLauncherRocketScript) == 0x000118, "Wrong size on URGPlasmaLauncherRocketScript");
static_assert(offsetof(URGPlasmaLauncherRocketScript, ExplosiveValveMutatorPA) == 0x0000E8, "Member 'URGPlasmaLauncherRocketScript::ExplosiveValveMutatorPA' has a wrong offset!");
static_assert(offsetof(URGPlasmaLauncherRocketScript, ThickOilMutatorPA) == 0x0000F0, "Member 'URGPlasmaLauncherRocketScript::ThickOilMutatorPA' has a wrong offset!");
static_assert(offsetof(URGPlasmaLauncherRocketScript, ThickOilAreaEffectDurationMutatorValueArrayIndex) == 0x0000F8, "Member 'URGPlasmaLauncherRocketScript::ThickOilAreaEffectDurationMutatorValueArrayIndex' has a wrong offset!");
static_assert(offsetof(URGPlasmaLauncherRocketScript, ThickOilAreaEffectClass) == 0x000100, "Member 'URGPlasmaLauncherRocketScript::ThickOilAreaEffectClass' has a wrong offset!");
static_assert(offsetof(URGPlasmaLauncherRocketScript, DamageSources) == 0x000108, "Member 'URGPlasmaLauncherRocketScript::DamageSources' has a wrong offset!");
static_assert(offsetof(URGPlasmaLauncherRocketScript, WeaponPrimaryFireDefaultDamageSources) == 0x00010C, "Member 'URGPlasmaLauncherRocketScript::WeaponPrimaryFireDefaultDamageSources' has a wrong offset!");
static_assert(offsetof(URGPlasmaLauncherRocketScript, WeaponSecondaryFireDefaultDamageSources) == 0x000110, "Member 'URGPlasmaLauncherRocketScript::WeaponSecondaryFireDefaultDamageSources' has a wrong offset!");

// Class RGame.RGProjectileEffectScript
// 0x0030 (0x00F0 - 0x00C0)
class URGProjectileEffectScript : public URGScript
{
public:
	class URGScript*                              InstigatorScript;                                  // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URStatusEffectGScript>      StatusEffectClass;                                 // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERDamageFlag                                  CanApplyEffectTo;                                  // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x1F];                                      // 0x00D1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyStatusEffects();
	void K2_ApplyStatusEffects();
	void K2_OnBounce();
	void K2_OnDetonate();
	void K2_OnHit();
	void K2_PostAddMutators();
	void K2_PostDetonate();
	void K2_PostHit();
	void K2_PreHit();
	void K2_ProjectileDisabled();
	void OnBounce();
	void OnDetonate();
	void OnHit();
	void PostAddMutators();
	void PostDetonate();
	void PostHit();
	void PreHit();
	void ProjectileDisabled();

	class ARProjectileBase* GetOwningProjectile() const;
	class URProjectileBaseScript* GetProjectileScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGProjectileEffectScript">();
	}
	static class URGProjectileEffectScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGProjectileEffectScript>();
	}
};
static_assert(alignof(URGProjectileEffectScript) == 0x000008, "Wrong alignment on URGProjectileEffectScript");
static_assert(sizeof(URGProjectileEffectScript) == 0x0000F0, "Wrong size on URGProjectileEffectScript");
static_assert(offsetof(URGProjectileEffectScript, InstigatorScript) == 0x0000C0, "Member 'URGProjectileEffectScript::InstigatorScript' has a wrong offset!");
static_assert(offsetof(URGProjectileEffectScript, StatusEffectClass) == 0x0000C8, "Member 'URGProjectileEffectScript::StatusEffectClass' has a wrong offset!");
static_assert(offsetof(URGProjectileEffectScript, CanApplyEffectTo) == 0x0000D0, "Member 'URGProjectileEffectScript::CanApplyEffectTo' has a wrong offset!");

// Class RGame.RGProjectileMutatorScript
// 0x0010 (0x00D0 - 0x00C0)
class URGProjectileMutatorScript : public URGScript
{
public:
	int32                                         MutatorRank;                                       // 0x00C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRunOnDetonate;                              // 0x00C4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRunPreHit;                                  // 0x00C5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRunOnHit;                                   // 0x00C6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRunPostHit;                                 // 0x00C7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyStatusEffects();
	class FText GetMutatorDescription();
	int32 GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	void K2_ApplyStatusEffects();
	void K2_OnDetonate();
	void K2_OnHit();
	void K2_PostDetonate();
	void K2_PostHit();
	void K2_PreHit();
	void K2_ProjectileDisabled();
	void OnDetonate();
	void OnHit();
	void PostDetonate();
	void PostHit();
	void PreHit();
	void ProjectileDisabled();

	class FText GetDescription() const;
	class ARProjectileBase* GetOwningProjectile() const;
	class URProjectileBaseScript* GetProjectileScript() const;
	bool RollProcChance(int32 Chance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGProjectileMutatorScript">();
	}
	static class URGProjectileMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGProjectileMutatorScript>();
	}
};
static_assert(alignof(URGProjectileMutatorScript) == 0x000008, "Wrong alignment on URGProjectileMutatorScript");
static_assert(sizeof(URGProjectileMutatorScript) == 0x0000D0, "Wrong size on URGProjectileMutatorScript");
static_assert(offsetof(URGProjectileMutatorScript, MutatorRank) == 0x0000C0, "Member 'URGProjectileMutatorScript::MutatorRank' has a wrong offset!");
static_assert(offsetof(URGProjectileMutatorScript, bAlwaysRunOnDetonate) == 0x0000C4, "Member 'URGProjectileMutatorScript::bAlwaysRunOnDetonate' has a wrong offset!");
static_assert(offsetof(URGProjectileMutatorScript, bAlwaysRunPreHit) == 0x0000C5, "Member 'URGProjectileMutatorScript::bAlwaysRunPreHit' has a wrong offset!");
static_assert(offsetof(URGProjectileMutatorScript, bAlwaysRunOnHit) == 0x0000C6, "Member 'URGProjectileMutatorScript::bAlwaysRunOnHit' has a wrong offset!");
static_assert(offsetof(URGProjectileMutatorScript, bAlwaysRunPostHit) == 0x0000C7, "Member 'URGProjectileMutatorScript::bAlwaysRunPostHit' has a wrong offset!");

// Class RGame.RGProjectileTask
// 0x0000 (0x0078 - 0x0078)
class URGProjectileTask : public URGTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGProjectileTask">();
	}
	static class URGProjectileTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGProjectileTask>();
	}
};
static_assert(alignof(URGProjectileTask) == 0x000008, "Wrong alignment on URGProjectileTask");
static_assert(sizeof(URGProjectileTask) == 0x000078, "Wrong size on URGProjectileTask");

// Class RGame.RGrenade
// 0x0130 (0x06E8 - 0x05B8)
class ARGrenade : public ARProjectileBase
{
public:
	float                                         TimeToDetonate;                                    // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseAreaOfEffectRadius;                            // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetonationTracesForObstacles;                     // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetonateOnNPCPawnBaseHit;                         // 0x05C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetonateOnGeometryCollectionHit;                  // 0x05C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunHitSequenceOnDetonate;                         // 0x05C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToSubsequentDetonates;                         // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             GrenadePrimaryHit;                                 // 0x05C8(0x0100)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           GrenadeDetonateHandle;                             // 0x06C8(0x0008)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AOERadiusMultiplier;                               // 0x06D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URGGrenadeScript*                       GrenadeScript;                                     // 0x06D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URGGrenadeScript>           GrenadeClass;                                      // 0x06E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Detonate();
	TArray<struct FHitResult> FetchHitResults();
	void ResetDetonateTimer(float NewTimeToDetonate);
	void SetBaseAreaOfEffectSize(float newBaseAreaOfEffectRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGrenade">();
	}
	static class ARGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARGrenade>();
	}
};
static_assert(alignof(ARGrenade) == 0x000008, "Wrong alignment on ARGrenade");
static_assert(sizeof(ARGrenade) == 0x0006E8, "Wrong size on ARGrenade");
static_assert(offsetof(ARGrenade, TimeToDetonate) == 0x0005B8, "Member 'ARGrenade::TimeToDetonate' has a wrong offset!");
static_assert(offsetof(ARGrenade, BaseAreaOfEffectRadius) == 0x0005BC, "Member 'ARGrenade::BaseAreaOfEffectRadius' has a wrong offset!");
static_assert(offsetof(ARGrenade, bDetonationTracesForObstacles) == 0x0005C0, "Member 'ARGrenade::bDetonationTracesForObstacles' has a wrong offset!");
static_assert(offsetof(ARGrenade, bDetonateOnNPCPawnBaseHit) == 0x0005C1, "Member 'ARGrenade::bDetonateOnNPCPawnBaseHit' has a wrong offset!");
static_assert(offsetof(ARGrenade, bDetonateOnGeometryCollectionHit) == 0x0005C2, "Member 'ARGrenade::bDetonateOnGeometryCollectionHit' has a wrong offset!");
static_assert(offsetof(ARGrenade, bRunHitSequenceOnDetonate) == 0x0005C3, "Member 'ARGrenade::bRunHitSequenceOnDetonate' has a wrong offset!");
static_assert(offsetof(ARGrenade, TimeToSubsequentDetonates) == 0x0005C4, "Member 'ARGrenade::TimeToSubsequentDetonates' has a wrong offset!");
static_assert(offsetof(ARGrenade, GrenadePrimaryHit) == 0x0005C8, "Member 'ARGrenade::GrenadePrimaryHit' has a wrong offset!");
static_assert(offsetof(ARGrenade, GrenadeDetonateHandle) == 0x0006C8, "Member 'ARGrenade::GrenadeDetonateHandle' has a wrong offset!");
static_assert(offsetof(ARGrenade, AOERadiusMultiplier) == 0x0006D0, "Member 'ARGrenade::AOERadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ARGrenade, GrenadeScript) == 0x0006D8, "Member 'ARGrenade::GrenadeScript' has a wrong offset!");
static_assert(offsetof(ARGrenade, GrenadeClass) == 0x0006E0, "Member 'ARGrenade::GrenadeClass' has a wrong offset!");

// Class RGame.RGScriptComponent
// 0x0428 (0x0540 - 0x0118)
class URGScriptComponent : public UGameplayTasksComponent
{
public:
	uint8                                         Pad_118[0x50];                                     // 0x0118(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGScriptActorContext>           ScriptActorContexts;                               // 0x0168(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGScriptActorContext>           ScriptActorContextsNoRep;                          // 0x0178(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URGScript*>                      TickingScripts;                                    // 0x0188(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             CachedHitResult;                                   // 0x0198(0x0100)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGScriptContainer>              ScriptContainers;                                  // 0x0298(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FGScriptContainer>              ScriptContainersNoRep;                             // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class URGTask*>                        Tasks;                                             // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPreHitDamageData                      PreHitDamageData;                                  // 0x02C8(0x0258)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FOnHitDamageData                       OnHitDamageData;                                   // 0x0520(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPostHitDamageData                     PostHitDamageData;                                 // 0x052C(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class URGScript* AddOrExecuteScriptFunction(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, TSubclassOf<class URGScript> ScriptClass, int32 Priority);
	static class URGScript* AddScript(class URGScriptComponent* OwningComponent, class FName Category, TSubclassOf<class URGScript> ScriptClass, int32 Priority, bool bNoRep, class URGScript* InstigatorScript);
	static class URGScript* AddScriptNoActivate(class URGScriptComponent* OwningComponent, class FName Category, TSubclassOf<class URGScript> ScriptClass, int32 Priority, bool bNoRep);
	static void BindOnFinishScriptExecutionByCategory(class URGScriptComponent* OwningComponent, class FName Category, class FName Function, const TDelegate<void(const class FName& Category, const class FName& Function)>& Event);
	static void ClearScripts(class URGScriptComponent* OwningComponent, class FName Category);
	static void ExecuteGenericScriptFunction(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication);
	static void ExecuteGenericScriptFunctionForAllCategories(class URGScriptComponent* OwningComponent, ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication);
	static void ExecuteGenericScriptFunctionWithActorRef(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, class AActor* Actor, EGScriptFunctionReplication Replication);
	static void ExecuteGenericScriptFunctionWithDamageEventRef(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, const struct FDamageCombatEvent& DamageCombatEvent, EGScriptFunctionReplication Replication);
	static void ExecuteGenericScriptFunctionWithGScriptRef(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, class URGScript* GScript, EGScriptFunctionReplication Replication);
	static void ExecuteGenericScriptFunctionWithInt(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, int32 Value, EGScriptFunctionReplication Replication);
	static void ExecuteGenericScriptFunctionWithVector(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, const struct FVector& Value, EGScriptFunctionReplication Replication);
	static TArray<class URStatusEffectAilmentGScript*> GetAllAilmentScripts(class URGScriptComponent* OwningComponent);
	static TArray<class URGEnemyAttackScript*> GetAllEnemyAttackScripts(class URGScriptComponent* OwningComponent);
	static TArray<class URGScript*> GetAllScriptChildrenOfType(class URGScriptComponent* OwningComponent, TSoftClassPtr<class UClass> parentType);
	static TArray<class URGScript*> GetAllScriptsOfType(class URGScriptComponent* OwningComponent, TSoftClassPtr<class UClass> scriptType);
	static TArray<class URStatusEffectGScript*> GetAllStatusEffectScripts(class URGScriptComponent* OwningComponent);
	static class URGScript* GetFirstScriptOfType(class URGScriptComponent* OwningComponent, TSoftClassPtr<class UClass> scriptType);
	static struct FGScriptActorInfo GetGScriptContext(class URGScriptComponent* OwningComponent, class FName Category);
	static class URGScriptComponent* GetRGScriptComponent(class APlayerController* OwningPlayer);
	static class URGScript* GetScriptInCategory(class URGScriptComponent* OwningComponent, class FName Category, TSoftClassPtr<class UClass> scriptType);
	static void K2_ExecuteGenericScriptFunctionWithParams(class URGScriptComponent* OwningComponent, class FName Category, ERGScriptFunction FunctionName, const int32& Params_0, EGScriptFunctionReplication Replication, bool bAllCategories);
	static void RemoveScript(class URGScriptComponent* OwningComponent, class FName Category, class URGScript* Script);
	static void RemoveScriptContext(class URGScriptComponent* OwningComponent, class FName Category);
	static struct FGScriptActorInfo SetGScriptContext(class URGScriptComponent* OwningComponent, class FName Category, class AActor* Owner, class AActor* AvatarActor, class AController* Controller, class URGScriptComponent* InstigatorScriptComponent, bool bNoRep);

	void CacheHitResult(const struct FHitResult& Hit);
	void CancelAllTasks();
	void FreezeAllTasks();
	void MulticastExecuteGenericScriptFunction(class FName Category, ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication, const struct FRGscriptFunctionParams& Params_0);
	void MulticastExecuteGenericScriptFunctionForAllCategories(ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication, const struct FRGscriptFunctionParams& Params_0);
	void MulticastExecuteGenericScriptFunctionWithActorRef(class FName Category, ERGScriptFunction FunctionName, class AActor* Actor, EGScriptFunctionReplication Replication);
	void MulticastExecuteGenericScriptFunctionWithDamageEventRef(class FName Category, ERGScriptFunction FunctionName, const struct FDamageCombatEvent& DamageCombatEvent, EGScriptFunctionReplication Replication);
	void MulticastExecuteGenericScriptFunctionWithGScriptRef(class FName Category, ERGScriptFunction FunctionName, class URGScript* GScript, EGScriptFunctionReplication Replication);
	void MulticastExecuteGenericScriptFunctionWithInt(class FName Category, ERGScriptFunction FunctionName, int32 Value, EGScriptFunctionReplication Replication);
	void MulticastExecuteGenericScriptFunctionWithVector(class FName Category, ERGScriptFunction FunctionName, const struct FVector& Value, EGScriptFunctionReplication Replication);
	void OnRep_ScriptContainers(const TArray<struct FGScriptContainer>& PreviousValue);
	void OnScriptFinishedExecution(class URGScript* Script, class FName Category, class FName ExecutionParam, int32 consumePriority);
	void OverridePreHitDamageData(const struct FPreHitDamageData& NewPreHitDamageData);
	void UnfreezeAllTasks();

	const struct FHitResult GetCachedHitResult() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGScriptComponent">();
	}
	static class URGScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGScriptComponent>();
	}
};
static_assert(alignof(URGScriptComponent) == 0x000008, "Wrong alignment on URGScriptComponent");
static_assert(sizeof(URGScriptComponent) == 0x000540, "Wrong size on URGScriptComponent");
static_assert(offsetof(URGScriptComponent, ScriptActorContexts) == 0x000168, "Member 'URGScriptComponent::ScriptActorContexts' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, ScriptActorContextsNoRep) == 0x000178, "Member 'URGScriptComponent::ScriptActorContextsNoRep' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, TickingScripts) == 0x000188, "Member 'URGScriptComponent::TickingScripts' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, CachedHitResult) == 0x000198, "Member 'URGScriptComponent::CachedHitResult' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, ScriptContainers) == 0x000298, "Member 'URGScriptComponent::ScriptContainers' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, ScriptContainersNoRep) == 0x0002A8, "Member 'URGScriptComponent::ScriptContainersNoRep' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, Tasks) == 0x0002B8, "Member 'URGScriptComponent::Tasks' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, PreHitDamageData) == 0x0002C8, "Member 'URGScriptComponent::PreHitDamageData' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, OnHitDamageData) == 0x000520, "Member 'URGScriptComponent::OnHitDamageData' has a wrong offset!");
static_assert(offsetof(URGScriptComponent, PostHitDamageData) == 0x00052C, "Member 'URGScriptComponent::PostHitDamageData' has a wrong offset!");

// Class RGame.RGSlowStatusEffect
// 0x0020 (0x04F8 - 0x04D8)
class URGSlowStatusEffect final : public URStatusEffectGScript
{
public:
	TArray<class FName>                           EntryKeys;                                         // 0x04D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x10];                                     // 0x04E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEntry(class FName Key, float Duration);
	void K2_OnAddEntry(class FName Key, float Duration);
	void K2_OnRemoveEntry(class FName Key);
	void RefreshEntriesWithDuration();
	void RemoveEntry(class FName Key, bool bRefreshEntriesWithDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGSlowStatusEffect">();
	}
	static class URGSlowStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGSlowStatusEffect>();
	}
};
static_assert(alignof(URGSlowStatusEffect) == 0x000008, "Wrong alignment on URGSlowStatusEffect");
static_assert(sizeof(URGSlowStatusEffect) == 0x0004F8, "Wrong size on URGSlowStatusEffect");
static_assert(offsetof(URGSlowStatusEffect, EntryKeys) == 0x0004D8, "Member 'URGSlowStatusEffect::EntryKeys' has a wrong offset!");

// Class RGame.RGSpiritOrbRocketScript
// 0x0038 (0x0120 - 0x00E8)
class URGSpiritOrbRocketScript : public URGRocketScript
{
public:
	TArray<class URCharacterMutatorPrimaryAsset*> SpiritBehaviorMutatorPAs;                          // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class URMutatorPrimaryAsset*                  SpiritPassive4MutatorPA;                           // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpiritChargeGainMutatorValueArrayIndex;            // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  SpiritPassive8MutatorPA;                           // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URStatusEffectGScript>      SpiritPassive8StatusEffectClass;                   // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageSources;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGSpiritOrbRocketScript">();
	}
	static class URGSpiritOrbRocketScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGSpiritOrbRocketScript>();
	}
};
static_assert(alignof(URGSpiritOrbRocketScript) == 0x000008, "Wrong alignment on URGSpiritOrbRocketScript");
static_assert(sizeof(URGSpiritOrbRocketScript) == 0x000120, "Wrong size on URGSpiritOrbRocketScript");
static_assert(offsetof(URGSpiritOrbRocketScript, SpiritBehaviorMutatorPAs) == 0x0000E8, "Member 'URGSpiritOrbRocketScript::SpiritBehaviorMutatorPAs' has a wrong offset!");
static_assert(offsetof(URGSpiritOrbRocketScript, SpiritPassive4MutatorPA) == 0x0000F8, "Member 'URGSpiritOrbRocketScript::SpiritPassive4MutatorPA' has a wrong offset!");
static_assert(offsetof(URGSpiritOrbRocketScript, SpiritChargeGainMutatorValueArrayIndex) == 0x000100, "Member 'URGSpiritOrbRocketScript::SpiritChargeGainMutatorValueArrayIndex' has a wrong offset!");
static_assert(offsetof(URGSpiritOrbRocketScript, SpiritPassive8MutatorPA) == 0x000108, "Member 'URGSpiritOrbRocketScript::SpiritPassive8MutatorPA' has a wrong offset!");
static_assert(offsetof(URGSpiritOrbRocketScript, SpiritPassive8StatusEffectClass) == 0x000110, "Member 'URGSpiritOrbRocketScript::SpiritPassive8StatusEffectClass' has a wrong offset!");
static_assert(offsetof(URGSpiritOrbRocketScript, DamageSources) == 0x000118, "Member 'URGSpiritOrbRocketScript::DamageSources' has a wrong offset!");

// Class RGame.RGTask_AddRecoil
// 0x0020 (0x0098 - 0x0078)
class URGTask_AddRecoil final : public URGWeaponTask
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRecoilAdded;                                     // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URGTask_AddRecoil* AddRecoil(class URGScript* OwningScript, class FName RecoilAnimOverride, float CooldownOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_AddRecoil">();
	}
	static class URGTask_AddRecoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_AddRecoil>();
	}
};
static_assert(alignof(URGTask_AddRecoil) == 0x000008, "Wrong alignment on URGTask_AddRecoil");
static_assert(sizeof(URGTask_AddRecoil) == 0x000098, "Wrong size on URGTask_AddRecoil");
static_assert(offsetof(URGTask_AddRecoil, OnRecoilAdded) == 0x000088, "Member 'URGTask_AddRecoil::OnRecoilAdded' has a wrong offset!");

// Class RGame.RGTask_DelayedWhile
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) URGTask_DelayedWhile final : public URGTask
{
public:
	TMulticastInlineDelegate<void()>              LoopBody;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TimeBetweenTicks;                                  // 0x0098(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x44];                                      // 0x009C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_DelayedWhile* DelayedWhile(class URGScript* OwningScript, const float& TimeBetweenTicks_0, TDelegate<void(bool* RetValue)> Predicate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_DelayedWhile">();
	}
	static class URGTask_DelayedWhile* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_DelayedWhile>();
	}
};
static_assert(alignof(URGTask_DelayedWhile) == 0x000010, "Wrong alignment on URGTask_DelayedWhile");
static_assert(sizeof(URGTask_DelayedWhile) == 0x0000E0, "Wrong size on URGTask_DelayedWhile");
static_assert(offsetof(URGTask_DelayedWhile, LoopBody) == 0x000078, "Member 'URGTask_DelayedWhile::LoopBody' has a wrong offset!");
static_assert(offsetof(URGTask_DelayedWhile, OnFinish) == 0x000088, "Member 'URGTask_DelayedWhile::OnFinish' has a wrong offset!");
static_assert(offsetof(URGTask_DelayedWhile, TimeBetweenTicks) == 0x000098, "Member 'URGTask_DelayedWhile::TimeBetweenTicks' has a wrong offset!");

// Class RGame.RGTask_PlayAnimation
// 0x0080 (0x00F8 - 0x0078)
class URGTask_PlayAnimation final : public URGTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBlendOut;                                        // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInterrupted;                                     // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelled;                                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate;                                          // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SectionName;                                       // 0x00EC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x00F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_PlayAnimation* CreatePlayMontageAndWaitProxy(class URGScript* OwningScript, class UAnimMontage* MontageToPlay_0, class FName SectionName_0, float PlayRate_0, bool bStopWhenAbilityEnds_0);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_PlayAnimation">();
	}
	static class URGTask_PlayAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_PlayAnimation>();
	}
};
static_assert(alignof(URGTask_PlayAnimation) == 0x000008, "Wrong alignment on URGTask_PlayAnimation");
static_assert(sizeof(URGTask_PlayAnimation) == 0x0000F8, "Wrong size on URGTask_PlayAnimation");
static_assert(offsetof(URGTask_PlayAnimation, OnCompleted) == 0x000078, "Member 'URGTask_PlayAnimation::OnCompleted' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, OnBlendOut) == 0x000088, "Member 'URGTask_PlayAnimation::OnBlendOut' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, OnInterrupted) == 0x000098, "Member 'URGTask_PlayAnimation::OnInterrupted' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, OnCancelled) == 0x0000A8, "Member 'URGTask_PlayAnimation::OnCancelled' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, MontageToPlay) == 0x0000E0, "Member 'URGTask_PlayAnimation::MontageToPlay' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, PlayRate) == 0x0000E8, "Member 'URGTask_PlayAnimation::PlayRate' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, SectionName) == 0x0000EC, "Member 'URGTask_PlayAnimation::SectionName' has a wrong offset!");
static_assert(offsetof(URGTask_PlayAnimation, bStopWhenAbilityEnds) == 0x0000F4, "Member 'URGTask_PlayAnimation::bStopWhenAbilityEnds' has a wrong offset!");

// Class RGame.RGTask_PlayPlayerSound
// 0x0060 (0x00D8 - 0x0078)
class URGTask_PlayPlayerSound final : public URGTask
{
public:
	TMulticastInlineDelegate<void()>              OnSoundPlayed;                                     // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x40];                                      // 0x0098(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_PlayPlayerSound* PlayPlayerSound(class URGScript* OwningScript, class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_PlayPlayerSound">();
	}
	static class URGTask_PlayPlayerSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_PlayPlayerSound>();
	}
};
static_assert(alignof(URGTask_PlayPlayerSound) == 0x000008, "Wrong alignment on URGTask_PlayPlayerSound");
static_assert(sizeof(URGTask_PlayPlayerSound) == 0x0000D8, "Wrong size on URGTask_PlayPlayerSound");
static_assert(offsetof(URGTask_PlayPlayerSound, OnSoundPlayed) == 0x000078, "Member 'URGTask_PlayPlayerSound::OnSoundPlayed' has a wrong offset!");
static_assert(offsetof(URGTask_PlayPlayerSound, OnFailed) == 0x000088, "Member 'URGTask_PlayPlayerSound::OnFailed' has a wrong offset!");

// Class RGame.RGTask_PredicateCheck
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) URGTask_PredicateCheck final : public URGTask
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x48];                                      // 0x0098(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_PredicateCheck* PredicateCheck(class URGScript* OwningScript, TDelegate<void(bool* RetValue)> Predicate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_PredicateCheck">();
	}
	static class URGTask_PredicateCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_PredicateCheck>();
	}
};
static_assert(alignof(URGTask_PredicateCheck) == 0x000010, "Wrong alignment on URGTask_PredicateCheck");
static_assert(sizeof(URGTask_PredicateCheck) == 0x0000E0, "Wrong size on URGTask_PredicateCheck");
static_assert(offsetof(URGTask_PredicateCheck, onSuccess) == 0x000078, "Member 'URGTask_PredicateCheck::onSuccess' has a wrong offset!");
static_assert(offsetof(URGTask_PredicateCheck, OnFailed) == 0x000088, "Member 'URGTask_PredicateCheck::OnFailed' has a wrong offset!");

// Class RGame.RGTask_ReloadWeapon
// 0x0020 (0x0098 - 0x0078)
class URGTask_ReloadWeapon final : public URGWeaponTask
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URGTask_ReloadWeapon* ReloadWeapon(class URGScript* OwningScript);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_ReloadWeapon">();
	}
	static class URGTask_ReloadWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_ReloadWeapon>();
	}
};
static_assert(alignof(URGTask_ReloadWeapon) == 0x000008, "Wrong alignment on URGTask_ReloadWeapon");
static_assert(sizeof(URGTask_ReloadWeapon) == 0x000098, "Wrong size on URGTask_ReloadWeapon");
static_assert(offsetof(URGTask_ReloadWeapon, OnFinish) == 0x000078, "Member 'URGTask_ReloadWeapon::OnFinish' has a wrong offset!");
static_assert(offsetof(URGTask_ReloadWeapon, OnFail) == 0x000088, "Member 'URGTask_ReloadWeapon::OnFail' has a wrong offset!");

// Class RGame.RGTask_ScopeWeapon
// 0x0028 (0x00A0 - 0x0078)
class URGTask_ScopeWeapon final : public URGWeaponTask
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URGTask_ScopeWeapon* ScopeWeapon(class URGScript* OwningScript, bool bScopeIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_ScopeWeapon">();
	}
	static class URGTask_ScopeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_ScopeWeapon>();
	}
};
static_assert(alignof(URGTask_ScopeWeapon) == 0x000008, "Wrong alignment on URGTask_ScopeWeapon");
static_assert(sizeof(URGTask_ScopeWeapon) == 0x0000A0, "Wrong size on URGTask_ScopeWeapon");
static_assert(offsetof(URGTask_ScopeWeapon, OnFinish) == 0x000080, "Member 'URGTask_ScopeWeapon::OnFinish' has a wrong offset!");
static_assert(offsetof(URGTask_ScopeWeapon, OnFail) == 0x000090, "Member 'URGTask_ScopeWeapon::OnFail' has a wrong offset!");

// Class RGame.RGTask_SpawnAreaEffect
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) URGTask_SpawnAreaEffect final : public URGTask
{
public:
	uint8                                         Pad_78[0x80];                                      // 0x0078(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ARAreaEffect* GroundEffect)> OnGroundEffectSpawned;          // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_SpawnAreaEffect* SpawnAreaEffect(class URGScript* OwningScript, TSubclassOf<class ARAreaEffect> InAreaEffectClass, const struct FTransform& InSpawnTransform, float InLifetime, class AActor* InOptionalOwningActor, class APawn* InOptionalInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_SpawnAreaEffect">();
	}
	static class URGTask_SpawnAreaEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_SpawnAreaEffect>();
	}
};
static_assert(alignof(URGTask_SpawnAreaEffect) == 0x000010, "Wrong alignment on URGTask_SpawnAreaEffect");
static_assert(sizeof(URGTask_SpawnAreaEffect) == 0x000120, "Wrong size on URGTask_SpawnAreaEffect");
static_assert(offsetof(URGTask_SpawnAreaEffect, OnGroundEffectSpawned) == 0x0000F8, "Member 'URGTask_SpawnAreaEffect::OnGroundEffectSpawned' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnAreaEffect, OnFail) == 0x000108, "Member 'URGTask_SpawnAreaEffect::OnFail' has a wrong offset!");

// Class RGame.RGTask_SpawnNonWeaponProjectile
// 0x0098 (0x0110 - 0x0078)
class alignas(0x10) URGTask_SpawnNonWeaponProjectile final : public URGTask
{
public:
	TMulticastInlineDelegate<void(class ARProjectileBase* Projectile)> OnProjectileSpawned;          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x78];                                      // 0x0098(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_SpawnNonWeaponProjectile* SpawnNonWeaponProjectile(class URGScript* OwningScript, TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FTransform& ProjectileSpawnTransform, float BaseDamage, float BaseCriticalMultiplier, float BaseEffectiveRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_SpawnNonWeaponProjectile">();
	}
	static class URGTask_SpawnNonWeaponProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_SpawnNonWeaponProjectile>();
	}
};
static_assert(alignof(URGTask_SpawnNonWeaponProjectile) == 0x000010, "Wrong alignment on URGTask_SpawnNonWeaponProjectile");
static_assert(sizeof(URGTask_SpawnNonWeaponProjectile) == 0x000110, "Wrong size on URGTask_SpawnNonWeaponProjectile");
static_assert(offsetof(URGTask_SpawnNonWeaponProjectile, OnProjectileSpawned) == 0x000078, "Member 'URGTask_SpawnNonWeaponProjectile::OnProjectileSpawned' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnNonWeaponProjectile, OnFail) == 0x000088, "Member 'URGTask_SpawnNonWeaponProjectile::OnFail' has a wrong offset!");

// Class RGame.RGTask_SpawnProjectile
// 0x0088 (0x0100 - 0x0078)
class URGTask_SpawnProjectile final : public URGWeaponTask
{
public:
	TMulticastInlineDelegate<void(class ARProjectileBase* Projectile)> OnProjectileSpawned;          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x68];                                      // 0x0098(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_SpawnProjectile* SpawnProjectile(class URGScript* OwningScript, TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FVector& projectileSpawnOffset, const struct FRotator& OffsetRotation, bool OverrideSpawnDirection, const struct FVector& SpawnDirectionOverride, bool useWeaponDamage, class URGWeaponModScript* WeaponScriptSpawner, bool RegisterLastTimeFired, bool IgnoreSpread, bool TriggerPrimaryFireFX);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_SpawnProjectile">();
	}
	static class URGTask_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_SpawnProjectile>();
	}
};
static_assert(alignof(URGTask_SpawnProjectile) == 0x000008, "Wrong alignment on URGTask_SpawnProjectile");
static_assert(sizeof(URGTask_SpawnProjectile) == 0x000100, "Wrong size on URGTask_SpawnProjectile");
static_assert(offsetof(URGTask_SpawnProjectile, OnProjectileSpawned) == 0x000078, "Member 'URGTask_SpawnProjectile::OnProjectileSpawned' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnProjectile, OnFail) == 0x000088, "Member 'URGTask_SpawnProjectile::OnFail' has a wrong offset!");

// Class RGame.RGTask_SpawnProjectileHitEffects
// 0x0028 (0x00A0 - 0x0078)
class URGTask_SpawnProjectileHitEffects final : public URGProjectileTask
{
public:
	TMulticastInlineDelegate<void()>              OnEffectSpawned;                                   // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_SpawnProjectileHitEffects* SpawnProjectileHitEffect(class URGScript* OwningScript, class FName OverrideTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_SpawnProjectileHitEffects">();
	}
	static class URGTask_SpawnProjectileHitEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_SpawnProjectileHitEffects>();
	}
};
static_assert(alignof(URGTask_SpawnProjectileHitEffects) == 0x000008, "Wrong alignment on URGTask_SpawnProjectileHitEffects");
static_assert(sizeof(URGTask_SpawnProjectileHitEffects) == 0x0000A0, "Wrong size on URGTask_SpawnProjectileHitEffects");
static_assert(offsetof(URGTask_SpawnProjectileHitEffects, OnEffectSpawned) == 0x000078, "Member 'URGTask_SpawnProjectileHitEffects::OnEffectSpawned' has a wrong offset!");
static_assert(offsetof(URGTask_SpawnProjectileHitEffects, OnFailed) == 0x000088, "Member 'URGTask_SpawnProjectileHitEffects::OnFailed' has a wrong offset!");

// Class RGame.RGTask_TimeLoop
// 0x0028 (0x00A0 - 0x0078)
class URGTask_TimeLoop final : public URGTask
{
public:
	TMulticastInlineDelegate<void(float DeltaSeconds, float Time)> LoopBody;                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_TimeLoop* TimeLoop(class URGScript* OwningScript, float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_TimeLoop">();
	}
	static class URGTask_TimeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_TimeLoop>();
	}
};
static_assert(alignof(URGTask_TimeLoop) == 0x000008, "Wrong alignment on URGTask_TimeLoop");
static_assert(sizeof(URGTask_TimeLoop) == 0x0000A0, "Wrong size on URGTask_TimeLoop");
static_assert(offsetof(URGTask_TimeLoop, LoopBody) == 0x000078, "Member 'URGTask_TimeLoop::LoopBody' has a wrong offset!");
static_assert(offsetof(URGTask_TimeLoop, OnFinish) == 0x000088, "Member 'URGTask_TimeLoop::OnFinish' has a wrong offset!");

// Class RGame.RGTask_TurnAndWait
// 0x0028 (0x00A0 - 0x0078)
class URGTask_TurnAndWait final : public URGTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class AActor*                                 TargetActor;                                       // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTime;                                       // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FinishTime;                                        // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARPawnBase*                             PawnRef;                                           // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class URGTask_TurnAndWait* TurnAndWait(class URGScript* OwningScript, class AActor* TargetActor_0, float TurningDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_TurnAndWait">();
	}
	static class URGTask_TurnAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_TurnAndWait>();
	}
};
static_assert(alignof(URGTask_TurnAndWait) == 0x000008, "Wrong alignment on URGTask_TurnAndWait");
static_assert(sizeof(URGTask_TurnAndWait) == 0x0000A0, "Wrong size on URGTask_TurnAndWait");
static_assert(offsetof(URGTask_TurnAndWait, OnCompleted) == 0x000078, "Member 'URGTask_TurnAndWait::OnCompleted' has a wrong offset!");
static_assert(offsetof(URGTask_TurnAndWait, TargetActor) == 0x000088, "Member 'URGTask_TurnAndWait::TargetActor' has a wrong offset!");
static_assert(offsetof(URGTask_TurnAndWait, CurrentTime) == 0x000090, "Member 'URGTask_TurnAndWait::CurrentTime' has a wrong offset!");
static_assert(offsetof(URGTask_TurnAndWait, FinishTime) == 0x000094, "Member 'URGTask_TurnAndWait::FinishTime' has a wrong offset!");
static_assert(offsetof(URGTask_TurnAndWait, PawnRef) == 0x000098, "Member 'URGTask_TurnAndWait::PawnRef' has a wrong offset!");

// Class RGame.RGTask_UpdateAmmoInClip
// 0x0028 (0x00A0 - 0x0078)
class URGTask_UpdateAmmoInClip final : public URGWeaponTask
{
public:
	TMulticastInlineDelegate<void()>              OnAmmoUpdated;                                     // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFail;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_UpdateAmmoInClip* UpdateAmmoInClip(class URGScript* OptionalOwningScript, int32 Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_UpdateAmmoInClip">();
	}
	static class URGTask_UpdateAmmoInClip* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_UpdateAmmoInClip>();
	}
};
static_assert(alignof(URGTask_UpdateAmmoInClip) == 0x000008, "Wrong alignment on URGTask_UpdateAmmoInClip");
static_assert(sizeof(URGTask_UpdateAmmoInClip) == 0x0000A0, "Wrong size on URGTask_UpdateAmmoInClip");
static_assert(offsetof(URGTask_UpdateAmmoInClip, OnAmmoUpdated) == 0x000078, "Member 'URGTask_UpdateAmmoInClip::OnAmmoUpdated' has a wrong offset!");
static_assert(offsetof(URGTask_UpdateAmmoInClip, OnFail) == 0x000088, "Member 'URGTask_UpdateAmmoInClip::OnFail' has a wrong offset!");

// Class RGame.RGTask_WaitDelay
// 0x0030 (0x00A8 - 0x0078)
class URGTask_WaitDelay final : public URGTask
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelled;                                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URGTask_WaitDelay* WaitDelay(class URGScript* OwningScript, float Time);

	void IncreaseTimer(class URGScript* OwningScript, float Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTask_WaitDelay">();
	}
	static class URGTask_WaitDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTask_WaitDelay>();
	}
};
static_assert(alignof(URGTask_WaitDelay) == 0x000008, "Wrong alignment on URGTask_WaitDelay");
static_assert(sizeof(URGTask_WaitDelay) == 0x0000A8, "Wrong size on URGTask_WaitDelay");
static_assert(offsetof(URGTask_WaitDelay, OnFinish) == 0x000078, "Member 'URGTask_WaitDelay::OnFinish' has a wrong offset!");
static_assert(offsetof(URGTask_WaitDelay, OnCancelled) == 0x000088, "Member 'URGTask_WaitDelay::OnCancelled' has a wrong offset!");

// Class RGame.RGTentacleBuffProjectileScript
// 0x0008 (0x00E8 - 0x00E0)
class URGTentacleBuffProjectileScript : public URGProjectileScript
{
public:
	TSubclassOf<class URStatusEffectGScript>      OceanGodPlayerBuffStatusEffect;                    // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTentacleBuffProjectileScript">();
	}
	static class URGTentacleBuffProjectileScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTentacleBuffProjectileScript>();
	}
};
static_assert(alignof(URGTentacleBuffProjectileScript) == 0x000008, "Wrong alignment on URGTentacleBuffProjectileScript");
static_assert(sizeof(URGTentacleBuffProjectileScript) == 0x0000E8, "Wrong size on URGTentacleBuffProjectileScript");
static_assert(offsetof(URGTentacleBuffProjectileScript, OceanGodPlayerBuffStatusEffect) == 0x0000E0, "Member 'URGTentacleBuffProjectileScript::OceanGodPlayerBuffStatusEffect' has a wrong offset!");

// Class RGame.RGTurretProjectileScript
// 0x0008 (0x00E8 - 0x00E0)
class URGTurretProjectileScript : public URGProjectileScript
{
public:
	int32                                         DamageSources;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGTurretProjectileScript">();
	}
	static class URGTurretProjectileScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGTurretProjectileScript>();
	}
};
static_assert(alignof(URGTurretProjectileScript) == 0x000008, "Wrong alignment on URGTurretProjectileScript");
static_assert(sizeof(URGTurretProjectileScript) == 0x0000E8, "Wrong size on URGTurretProjectileScript");
static_assert(offsetof(URGTurretProjectileScript, DamageSources) == 0x0000E0, "Member 'URGTurretProjectileScript::DamageSources' has a wrong offset!");

// Class RGame.RGWeaponModScript
// 0x0050 (0x0120 - 0x00D0)
class URGWeaponModScript : public URGWeaponMutatorScript
{
public:
	bool                                          bIgnoreWeaponROF;                                  // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterLastTimeFired;                            // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponModType                                WeaponModType;                                     // 0x00D2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresScoped;                                   // 0x00D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCurrentAmmo;                                // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoReloadWhenMagEmpty;                           // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantReloadWhenMagEmpty;                        // 0x00D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool IsPrimaryMod)> OnWeaponModFire;                               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool IsPrimaryMod)> OnWeaponModPostFire;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class URCrosshair>                CrosshairClass;                                    // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBaseWeaponSettings*                   WeaponModStats;                                    // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCustomFanSolution;                             // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0xF];                                      // 0x0109(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         NativeCachedBulletlineSystem;                      // 0x0118(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AlterRemainingCooldown(float DeltaSeconds);
	void ApplyFireSettings(class URBaseWeaponSettings* FireSettings);
	void ApplyThisFireSettings();
	void FanFire(const struct FRotator& RotationOffset);
	void FinishFire();
	void Fire();
	void FireProjectile(int32 AmmoCost, int32 BarrelIndex, TSubclassOf<class ARProjectileBase> ProjectileClass, const struct FVector& SpawnOffset, const struct FRotator& RotationOffset, bool bUseWeaponDamage, float ROFOverride, bool bSkipRecoil, bool bRunFanFireBehavior);
	void InterruptFireSequence();
	void NativeSpawnBulletline(const struct FVector& Forward);
	void PostFire();
	void PreFire();
	void RetryFire(bool bSkipFireSequenceCheck);
	void SetModScriptLastTimeFired(float LastTimeFired);
	void SpawnFX(TSubclassOf<class URNiagaraComponent> RNiagaraComponent, class USoundBase* SoundTemplate, TSubclassOf<class UCameraShakeBase> CameraShakeTemplate);
	void SpawnWeaponFireCameraShake(TSubclassOf<class UCameraShakeBase> CameraShakeTemplate);
	void SpawnWeaponFireFX(TSubclassOf<class URNiagaraComponent> RNiagaraComponent);
	void SpawnWeaponFireSFX(class USoundBase* SoundTemplate);
	void TriggerReload();
	void TryFire();

	float GetFloatWeaponModCurrentStat(EFloatWeaponStat Stat) const;
	float GetRemainingCooldown() const;
	float GetRemainingCooldownPercentage() const;
	bool IsPrimaryFire() const;
	bool IsSecondaryFire() const;
	bool IsWeaponHoldingFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGWeaponModScript">();
	}
	static class URGWeaponModScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGWeaponModScript>();
	}
};
static_assert(alignof(URGWeaponModScript) == 0x000008, "Wrong alignment on URGWeaponModScript");
static_assert(sizeof(URGWeaponModScript) == 0x000120, "Wrong size on URGWeaponModScript");
static_assert(offsetof(URGWeaponModScript, bIgnoreWeaponROF) == 0x0000D0, "Member 'URGWeaponModScript::bIgnoreWeaponROF' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, bRegisterLastTimeFired) == 0x0000D1, "Member 'URGWeaponModScript::bRegisterLastTimeFired' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, WeaponModType) == 0x0000D2, "Member 'URGWeaponModScript::WeaponModType' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, bRequiresScoped) == 0x0000D3, "Member 'URGWeaponModScript::bRequiresScoped' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, bIgnoreCurrentAmmo) == 0x0000D4, "Member 'URGWeaponModScript::bIgnoreCurrentAmmo' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, bAutoReloadWhenMagEmpty) == 0x0000D5, "Member 'URGWeaponModScript::bAutoReloadWhenMagEmpty' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, bInstantReloadWhenMagEmpty) == 0x0000D6, "Member 'URGWeaponModScript::bInstantReloadWhenMagEmpty' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, OnWeaponModFire) == 0x0000D8, "Member 'URGWeaponModScript::OnWeaponModFire' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, OnWeaponModPostFire) == 0x0000E8, "Member 'URGWeaponModScript::OnWeaponModPostFire' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, CrosshairClass) == 0x0000F8, "Member 'URGWeaponModScript::CrosshairClass' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, WeaponModStats) == 0x000100, "Member 'URGWeaponModScript::WeaponModStats' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, bHasCustomFanSolution) == 0x000108, "Member 'URGWeaponModScript::bHasCustomFanSolution' has a wrong offset!");
static_assert(offsetof(URGWeaponModScript, NativeCachedBulletlineSystem) == 0x000118, "Member 'URGWeaponModScript::NativeCachedBulletlineSystem' has a wrong offset!");

// Class RGame.RGenericWeaponSettings
// 0x0B10 (0x0B40 - 0x0030)
class URGenericWeaponSettings final : public UDataAsset
{
public:
	struct FRMutableFloat                         WeaponDamage;                                      // 0x0030(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         WeaponCriticalMultiplier;                          // 0x0158(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         RateOfFire;                                        // 0x0280(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         Recoil;                                            // 0x03A8(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         Spread;                                            // 0x04D0(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         ScopedSpread;                                      // 0x05F8(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTransform                             ScopedInTransform;                                 // 0x0720(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         ReloadTime;                                        // 0x0780(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableInteger                       ClipSize;                                          // 0x08A8(0x0120)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         EffectiveRange;                                    // 0x09C8(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinimumSpreadMultiplier;                           // 0x0AF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceProjectileSpreadTime;                        // 0x0AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARProjectileBase>           ProjectileClass;                                   // 0x0AF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ProjectileDummyClass;                              // 0x0B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectileTraceOffset;                             // 0x0B08(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScopedProjectileTraceOffset;                       // 0x0B20(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARProjectileBase*                       LastSpawnedProjectile;                             // 0x0B38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGenericWeaponSettings">();
	}
	static class URGenericWeaponSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGenericWeaponSettings>();
	}
};
static_assert(alignof(URGenericWeaponSettings) == 0x000010, "Wrong alignment on URGenericWeaponSettings");
static_assert(sizeof(URGenericWeaponSettings) == 0x000B40, "Wrong size on URGenericWeaponSettings");
static_assert(offsetof(URGenericWeaponSettings, WeaponDamage) == 0x000030, "Member 'URGenericWeaponSettings::WeaponDamage' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, WeaponCriticalMultiplier) == 0x000158, "Member 'URGenericWeaponSettings::WeaponCriticalMultiplier' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, RateOfFire) == 0x000280, "Member 'URGenericWeaponSettings::RateOfFire' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, Recoil) == 0x0003A8, "Member 'URGenericWeaponSettings::Recoil' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, Spread) == 0x0004D0, "Member 'URGenericWeaponSettings::Spread' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ScopedSpread) == 0x0005F8, "Member 'URGenericWeaponSettings::ScopedSpread' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ScopedInTransform) == 0x000720, "Member 'URGenericWeaponSettings::ScopedInTransform' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ReloadTime) == 0x000780, "Member 'URGenericWeaponSettings::ReloadTime' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ClipSize) == 0x0008A8, "Member 'URGenericWeaponSettings::ClipSize' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, EffectiveRange) == 0x0009C8, "Member 'URGenericWeaponSettings::EffectiveRange' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, MinimumSpreadMultiplier) == 0x000AF0, "Member 'URGenericWeaponSettings::MinimumSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ReduceProjectileSpreadTime) == 0x000AF4, "Member 'URGenericWeaponSettings::ReduceProjectileSpreadTime' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ProjectileClass) == 0x000AF8, "Member 'URGenericWeaponSettings::ProjectileClass' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ProjectileDummyClass) == 0x000B00, "Member 'URGenericWeaponSettings::ProjectileDummyClass' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ProjectileTraceOffset) == 0x000B08, "Member 'URGenericWeaponSettings::ProjectileTraceOffset' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, ScopedProjectileTraceOffset) == 0x000B20, "Member 'URGenericWeaponSettings::ScopedProjectileTraceOffset' has a wrong offset!");
static_assert(offsetof(URGenericWeaponSettings, LastSpawnedProjectile) == 0x000B38, "Member 'URGenericWeaponSettings::LastSpawnedProjectile' has a wrong offset!");

// Class RGame.RGWeaponScript
// 0x03E8 (0x04A8 - 0x00C0)
class URGWeaponScript : public URGScript
{
public:
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoInClip;                                        // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntegerWeaponSetting                  ClipSize;                                          // 0x00E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFloatWeaponSetting                    ReloadTime;                                        // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class URBaseWeaponSettings*                   WeaponBaseSettings;                                // 0x0108(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMutableWeaponSettings*                WeaponMutableSettings;                             // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         RetriggerableExplosionChance;                      // 0x0118(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         RetriggerableExplosionChanceDiminishingReturn;     // 0x0240(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	class URGlobalWeaponModifiers*                GlobalWeaponModifiers;                             // 0x0368(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URGWeaponModScript*                     PrimaryWeaponModScript;                            // 0x0370(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URGWeaponModScript*                     SecondaryWeaponModScript;                          // 0x0378(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URGWeaponModScript*>             StatWeaponModScripts;                              // 0x0380(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ARProjectileBase*                       LastSpawnedProjectile;                             // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOnHitDamageData                       LatestProjectileHitDamageData;                     // 0x0398(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x34];                                     // 0x03A4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasSingleShotReload;                              // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnWeaponReload;                                    // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bReloadGrantsAmmo;                                 // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0xB7];                                     // 0x03F1(0x00B7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientReloaded();
	void ExecuteWeaponScriptFunction(ERGScriptFunction FunctionName, EGScriptFunctionReplication Replication);
	void ExecuteWeaponScriptFunctionWithActorRef(ERGScriptFunction FunctionName, class AActor* Actor, EGScriptFunctionReplication Replication);
	void ExecuteWeaponScriptFunctionWithInt(ERGScriptFunction FunctionName, int32 Value, EGScriptFunctionReplication Replication);
	void ExecuteWeaponScriptFunctionWithVector(ERGScriptFunction FunctionName, const struct FVector& Value, EGScriptFunctionReplication Replication);
	void FinishReload();
	bool GetIsScoped();
	void InterruptReload();
	void K2_OnBeginFire();
	void K2_OnBeginSecondaryFire();
	void K2_OnEndFire();
	void K2_OnEndSecondaryFire();
	void K2_OnEnemyKilled(class AActor* KilledActor);
	void K2_OnEquip();
	void K2_OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile);
	void K2_OnProjectileSpawnedClientDummy(const struct FVector& Direction);
	void K2_OnReload();
	void K2_OnReloadFinished();
	void K2_OnUnequip();
	void MulticastSetAmmoInClip(int32 NewAmmo);
	void OnBeginFire(int32 CurrentAmmo);
	void OnBeginSecondaryFire(int32 CurrentAmmo);
	void OnEndFire();
	void OnEndSecondaryFire();
	void OnEnemyKilled(class AActor* KilledActor);
	void OnEquip();
	void OnProjectileSpawned(class ARProjectileBase* SpawnedProjectile);
	void OnProjectileSpawnedClientDummy(const struct FVector& Direction);
	void OnReload();
	void OnReloadFinished();
	void OnRep_AmmoInClip();
	void OnUnequip();
	void ReloadAmmo();
	void ServerRequestReload();
	void SetBaseWeaponSettings(class URBaseWeaponSettings* BaseSettings);
	void SetHasSingleShotReload(bool bSingleShotReload);
	void SetIsAiming(const bool bAiming);
	void SetIsScoped(bool bScoped);
	void SetLastTimeFired();
	void TryReload();

	float CalculateAilmentProcChance(EFloatWeaponStat ChanceStat) const;
	float CalculateProcChance() const;
	int32 GetAmmoInClip() const;
	class URBaseWeaponSettings* GetBaseWeaponSettings() const;
	float GetFloatWeaponStat(EFloatWeaponStat Stat) const;
	class URGlobalWeaponModifiers* GetGlobalWeaponModifiers() const;
	bool GetInputHoldingFire() const;
	bool GetInputHoldingSecondaryFire() const;
	int32 GetIntegerWeaponStat(EIntegerWeaponStat Stat) const;
	float GetLastTimeFired() const;
	class URMutableWeaponSettings* GetMutableWeaponSettings() const;
	class FName GetMuzzleSocketName() const;
	TSubclassOf<class ARProjectileBase> GetProjectileClass() const;
	TSubclassOf<class AActor> GetProjectileDummyClass() const;
	float GetRandomSpreadNormalDistribution(struct FVector2D* SpreadError) const;
	float GetROFTime() const;
	float GetROFWaitTime() const;
	float GetSpread() const;
	float GetSpreadMultiplier() const;
	class ARWeapon* GetWeaponActor() const;
	float RollAilmentProcChance(EFloatWeaponStat ChanceStat) const;
	bool RollProcChance(const float Chance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGWeaponScript">();
	}
	static class URGWeaponScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGWeaponScript>();
	}
};
static_assert(alignof(URGWeaponScript) == 0x000008, "Wrong alignment on URGWeaponScript");
static_assert(sizeof(URGWeaponScript) == 0x0004A8, "Wrong size on URGWeaponScript");
static_assert(offsetof(URGWeaponScript, AmmoInClip) == 0x0000E0, "Member 'URGWeaponScript::AmmoInClip' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, ClipSize) == 0x0000E4, "Member 'URGWeaponScript::ClipSize' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, ReloadTime) == 0x0000F0, "Member 'URGWeaponScript::ReloadTime' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, WeaponBaseSettings) == 0x000108, "Member 'URGWeaponScript::WeaponBaseSettings' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, WeaponMutableSettings) == 0x000110, "Member 'URGWeaponScript::WeaponMutableSettings' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, RetriggerableExplosionChance) == 0x000118, "Member 'URGWeaponScript::RetriggerableExplosionChance' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, RetriggerableExplosionChanceDiminishingReturn) == 0x000240, "Member 'URGWeaponScript::RetriggerableExplosionChanceDiminishingReturn' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, GlobalWeaponModifiers) == 0x000368, "Member 'URGWeaponScript::GlobalWeaponModifiers' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, PrimaryWeaponModScript) == 0x000370, "Member 'URGWeaponScript::PrimaryWeaponModScript' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, SecondaryWeaponModScript) == 0x000378, "Member 'URGWeaponScript::SecondaryWeaponModScript' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, StatWeaponModScripts) == 0x000380, "Member 'URGWeaponScript::StatWeaponModScripts' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, LastSpawnedProjectile) == 0x000390, "Member 'URGWeaponScript::LastSpawnedProjectile' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, LatestProjectileHitDamageData) == 0x000398, "Member 'URGWeaponScript::LatestProjectileHitDamageData' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, bHasSingleShotReload) == 0x0003D8, "Member 'URGWeaponScript::bHasSingleShotReload' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, OnWeaponReload) == 0x0003E0, "Member 'URGWeaponScript::OnWeaponReload' has a wrong offset!");
static_assert(offsetof(URGWeaponScript, bReloadGrantsAmmo) == 0x0003F0, "Member 'URGWeaponScript::bReloadGrantsAmmo' has a wrong offset!");

// Class RGame.RWeapon
// 0x00E8 (0x0390 - 0x02A8)
class ARWeapon : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnEquipActionBlockTime;                            // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryWeaponModRank;                              // 0x02B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryWeaponModRank;                            // 0x02B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      PrimaryModWeaponFireNiagaraComponent;              // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SecondaryModWeaponFireNiagaraComponent;            // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URSkeletalMeshComponent*                SkeletalMeshComponent;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ArmsMontage;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ArmsMontageAdditive;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          ArmsBasePose;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          ArmsLocomotionSequence;                            // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          ArmsDetailSequence;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CharacterBasePose;                                 // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            AimOffset;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CharacterMontage;                                  // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CharacterMontageAdditive;                          // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CharacterDetailSequence;                           // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FPGunMontage;                                      // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           TPGunMontage;                                      // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URWeaponModPrimaryAsset*>        WeaponModPrimaryAssets;                            // 0x0338(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URGWeaponScript*                        RuntimeWeaponScript;                               // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCrosshair*                            Crosshair;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WeaponIcon;                                        // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URNiagaraComponent>         DefaultMuzzleFlash;                                // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DefaultFireSound;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           DefaultCameraShake;                                // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URWeaponPrimaryAsset*                   WeaponPrimaryAsset;                                // 0x0388(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddWeaponModCosmeticEditorOnly(class URWeaponModPrimaryAsset* WeaponMod);
	TArray<class URStaticMeshComponent*> AttachWeaponModCosmeticMesh(const class URWeaponModPrimaryAsset* WeaponMod);
	void DestroyWeaponModCosmeticMesh(class UStaticMeshComponent* Mesh);
	struct FTransform GetEjectionPortTransform();
	class USkeletalMeshComponent* GetGunMeshComponent();
	TArray<struct FTransform> GetMuzzleTransforms();
	TArray<class URWeaponModPrimaryAsset*> GetWeaponModPrimaryAssets();
	class URWeaponPrimaryAsset* GetWeaponPrimaryAsset();
	bool IsDefaultWeaponMod(class URWeaponModPrimaryAsset* Mod);
	void K2_OnWeaponModCosmeticAttached(const class URWeaponModPrimaryAsset* WeaponMod);
	void K2_OnWeaponModCosmeticRemoved(const class URWeaponModPrimaryAsset* WeaponMod);
	void OnRep_WeaponModPrimaryAssets();
	void OnWeaponEquipped();
	void OnWeaponFired(bool IsPrimaryMod);
	void OnWeaponRemoved();
	void SetWeaponVisibility(const bool bNewVisible);
	void SetWeaponVisible(bool bVisible);
	void UpdateFOVValues(float FOV);

	class URWeaponModPrimaryAsset* GetEquippedWeaponModPrimaryAsset(const EWeaponModType WeaponModType) const;
	int32 GetEquippedWeaponModRank(const EWeaponModType WeaponModType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeapon">();
	}
	static class ARWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeapon>();
	}
};
static_assert(alignof(ARWeapon) == 0x000008, "Wrong alignment on ARWeapon");
static_assert(sizeof(ARWeapon) == 0x000390, "Wrong size on ARWeapon");
static_assert(offsetof(ARWeapon, OnEquipActionBlockTime) == 0x0002B0, "Member 'ARWeapon::OnEquipActionBlockTime' has a wrong offset!");
static_assert(offsetof(ARWeapon, PrimaryWeaponModRank) == 0x0002B4, "Member 'ARWeapon::PrimaryWeaponModRank' has a wrong offset!");
static_assert(offsetof(ARWeapon, SecondaryWeaponModRank) == 0x0002B8, "Member 'ARWeapon::SecondaryWeaponModRank' has a wrong offset!");
static_assert(offsetof(ARWeapon, PrimaryModWeaponFireNiagaraComponent) == 0x0002C0, "Member 'ARWeapon::PrimaryModWeaponFireNiagaraComponent' has a wrong offset!");
static_assert(offsetof(ARWeapon, SecondaryModWeaponFireNiagaraComponent) == 0x0002C8, "Member 'ARWeapon::SecondaryModWeaponFireNiagaraComponent' has a wrong offset!");
static_assert(offsetof(ARWeapon, SkeletalMeshComponent) == 0x0002D0, "Member 'ARWeapon::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ARWeapon, ArmsMontage) == 0x0002D8, "Member 'ARWeapon::ArmsMontage' has a wrong offset!");
static_assert(offsetof(ARWeapon, ArmsMontageAdditive) == 0x0002E0, "Member 'ARWeapon::ArmsMontageAdditive' has a wrong offset!");
static_assert(offsetof(ARWeapon, ArmsBasePose) == 0x0002E8, "Member 'ARWeapon::ArmsBasePose' has a wrong offset!");
static_assert(offsetof(ARWeapon, ArmsLocomotionSequence) == 0x0002F0, "Member 'ARWeapon::ArmsLocomotionSequence' has a wrong offset!");
static_assert(offsetof(ARWeapon, ArmsDetailSequence) == 0x0002F8, "Member 'ARWeapon::ArmsDetailSequence' has a wrong offset!");
static_assert(offsetof(ARWeapon, CharacterBasePose) == 0x000300, "Member 'ARWeapon::CharacterBasePose' has a wrong offset!");
static_assert(offsetof(ARWeapon, AimOffset) == 0x000308, "Member 'ARWeapon::AimOffset' has a wrong offset!");
static_assert(offsetof(ARWeapon, CharacterMontage) == 0x000310, "Member 'ARWeapon::CharacterMontage' has a wrong offset!");
static_assert(offsetof(ARWeapon, CharacterMontageAdditive) == 0x000318, "Member 'ARWeapon::CharacterMontageAdditive' has a wrong offset!");
static_assert(offsetof(ARWeapon, CharacterDetailSequence) == 0x000320, "Member 'ARWeapon::CharacterDetailSequence' has a wrong offset!");
static_assert(offsetof(ARWeapon, FPGunMontage) == 0x000328, "Member 'ARWeapon::FPGunMontage' has a wrong offset!");
static_assert(offsetof(ARWeapon, TPGunMontage) == 0x000330, "Member 'ARWeapon::TPGunMontage' has a wrong offset!");
static_assert(offsetof(ARWeapon, WeaponModPrimaryAssets) == 0x000338, "Member 'ARWeapon::WeaponModPrimaryAssets' has a wrong offset!");
static_assert(offsetof(ARWeapon, RuntimeWeaponScript) == 0x000358, "Member 'ARWeapon::RuntimeWeaponScript' has a wrong offset!");
static_assert(offsetof(ARWeapon, Crosshair) == 0x000360, "Member 'ARWeapon::Crosshair' has a wrong offset!");
static_assert(offsetof(ARWeapon, WeaponIcon) == 0x000368, "Member 'ARWeapon::WeaponIcon' has a wrong offset!");
static_assert(offsetof(ARWeapon, DefaultMuzzleFlash) == 0x000370, "Member 'ARWeapon::DefaultMuzzleFlash' has a wrong offset!");
static_assert(offsetof(ARWeapon, DefaultFireSound) == 0x000378, "Member 'ARWeapon::DefaultFireSound' has a wrong offset!");
static_assert(offsetof(ARWeapon, DefaultCameraShake) == 0x000380, "Member 'ARWeapon::DefaultCameraShake' has a wrong offset!");
static_assert(offsetof(ARWeapon, WeaponPrimaryAsset) == 0x000388, "Member 'ARWeapon::WeaponPrimaryAsset' has a wrong offset!");

// Class RGame.RWeapon_FishDiety
// 0x0000 (0x0390 - 0x0390)
class ARWeapon_FishDiety : public ARWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeapon_FishDiety">();
	}
	static class ARWeapon_FishDiety* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeapon_FishDiety>();
	}
};
static_assert(alignof(ARWeapon_FishDiety) == 0x000008, "Wrong alignment on ARWeapon_FishDiety");
static_assert(sizeof(ARWeapon_FishDiety) == 0x000390, "Wrong size on ARWeapon_FishDiety");

// Class RGame.RGWeaponSkillTreeMutatorScript
// 0x0000 (0x00D0 - 0x00D0)
class URGWeaponSkillTreeMutatorScript final : public URGWeaponMutatorScript
{
public:
	void OnPlayerEquippedWeapon(class ARWeapon* RWeapon);
	void RefreshSkillTreeMutator();

	void AddMutableWeaponFloatCoefficient(const EFloatWeaponStat FloatWeaponStat, const float Value) const;
	void RemoveMutableWeaponFloatCoefficient(const EFloatWeaponStat FloatWeaponStat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGWeaponSkillTreeMutatorScript">();
	}
	static class URGWeaponSkillTreeMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGWeaponSkillTreeMutatorScript>();
	}
};
static_assert(alignof(URGWeaponSkillTreeMutatorScript) == 0x000008, "Wrong alignment on URGWeaponSkillTreeMutatorScript");
static_assert(sizeof(URGWeaponSkillTreeMutatorScript) == 0x0000D0, "Wrong size on URGWeaponSkillTreeMutatorScript");

// Class RGame.RHealAltar
// 0x0000 (0x02A8 - 0x02A8)
class ARHealAltar : public AActor
{
public:
	void AddHealAltarSelectionForController(class APlayerController* PlayerController, bool bConsumed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHealAltar">();
	}
	static class ARHealAltar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHealAltar>();
	}
};
static_assert(alignof(ARHealAltar) == 0x000008, "Wrong alignment on ARHealAltar");
static_assert(sizeof(ARHealAltar) == 0x0002A8, "Wrong size on ARHealAltar");

// Class RGame.RHealthComponent
// 0x0E38 (0x0ED8 - 0x00A0)
class URHealthComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableInteger                       Invulnerable;                                      // 0x00B8(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          SpawnDamagenumbers;                                // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInvisFrames;                                   // 0x01D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DA[0x2];                                      // 0x01DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvisFramesDuration;                               // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         currentHealth;                                     // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentArmor;                                      // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentBarrier;                                    // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         currentPlatings;                                   // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         DamageMultiplier;                                  // 0x01F8(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FRMutableFloat                         CriticalDamageMultiplier;                          // 0x0320(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FLastDamageEventData                   LastDamageEvent;                                   // 0x0448(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ERDamageFlag                                  DamageFlag;                                        // 0x04D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DamageSourceMaskImmunities;                        // 0x04D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPreventBarrierOverkill;                           // 0x04E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreExecutionerModifier;                        // 0x04E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EA[0x6];                                      // 0x04EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      SocketMultiplierDamage;                            // 0x04F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         BarrierTimerDelay;                                 // 0x0540(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         BarrierOverChargeThreshold;                        // 0x0668(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         BarrierDamagePerTick;                              // 0x0790(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BarrierOverChargeReductionMulti;                   // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         MaxHealth;                                         // 0x08C0(0x0128)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         MaxArmor;                                          // 0x09E8(0x0128)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         MaxBarrier;                                        // 0x0B10(0x0128)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPublic)
	struct FRMutableInteger                       MaxPlatings;                                       // 0x0C38(0x0120)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float Damage, int32 DamageSourceMask)> OnPreDamageTaken; // 0x0D58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float Damage, int32 DamageSourceMask)> OnPreHealthDamageTaken; // 0x0D68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, class AController* Source, int32 DamageSourceMask)> OnPreDamageTakenFromSource; // 0x0D78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEvent)> OnDamageTaken; // 0x0D88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnHealthRegained; // 0x0D98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnArmorRegained; // 0x0DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnBarrierRegained; // 0x0DB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnHealthChanged; // 0x0DC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnBarrierChanged; // 0x0DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)> OnHealthDepleted; // 0x0DE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)> OnArmorDepleted; // 0x0DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)> OnBarrierDepleted; // 0x0E08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, int32 currentPlatings)> OnPlatingsUpdated; // 0x0E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, int32 currentPlatings)> OnPlatingsRegained; // 0x0E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float MaximumHealth)> OnMaximumHealthChanged; // 0x0E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float MaximumHealth)> OnMaximumArmorChanged; // 0x0E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float MaximumHealth)> OnMaximumBarrierChanged; // 0x0E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, int32 MaximumPlating)> OnMaximumPlatingsChanged; // 0x0E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, bool NewInvulnerability)> OnInvulnerabilityChanged; // 0x0E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData)> OnDamagePreventedByInvlunerability; // 0x0E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float Dmg, const class FString& NPCName)> OnDamageTakenFromNPC; // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnHealthChangedServerValidated; // 0x0EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEvent)> OnDamageTakenServerValidated; // 0x0EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHealthComponent* Component, float currentHealth, float healthDelta, const struct FHealCombatEvent& HealEvent)> OnPredictedHealthReconciled; // 0x0EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static struct FLastDamageEventData ApplyHealthDamage(class AActor* DamagedActor, class AController* Instigator, class AActor* DamageCauser, float Damage, int32 DamageSources, const struct FVector& HitLocation, const struct FVector& ShotFromDirection, class UPrimitiveComponent* HitComponent, bool bWasCritical, class AActor* DamageCausedBy, bool bForceKilled, bool bDamageClientPrediction, const struct FRLightningDamageCombatEventData& LightningDamageCombatEventData, const bool bIgnoreDamageModifiers, class AActor* AvatarActor);
	static bool CanTakeDamageFromInstigator(class AActor* Instigator, class AActor* DamagedActor);
	static class URHealthComponent* GetHealthComponent(const class AActor* OwningActor);
	static void HealActor(class AActor* Instigator, class AActor* ActorToHeal, EHealType HealType, float Value, bool bHealIfDead);
	static void KillActor(class AActor* ActorToKill);

	void AddDamageSourceMaskImmunity(int32 NewImmunity);
	void BarrierTimerFunction();
	struct FRMutableFloat GetDamageMultiplier();
	bool GetIsDamaged();
	float GetMaxArmor();
	float GetMaxBarrier();
	float GetMaxHealth();
	int32 GetMaxPlatings();
	float GetMissingHealthPercentage();
	float GetRemainingBarrierTimer();
	void OnDamageCombatEvent(const struct FDamageCombatEvent& EventData);
	void OnDamageCombatEventServerValidated(const struct FDamageCombatEvent& EventData);
	void OnHealCombatEvent(const struct FHealCombatEvent& EventData);
	void OnRep_Invulnerable();
	void OnRep_MaxArmor();
	void OnRep_MaxBarrier();
	void OnRep_MaxHealth();
	void OnRep_MaxPlating();
	void OnSetArmorCombatEvent(const struct FSetArmorCombatEvent& EventData);
	void OnSetBarrierCombatEvent(const struct FSetBarrierCombatEvent& EventData);
	void OnSetHealthCombatEvent(const struct FSetHealthCombatEvent& EventData);
	void PushStatusText_Multicast(class AController* Instigator, class URHealthComponent* HealthComponent, const struct FVector& Location, const class FText& Text, ERFloatingTextType Type, bool bSkipDelay);
	void RemoveDamageSourceMaskImmunity(int32 RemovedImmunity);
	void SetCurrentArmor(float Value);
	void SetCurrentBarrier(float Value);
	void SetCurrentHealth(float Value);
	void SetCurrentHealth_Server(float Value);
	void SetDamageFlag(ERDamageFlag NewDamageFlag);
	void SetInvulnerable(bool bNewInvulnerable, class FName Key, bool ResetInvulnerability);
	void SetPreventBarrierOverkill(bool bNewValue);
	void StartBarrierTimer_Multicast(float RemoveDelay);
	void UpdateMaxArmor();
	void UpdateMaxBarrier();
	void UpdateMaxHealth();
	void UpdateMaxPlating();

	bool GetCanNotBeDamaged() const;
	float GetCurrentBarrier() const;
	float GetCurrentHealth() const;
	int32 GetCurrentPlatings() const;
	ERDamageFlag GetDamageFlag() const;
	bool GetIgnoreExecutionerModifier() const;
	class AController* GetInstigatorFromLastDamageEvent() const;
	bool GetInvulnerable() const;
	bool GetIsAlive() const;
	bool GetIsDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHealthComponent">();
	}
	static class URHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHealthComponent>();
	}
};
static_assert(alignof(URHealthComponent) == 0x000008, "Wrong alignment on URHealthComponent");
static_assert(sizeof(URHealthComponent) == 0x000ED8, "Wrong size on URHealthComponent");
static_assert(offsetof(URHealthComponent, Invulnerable) == 0x0000B8, "Member 'URHealthComponent::Invulnerable' has a wrong offset!");
static_assert(offsetof(URHealthComponent, SpawnDamagenumbers) == 0x0001D8, "Member 'URHealthComponent::SpawnDamagenumbers' has a wrong offset!");
static_assert(offsetof(URHealthComponent, bUseInvisFrames) == 0x0001D9, "Member 'URHealthComponent::bUseInvisFrames' has a wrong offset!");
static_assert(offsetof(URHealthComponent, InvisFramesDuration) == 0x0001DC, "Member 'URHealthComponent::InvisFramesDuration' has a wrong offset!");
static_assert(offsetof(URHealthComponent, currentHealth) == 0x0001E0, "Member 'URHealthComponent::currentHealth' has a wrong offset!");
static_assert(offsetof(URHealthComponent, CurrentArmor) == 0x0001E8, "Member 'URHealthComponent::CurrentArmor' has a wrong offset!");
static_assert(offsetof(URHealthComponent, CurrentBarrier) == 0x0001EC, "Member 'URHealthComponent::CurrentBarrier' has a wrong offset!");
static_assert(offsetof(URHealthComponent, currentPlatings) == 0x0001F0, "Member 'URHealthComponent::currentPlatings' has a wrong offset!");
static_assert(offsetof(URHealthComponent, DamageMultiplier) == 0x0001F8, "Member 'URHealthComponent::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(URHealthComponent, CriticalDamageMultiplier) == 0x000320, "Member 'URHealthComponent::CriticalDamageMultiplier' has a wrong offset!");
static_assert(offsetof(URHealthComponent, LastDamageEvent) == 0x000448, "Member 'URHealthComponent::LastDamageEvent' has a wrong offset!");
static_assert(offsetof(URHealthComponent, DamageFlag) == 0x0004D0, "Member 'URHealthComponent::DamageFlag' has a wrong offset!");
static_assert(offsetof(URHealthComponent, DamageSourceMaskImmunities) == 0x0004D8, "Member 'URHealthComponent::DamageSourceMaskImmunities' has a wrong offset!");
static_assert(offsetof(URHealthComponent, bPreventBarrierOverkill) == 0x0004E8, "Member 'URHealthComponent::bPreventBarrierOverkill' has a wrong offset!");
static_assert(offsetof(URHealthComponent, bIgnoreExecutionerModifier) == 0x0004E9, "Member 'URHealthComponent::bIgnoreExecutionerModifier' has a wrong offset!");
static_assert(offsetof(URHealthComponent, SocketMultiplierDamage) == 0x0004F0, "Member 'URHealthComponent::SocketMultiplierDamage' has a wrong offset!");
static_assert(offsetof(URHealthComponent, BarrierTimerDelay) == 0x000540, "Member 'URHealthComponent::BarrierTimerDelay' has a wrong offset!");
static_assert(offsetof(URHealthComponent, BarrierOverChargeThreshold) == 0x000668, "Member 'URHealthComponent::BarrierOverChargeThreshold' has a wrong offset!");
static_assert(offsetof(URHealthComponent, BarrierDamagePerTick) == 0x000790, "Member 'URHealthComponent::BarrierDamagePerTick' has a wrong offset!");
static_assert(offsetof(URHealthComponent, BarrierOverChargeReductionMulti) == 0x0008B8, "Member 'URHealthComponent::BarrierOverChargeReductionMulti' has a wrong offset!");
static_assert(offsetof(URHealthComponent, MaxHealth) == 0x0008C0, "Member 'URHealthComponent::MaxHealth' has a wrong offset!");
static_assert(offsetof(URHealthComponent, MaxArmor) == 0x0009E8, "Member 'URHealthComponent::MaxArmor' has a wrong offset!");
static_assert(offsetof(URHealthComponent, MaxBarrier) == 0x000B10, "Member 'URHealthComponent::MaxBarrier' has a wrong offset!");
static_assert(offsetof(URHealthComponent, MaxPlatings) == 0x000C38, "Member 'URHealthComponent::MaxPlatings' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnPreDamageTaken) == 0x000D58, "Member 'URHealthComponent::OnPreDamageTaken' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnPreHealthDamageTaken) == 0x000D68, "Member 'URHealthComponent::OnPreHealthDamageTaken' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnPreDamageTakenFromSource) == 0x000D78, "Member 'URHealthComponent::OnPreDamageTakenFromSource' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnDamageTaken) == 0x000D88, "Member 'URHealthComponent::OnDamageTaken' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnHealthRegained) == 0x000D98, "Member 'URHealthComponent::OnHealthRegained' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnArmorRegained) == 0x000DA8, "Member 'URHealthComponent::OnArmorRegained' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnBarrierRegained) == 0x000DB8, "Member 'URHealthComponent::OnBarrierRegained' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnHealthChanged) == 0x000DC8, "Member 'URHealthComponent::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnBarrierChanged) == 0x000DD8, "Member 'URHealthComponent::OnBarrierChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnHealthDepleted) == 0x000DE8, "Member 'URHealthComponent::OnHealthDepleted' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnArmorDepleted) == 0x000DF8, "Member 'URHealthComponent::OnArmorDepleted' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnBarrierDepleted) == 0x000E08, "Member 'URHealthComponent::OnBarrierDepleted' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnPlatingsUpdated) == 0x000E18, "Member 'URHealthComponent::OnPlatingsUpdated' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnPlatingsRegained) == 0x000E28, "Member 'URHealthComponent::OnPlatingsRegained' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnMaximumHealthChanged) == 0x000E38, "Member 'URHealthComponent::OnMaximumHealthChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnMaximumArmorChanged) == 0x000E48, "Member 'URHealthComponent::OnMaximumArmorChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnMaximumBarrierChanged) == 0x000E58, "Member 'URHealthComponent::OnMaximumBarrierChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnMaximumPlatingsChanged) == 0x000E68, "Member 'URHealthComponent::OnMaximumPlatingsChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnInvulnerabilityChanged) == 0x000E78, "Member 'URHealthComponent::OnInvulnerabilityChanged' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnDamagePreventedByInvlunerability) == 0x000E88, "Member 'URHealthComponent::OnDamagePreventedByInvlunerability' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnDamageTakenFromNPC) == 0x000E98, "Member 'URHealthComponent::OnDamageTakenFromNPC' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnHealthChangedServerValidated) == 0x000EA8, "Member 'URHealthComponent::OnHealthChangedServerValidated' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnDamageTakenServerValidated) == 0x000EB8, "Member 'URHealthComponent::OnDamageTakenServerValidated' has a wrong offset!");
static_assert(offsetof(URHealthComponent, OnPredictedHealthReconciled) == 0x000EC8, "Member 'URHealthComponent::OnPredictedHealthReconciled' has a wrong offset!");

// Class RGame.RHiddenCoin
// 0x0008 (0x02B0 - 0x02A8)
class ARHiddenCoin final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHiddenCoin">();
	}
	static class ARHiddenCoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHiddenCoin>();
	}
};
static_assert(alignof(ARHiddenCoin) == 0x000008, "Wrong alignment on ARHiddenCoin");
static_assert(sizeof(ARHiddenCoin) == 0x0002B0, "Wrong size on ARHiddenCoin");

// Class RGame.RInteractableInterface
// 0x0000 (0x0000 - 0x0000)
class IRInteractableInterface final
{
public:
	bool CanInteract(class APlayerController* Controller);
	void OnFocus(class APlayerController* Controller);
	void OnFocusGone(class APlayerController* Controller);
	void OnInteract(class APlayerController* Controller);
	void ToggleInteractionIndicatorVisibility(class AActor* InteractingActor, const bool NewVisible);

	class FText GetInteractableAlternativeDescription() const;
	int32 GetInteractableCost() const;
	class FText GetInteractableCostCurrencyType() const;
	class FText GetInteractableDescription() const;
	class FText GetInteractableName() const;
	class FText GetInteractableSubHeader() const;
	class UWidgetComponent* GetInteractionIndicatorWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RInteractableInterface">();
	}
	static class IRInteractableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRInteractableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRInteractableInterface) == 0x000001, "Wrong alignment on IRInteractableInterface");
static_assert(sizeof(IRInteractableInterface) == 0x000001, "Wrong size on IRInteractableInterface");

// Class RGame.RWeapon_BrineRifle
// 0x0000 (0x0390 - 0x0390)
class ARWeapon_BrineRifle final : public ARWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeapon_BrineRifle">();
	}
	static class ARWeapon_BrineRifle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeapon_BrineRifle>();
	}
};
static_assert(alignof(ARWeapon_BrineRifle) == 0x000008, "Wrong alignment on ARWeapon_BrineRifle");
static_assert(sizeof(ARWeapon_BrineRifle) == 0x000390, "Wrong size on ARWeapon_BrineRifle");

// Class RGame.RKillPlayerVolume
// 0x0010 (0x02B8 - 0x02A8)
class ARKillPlayerVolume final : public AActor
{
public:
	class UDMActorProximityBoxComponent*          ActorProximityBoxComponent;                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPermaDeath;                                       // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEnterArea(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RKillPlayerVolume">();
	}
	static class ARKillPlayerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARKillPlayerVolume>();
	}
};
static_assert(alignof(ARKillPlayerVolume) == 0x000008, "Wrong alignment on ARKillPlayerVolume");
static_assert(sizeof(ARKillPlayerVolume) == 0x0002B8, "Wrong size on ARKillPlayerVolume");
static_assert(offsetof(ARKillPlayerVolume, ActorProximityBoxComponent) == 0x0002A8, "Member 'ARKillPlayerVolume::ActorProximityBoxComponent' has a wrong offset!");
static_assert(offsetof(ARKillPlayerVolume, bPermaDeath) == 0x0002B0, "Member 'ARKillPlayerVolume::bPermaDeath' has a wrong offset!");

// Class RGame.RLevelGenerationInterface
// 0x0000 (0x0000 - 0x0000)
class IRLevelGenerationInterface final
{
public:
	void ClearFromScene();
	bool ShouldClearFromScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLevelGenerationInterface">();
	}
	static class IRLevelGenerationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRLevelGenerationInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRLevelGenerationInterface) == 0x000001, "Wrong alignment on IRLevelGenerationInterface");
static_assert(sizeof(IRLevelGenerationInterface) == 0x000001, "Wrong size on IRLevelGenerationInterface");

// Class RGame.RLevelGenerator
// 0x0200 (0x04A8 - 0x02A8)
class ARLevelGenerator final : public AActor
{
public:
	bool                                          bShouldToggleLevelVisibilities;                    // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FallbackDataTable;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LightingDataTable;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxLookingForNavmeshAttempts;                      // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     DataTables;                                        // 0x02D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ARReplicatedLevelInstance*>      CurrentLevels;                                     // 0x02E0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLevelGenerationSettings>       GeneratedLevelSettings;                            // 0x02F0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           BaseActors;                                        // 0x0300(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           CurrentLevelIds;                                   // 0x0350(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LastLevelIds;                                      // 0x0370(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x78];                                     // 0x0380(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         PersistentActors;                                  // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLobbyElevatorSequenceActive;                      // 0x0418(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUngluTeleportSequenceActive;                      // 0x0419(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41A[0x6];                                      // 0x041A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentLevelExit;                                  // 0x0420(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CurrentEventRoomChests;                            // 0x0428(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CurrentNodeChoiceChests;                           // 0x0438(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CurrentNodeDoors;                                  // 0x0448(0x0010)(BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelChanged;                                    // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPreLevelChanged;                                 // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelsUnloaded;                                  // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNextLevelsFinishedShowing;                       // 0x0488(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARLevelGenerator* GetLevelManager(const class UObject* WorldContextObject);

	TArray<struct FLevelGenerationSettings> GetCurrentLevelSettings();
	TArray<struct FLevelGenerationSettings> GetCurrentLevelSettingsWithLevelAttributeTags(const struct FGameplayTagContainer& LevelTags);
	TArray<struct FLevelGenerationSettings> GetCurrentLevelSettingsWithLevelTags(const struct FGameplayTagContainer& LevelTags);
	int32 GetCurrentLoadingLevelsCount();
	int32 GetEncounterRoomPositionOfActor(class AActor* Actor);
	bool GetIsInLoadingScreen();
	bool GetLobbyElevatorSequenceActive();
	bool GetUngluTeleportSequenceActive();
	bool IsActorInLastEncounterRoom(class AActor* Actor, int32* OutEncounterRoomPosition);
	void LoadLevelInstance(const struct FLevelGenerationSettings& LevelGenerationSettings);
	void Multicast_ClearDynamicActors();
	void OnUpdateLevelStreaming();
	void PreLevelTransition_Multicast();
	void PruneEventRoomChests(class AActor* LastCreatedChest);
	void PruneNodeChoiceChests(class AActor* LastCreatedChest);
	void RegisterPersistentActor(class AActor* Actor);
	void RegisterPersistentActorIfReplicated(class AActor* Actor);
	void SetLobbyElevatorSequenceActive(bool NewLobbyElevatorSequenceActive);
	void SetUngluTeleportSequenceActive(bool NewUngluTeleportSequenceActive);

	bool GetCameFromMainMenu() const;
	bool GetCameFromTutorial() const;
	TArray<class FName> GetCurrentLevelIds() const;
	TArray<class FName> GetLastLevelIds() const;
	bool ShouldToggleLevelVisibilities() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLevelGenerator">();
	}
	static class ARLevelGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARLevelGenerator>();
	}
};
static_assert(alignof(ARLevelGenerator) == 0x000008, "Wrong alignment on ARLevelGenerator");
static_assert(sizeof(ARLevelGenerator) == 0x0004A8, "Wrong size on ARLevelGenerator");
static_assert(offsetof(ARLevelGenerator, bShouldToggleLevelVisibilities) == 0x0002A8, "Member 'ARLevelGenerator::bShouldToggleLevelVisibilities' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, FallbackDataTable) == 0x0002B0, "Member 'ARLevelGenerator::FallbackDataTable' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, LightingDataTable) == 0x0002B8, "Member 'ARLevelGenerator::LightingDataTable' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, MaxLookingForNavmeshAttempts) == 0x0002C0, "Member 'ARLevelGenerator::MaxLookingForNavmeshAttempts' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, DataTables) == 0x0002D0, "Member 'ARLevelGenerator::DataTables' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, CurrentLevels) == 0x0002E0, "Member 'ARLevelGenerator::CurrentLevels' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, GeneratedLevelSettings) == 0x0002F0, "Member 'ARLevelGenerator::GeneratedLevelSettings' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, BaseActors) == 0x000300, "Member 'ARLevelGenerator::BaseActors' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, CurrentLevelIds) == 0x000350, "Member 'ARLevelGenerator::CurrentLevelIds' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, LastLevelIds) == 0x000370, "Member 'ARLevelGenerator::LastLevelIds' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, PersistentActors) == 0x0003F8, "Member 'ARLevelGenerator::PersistentActors' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, bLobbyElevatorSequenceActive) == 0x000418, "Member 'ARLevelGenerator::bLobbyElevatorSequenceActive' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, bUngluTeleportSequenceActive) == 0x000419, "Member 'ARLevelGenerator::bUngluTeleportSequenceActive' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, CurrentLevelExit) == 0x000420, "Member 'ARLevelGenerator::CurrentLevelExit' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, CurrentEventRoomChests) == 0x000428, "Member 'ARLevelGenerator::CurrentEventRoomChests' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, CurrentNodeChoiceChests) == 0x000438, "Member 'ARLevelGenerator::CurrentNodeChoiceChests' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, CurrentNodeDoors) == 0x000448, "Member 'ARLevelGenerator::CurrentNodeDoors' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, OnLevelChanged) == 0x000458, "Member 'ARLevelGenerator::OnLevelChanged' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, OnPreLevelChanged) == 0x000468, "Member 'ARLevelGenerator::OnPreLevelChanged' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, OnLevelsUnloaded) == 0x000478, "Member 'ARLevelGenerator::OnLevelsUnloaded' has a wrong offset!");
static_assert(offsetof(ARLevelGenerator, OnNextLevelsFinishedShowing) == 0x000488, "Member 'ARLevelGenerator::OnNextLevelsFinishedShowing' has a wrong offset!");

// Class RGame.RLootableActor
// 0x00E0 (0x0388 - 0x02A8)
class ARLootableActor : public AActor
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SpawnedItems;                                      // 0x02B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDMActorProximityBoxComponent*          ActorProximityBoxComponent;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMutatorPrimaryAsset*                  RequiredMutatorPA;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoSpawnRewards;                                 // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InteractionCost;                                   // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InteractionTitle;                                  // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   InteractionText;                                   // 0x02F0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InteractionCostCurrency;                           // 0x0300(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bFilterHealingItems;                               // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterUniqueItems;                                // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawningEnabled;                                  // 0x0312(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySpawnAbilityMutators;                         // 0x0313(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresKey;                                      // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerHealthBasedWeightingForHealingItems;         // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RewardTableTypeTag;                                // 0x031C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMutatorLootTableRow>           AvailableMutatorRows;                              // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RewardCategoryTag;                                 // 0x0338(0x0008)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AREnemySpawnAreaSegment*                AssociatedSpawnAreaSegment;                        // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       RadarBaseIcon;                                     // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RadarBaseIconSize;                                 // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RadarBaseIconColor;                                // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URMutatorPrimaryAsset*>          BlacklistedMutators;                               // 0x0378(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	int32 GetNumMutatorsSpawnedInCategory(const struct FGameplayTag& CategoryTag, const bool bIncludeTriggers);
	TArray<class AActor*> GetSpawnedItems();
	bool HasRequiredMutatorPA(class APlayerController* PlayerController);
	void SetAssociatedSpawnAreaSegment(class AREnemySpawnAreaSegment* Segment);
	void SetAvailableMutators(EMutatorRarity MutatorRarity);
	bool ShouldShowOnRadarBase();

	bool IsAssociatedSpawnAreaSegmentCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLootableActor">();
	}
	static class ARLootableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARLootableActor>();
	}
};
static_assert(alignof(ARLootableActor) == 0x000008, "Wrong alignment on ARLootableActor");
static_assert(sizeof(ARLootableActor) == 0x000388, "Wrong size on ARLootableActor");
static_assert(offsetof(ARLootableActor, SpawnedItems) == 0x0002B8, "Member 'ARLootableActor::SpawnedItems' has a wrong offset!");
static_assert(offsetof(ARLootableActor, ActorProximityBoxComponent) == 0x0002C8, "Member 'ARLootableActor::ActorProximityBoxComponent' has a wrong offset!");
static_assert(offsetof(ARLootableActor, RequiredMutatorPA) == 0x0002D0, "Member 'ARLootableActor::RequiredMutatorPA' has a wrong offset!");
static_assert(offsetof(ARLootableActor, bAutoSpawnRewards) == 0x0002D8, "Member 'ARLootableActor::bAutoSpawnRewards' has a wrong offset!");
static_assert(offsetof(ARLootableActor, InteractionCost) == 0x0002DC, "Member 'ARLootableActor::InteractionCost' has a wrong offset!");
static_assert(offsetof(ARLootableActor, InteractionTitle) == 0x0002E0, "Member 'ARLootableActor::InteractionTitle' has a wrong offset!");
static_assert(offsetof(ARLootableActor, InteractionText) == 0x0002F0, "Member 'ARLootableActor::InteractionText' has a wrong offset!");
static_assert(offsetof(ARLootableActor, InteractionCostCurrency) == 0x000300, "Member 'ARLootableActor::InteractionCostCurrency' has a wrong offset!");
static_assert(offsetof(ARLootableActor, bFilterHealingItems) == 0x000310, "Member 'ARLootableActor::bFilterHealingItems' has a wrong offset!");
static_assert(offsetof(ARLootableActor, bFilterUniqueItems) == 0x000311, "Member 'ARLootableActor::bFilterUniqueItems' has a wrong offset!");
static_assert(offsetof(ARLootableActor, bSpawningEnabled) == 0x000312, "Member 'ARLootableActor::bSpawningEnabled' has a wrong offset!");
static_assert(offsetof(ARLootableActor, bOnlySpawnAbilityMutators) == 0x000313, "Member 'ARLootableActor::bOnlySpawnAbilityMutators' has a wrong offset!");
static_assert(offsetof(ARLootableActor, bRequiresKey) == 0x000314, "Member 'ARLootableActor::bRequiresKey' has a wrong offset!");
static_assert(offsetof(ARLootableActor, PlayerHealthBasedWeightingForHealingItems) == 0x000318, "Member 'ARLootableActor::PlayerHealthBasedWeightingForHealingItems' has a wrong offset!");
static_assert(offsetof(ARLootableActor, RewardTableTypeTag) == 0x00031C, "Member 'ARLootableActor::RewardTableTypeTag' has a wrong offset!");
static_assert(offsetof(ARLootableActor, AvailableMutatorRows) == 0x000328, "Member 'ARLootableActor::AvailableMutatorRows' has a wrong offset!");
static_assert(offsetof(ARLootableActor, RewardCategoryTag) == 0x000338, "Member 'ARLootableActor::RewardCategoryTag' has a wrong offset!");
static_assert(offsetof(ARLootableActor, AssociatedSpawnAreaSegment) == 0x000340, "Member 'ARLootableActor::AssociatedSpawnAreaSegment' has a wrong offset!");
static_assert(offsetof(ARLootableActor, RadarBaseIcon) == 0x000348, "Member 'ARLootableActor::RadarBaseIcon' has a wrong offset!");
static_assert(offsetof(ARLootableActor, RadarBaseIconSize) == 0x000350, "Member 'ARLootableActor::RadarBaseIconSize' has a wrong offset!");
static_assert(offsetof(ARLootableActor, RadarBaseIconColor) == 0x000360, "Member 'ARLootableActor::RadarBaseIconColor' has a wrong offset!");
static_assert(offsetof(ARLootableActor, BlacklistedMutators) == 0x000378, "Member 'ARLootableActor::BlacklistedMutators' has a wrong offset!");

// Class RGame.RLootableContainer
// 0x0068 (0x03F0 - 0x0388)
class ARLootableContainer : public ARLootableActor
{
public:
	class UDMActorProximityBoxComponent*          VoicelineProximityBoxComponent;                    // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x11];                                     // 0x0390(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOneLimitLoot;                                     // 0x03A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSpawningWhileItemIsSpawned;                // 0x03A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAltarVoiceline;                               // 0x03A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRewardsToSpawn;                                 // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreExtraMutatorLootModifier;                   // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseChestLootModifier;                             // 0x03A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AA[0x2];                                      // 0x03AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRewardsPerRow;                                  // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RowSpacing;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColumnSpacing;                                     // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RewardSpawnPosition;                               // 0x03B8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFilterRewardsBasedOnNodeRewardCategories;   // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             FixedRewards;                                      // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UPrimaryDataAsset*                      NodeChoiceRewardPA;                                // 0x03E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddGeneratedLootOptionForController(const TArray<struct FRLootSelectionOption>& LootOption, class APlayerController* PlayerController, bool bHasChosenLoot);
	void AddSacrificeCostForController(int32 NewInteractionCost, class APlayerController* PlayerController);
	void AddWishingWellCostForController(int32 NewInteractionCost, int32 UsesLeft, class APlayerController* PlayerController);
	void OnRewardsHasBeenSpawned(class APlayerController* PlayerController);
	void OnSpawnedItemPickedUp(class ARPickupableItem* PickedUpItem, int32 PickupCost, class APlayerController* PlayerController);
	void OnSpawnTrigBoxCompEntered(class AActor* OtherActor);
	void OnVoiceTrigBoxCompEntered(class AActor* OtherActor);
	void SetChestStateForController(EChestState NewChestState, class APlayerController* PlayerController);
	void SetRewardSpawnPosition(const struct FVector& Origin);
	void SetupEventLogic();
	void SpawnReplicatedReward_Multicast(class APlayerController* PlayerController, const struct FRewardTableRow& RewardRow, const struct FVector& SpawnPosition);
	void SpawnRewards(class APlayerController* PlayerController, const struct FVector& SpawnOffset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLootableContainer">();
	}
	static class ARLootableContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARLootableContainer>();
	}
};
static_assert(alignof(ARLootableContainer) == 0x000008, "Wrong alignment on ARLootableContainer");
static_assert(sizeof(ARLootableContainer) == 0x0003F0, "Wrong size on ARLootableContainer");
static_assert(offsetof(ARLootableContainer, VoicelineProximityBoxComponent) == 0x000388, "Member 'ARLootableContainer::VoicelineProximityBoxComponent' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, bOneLimitLoot) == 0x0003A1, "Member 'ARLootableContainer::bOneLimitLoot' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, bDisableSpawningWhileItemIsSpawned) == 0x0003A2, "Member 'ARLootableContainer::bDisableSpawningWhileItemIsSpawned' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, bPlayAltarVoiceline) == 0x0003A3, "Member 'ARLootableContainer::bPlayAltarVoiceline' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, NumRewardsToSpawn) == 0x0003A4, "Member 'ARLootableContainer::NumRewardsToSpawn' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, bIgnoreExtraMutatorLootModifier) == 0x0003A8, "Member 'ARLootableContainer::bIgnoreExtraMutatorLootModifier' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, bUseChestLootModifier) == 0x0003A9, "Member 'ARLootableContainer::bUseChestLootModifier' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, MaxRewardsPerRow) == 0x0003AC, "Member 'ARLootableContainer::MaxRewardsPerRow' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, RowSpacing) == 0x0003B0, "Member 'ARLootableContainer::RowSpacing' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, ColumnSpacing) == 0x0003B4, "Member 'ARLootableContainer::ColumnSpacing' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, RewardSpawnPosition) == 0x0003B8, "Member 'ARLootableContainer::RewardSpawnPosition' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, bShouldFilterRewardsBasedOnNodeRewardCategories) == 0x0003D0, "Member 'ARLootableContainer::bShouldFilterRewardsBasedOnNodeRewardCategories' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, FixedRewards) == 0x0003D8, "Member 'ARLootableContainer::FixedRewards' has a wrong offset!");
static_assert(offsetof(ARLootableContainer, NodeChoiceRewardPA) == 0x0003E8, "Member 'ARLootableContainer::NodeChoiceRewardPA' has a wrong offset!");

// Class RGame.RLootableChest
// 0x0000 (0x03F0 - 0x03F0)
class ARLootableChest : public ARLootableContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLootableChest">();
	}
	static class ARLootableChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARLootableChest>();
	}
};
static_assert(alignof(ARLootableChest) == 0x000008, "Wrong alignment on ARLootableChest");
static_assert(sizeof(ARLootableChest) == 0x0003F0, "Wrong size on ARLootableChest");

// Class RGame.RGlobalWeaponModifiers
// 0x0E20 (0x0E48 - 0x0028)
class URGlobalWeaponModifiers final : public UObject
{
public:
	uint8                                         Pad_28[0xE00];                                     // 0x0028(0x0E00)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EFloatWeaponStat FloatWeaponStat)> OnGlobalWeaponFloatModifierAltered; // 0x0E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EIntegerWeaponStat IntegerWeaponStat)> OnGlobalWeaponIntegerModifierAltered; // 0x0E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddFloatCoefficient(EFloatWeaponStat Stat, class FName Key, float Value);
	void AddFloatPostAdditive(EFloatWeaponStat Stat, class FName Key, float Value);
	void AddFloatPreAdditive(EFloatWeaponStat Stat, class FName Key, float Value);
	void AddIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key, float Value);
	void AddIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value);
	void AddIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value);
	float GetFloatTotalPositiveCoefficients(EFloatWeaponStat Stat);
	float GetFloatTotalPositivePostAdditive(EFloatWeaponStat Stat);
	float GetFloatTotalPositivePreAdditive(EFloatWeaponStat Stat);
	void RemoveFloatCoefficient(EFloatWeaponStat Stat, class FName Key);
	void RemoveFloatPostAdditive(EFloatWeaponStat Stat, class FName Key);
	void RemoveFloatPreAdditive(EFloatWeaponStat Stat, class FName Key);
	void RemoveIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key);
	void RemoveIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key);
	void RemoveIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGlobalWeaponModifiers">();
	}
	static class URGlobalWeaponModifiers* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGlobalWeaponModifiers>();
	}
};
static_assert(alignof(URGlobalWeaponModifiers) == 0x000008, "Wrong alignment on URGlobalWeaponModifiers");
static_assert(sizeof(URGlobalWeaponModifiers) == 0x000E48, "Wrong size on URGlobalWeaponModifiers");
static_assert(offsetof(URGlobalWeaponModifiers, OnGlobalWeaponFloatModifierAltered) == 0x000E28, "Member 'URGlobalWeaponModifiers::OnGlobalWeaponFloatModifierAltered' has a wrong offset!");
static_assert(offsetof(URGlobalWeaponModifiers, OnGlobalWeaponIntegerModifierAltered) == 0x000E38, "Member 'URGlobalWeaponModifiers::OnGlobalWeaponIntegerModifierAltered' has a wrong offset!");

// Class RGame.RLootGoblin
// 0x0000 (0x4DD0 - 0x4DD0)
class ARLootGoblin : public AREnemyPawnBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLootGoblin">();
	}
	static class ARLootGoblin* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARLootGoblin>();
	}
};
static_assert(alignof(ARLootGoblin) == 0x000008, "Wrong alignment on ARLootGoblin");
static_assert(sizeof(ARLootGoblin) == 0x004DD0, "Wrong size on ARLootGoblin");

// Class RGame.RLootOptionWidget
// 0x0020 (0x02F0 - 0x02D0)
class URLootOptionWidget : public UUserWidget
{
public:
	struct FRLootSelectionOption                  LootOption;                                        // 0x02D0(0x0010)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRLootSelectionOption& LootSelectionOption)> OnLooted; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLootOptionWidget">();
	}
	static class URLootOptionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URLootOptionWidget>();
	}
};
static_assert(alignof(URLootOptionWidget) == 0x000008, "Wrong alignment on URLootOptionWidget");
static_assert(sizeof(URLootOptionWidget) == 0x0002F0, "Wrong size on URLootOptionWidget");
static_assert(offsetof(URLootOptionWidget, LootOption) == 0x0002D0, "Member 'URLootOptionWidget::LootOption' has a wrong offset!");
static_assert(offsetof(URLootOptionWidget, OnLooted) == 0x0002E0, "Member 'URLootOptionWidget::OnLooted' has a wrong offset!");

// Class RGame.RLootTableManager
// 0x00F8 (0x03A0 - 0x02A8)
class ARLootTableManager final : public AActor
{
public:
	TArray<struct FRMutatorCategoryTable>         MutatorCategoryTables;                             // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UDataTable*                             AbilityLootTable;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             AbilityMutatorLootTable;                           // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             WeaponMutatorLootTable;                            // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CharmLootTable;                                    // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URMutatorRewardCategoryDataAsset*> MutatorRewardCategoryDataAssets;                 // 0x02D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class URMutatorRewardCategoryDataAsset*       AbilityMutatorRewardCategoryDataAsset;             // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URMutatorRewardCategoryDataAsset*       WeaponMutatorRewardCategoryDataAsset;              // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FLinearColor>              RankColorsMap;                                     // 0x02F8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	int32                                         TriggerArtifactChanceModifier;                     // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTriggerTypeLootThresholdModifier;               // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            TriggerTypeLootThresholdModifierTable;             // 0x0350(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static bool CanMutatorBeDropped(const class APlayerController* PlayerController, const class URMutatorPrimaryAsset* Mutator);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsBasedOnRewardTag(const struct FGameplayTag& InTag, const TArray<struct FMutatorLootTableRow>& InRows);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsByFirstRandomAmount(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators, int32 MinAmount, int32 MaxAmount);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsByLootability(const class APlayerController* PlayerController, const TArray<struct FMutatorLootTableRow>& UnfilteredMutators);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsByRarity(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators, EMutatorRarity Rarity);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsByTags(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsByTriggersAndPassivesWeighting(const TArray<struct FMutatorLootTableRow>& InRows, class APlayerController* PlayerController);
	static TArray<struct FMutatorLootTableRow> FilterMutatorRowsByWeightedRandomRarity(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators, const TMap<EMutatorRarity, float>& MutatorChances);
	static TArray<struct FRewardTableRow> FilterRewardCategoryRowsContainedInParentTag(const struct FGameplayTag& InTag, const TArray<struct FRewardTableRow>& InRows);
	static TArray<struct FMutatorLootTableRow> GetAbilitySpecificCharacterMutatorLootTableRows(const class APlayerController* PlayerController, class URMutatorPrimaryAsset* AbilitySpecificMutatorPrimaryAsset);
	static TArray<class URMutatorPrimaryAsset*> GetAllLogbookBlessings(const class UObject* WorldContextObject);
	static TArray<class URMutatorPrimaryAsset*> GetAllLogbookCharms(const class APlayerController* PlayerController);
	static struct FMutatorLootSettings GetCharmLootSettings(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* CharmMutatorPA);
	static TArray<struct FRLootSelectionOption> GetLootableOptionsByMutatorRewardCategory(const class UObject* WorldContextObject, class URMutatorRewardCategoryDataAsset* RMutatorRewardCategoryDataAsset, const int32 NumOptions, const bool bFilterByLootableActorBlacklist);
	static TArray<struct FMutatorLootTableRow> GetLootTableAbilityMutatorRows(const class APlayerController* PlayerController);
	static TArray<struct FMutatorLootTableRow> GetLootTableCharmRows(const class APlayerController* PlayerController, const EMutatorRarity Rarity);
	static class ARLootTableManager* GetLootTableManager(const class UObject* WorldContextObject);
	static TArray<struct FMutatorLootTableRow> GetLoottableMutatorRowsWithStandardFilters(const class APlayerController* PlayerController, const EMutatorRarity Rarity);
	static class URMutatorRewardCategoryDataAsset* GetMutatorCategoryDataAssetByMutatorPrimaryAsset(const class UObject* WorldContextObject, class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	static TArray<class URMutatorPrimaryAsset*> GetMutatorPrimaryAssetsFromRows(const TArray<struct FMutatorLootTableRow>& MutatorRows);
	static TArray<class URMutatorRewardCategoryDataAsset*> GetMutatorRewardCategoryDataAssets(const class UObject* WorldContextObject);
	static TArray<class URMutatorRewardCategoryDataAsset*> GetMutatorRewardCategoryDataAssetsByTags(const class UObject* WorldContextObject, const struct FGameplayTagContainer& InTags);
	static int32 GetNumLootableMutatorsInCategory(class APlayerController* PlayerController, const struct FGameplayTag& CategoryTag, const bool bIncludeTriggers);
	static struct FLinearColor GetRankColor(const class UObject* WorldContextObject, const int32 Rank);
	static struct FGameplayTagContainer GetUniqueRewardCategoriesFromRewardCategryoDataAssets(const TArray<class URMutatorRewardCategoryDataAsset*>& DataAssets);
	static EMutatorRarity GetWeightedRarity(const TMap<EMutatorRarity, float>& MutatorChances);
	static TArray<struct FMutatorLootTableRow> ShuffleMutatorRows(const TArray<struct FMutatorLootTableRow>& MutatorRows);

	void CopyMutatorDescriptionVariableRankValues();
	TArray<struct FMutatorLootTableRow> FilterMutatorRowsByChallengeCompletion(const TArray<struct FMutatorLootTableRow>& UnfilteredMutators);
	TArray<struct FMutatorLootTableRow> GetAllEnabledMutatorRows();
	TArray<struct FMutatorLootTableRow> GetEnabledMutatorRowsByCategory(const struct FGameplayTag& CategoryTag);
	TArray<struct FMutatorLootTableRow> GetLootableCharmRows(const class APlayerController* PlayerController);
	TArray<struct FMutatorLootTableRow> GetLootableMutatorRows(const class APlayerController* PlayerController);
	struct FMutatorLootSettings GetMutatorLootSettingsFromPrimaryAsset(class URMutatorPrimaryAsset* MutatorPrimaryAsset);
	TArray<struct FMutatorLootTableRow> GetMutatorRowsFromTable(class UDataTable* Table);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RLootTableManager">();
	}
	static class ARLootTableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARLootTableManager>();
	}
};
static_assert(alignof(ARLootTableManager) == 0x000008, "Wrong alignment on ARLootTableManager");
static_assert(sizeof(ARLootTableManager) == 0x0003A0, "Wrong size on ARLootTableManager");
static_assert(offsetof(ARLootTableManager, MutatorCategoryTables) == 0x0002A8, "Member 'ARLootTableManager::MutatorCategoryTables' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, AbilityLootTable) == 0x0002B8, "Member 'ARLootTableManager::AbilityLootTable' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, AbilityMutatorLootTable) == 0x0002C0, "Member 'ARLootTableManager::AbilityMutatorLootTable' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, WeaponMutatorLootTable) == 0x0002C8, "Member 'ARLootTableManager::WeaponMutatorLootTable' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, CharmLootTable) == 0x0002D0, "Member 'ARLootTableManager::CharmLootTable' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, MutatorRewardCategoryDataAssets) == 0x0002D8, "Member 'ARLootTableManager::MutatorRewardCategoryDataAssets' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, AbilityMutatorRewardCategoryDataAsset) == 0x0002E8, "Member 'ARLootTableManager::AbilityMutatorRewardCategoryDataAsset' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, WeaponMutatorRewardCategoryDataAsset) == 0x0002F0, "Member 'ARLootTableManager::WeaponMutatorRewardCategoryDataAsset' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, RankColorsMap) == 0x0002F8, "Member 'ARLootTableManager::RankColorsMap' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, TriggerArtifactChanceModifier) == 0x000348, "Member 'ARLootTableManager::TriggerArtifactChanceModifier' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, NumTriggerTypeLootThresholdModifier) == 0x00034C, "Member 'ARLootTableManager::NumTriggerTypeLootThresholdModifier' has a wrong offset!");
static_assert(offsetof(ARLootTableManager, TriggerTypeLootThresholdModifierTable) == 0x000350, "Member 'ARLootTableManager::TriggerTypeLootThresholdModifierTable' has a wrong offset!");

// Class RGame.RMerchant
// 0x0030 (0x03B8 - 0x0388)
class ARMerchant final : public ARLootableActor
{
public:
	TArray<class ARMerchantPlinth*>               Plinths;                                           // 0x0388(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ExtraPlinths;                                      // 0x0398(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRestocks;                                       // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URMutatorRewardCategoryDataAsset*> AvailableMutatorRewardCategoryDataAssets;        // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RestockCost;                                       // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAppeared;                                       // 0x03B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSpawnedItems(class APlayerController* PlayerController);
	int32 GetNumUniqueGeneratedMutatorCategories();
	void OnItemSold(class ARPickupableItem* PickedUpItem, int32 Cost, class APlayerController* PlayerController);
	void OnSpawnTrigBoxCompEntered(class AActor* OtherActor);
	void ResetAvailableMutatorRewardCategoryDataAssets();
	void SpawnItems(class APlayerController* PlayerController);
	void UnhideExtraPlinths();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMerchant">();
	}
	static class ARMerchant* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARMerchant>();
	}
};
static_assert(alignof(ARMerchant) == 0x000008, "Wrong alignment on ARMerchant");
static_assert(sizeof(ARMerchant) == 0x0003B8, "Wrong size on ARMerchant");
static_assert(offsetof(ARMerchant, Plinths) == 0x000388, "Member 'ARMerchant::Plinths' has a wrong offset!");
static_assert(offsetof(ARMerchant, ExtraPlinths) == 0x000398, "Member 'ARMerchant::ExtraPlinths' has a wrong offset!");
static_assert(offsetof(ARMerchant, NumRestocks) == 0x00039C, "Member 'ARMerchant::NumRestocks' has a wrong offset!");
static_assert(offsetof(ARMerchant, AvailableMutatorRewardCategoryDataAssets) == 0x0003A0, "Member 'ARMerchant::AvailableMutatorRewardCategoryDataAssets' has a wrong offset!");
static_assert(offsetof(ARMerchant, RestockCost) == 0x0003B0, "Member 'ARMerchant::RestockCost' has a wrong offset!");
static_assert(offsetof(ARMerchant, HasAppeared) == 0x0003B4, "Member 'ARMerchant::HasAppeared' has a wrong offset!");

// Class RGame.RMerchantPlinth
// 0x0068 (0x0310 - 0x02A8)
class ARMerchantPlinth final : public AActor
{
public:
	TArray<struct FRUniquePlinthLoot>             UniquePlinthLoot;                                  // 0x02A8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x30];                                     // 0x02B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ItemSpawnZOffset;                                  // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           SoftSpawnedItemTypes;                              // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAndUpdateLootForController(class APlayerController* PlayerController);
	void ClearSpawnedItem(class APlayerController* PlayerController);
	void OnItemSold(class ARPickupableItem* PickedUpItem, int32 Cost, class APlayerController* PlayerController);
	void OnMutatorPASet(class URMutatorPrimaryAsset* NewPrimaryAsset);
	void SetLootOptionForController(const TArray<struct FRLootSelectionOption>& NewMutatorLootSelection, EPlinthRewardType NewPlinthRewardType, class URMutatorPrimaryAsset* NewPrimaryAsset, bool bLooted, class URMutatorRewardCategoryDataAsset* NewGodCategory, class APlayerController* PlayerController);
	void TurnOnCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMerchantPlinth">();
	}
	static class ARMerchantPlinth* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARMerchantPlinth>();
	}
};
static_assert(alignof(ARMerchantPlinth) == 0x000008, "Wrong alignment on ARMerchantPlinth");
static_assert(sizeof(ARMerchantPlinth) == 0x000310, "Wrong size on ARMerchantPlinth");
static_assert(offsetof(ARMerchantPlinth, UniquePlinthLoot) == 0x0002A8, "Member 'ARMerchantPlinth::UniquePlinthLoot' has a wrong offset!");
static_assert(offsetof(ARMerchantPlinth, ItemSpawnZOffset) == 0x0002E8, "Member 'ARMerchantPlinth::ItemSpawnZOffset' has a wrong offset!");
static_assert(offsetof(ARMerchantPlinth, SoftSpawnedItemTypes) == 0x0002F0, "Member 'ARMerchantPlinth::SoftSpawnedItemTypes' has a wrong offset!");

// Class RGame.RMusicData
// 0x0010 (0x0040 - 0x0030)
class URMusicData final : public UDataAsset
{
public:
	TArray<struct FRLevelMusicData>               LevelMusic;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMusicData">();
	}
	static class URMusicData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMusicData>();
	}
};
static_assert(alignof(URMusicData) == 0x000008, "Wrong alignment on URMusicData");
static_assert(sizeof(URMusicData) == 0x000040, "Wrong size on URMusicData");
static_assert(offsetof(URMusicData, LevelMusic) == 0x000030, "Member 'URMusicData::LevelMusic' has a wrong offset!");

// Class RGame.RMusicManager
// 0x0088 (0x0330 - 0x02A8)
class ARMusicManager : public AActor
{
public:
	class URMusicData*                            MusicData;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShuffleLevelMusic;                                // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Progression;                                       // 0x02B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText SongName)> OnMusicPlay;                                // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FRLevelMusicData                       CurrentLevelMusicData;                             // 0x02C8(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bLevelHasMusic;                                    // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CurrentLevelTagIDContainer;                        // 0x0310(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class ARMusicManager* GetMusicManager(const class UObject* WorldContextObject);

	float GetDurationFromWaveInCue(class USoundCue* SoundCue, int32 WaveIndex);
	bool GetLevelHasMusic();
	void K2_OnLevelChanged();
	void OnBossPhaseStarted(class FName NewState);
	void OnBossPhaseStarted_Multicast(class FName NewState);
	void OnLevelChanged_Internal();
	void OnPlayerAlive(class ARPlayerPawn* Player);
	void OnPlayerAlive_Multicast(class ARPlayerPawn* Player);
	void OnPlayerDowned(class ARPlayerPawn* Player);
	void OnPlayerDowned_Multicast(class ARPlayerPawn* Player);
	void OnSegmentCompleted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnSegmentCompleted_Multicast(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnSegmentStarted(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void OnSegmentStarted_Multicast(class AREnemySpawnAreaSegment* EnemySpawnAreaSegment);
	void PlayCurrentLevelMusic();
	void PlayEmoteSong(const class USoundBase* EmoteSong, const class ARPawnBase* RequestingPlayer);
	void PlayEmoteSong_Multicast(const class USoundBase* EmoteSong, const class ARPawnBase* RequestingPlayer);
	void PlayEmoteSongImplementation(const class USoundBase* EmoteSong, const class ARPawnBase* RequestingPlayer);
	void PlayEventMusic(class FName Event);
	void SetCurrentLevelMusicData(const struct FRLevelMusicData& NewLevelMusicData);
	void SetMusicData(class URMusicData* NewMusicData);
	bool UpdateLevelMusicData(const struct FGameplayTagContainer& LevelTagIDContainer, class URAreaData* AreaData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMusicManager">();
	}
	static class ARMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARMusicManager>();
	}
};
static_assert(alignof(ARMusicManager) == 0x000008, "Wrong alignment on ARMusicManager");
static_assert(sizeof(ARMusicManager) == 0x000330, "Wrong size on ARMusicManager");
static_assert(offsetof(ARMusicManager, MusicData) == 0x0002A8, "Member 'ARMusicManager::MusicData' has a wrong offset!");
static_assert(offsetof(ARMusicManager, bShuffleLevelMusic) == 0x0002B0, "Member 'ARMusicManager::bShuffleLevelMusic' has a wrong offset!");
static_assert(offsetof(ARMusicManager, Progression) == 0x0002B4, "Member 'ARMusicManager::Progression' has a wrong offset!");
static_assert(offsetof(ARMusicManager, OnMusicPlay) == 0x0002B8, "Member 'ARMusicManager::OnMusicPlay' has a wrong offset!");
static_assert(offsetof(ARMusicManager, CurrentLevelMusicData) == 0x0002C8, "Member 'ARMusicManager::CurrentLevelMusicData' has a wrong offset!");
static_assert(offsetof(ARMusicManager, bLevelHasMusic) == 0x000308, "Member 'ARMusicManager::bLevelHasMusic' has a wrong offset!");
static_assert(offsetof(ARMusicManager, CurrentLevelTagIDContainer) == 0x000310, "Member 'ARMusicManager::CurrentLevelTagIDContainer' has a wrong offset!");

// Class RGame.RMutatorEntryWidget
// 0x0000 (0x02D0 - 0x02D0)
class URMutatorEntryWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutatorEntryWidget">();
	}
	static class URMutatorEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutatorEntryWidget>();
	}
};
static_assert(alignof(URMutatorEntryWidget) == 0x000008, "Wrong alignment on URMutatorEntryWidget");
static_assert(sizeof(URMutatorEntryWidget) == 0x0002D0, "Wrong size on URMutatorEntryWidget");

// Class RGame.RMutatorLog
// 0x0000 (0x02D0 - 0x02D0)
class URMutatorLog final : public UUserWidget
{
public:
	class UTileView* GetMutatorTiles();
	void NativeFillGridByCategory(const struct FGameplayTag& CategoryTag, const bool bClearFirst);
	void NativeFillGridByCharms(const bool bClearFirst);
	void NativeFillGridByMutatorTable(class UDataTable* MutatorTable, const bool bClearFirst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutatorLog">();
	}
	static class URMutatorLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutatorLog>();
	}
};
static_assert(alignof(URMutatorLog) == 0x000008, "Wrong alignment on URMutatorLog");
static_assert(sizeof(URMutatorLog) == 0x0002D0, "Wrong size on URMutatorLog");

// Class RGame.RMutatorSetComponent
// 0x0000 (0x00A0 - 0x00A0)
class URMutatorSetComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutatorSetComponent">();
	}
	static class URMutatorSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutatorSetComponent>();
	}
};
static_assert(alignof(URMutatorSetComponent) == 0x000008, "Wrong alignment on URMutatorSetComponent");
static_assert(sizeof(URMutatorSetComponent) == 0x0000A0, "Wrong size on URMutatorSetComponent");

// Class RGame.RMutatorWidget
// 0x0000 (0x02D0 - 0x02D0)
class URMutatorWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutatorWidget">();
	}
	static class URMutatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutatorWidget>();
	}
};
static_assert(alignof(URMutatorWidget) == 0x000008, "Wrong alignment on URMutatorWidget");
static_assert(sizeof(URMutatorWidget) == 0x0002D0, "Wrong size on URMutatorWidget");

// Class RGame.RNavigationManager
// 0x9B68 (0x9E10 - 0x02A8)
class alignas(0x10) ARNavigationManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x280];                                    // 0x02A8(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             NavMeshDataTable;                                  // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingJumpVoxelMultiplier;                        // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeight;                                     // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelSize;                                         // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XGridSize;                                         // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YGridSize;                                         // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZGridSize;                                         // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ObstacleQueryChannels;                             // 0x0568(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnoreForCollision;                        // 0x0578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AutoCorrectionGuessList;                           // 0x0588(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UnrealPhyxPenetrationDepth;                        // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PerformCollisionChecksOnStartup;                   // 0x059C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateNavmeshJSONIfNoneExist;                   // 0x059D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiThreadingEnabled;                            // 0x059E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59F[0x1];                                      // 0x059F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorkerThreadsToSpawn;                              // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSolutionsPerWorkerThread;                       // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         neighborSearchMaxDepth;                            // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPathSolverIterationsPerTick;                    // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollisionSolverIterationsPerTick;               // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPathSolverIterationsOnThread;                   // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollisionSolverIterationsOnThread;              // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalItterations;                               // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxItterationDuration;                             // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   FilledBoxWorldVisualizer;                          // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          WorldBoundaryVisualizer;                           // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundary;                             // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundaryFilled;                       // 0x05D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundaryInGame;                       // 0x05DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DB[0x1];                                      // 0x05DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugVoxelsLineThickness;                          // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunDebugValidationsForDynamicCollisions;          // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWalkableVoxels;                            // 0x05E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayClimbableVoxels;                           // 0x05E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayFlyableVoxels;                             // 0x05E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayBlockedVoxels;                             // 0x05E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E5[0x95A3];                                   // 0x05E5(0x95A3)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           ActiveNavigationTaskOwners;                        // 0x9B88(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class UPrimitiveComponent*>              ActiveCollisionTaskOwners;                         // 0x9BD8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C28[0x1E8];                                   // 0x9C28(0x01E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortPathfindingTask(class AActor* Actor);
	void CacheVoxelCollision();
	bool CanNavigate(const struct FVector& Location, ERVoxelNavigationType NavigationType);
	struct FVector ClampLocationToNavigableWorld(const struct FVector& DesiredLocation);
	void ConstructBuilder();
	void Debug_ClearAllVolumes();
	void Debug_DrawAllVolumes(float LineThickness);
	void Debug_DrawVolumesAroundPoint(const struct FVector& Location, int32 CubeSize, bool DrawPersistentLines, float Duration, float LineThickness, bool bAutoInitializeVolumes);
	void Debug_DrawVoxelCollisionProfile(class UPrimitiveComponent* MeshOrPrimitive, const struct FVector& OriginLocation, bool bDrawPersistent, float Duration);
	void Debug_ToggleWorldBoundaryInGame();
	bool FindPathSolution(class AActor* Actor, const struct FVector& Destination, const struct FRNavigationQueryParams& QueryParams, const struct FRNavigationDebugParams& DebugParams, ERVoxelNavigationType NavigationType, bool bAllowJump, float MaxJumpDistance, float MinFlightHeight, float MaxFlightHeight);
	struct FVector FindRandomPointAroundOriginInNavWorld(class AActor* NavigationActor, const struct FVector& Origin, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts, ERVoxelNavigationType NavigationType);
	struct FVector FindRandomPointFromActorInNavWorld(class AActor* Actor, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts, ERVoxelNavigationType NavigationType);
	struct FVector GetClosestNavigableLocation(const struct FVector& DesiredLocation, ERVoxelNavigationType NavigationType, int32 NeighborSearchMaxDepthOverride, bool bAllowClimbable);
	bool HasTask(class AActor* Actor);
	void InitVoxelCollision();
	bool IsDirectPathLineSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation);
	bool IsDirectPathSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation);
	bool IsLocationBeneathLandscape(const struct FVector& Location, float LineTraceHeight);
	bool IsLocationWithinNavigableWorld(const struct FVector& DesiredLocation);
	bool IsMeshBoundsWithinNavigableWorld(class UPrimitiveComponent* Mesh, float BoundsScaleFactor);
	bool ScheduleDynamicCollisionUpdate(class UPrimitiveComponent* Mesh, TDelegate<void(bool bTaskSuccessful)> ResultHandler, class FName CustomCacheIdentifier, bool bReplaceExistingTask, bool bDisableCacheUsage, bool bReloadCollisionCache, bool bUseCheapBoundsCollision, float BoundsScaleFactor, bool bForceSynchronousExecution, bool bDrawDebug);
	bool SchedulePathfindingTask(class AActor* Actor, const struct FVector& Destination, const struct FRNavigationQueryParams& QueryParams, const struct FRNavigationDebugParams& DebugParams, TDelegate<void(const struct FRNavigationQueryData& Data)> ResultHandlerDelegate, TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> DynamicCollisionListener, ERVoxelNavigationType NavigationType, bool bAllowJump, float MaxJumpDistance, float MinFlightHeight, float MaxFlightHeight);
	void StopListeningToDynamicCollisionsForPath(TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> ListenerToClear, const struct FRNavigationQueryData& QueryData);
	void StopListeningToDynamicCollisionsForPathIndex(TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> ListenerToClear, const struct FRNavigationQueryData& QueryData, const int32 VolumeIndex);
	void VisualizeDynamicCollisionListeners(TDelegate<void(const struct FRNavigationDynamicCollisionPayload& Data)> Listener, const struct FRNavigationQueryData& QueryData);
	void VisualizeNAVResult(const TArray<struct FVector>& PathSolution, const struct FVector& Source, const struct FVector& Destination, bool Reset, const struct FRNavigationDebugParams& DebugParams, const struct FColor& LineColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNavigationManager">();
	}
	static class ARNavigationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARNavigationManager>();
	}
};
static_assert(alignof(ARNavigationManager) == 0x000010, "Wrong alignment on ARNavigationManager");
static_assert(sizeof(ARNavigationManager) == 0x009E10, "Wrong size on ARNavigationManager");
static_assert(offsetof(ARNavigationManager, SceneComponent) == 0x000528, "Member 'ARNavigationManager::SceneComponent' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, NavMeshDataTable) == 0x000530, "Member 'ARNavigationManager::NavMeshDataTable' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, WalkingJumpVoxelMultiplier) == 0x000548, "Member 'ARNavigationManager::WalkingJumpVoxelMultiplier' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxStepHeight) == 0x00054C, "Member 'ARNavigationManager::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxJumpHeight) == 0x000550, "Member 'ARNavigationManager::MaxJumpHeight' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, VoxelSize) == 0x000554, "Member 'ARNavigationManager::VoxelSize' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, XGridSize) == 0x000558, "Member 'ARNavigationManager::XGridSize' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, YGridSize) == 0x00055C, "Member 'ARNavigationManager::YGridSize' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, ZGridSize) == 0x000560, "Member 'ARNavigationManager::ZGridSize' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, ObstacleQueryChannels) == 0x000568, "Member 'ARNavigationManager::ObstacleQueryChannels' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, ActorsToIgnoreForCollision) == 0x000578, "Member 'ARNavigationManager::ActorsToIgnoreForCollision' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, AutoCorrectionGuessList) == 0x000588, "Member 'ARNavigationManager::AutoCorrectionGuessList' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, UnrealPhyxPenetrationDepth) == 0x000598, "Member 'ARNavigationManager::UnrealPhyxPenetrationDepth' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, PerformCollisionChecksOnStartup) == 0x00059C, "Member 'ARNavigationManager::PerformCollisionChecksOnStartup' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bGenerateNavmeshJSONIfNoneExist) == 0x00059D, "Member 'ARNavigationManager::bGenerateNavmeshJSONIfNoneExist' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bMultiThreadingEnabled) == 0x00059E, "Member 'ARNavigationManager::bMultiThreadingEnabled' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, WorkerThreadsToSpawn) == 0x0005A0, "Member 'ARNavigationManager::WorkerThreadsToSpawn' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxSolutionsPerWorkerThread) == 0x0005A4, "Member 'ARNavigationManager::MaxSolutionsPerWorkerThread' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, neighborSearchMaxDepth) == 0x0005A8, "Member 'ARNavigationManager::neighborSearchMaxDepth' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxPathSolverIterationsPerTick) == 0x0005AC, "Member 'ARNavigationManager::MaxPathSolverIterationsPerTick' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxCollisionSolverIterationsPerTick) == 0x0005B0, "Member 'ARNavigationManager::MaxCollisionSolverIterationsPerTick' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxPathSolverIterationsOnThread) == 0x0005B4, "Member 'ARNavigationManager::MaxPathSolverIterationsOnThread' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxCollisionSolverIterationsOnThread) == 0x0005B8, "Member 'ARNavigationManager::MaxCollisionSolverIterationsOnThread' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxTotalItterations) == 0x0005BC, "Member 'ARNavigationManager::MaxTotalItterations' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, MaxItterationDuration) == 0x0005C0, "Member 'ARNavigationManager::MaxItterationDuration' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, FilledBoxWorldVisualizer) == 0x0005C8, "Member 'ARNavigationManager::FilledBoxWorldVisualizer' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, WorldBoundaryVisualizer) == 0x0005D0, "Member 'ARNavigationManager::WorldBoundaryVisualizer' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayWorldBoundary) == 0x0005D8, "Member 'ARNavigationManager::bDisplayWorldBoundary' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayWorldBoundaryFilled) == 0x0005D9, "Member 'ARNavigationManager::bDisplayWorldBoundaryFilled' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayWorldBoundaryInGame) == 0x0005DA, "Member 'ARNavigationManager::bDisplayWorldBoundaryInGame' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, DebugVoxelsLineThickness) == 0x0005DC, "Member 'ARNavigationManager::DebugVoxelsLineThickness' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bRunDebugValidationsForDynamicCollisions) == 0x0005E0, "Member 'ARNavigationManager::bRunDebugValidationsForDynamicCollisions' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayWalkableVoxels) == 0x0005E1, "Member 'ARNavigationManager::bDisplayWalkableVoxels' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayClimbableVoxels) == 0x0005E2, "Member 'ARNavigationManager::bDisplayClimbableVoxels' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayFlyableVoxels) == 0x0005E3, "Member 'ARNavigationManager::bDisplayFlyableVoxels' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, bDisplayBlockedVoxels) == 0x0005E4, "Member 'ARNavigationManager::bDisplayBlockedVoxels' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, ActiveNavigationTaskOwners) == 0x009B88, "Member 'ARNavigationManager::ActiveNavigationTaskOwners' has a wrong offset!");
static_assert(offsetof(ARNavigationManager, ActiveCollisionTaskOwners) == 0x009BD8, "Member 'ARNavigationManager::ActiveCollisionTaskOwners' has a wrong offset!");

// Class RGame.RNiagaraComponent
// 0x0000 (0x0750 - 0x0750)
class URNiagaraComponent : public UNiagaraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNiagaraComponent">();
	}
	static class URNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URNiagaraComponent>();
	}
};
static_assert(alignof(URNiagaraComponent) == 0x000010, "Wrong alignment on URNiagaraComponent");
static_assert(sizeof(URNiagaraComponent) == 0x000750, "Wrong size on URNiagaraComponent");

// Class RGame.RNodeChoicePrimaryAsset
// 0x0098 (0x0108 - 0x0070)
class URNodeChoicePrimaryAsset final : public URPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   SoftScriptClass;                                   // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FDescriptionVariable>           DescriptionVariables;                              // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsReward;                                         // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NodeChoiceRewardClass;                             // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           NodeChoiceRewards;                                 // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         NumRewardWithFixedMutatorRarity;                   // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMutatorRarity                                FixedMutatorRarity;                                // 0x00FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumEnemyMutators;                                  // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNodeChoicePrimaryAsset">();
	}
	static class URNodeChoicePrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URNodeChoicePrimaryAsset>();
	}
};
static_assert(alignof(URNodeChoicePrimaryAsset) == 0x000008, "Wrong alignment on URNodeChoicePrimaryAsset");
static_assert(sizeof(URNodeChoicePrimaryAsset) == 0x000108, "Wrong size on URNodeChoicePrimaryAsset");
static_assert(offsetof(URNodeChoicePrimaryAsset, SoftScriptClass) == 0x000070, "Member 'URNodeChoicePrimaryAsset::SoftScriptClass' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, Description) == 0x000098, "Member 'URNodeChoicePrimaryAsset::Description' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, DescriptionVariables) == 0x0000A8, "Member 'URNodeChoicePrimaryAsset::DescriptionVariables' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, bIsReward) == 0x0000B8, "Member 'URNodeChoicePrimaryAsset::bIsReward' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, NodeChoiceRewardClass) == 0x0000C0, "Member 'URNodeChoicePrimaryAsset::NodeChoiceRewardClass' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, NodeChoiceRewards) == 0x0000E8, "Member 'URNodeChoicePrimaryAsset::NodeChoiceRewards' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, NumRewardWithFixedMutatorRarity) == 0x0000F8, "Member 'URNodeChoicePrimaryAsset::NumRewardWithFixedMutatorRarity' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, FixedMutatorRarity) == 0x0000FC, "Member 'URNodeChoicePrimaryAsset::FixedMutatorRarity' has a wrong offset!");
static_assert(offsetof(URNodeChoicePrimaryAsset, NumEnemyMutators) == 0x000100, "Member 'URNodeChoicePrimaryAsset::NumEnemyMutators' has a wrong offset!");

// Class RGame.RNodeRewardSpawnPoint
// 0x0000 (0x02A8 - 0x02A8)
class ARNodeRewardSpawnPoint : public AActor
{
public:
	void SetCharmForController(class URMutatorPrimaryAsset* CharmPrimaryAsset, bool bCharmPickedUp, class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNodeRewardSpawnPoint">();
	}
	static class ARNodeRewardSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARNodeRewardSpawnPoint>();
	}
};
static_assert(alignof(ARNodeRewardSpawnPoint) == 0x000008, "Wrong alignment on ARNodeRewardSpawnPoint");
static_assert(sizeof(ARNodeRewardSpawnPoint) == 0x0002A8, "Wrong size on ARNodeRewardSpawnPoint");

// Class RGame.RNotificationScreenWidget
// 0x0088 (0x0358 - 0x02D0)
class URNotificationScreenWidget : public UUserWidget
{
public:
	TSubclassOf<class URNotificationWidget>       NormalNotificationWidget;                          // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class URNotificationWidget>       WarningNotificationWidget;                         // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class URNotificationWidget>       ErrorNotificationWidget;                           // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class URPickupNotificationWidget> PickupNotificationWidget;                          // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           NormalNotificationContainer;                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           WarningNotificationContainer;                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           ErrorNotificationContainer;                        // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class URPickupNotificationWidget*> CurrentPickupEntries;                     // 0x0308(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static void PushNotification(class APlayerController* PlayerController, const class FText& Message, ERNotificationSeverity Severity);
	static void PushPickupNotification(class APlayerController* PlayerController, const class FText& Message, int32 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNotificationScreenWidget">();
	}
	static class URNotificationScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URNotificationScreenWidget>();
	}
};
static_assert(alignof(URNotificationScreenWidget) == 0x000008, "Wrong alignment on URNotificationScreenWidget");
static_assert(sizeof(URNotificationScreenWidget) == 0x000358, "Wrong size on URNotificationScreenWidget");
static_assert(offsetof(URNotificationScreenWidget, NormalNotificationWidget) == 0x0002D0, "Member 'URNotificationScreenWidget::NormalNotificationWidget' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, WarningNotificationWidget) == 0x0002D8, "Member 'URNotificationScreenWidget::WarningNotificationWidget' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, ErrorNotificationWidget) == 0x0002E0, "Member 'URNotificationScreenWidget::ErrorNotificationWidget' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, PickupNotificationWidget) == 0x0002E8, "Member 'URNotificationScreenWidget::PickupNotificationWidget' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, NormalNotificationContainer) == 0x0002F0, "Member 'URNotificationScreenWidget::NormalNotificationContainer' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, WarningNotificationContainer) == 0x0002F8, "Member 'URNotificationScreenWidget::WarningNotificationContainer' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, ErrorNotificationContainer) == 0x000300, "Member 'URNotificationScreenWidget::ErrorNotificationContainer' has a wrong offset!");
static_assert(offsetof(URNotificationScreenWidget, CurrentPickupEntries) == 0x000308, "Member 'URNotificationScreenWidget::CurrentPickupEntries' has a wrong offset!");

// Class RGame.RNotificationWidget
// 0x0028 (0x02F8 - 0x02D0)
class URNotificationWidget : public UUserWidget
{
public:
	class UTextBlock*                             MessageText;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Message;                                           // 0x02D8(0x0010)(Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ConstructAnimation;                                // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSequencePlayer*                     ConstructAnimationSequencePlayer;                  // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnConstructAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNotificationWidget">();
	}
	static class URNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URNotificationWidget>();
	}
};
static_assert(alignof(URNotificationWidget) == 0x000008, "Wrong alignment on URNotificationWidget");
static_assert(sizeof(URNotificationWidget) == 0x0002F8, "Wrong size on URNotificationWidget");
static_assert(offsetof(URNotificationWidget, MessageText) == 0x0002D0, "Member 'URNotificationWidget::MessageText' has a wrong offset!");
static_assert(offsetof(URNotificationWidget, Message) == 0x0002D8, "Member 'URNotificationWidget::Message' has a wrong offset!");
static_assert(offsetof(URNotificationWidget, ConstructAnimation) == 0x0002E8, "Member 'URNotificationWidget::ConstructAnimation' has a wrong offset!");
static_assert(offsetof(URNotificationWidget, ConstructAnimationSequencePlayer) == 0x0002F0, "Member 'URNotificationWidget::ConstructAnimationSequencePlayer' has a wrong offset!");

// Class RGame.RPawnMovementComponent
// 0x08A0 (0x0A10 - 0x0170)
class URPawnMovementComponent : public UPawnMovementComponent
{
public:
	uint8                                         Pad_170[0x80];                                     // 0x0170(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FixedCurveMovement;                                // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            FixedCurveTimeModifier;                            // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x90];                                     // 0x0200(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class ARPawnBase*                             Pawn;                                              // 0x0290(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x114];                                    // 0x0298(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bPositionCorrected : 1;                            // 0x03AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3AD[0x11B];                                    // 0x03AD(0x011B)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MovementTargetActor;                               // 0x04C8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x19];                                     // 0x04D0(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	ERClientMovement                              ClientMovement;                                    // 0x04E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EA[0x2];                                      // 0x04EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundAcceleration;                                // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeceleration;                                // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningBoost;                                      // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AboveMaxSpeedDecelerationMultiplier;               // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirMaxSpeed;                                       // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirAcceleration;                                   // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDeceleration;                                   // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirTurningBoost;                                   // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirAboveMaxSpeedDecelerationMultiplier;            // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlFactor;                                  // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         MovementSpeedModifier;                             // 0x0518(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSlowImmunity;                                     // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpHeight;                                        // 0x0644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngle;                                // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_654[0x4];                                      // 0x0654(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMutableFloat                         GravityMultiplier;                                 // 0x0658(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DashSpeed;                                         // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashTime;                                          // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelDashOnImpact;                               // 0x0788(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyGravityWhileDashing;                         // 0x0789(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyForcesAndImpulsesWhileDashing;               // 0x078A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKnockbackEnabled;                                 // 0x078B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackFriction;                                 // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackAirFriction;                              // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackEndVelocityThreshold;                     // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackResistance;                               // 0x0798(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingFriction;                                    // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetMovementInput;                               // 0x07A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRotatingTowardsTarget;                          // 0x07B0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x3];                                      // 0x07B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationInterpSpeed;                               // 0x07B4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputInterpSpeed;                          // 0x07B8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventSurfaceCheck;                              // 0x07BC(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventMovementTick;                              // 0x07BD(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventPendingLaunches;                           // 0x07BE(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BF[0x1];                                      // 0x07BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    RotationTargetLocation;                            // 0x07C0(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RotationTargetActor;                               // 0x07D8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRotationToVector;                             // 0x07E0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERPawnMovementMode                            PreFallingMovementMode;                            // 0x07E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E2[0x6];                                      // 0x07E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastWalkingLocation;                               // 0x07E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSafeWalkingLocation;                           // 0x0800(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FailsafeTeleportLocation;                          // 0x0818(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientPredictionSmoothingData         Smoothing;                                         // 0x0830(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSlidingSpeed;                                   // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRPawnMovementState                    PawnMovementState;                                 // 0x0848(0x0080)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRPawnMovementInput                    PawnMovementInput;                                 // 0x08C8(0x0098)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLandedOnGround;                                  // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDirectLerpEnded;                                 // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName EventName)> OnMovementEvent;                           // 0x0980(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDashEndedReason Reason)> OnDashEnded;                             // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDashStarted;                                     // 0x09A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EChargeEndedReason Reason)> OnChargeEnded;                         // 0x09B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPawnBase* Pawn)> OnMovement;                               // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& NewDir)> OnChargeBounce;                     // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnChargeHitWall;                                   // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnKnockbacked;                                     // 0x09F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnKnockbackEnded;                                  // 0x0A00(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void AddControlInputBlock(class FName Key);
	void AddDashBlock(class FName Key);
	void AddForce(const struct FVector& Force);
	void AddImpulse(const struct FVector& Impulse, bool bVelocityChange);
	void AddInputPhysicsBlock(class FName Key);
	void AddJumpBlock(class FName Key);
	void ClearControlInputBlocks();
	void ClearDashBlocks();
	void ClearInputPhysicsBlocks();
	void ClearJumpBlocks();
	void ClearMovementTarget();
	void ClearRotationTarget();
	void EndCharge(EChargeEndedReason Reason);
	void FlushMovementStateLocation();
	void ForceStopAllMovementImmediatly();
	void Knockback(const struct FVector& Impulse, bool bVelocityChange);
	void Launch(const struct FVector& LaunchVelocity);
	void OnLevelChanged();
	void OnRep_PawnMovementInput();
	void OnRep_PawnMovementState(const struct FRPawnMovementState& OldState);
	void RemoveControlInputBlock(class FName Key);
	void RemoveDashBlock(class FName Key);
	void RemoveInputPhysicsBlock(class FName Key);
	void RemoveJumpBlock(class FName Key);
	void SendStateAndInput_Server(const struct FRPawnMovementState& NewState, const struct FRPawnMovementInput& NewInput);
	void ServerDoJump(uint32 EventId, float JumpHeightMultiplier);
	void ServerSetInput(const struct FRPawnMovementInput& NewInput);
	void SetFrozenBounceOnWalls(bool bNewFrozenBounceOnWalls);
	void SetLastWalkingLocation(const struct FVector& Location, bool bOverrideFailsafeTeleportLocation);
	void SetMovementInput(const struct FVector2D& NewMovementInput);
	void SetMovementTargetActor(class AActor* Actor);
	void SetRotationTargetActor(class AActor* Actor, bool bOverrideVectorRotationLock);
	void SetRotationTargetLocation(const struct FVector& Location, bool bNewLockRotationToVector);
	void StartChargeActor(class AActor* Actor, float TargetReachedTolerance, float SpeedMultiplier, float TimeLimit, bool bEndOnTargetReached);
	void StartChargeDirection(const struct FVector& Direction, float SpeedMultiplier, float TimeLimit, bool bBounceOnWalls, bool bStopOnWalls, bool bBounceOnPits, bool bStopOnPits);
	void StartChargeLocation(const struct FVector& Location, float TargetReachedTolerance, float SpeedMultiplier, float TimeLimit, bool bEndOnTargetReached);
	void StartDash(const struct FVector& WorldDirection, float SpeedMultiplier, float DistanceMultiplier);
	void StartDirectLerp(const struct FVector& TargetLocation, float LerpDuration);
	void StartFixedCurve(class UCurveFloat* Curve, const struct FVector& EndWorldLocation, float BaseTime, class UCurveFloat* TimeModifier);
	void StartFlying();
	void StopAllHorizontalMovementImmediately();
	void StopDirectLerp();
	void StopFlying();
	void TeleportActor(const struct FVector& NewLocation);
	bool TryJump(float JumpHeightMultiplier);

	EPhysicalSurface GetSurfaceType() const;
	struct FVector GetWorldInputVector() const;
	bool IsControlInputBlocked() const;
	bool IsDashingBlocked() const;
	bool IsInputPhysicsBlocked() const;
	bool IsJumpingBlocked() const;
	bool IsWalkableAngle(const struct FHitResult& Hit) const;
	const struct FVector2D MovementInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPawnMovementComponent">();
	}
	static class URPawnMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPawnMovementComponent>();
	}
};
static_assert(alignof(URPawnMovementComponent) == 0x000008, "Wrong alignment on URPawnMovementComponent");
static_assert(sizeof(URPawnMovementComponent) == 0x000A10, "Wrong size on URPawnMovementComponent");
static_assert(offsetof(URPawnMovementComponent, FixedCurveMovement) == 0x0001F0, "Member 'URPawnMovementComponent::FixedCurveMovement' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, FixedCurveTimeModifier) == 0x0001F8, "Member 'URPawnMovementComponent::FixedCurveTimeModifier' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, Pawn) == 0x000290, "Member 'URPawnMovementComponent::Pawn' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, MovementTargetActor) == 0x0004C8, "Member 'URPawnMovementComponent::MovementTargetActor' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, ClientMovement) == 0x0004E9, "Member 'URPawnMovementComponent::ClientMovement' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, MaxSpeed) == 0x0004EC, "Member 'URPawnMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, GroundAcceleration) == 0x0004F0, "Member 'URPawnMovementComponent::GroundAcceleration' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, GroundDeceleration) == 0x0004F4, "Member 'URPawnMovementComponent::GroundDeceleration' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, TurningBoost) == 0x0004F8, "Member 'URPawnMovementComponent::TurningBoost' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AboveMaxSpeedDecelerationMultiplier) == 0x0004FC, "Member 'URPawnMovementComponent::AboveMaxSpeedDecelerationMultiplier' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AirMaxSpeed) == 0x000500, "Member 'URPawnMovementComponent::AirMaxSpeed' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AirAcceleration) == 0x000504, "Member 'URPawnMovementComponent::AirAcceleration' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AirDeceleration) == 0x000508, "Member 'URPawnMovementComponent::AirDeceleration' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AirTurningBoost) == 0x00050C, "Member 'URPawnMovementComponent::AirTurningBoost' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AirAboveMaxSpeedDecelerationMultiplier) == 0x000510, "Member 'URPawnMovementComponent::AirAboveMaxSpeedDecelerationMultiplier' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, AirControlFactor) == 0x000514, "Member 'URPawnMovementComponent::AirControlFactor' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, MovementSpeedModifier) == 0x000518, "Member 'URPawnMovementComponent::MovementSpeedModifier' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bSlowImmunity) == 0x000640, "Member 'URPawnMovementComponent::bSlowImmunity' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, JumpHeight) == 0x000644, "Member 'URPawnMovementComponent::JumpHeight' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, WalkableFloorAngle) == 0x000648, "Member 'URPawnMovementComponent::WalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, MaxStepHeight) == 0x00064C, "Member 'URPawnMovementComponent::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, Mass) == 0x000650, "Member 'URPawnMovementComponent::Mass' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, GravityMultiplier) == 0x000658, "Member 'URPawnMovementComponent::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, DashSpeed) == 0x000780, "Member 'URPawnMovementComponent::DashSpeed' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, DashTime) == 0x000784, "Member 'URPawnMovementComponent::DashTime' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bCancelDashOnImpact) == 0x000788, "Member 'URPawnMovementComponent::bCancelDashOnImpact' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bApplyGravityWhileDashing) == 0x000789, "Member 'URPawnMovementComponent::bApplyGravityWhileDashing' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bApplyForcesAndImpulsesWhileDashing) == 0x00078A, "Member 'URPawnMovementComponent::bApplyForcesAndImpulsesWhileDashing' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bKnockbackEnabled) == 0x00078B, "Member 'URPawnMovementComponent::bKnockbackEnabled' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, KnockbackFriction) == 0x00078C, "Member 'URPawnMovementComponent::KnockbackFriction' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, KnockbackAirFriction) == 0x000790, "Member 'URPawnMovementComponent::KnockbackAirFriction' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, KnockbackEndVelocityThreshold) == 0x000794, "Member 'URPawnMovementComponent::KnockbackEndVelocityThreshold' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, KnockbackResistance) == 0x000798, "Member 'URPawnMovementComponent::KnockbackResistance' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, FlyingFriction) == 0x00079C, "Member 'URPawnMovementComponent::FlyingFriction' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, TargetMovementInput) == 0x0007A0, "Member 'URPawnMovementComponent::TargetMovementInput' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bIsRotatingTowardsTarget) == 0x0007B0, "Member 'URPawnMovementComponent::bIsRotatingTowardsTarget' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, RotationInterpSpeed) == 0x0007B4, "Member 'URPawnMovementComponent::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, MovementInputInterpSpeed) == 0x0007B8, "Member 'URPawnMovementComponent::MovementInputInterpSpeed' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bPreventSurfaceCheck) == 0x0007BC, "Member 'URPawnMovementComponent::bPreventSurfaceCheck' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bPreventMovementTick) == 0x0007BD, "Member 'URPawnMovementComponent::bPreventMovementTick' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bPreventPendingLaunches) == 0x0007BE, "Member 'URPawnMovementComponent::bPreventPendingLaunches' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, RotationTargetLocation) == 0x0007C0, "Member 'URPawnMovementComponent::RotationTargetLocation' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, RotationTargetActor) == 0x0007D8, "Member 'URPawnMovementComponent::RotationTargetActor' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, bLockRotationToVector) == 0x0007E0, "Member 'URPawnMovementComponent::bLockRotationToVector' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, PreFallingMovementMode) == 0x0007E1, "Member 'URPawnMovementComponent::PreFallingMovementMode' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, LastWalkingLocation) == 0x0007E8, "Member 'URPawnMovementComponent::LastWalkingLocation' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, LastSafeWalkingLocation) == 0x000800, "Member 'URPawnMovementComponent::LastSafeWalkingLocation' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, FailsafeTeleportLocation) == 0x000818, "Member 'URPawnMovementComponent::FailsafeTeleportLocation' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, Smoothing) == 0x000830, "Member 'URPawnMovementComponent::Smoothing' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, MaxSlidingSpeed) == 0x000844, "Member 'URPawnMovementComponent::MaxSlidingSpeed' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, PawnMovementState) == 0x000848, "Member 'URPawnMovementComponent::PawnMovementState' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, PawnMovementInput) == 0x0008C8, "Member 'URPawnMovementComponent::PawnMovementInput' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnLandedOnGround) == 0x000960, "Member 'URPawnMovementComponent::OnLandedOnGround' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnDirectLerpEnded) == 0x000970, "Member 'URPawnMovementComponent::OnDirectLerpEnded' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnMovementEvent) == 0x000980, "Member 'URPawnMovementComponent::OnMovementEvent' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnDashEnded) == 0x000990, "Member 'URPawnMovementComponent::OnDashEnded' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnDashStarted) == 0x0009A0, "Member 'URPawnMovementComponent::OnDashStarted' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnChargeEnded) == 0x0009B0, "Member 'URPawnMovementComponent::OnChargeEnded' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnMovement) == 0x0009C0, "Member 'URPawnMovementComponent::OnMovement' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnChargeBounce) == 0x0009D0, "Member 'URPawnMovementComponent::OnChargeBounce' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnChargeHitWall) == 0x0009E0, "Member 'URPawnMovementComponent::OnChargeHitWall' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnKnockbacked) == 0x0009F0, "Member 'URPawnMovementComponent::OnKnockbacked' has a wrong offset!");
static_assert(offsetof(URPawnMovementComponent, OnKnockbackEnded) == 0x000A00, "Member 'URPawnMovementComponent::OnKnockbackEnded' has a wrong offset!");

// Class RGame.RNPCPawnMovementComponent
// 0x0008 (0x0A18 - 0x0A10)
class URNPCPawnMovementComponent final : public URPawnMovementComponent
{
public:
	uint8                                         Pad_A10[0x8];                                      // 0x0A10(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateWalkingTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNPCPawnMovementComponent">();
	}
	static class URNPCPawnMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URNPCPawnMovementComponent>();
	}
};
static_assert(alignof(URNPCPawnMovementComponent) == 0x000008, "Wrong alignment on URNPCPawnMovementComponent");
static_assert(sizeof(URNPCPawnMovementComponent) == 0x000A18, "Wrong size on URNPCPawnMovementComponent");

// Class RGame.RObjectHighlightWidget
// 0x0018 (0x02E8 - 0x02D0)
class URObjectHighlightWidget : public UUserWidget
{
public:
	class AActor*                                 ObjectToHighlight;                                 // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColor;                                         // 0x02D8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetInfo(const class FText& ObjectName, const class FText& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RObjectHighlightWidget">();
	}
	static class URObjectHighlightWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URObjectHighlightWidget>();
	}
};
static_assert(alignof(URObjectHighlightWidget) == 0x000008, "Wrong alignment on URObjectHighlightWidget");
static_assert(sizeof(URObjectHighlightWidget) == 0x0002E8, "Wrong size on URObjectHighlightWidget");
static_assert(offsetof(URObjectHighlightWidget, ObjectToHighlight) == 0x0002D0, "Member 'URObjectHighlightWidget::ObjectToHighlight' has a wrong offset!");
static_assert(offsetof(URObjectHighlightWidget, IconColor) == 0x0002D8, "Member 'URObjectHighlightWidget::IconColor' has a wrong offset!");

// Class RGame.RObjectivePrimaryDataAsset
// 0x0048 (0x00B8 - 0x0070)
class URObjectivePrimaryDataAsset final : public URPrimaryDataAsset
{
public:
	struct FGameplayTag                           ObjectiveTag;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftObjectiveScript;                               // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveRemovalPolicy                       ObjectiveRemovalPolicy;                            // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMultiplayerObjective;                           // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocal;                                          // 0x00A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDependsOnNumPlayers;                              // 0x00A3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWithAllObjectsVisible;                       // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowObjectiveStartNotification;                   // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowObjectiveAnnouncement;                        // 0x00A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A7[0x1];                                       // 0x00A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RewardText;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RObjectivePrimaryDataAsset">();
	}
	static class URObjectivePrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URObjectivePrimaryDataAsset>();
	}
};
static_assert(alignof(URObjectivePrimaryDataAsset) == 0x000008, "Wrong alignment on URObjectivePrimaryDataAsset");
static_assert(sizeof(URObjectivePrimaryDataAsset) == 0x0000B8, "Wrong size on URObjectivePrimaryDataAsset");
static_assert(offsetof(URObjectivePrimaryDataAsset, ObjectiveTag) == 0x000070, "Member 'URObjectivePrimaryDataAsset::ObjectiveTag' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, SoftObjectiveScript) == 0x000078, "Member 'URObjectivePrimaryDataAsset::SoftObjectiveScript' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, ObjectiveRemovalPolicy) == 0x0000A0, "Member 'URObjectivePrimaryDataAsset::ObjectiveRemovalPolicy' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, bIsMultiplayerObjective) == 0x0000A1, "Member 'URObjectivePrimaryDataAsset::bIsMultiplayerObjective' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, bIsLocal) == 0x0000A2, "Member 'URObjectivePrimaryDataAsset::bIsLocal' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, bDependsOnNumPlayers) == 0x0000A3, "Member 'URObjectivePrimaryDataAsset::bDependsOnNumPlayers' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, bStartWithAllObjectsVisible) == 0x0000A4, "Member 'URObjectivePrimaryDataAsset::bStartWithAllObjectsVisible' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, bShowObjectiveStartNotification) == 0x0000A5, "Member 'URObjectivePrimaryDataAsset::bShowObjectiveStartNotification' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, bShowObjectiveAnnouncement) == 0x0000A6, "Member 'URObjectivePrimaryDataAsset::bShowObjectiveAnnouncement' has a wrong offset!");
static_assert(offsetof(URObjectivePrimaryDataAsset, RewardText) == 0x0000A8, "Member 'URObjectivePrimaryDataAsset::RewardText' has a wrong offset!");

// Class RGame.ROffScreenIndicatorWidget
// 0x00C8 (0x0398 - 0x02D0)
class UROffScreenIndicatorWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0xB8];                                     // 0x02D0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Accuracy;                                          // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionImageAngleOffset;                         // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActorRef;                                    // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UImage* GetDirectionImage();
	void Setup(class UCanvasPanel* CanvasPanel, class AActor* TargetActor);
	void TickUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ROffScreenIndicatorWidget">();
	}
	static class UROffScreenIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UROffScreenIndicatorWidget>();
	}
};
static_assert(alignof(UROffScreenIndicatorWidget) == 0x000008, "Wrong alignment on UROffScreenIndicatorWidget");
static_assert(sizeof(UROffScreenIndicatorWidget) == 0x000398, "Wrong size on UROffScreenIndicatorWidget");
static_assert(offsetof(UROffScreenIndicatorWidget, Accuracy) == 0x000388, "Member 'UROffScreenIndicatorWidget::Accuracy' has a wrong offset!");
static_assert(offsetof(UROffScreenIndicatorWidget, DirectionImageAngleOffset) == 0x00038C, "Member 'UROffScreenIndicatorWidget::DirectionImageAngleOffset' has a wrong offset!");
static_assert(offsetof(UROffScreenIndicatorWidget, TargetActorRef) == 0x000390, "Member 'UROffScreenIndicatorWidget::TargetActorRef' has a wrong offset!");

// Class RGame.ROnlineSubsystem
// 0x0028 (0x0058 - 0x0030)
class UROnlineSubsystem final : public UGameInstanceSubsystem
{
public:
	class FString                                 NetworkError;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearNetworkFailure();
	void KickPlayer(class APlayerController* PlayerController);

	bool HasNetworkFailure() const;
	bool IsDLCInstalled(const class FString& DLCId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ROnlineSubsystem">();
	}
	static class UROnlineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UROnlineSubsystem>();
	}
};
static_assert(alignof(UROnlineSubsystem) == 0x000008, "Wrong alignment on UROnlineSubsystem");
static_assert(sizeof(UROnlineSubsystem) == 0x000058, "Wrong size on UROnlineSubsystem");
static_assert(offsetof(UROnlineSubsystem, NetworkError) == 0x000030, "Member 'UROnlineSubsystem::NetworkError' has a wrong offset!");

// Class RGame.RNodeData
// 0x00E0 (0x0110 - 0x0030)
class URNodeData final : public UDataAsset
{
public:
	float                                         GenerationWeight;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumEncounters;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CanOnlyGenerateOnRows;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NodeDataTag;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ExtraLevelTag;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExtraLevelReplaceRandomEncounterRoom;       // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExtraRoomAlwaysBeGeneratedAtEndOfNode;      // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRNodeLightingLevelOverride            LightingLevelOverride;                             // 0x0060(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   NodeName;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   NodeDescription;                                   // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconTexture;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColor;                                         // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RewardCategoryTag;                                 // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyLevelMultiplier;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEventNode;                                      // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SoftNodeRewardActor;                               // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnInLastConnector;                             // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RNodeData">();
	}
	static class URNodeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URNodeData>();
	}
};
static_assert(alignof(URNodeData) == 0x000008, "Wrong alignment on URNodeData");
static_assert(sizeof(URNodeData) == 0x000110, "Wrong size on URNodeData");
static_assert(offsetof(URNodeData, GenerationWeight) == 0x000030, "Member 'URNodeData::GenerationWeight' has a wrong offset!");
static_assert(offsetof(URNodeData, NumEncounters) == 0x000034, "Member 'URNodeData::NumEncounters' has a wrong offset!");
static_assert(offsetof(URNodeData, CanOnlyGenerateOnRows) == 0x000038, "Member 'URNodeData::CanOnlyGenerateOnRows' has a wrong offset!");
static_assert(offsetof(URNodeData, NodeDataTag) == 0x000048, "Member 'URNodeData::NodeDataTag' has a wrong offset!");
static_assert(offsetof(URNodeData, ExtraLevelTag) == 0x000050, "Member 'URNodeData::ExtraLevelTag' has a wrong offset!");
static_assert(offsetof(URNodeData, bShouldExtraLevelReplaceRandomEncounterRoom) == 0x000058, "Member 'URNodeData::bShouldExtraLevelReplaceRandomEncounterRoom' has a wrong offset!");
static_assert(offsetof(URNodeData, bShouldExtraRoomAlwaysBeGeneratedAtEndOfNode) == 0x000059, "Member 'URNodeData::bShouldExtraRoomAlwaysBeGeneratedAtEndOfNode' has a wrong offset!");
static_assert(offsetof(URNodeData, LightingLevelOverride) == 0x000060, "Member 'URNodeData::LightingLevelOverride' has a wrong offset!");
static_assert(offsetof(URNodeData, NodeName) == 0x000098, "Member 'URNodeData::NodeName' has a wrong offset!");
static_assert(offsetof(URNodeData, NodeDescription) == 0x0000A8, "Member 'URNodeData::NodeDescription' has a wrong offset!");
static_assert(offsetof(URNodeData, IconTexture) == 0x0000B8, "Member 'URNodeData::IconTexture' has a wrong offset!");
static_assert(offsetof(URNodeData, IconColor) == 0x0000C0, "Member 'URNodeData::IconColor' has a wrong offset!");
static_assert(offsetof(URNodeData, RewardCategoryTag) == 0x0000D0, "Member 'URNodeData::RewardCategoryTag' has a wrong offset!");
static_assert(offsetof(URNodeData, DifficultyLevelMultiplier) == 0x0000D8, "Member 'URNodeData::DifficultyLevelMultiplier' has a wrong offset!");
static_assert(offsetof(URNodeData, bIsEventNode) == 0x0000DC, "Member 'URNodeData::bIsEventNode' has a wrong offset!");
static_assert(offsetof(URNodeData, SoftNodeRewardActor) == 0x0000E0, "Member 'URNodeData::SoftNodeRewardActor' has a wrong offset!");
static_assert(offsetof(URNodeData, bSpawnInLastConnector) == 0x000108, "Member 'URNodeData::bSpawnInLastConnector' has a wrong offset!");

// Class RGame.RAreaData
// 0x00E8 (0x0118 - 0x0030)
class URAreaData final : public UDataAsset
{
public:
	struct FGameplayTag                           AreaTag;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     OverrideTableOptions;                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    LightingLevel;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FRLevelData                            LevelTable;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftDoorClass;                                     // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumLevelSequences;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URNodeData*>                     GuaranteedNodes;                                   // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class URNodeData*>                     UniqueNodes;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class URNodeData*>                     FillerNodes;                                       // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         GoldTreasuresPerArea;                              // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              GoldPerRoom;                                       // 0x00D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              GoldPerEnemy;                                      // 0x00DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInGameLoop;                                    // 0x00E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FROverridableEnemyTags>         OverridingTags;                                    // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxAmount;                                         // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MinEnemyAmountLimitPerPlayer;                      // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaxEnemyAmountLimitPerPlayer;                      // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanHaveCorruptedNodes;                            // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RAreaData">();
	}
	static class URAreaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URAreaData>();
	}
};
static_assert(alignof(URAreaData) == 0x000008, "Wrong alignment on URAreaData");
static_assert(sizeof(URAreaData) == 0x000118, "Wrong size on URAreaData");
static_assert(offsetof(URAreaData, AreaTag) == 0x000030, "Member 'URAreaData::AreaTag' has a wrong offset!");
static_assert(offsetof(URAreaData, AreaName) == 0x000038, "Member 'URAreaData::AreaName' has a wrong offset!");
static_assert(offsetof(URAreaData, OverrideTableOptions) == 0x000040, "Member 'URAreaData::OverrideTableOptions' has a wrong offset!");
static_assert(offsetof(URAreaData, LightingLevel) == 0x000050, "Member 'URAreaData::LightingLevel' has a wrong offset!");
static_assert(offsetof(URAreaData, LevelTable) == 0x000060, "Member 'URAreaData::LevelTable' has a wrong offset!");
static_assert(offsetof(URAreaData, SoftDoorClass) == 0x000070, "Member 'URAreaData::SoftDoorClass' has a wrong offset!");
static_assert(offsetof(URAreaData, NumLevelSequences) == 0x000098, "Member 'URAreaData::NumLevelSequences' has a wrong offset!");
static_assert(offsetof(URAreaData, GuaranteedNodes) == 0x0000A0, "Member 'URAreaData::GuaranteedNodes' has a wrong offset!");
static_assert(offsetof(URAreaData, UniqueNodes) == 0x0000B0, "Member 'URAreaData::UniqueNodes' has a wrong offset!");
static_assert(offsetof(URAreaData, FillerNodes) == 0x0000C0, "Member 'URAreaData::FillerNodes' has a wrong offset!");
static_assert(offsetof(URAreaData, GoldTreasuresPerArea) == 0x0000D0, "Member 'URAreaData::GoldTreasuresPerArea' has a wrong offset!");
static_assert(offsetof(URAreaData, GoldPerRoom) == 0x0000D4, "Member 'URAreaData::GoldPerRoom' has a wrong offset!");
static_assert(offsetof(URAreaData, GoldPerEnemy) == 0x0000DC, "Member 'URAreaData::GoldPerEnemy' has a wrong offset!");
static_assert(offsetof(URAreaData, bUseInGameLoop) == 0x0000E4, "Member 'URAreaData::bUseInGameLoop' has a wrong offset!");
static_assert(offsetof(URAreaData, OverridingTags) == 0x0000E8, "Member 'URAreaData::OverridingTags' has a wrong offset!");
static_assert(offsetof(URAreaData, MaxAmount) == 0x0000F8, "Member 'URAreaData::MaxAmount' has a wrong offset!");
static_assert(offsetof(URAreaData, MinEnemyAmountLimitPerPlayer) == 0x000100, "Member 'URAreaData::MinEnemyAmountLimitPerPlayer' has a wrong offset!");
static_assert(offsetof(URAreaData, MaxEnemyAmountLimitPerPlayer) == 0x000108, "Member 'URAreaData::MaxEnemyAmountLimitPerPlayer' has a wrong offset!");
static_assert(offsetof(URAreaData, bCanHaveCorruptedNodes) == 0x000110, "Member 'URAreaData::bCanHaveCorruptedNodes' has a wrong offset!");

// Class RGame.ROverworldManager
// 0x02A8 (0x0550 - 0x02A8)
class AROverworldManager : public AActor
{
public:
	TArray<struct FROverworldArea>                OverworldAreas;                                    // 0x02A8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         AreaIndex;                                         // 0x02B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelIndex;                                        // 0x02BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentNodeId;                                     // 0x02C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CompletedNodeIds;                                  // 0x02C8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         NumTotalCompletedNodes;                            // 0x02D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x44];                                     // 0x02DC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumNavVolumesToInitialize;                         // 0x0320(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRExtraRewardData>              ExtraRewardsData;                                  // 0x0328(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URAreaData*>                     OverworldAreaDataAssets;                           // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class URAreaData*>                     DemoOverworldAreaDataAssets;                       // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentNodeRewardRoomTag;                          // 0x0358(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSelectedNodeId;                                // 0x0360(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnNodeCompleted;                                   // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         NodeMaxOutConnections;                             // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DifficultyExtraLevelTags;                          // 0x0380(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UPrimaryDataAsset*                      NodeChoiceRewardPA;                                // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URNodeData*                             MerchantNodeData;                                  // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName AreaName)> OnPreAreaChanged;                           // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName AreaName)> OnAreaChanged;                              // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnOverworldGenerated;                              // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<class URNodeChoicePrimaryAsset*>& NodeChoicePAs, const TArray<class URGScript*>& NodeChoiceScripts)> OnCorruptedEffectApplied; // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRNodeChoicePair>               NodePairChoices;                                   // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRNodeChoicePair>               NodePairRewardChoices;                             // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   NodeChoiceScriptCategory;                          // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRNodeChoiceVoteData>           NodeChoiceVoteData;                                // 0x0418(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRNodeChoicePair                       RandomizedNodeChoicePair;                          // 0x0428(0x0078)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FRNodeChoicePair                       RandomizedNodeChoiceRewardPair;                    // 0x04A0(0x0078)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnedNodeReward;                             // 0x0518(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FREncounterExtraRewardData>     EncounterExtraRewardsData;                         // 0x0520(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRRandomizedCorruptedDepthAssets       RandomizedCorruptedDepthAssets;                    // 0x0530(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class AROverworldManager* GetOverworldManager(const class UObject* WorldContextObject);

	void AddEncounterExtraRewardData(TSoftClassPtr<class UClass> SoftRewardClass, TSoftObjectPtr<class URAreaData> SoftFixedAreaData);
	void AddExtraLevelEntryToArea(class URAreaData* AreaData, const struct FRExtraLevelEntry& NewExtraLevelEntry);
	void BroadcastOnNodeCompletedMulticast();
	void ClearCorruptedNodeChoiceScripts();
	void ClearNodeChoicePairs();
	void ClearNodeChoiceVoteData();
	int32 GetAreaIndex();
	TArray<int32> GetCompletedNodeIds();
	int32 GetCurrentAreaBossNodeId();
	class URNodeData* GetCurrentNodeData();
	int32 GetCurrentNodeId();
	struct FROverworldArea GetCurrentOverworldArea();
	int32 GetDepth();
	int32 GetDepthInCurrentArea();
	int32 GetEncounterRoomPositionOfActorInOverworld(class AActor* Actor);
	int32 GetLevelIndex();
	int32 GetNextNodeId();
	struct FROverworldArea GetNextOverworldArea();
	class URNodeChoicePrimaryAsset* GetNodeChoicePAWithHighestVote(const TArray<struct FRNodeChoiceVoteData>& NodeChoiceDataVotes, const bool bGetRewardPA);
	int32 GetNumCompletedNodesInCurrentArea();
	int32 GetNumTotalCompletedNodes();
	TArray<struct FROverworldArea> GetOverworldAreas();
	TArray<struct FROverworldArea> GetOverworldAreasInGameLoop();
	struct FROverworldNode GetOverworldNodeById(int32 ID);
	int32 GetRowIndexByNodeId(int32 NodeID);
	int32 GetRowOfNode(int32 NodeID);
	bool HasPlayerVotedForCorruptedNode(class APlayerController* PlayerController);
	bool IsCurrentPortalCorrupted();
	bool IsInLastArea();
	bool IsNodeIdInCurrentArea(const int32 NodeID);
	bool IsNodePlayable(const struct FROverworldNode& Node);
	bool IsOnLastNode();
	void NodeSelected(const int32 SelectedNodeId, const int32 PlayerId, const struct FLinearColor& Color);
	void OnLevelChanged();
	void OnLevelsUnloadedOnAreaChange();
	void OnPreLevelChanged();
	void RandomizeCorruptedNodeChoices();
	void RemoveEncounterExtraRewardData(TSoftClassPtr<class UClass> SoftRewardClass, TSoftObjectPtr<class URAreaData> SoftFixedAreaData);
	void RemoveExtraLevelEntryToArea(class URAreaData* AreaData, const struct FRExtraLevelEntry& NewExtraLevelEntry);
	void SetAreaIndex(int32 NewIndex);
	void SetAreaNodeDataAtIndex(struct FROverworldArea* Area, class URNodeData* NodeData, const int32 Index_0);
	void SetCurrentNodeId(const int32 NewNodeId);
	void SetLevelIndex(int32 Index_0);
	void SetPlayerCorruptedNodeChoiceVote_Server(class APlayerState* PlayerState, class URNodeChoicePrimaryAsset* VotedNodeChoicePA, class URNodeChoicePrimaryAsset* VotedNodeChoiceRewardPA);
	void SpawnNodeRewardActor(class AActor* SpawnPointActor, TSubclassOf<class AActor> RewardClass, class URNodeData* NodeData);

	bool IsInLobby() const;
	bool IsInTutorial() const;
	bool IsInUngluArena() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ROverworldManager">();
	}
	static class AROverworldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AROverworldManager>();
	}
};
static_assert(alignof(AROverworldManager) == 0x000008, "Wrong alignment on AROverworldManager");
static_assert(sizeof(AROverworldManager) == 0x000550, "Wrong size on AROverworldManager");
static_assert(offsetof(AROverworldManager, OverworldAreas) == 0x0002A8, "Member 'AROverworldManager::OverworldAreas' has a wrong offset!");
static_assert(offsetof(AROverworldManager, AreaIndex) == 0x0002B8, "Member 'AROverworldManager::AreaIndex' has a wrong offset!");
static_assert(offsetof(AROverworldManager, LevelIndex) == 0x0002BC, "Member 'AROverworldManager::LevelIndex' has a wrong offset!");
static_assert(offsetof(AROverworldManager, CurrentNodeId) == 0x0002C0, "Member 'AROverworldManager::CurrentNodeId' has a wrong offset!");
static_assert(offsetof(AROverworldManager, CompletedNodeIds) == 0x0002C8, "Member 'AROverworldManager::CompletedNodeIds' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NumTotalCompletedNodes) == 0x0002D8, "Member 'AROverworldManager::NumTotalCompletedNodes' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NumNavVolumesToInitialize) == 0x000320, "Member 'AROverworldManager::NumNavVolumesToInitialize' has a wrong offset!");
static_assert(offsetof(AROverworldManager, ExtraRewardsData) == 0x000328, "Member 'AROverworldManager::ExtraRewardsData' has a wrong offset!");
static_assert(offsetof(AROverworldManager, OverworldAreaDataAssets) == 0x000338, "Member 'AROverworldManager::OverworldAreaDataAssets' has a wrong offset!");
static_assert(offsetof(AROverworldManager, DemoOverworldAreaDataAssets) == 0x000348, "Member 'AROverworldManager::DemoOverworldAreaDataAssets' has a wrong offset!");
static_assert(offsetof(AROverworldManager, CurrentNodeRewardRoomTag) == 0x000358, "Member 'AROverworldManager::CurrentNodeRewardRoomTag' has a wrong offset!");
static_assert(offsetof(AROverworldManager, LastSelectedNodeId) == 0x000360, "Member 'AROverworldManager::LastSelectedNodeId' has a wrong offset!");
static_assert(offsetof(AROverworldManager, OnNodeCompleted) == 0x000368, "Member 'AROverworldManager::OnNodeCompleted' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NodeMaxOutConnections) == 0x000378, "Member 'AROverworldManager::NodeMaxOutConnections' has a wrong offset!");
static_assert(offsetof(AROverworldManager, DifficultyExtraLevelTags) == 0x000380, "Member 'AROverworldManager::DifficultyExtraLevelTags' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NodeChoiceRewardPA) == 0x0003A0, "Member 'AROverworldManager::NodeChoiceRewardPA' has a wrong offset!");
static_assert(offsetof(AROverworldManager, MerchantNodeData) == 0x0003A8, "Member 'AROverworldManager::MerchantNodeData' has a wrong offset!");
static_assert(offsetof(AROverworldManager, OnPreAreaChanged) == 0x0003B0, "Member 'AROverworldManager::OnPreAreaChanged' has a wrong offset!");
static_assert(offsetof(AROverworldManager, OnAreaChanged) == 0x0003C0, "Member 'AROverworldManager::OnAreaChanged' has a wrong offset!");
static_assert(offsetof(AROverworldManager, OnOverworldGenerated) == 0x0003D0, "Member 'AROverworldManager::OnOverworldGenerated' has a wrong offset!");
static_assert(offsetof(AROverworldManager, OnCorruptedEffectApplied) == 0x0003E0, "Member 'AROverworldManager::OnCorruptedEffectApplied' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NodePairChoices) == 0x0003F0, "Member 'AROverworldManager::NodePairChoices' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NodePairRewardChoices) == 0x000400, "Member 'AROverworldManager::NodePairRewardChoices' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NodeChoiceScriptCategory) == 0x000410, "Member 'AROverworldManager::NodeChoiceScriptCategory' has a wrong offset!");
static_assert(offsetof(AROverworldManager, NodeChoiceVoteData) == 0x000418, "Member 'AROverworldManager::NodeChoiceVoteData' has a wrong offset!");
static_assert(offsetof(AROverworldManager, RandomizedNodeChoicePair) == 0x000428, "Member 'AROverworldManager::RandomizedNodeChoicePair' has a wrong offset!");
static_assert(offsetof(AROverworldManager, RandomizedNodeChoiceRewardPair) == 0x0004A0, "Member 'AROverworldManager::RandomizedNodeChoiceRewardPair' has a wrong offset!");
static_assert(offsetof(AROverworldManager, bHasSpawnedNodeReward) == 0x000518, "Member 'AROverworldManager::bHasSpawnedNodeReward' has a wrong offset!");
static_assert(offsetof(AROverworldManager, EncounterExtraRewardsData) == 0x000520, "Member 'AROverworldManager::EncounterExtraRewardsData' has a wrong offset!");
static_assert(offsetof(AROverworldManager, RandomizedCorruptedDepthAssets) == 0x000530, "Member 'AROverworldManager::RandomizedCorruptedDepthAssets' has a wrong offset!");

// Class RGame.RPawnDownedWidget
// 0x0008 (0x02D8 - 0x02D0)
class URPawnDownedWidget : public UUserWidget
{
public:
	TWeakObjectPtr<class ARPlayerPawn>            TheOwningPawn;                                     // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPawnDownedWidget">();
	}
	static class URPawnDownedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPawnDownedWidget>();
	}
};
static_assert(alignof(URPawnDownedWidget) == 0x000008, "Wrong alignment on URPawnDownedWidget");
static_assert(sizeof(URPawnDownedWidget) == 0x0002D8, "Wrong size on URPawnDownedWidget");
static_assert(offsetof(URPawnDownedWidget, TheOwningPawn) == 0x0002D0, "Member 'URPawnDownedWidget::TheOwningPawn' has a wrong offset!");

// Class RGame.RPersistentReplicatedActorInterface
// 0x0000 (0x0000 - 0x0000)
class IRPersistentReplicatedActorInterface final
{
public:
	void PostRegisterPersistentReplicatedActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPersistentReplicatedActorInterface">();
	}
	static class IRPersistentReplicatedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRPersistentReplicatedActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRPersistentReplicatedActorInterface) == 0x000001, "Wrong alignment on IRPersistentReplicatedActorInterface");
static_assert(sizeof(IRPersistentReplicatedActorInterface) == 0x000001, "Wrong size on IRPersistentReplicatedActorInterface");

// Class RGame.RPickupableItem
// 0x00E0 (0x0388 - 0x02A8)
class ARPickupableItem : public AActor
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARPickupableItem*                       NativeSuperSelf;                                   // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasPickedUp;                                      // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFinishedSpawning;                              // 0x02D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PickupCostOverride;                                // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCostIncreasePerNode;                           // 0x02D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x02E0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x02F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         BaseCost;                                          // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionCostCurrency;                           // 0x0308(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USoundBase*                             PickupSound;                                       // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SoftInsufficientGoldSound;                         // 0x0320(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InsufficientCurrencyPickupMessage;                 // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPickupableItem* PickedUpItem, int32 PickupCost, class APlayerController* PlayerController)> OnPickupablePickedUp; // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x4];                                      // 0x0368(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RewardCategoryTag;                                 // 0x036C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EnemyLootSource;                                   // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOnSimulateLootPhysicsFinished();
	void CallOnSimulateLootPhysicsFinished_Multicast();
	int32 GetBaseCost();
	int32 GetPickupCost(const class APlayerController* PlayerController);
	int32 GetQuantity();
	bool HasEnoughCurrencyForPickup(class APlayerController* PlayerController);
	void MakeItemInformationObscured(const class FText& Name_0, const class FText& Description);
	void OnSimulateLootPhysicsFinished();
	bool Pickup(class APlayerController* PlayerController);
	void PickupableSpawned();
	void SetPickupCost(int32 NewCost);
	void SetQuantity(int32 Amount);
	void SetVisualIdentifier();
	bool SimulateLootPhysics(class UPrimitiveComponent* Component);
	void TriggerPickup(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPickupableItem">();
	}
	static class ARPickupableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPickupableItem>();
	}
};
static_assert(alignof(ARPickupableItem) == 0x000008, "Wrong alignment on ARPickupableItem");
static_assert(sizeof(ARPickupableItem) == 0x000388, "Wrong size on ARPickupableItem");
static_assert(offsetof(ARPickupableItem, Quantity) == 0x0002C0, "Member 'ARPickupableItem::Quantity' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, NativeSuperSelf) == 0x0002C8, "Member 'ARPickupableItem::NativeSuperSelf' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, bWasPickedUp) == 0x0002D0, "Member 'ARPickupableItem::bWasPickedUp' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, bHasFinishedSpawning) == 0x0002D1, "Member 'ARPickupableItem::bHasFinishedSpawning' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, PickupCostOverride) == 0x0002D4, "Member 'ARPickupableItem::PickupCostOverride' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, BaseCostIncreasePerNode) == 0x0002D8, "Member 'ARPickupableItem::BaseCostIncreasePerNode' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, ItemName) == 0x0002E0, "Member 'ARPickupableItem::ItemName' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, ItemDescription) == 0x0002F0, "Member 'ARPickupableItem::ItemDescription' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, BaseCost) == 0x000300, "Member 'ARPickupableItem::BaseCost' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, InteractionCostCurrency) == 0x000308, "Member 'ARPickupableItem::InteractionCostCurrency' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, PickupSound) == 0x000318, "Member 'ARPickupableItem::PickupSound' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, SoftInsufficientGoldSound) == 0x000320, "Member 'ARPickupableItem::SoftInsufficientGoldSound' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, InsufficientCurrencyPickupMessage) == 0x000348, "Member 'ARPickupableItem::InsufficientCurrencyPickupMessage' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, OnPickupablePickedUp) == 0x000358, "Member 'ARPickupableItem::OnPickupablePickedUp' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, RewardCategoryTag) == 0x00036C, "Member 'ARPickupableItem::RewardCategoryTag' has a wrong offset!");
static_assert(offsetof(ARPickupableItem, EnemyLootSource) == 0x000378, "Member 'ARPickupableItem::EnemyLootSource' has a wrong offset!");

// Class RGame.RPickupableMutator
// 0x0038 (0x03C0 - 0x0388)
class ARPickupableMutator : public ARPickupableItem
{
public:
	class URMutatorRewardCategoryDataAsset*       NativeGeneratedGodCategory;                        // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMutatorPrimaryAsset*                  MutatorPrimaryAsset;                               // 0x0390(0x0008)(Edit, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0398(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetRank;                                        // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& MutatorName)> OnPickupableMutatorPickedUp;    // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bSupressNoMutatorPrimaryAssetWarning;              // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateWorldPosition;                             // 0x03B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFixedRarity;                                   // 0x03B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMutatorRarity                                FixedMutatorRarity;                                // 0x03B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARMerchantPlinth>        PlinthSpawner;                                     // 0x03B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterHealingItems;                               // 0x03BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFilterUniqueItems;                                // 0x03BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BE[0x2];                                      // 0x03BE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateMutator();
	void GenerateMutatorByFixedRarity();
	class UDataAsset* GetGeneratedGodCategoryDataAsset();
	void NativeUpdateMutatorIconColor();
	void OnRep_MutatorPrimaryAsset();
	void OnRep_Rank();
	bool PickupMutator(class APlayerController* PlayerController, int32 MutatorRank);
	void SetMutatorPrimaryAsset(class URMutatorPrimaryAsset* MutatorAsset);
	void SetMutatorPrimaryAssetFromTable(const struct FGameplayTag& InRewardTableType, class APlayerController* PlayerController, const EMutatorRarity Rarity);
	void UpdateGeneratedGodCategory(class URMutatorRewardCategoryDataAsset* NewGodCategory);
	void UpdateGeneratedMutatorOptions(const TArray<struct FRLootSelectionOption>& NewLootOptions);
	void UpdateMutatorIconColorEvent();
	void UpdateTooltipInfo();

	class FString GetContextMessage() const;
	class URMutatorPrimaryAsset* GetMutatorPrimaryAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPickupableMutator">();
	}
	static class ARPickupableMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPickupableMutator>();
	}
};
static_assert(alignof(ARPickupableMutator) == 0x000008, "Wrong alignment on ARPickupableMutator");
static_assert(sizeof(ARPickupableMutator) == 0x0003C0, "Wrong size on ARPickupableMutator");
static_assert(offsetof(ARPickupableMutator, NativeGeneratedGodCategory) == 0x000388, "Member 'ARPickupableMutator::NativeGeneratedGodCategory' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, MutatorPrimaryAsset) == 0x000390, "Member 'ARPickupableMutator::MutatorPrimaryAsset' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, Rank) == 0x000398, "Member 'ARPickupableMutator::Rank' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, PresetRank) == 0x00039C, "Member 'ARPickupableMutator::PresetRank' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, OnPickupableMutatorPickedUp) == 0x0003A0, "Member 'ARPickupableMutator::OnPickupableMutatorPickedUp' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, bSupressNoMutatorPrimaryAssetWarning) == 0x0003B0, "Member 'ARPickupableMutator::bSupressNoMutatorPrimaryAssetWarning' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, bAnimateWorldPosition) == 0x0003B1, "Member 'ARPickupableMutator::bAnimateWorldPosition' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, bHasFixedRarity) == 0x0003B2, "Member 'ARPickupableMutator::bHasFixedRarity' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, FixedMutatorRarity) == 0x0003B3, "Member 'ARPickupableMutator::FixedMutatorRarity' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, PlinthSpawner) == 0x0003B4, "Member 'ARPickupableMutator::PlinthSpawner' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, bFilterHealingItems) == 0x0003BC, "Member 'ARPickupableMutator::bFilterHealingItems' has a wrong offset!");
static_assert(offsetof(ARPickupableMutator, bFilterUniqueItems) == 0x0003BD, "Member 'ARPickupableMutator::bFilterUniqueItems' has a wrong offset!");

// Class RGame.RPickupableCharm
// 0x0020 (0x03E0 - 0x03C0)
class ARPickupableCharm final : public ARPickupableMutator
{
public:
	int32                                         CommonGoldToSpawn;                                 // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareGoldToSpawn;                                   // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryGoldToSpawn;                              // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BrokenByPlayer;                                    // 0x03CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URMutatorPrimaryAsset* NewPrimaryAsset)> OnMutatorPASet;     // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BreakCharm(class ARPlayerController* BrokenBy);
	void CallOnOnMutatorPaSet(class URMutatorPrimaryAsset* NewPrimaryAsset);
	struct FMutatorLootSettings GetCharmLootSettings();
	void NativeUpdateVisuals();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPickupableCharm">();
	}
	static class ARPickupableCharm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPickupableCharm>();
	}
};
static_assert(alignof(ARPickupableCharm) == 0x000008, "Wrong alignment on ARPickupableCharm");
static_assert(sizeof(ARPickupableCharm) == 0x0003E0, "Wrong size on ARPickupableCharm");
static_assert(offsetof(ARPickupableCharm, CommonGoldToSpawn) == 0x0003C0, "Member 'ARPickupableCharm::CommonGoldToSpawn' has a wrong offset!");
static_assert(offsetof(ARPickupableCharm, RareGoldToSpawn) == 0x0003C4, "Member 'ARPickupableCharm::RareGoldToSpawn' has a wrong offset!");
static_assert(offsetof(ARPickupableCharm, LegendaryGoldToSpawn) == 0x0003C8, "Member 'ARPickupableCharm::LegendaryGoldToSpawn' has a wrong offset!");
static_assert(offsetof(ARPickupableCharm, BrokenByPlayer) == 0x0003CC, "Member 'ARPickupableCharm::BrokenByPlayer' has a wrong offset!");
static_assert(offsetof(ARPickupableCharm, OnMutatorPASet) == 0x0003D0, "Member 'ARPickupableCharm::OnMutatorPASet' has a wrong offset!");

// Class RGame.RPickupNotificationWidget
// 0x0008 (0x0300 - 0x02F8)
class URPickupNotificationWidget : public URNotificationWidget
{
public:
	int32                                         Amount;                                            // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPickupNotificationWidget">();
	}
	static class URPickupNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPickupNotificationWidget>();
	}
};
static_assert(alignof(URPickupNotificationWidget) == 0x000008, "Wrong alignment on URPickupNotificationWidget");
static_assert(sizeof(URPickupNotificationWidget) == 0x000300, "Wrong size on URPickupNotificationWidget");
static_assert(offsetof(URPickupNotificationWidget, Amount) == 0x0002F8, "Member 'URPickupNotificationWidget::Amount' has a wrong offset!");

// Class RGame.RPingableActor
// 0x0008 (0x02B0 - 0x02A8)
class ARPingableActor final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingableActor">();
	}
	static class ARPingableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPingableActor>();
	}
};
static_assert(alignof(ARPingableActor) == 0x000008, "Wrong alignment on ARPingableActor");
static_assert(sizeof(ARPingableActor) == 0x0002B0, "Wrong size on ARPingableActor");

// Class RGame.RPingableInterface
// 0x0000 (0x0000 - 0x0000)
class IRPingableInterface final
{
public:
	class UTexture2D* GetPingableIconTexture() const;
	class FText GetPingableName() const;
	bool IsCurrentlyPinged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingableInterface">();
	}
	static class IRPingableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRPingableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRPingableInterface) == 0x000001, "Wrong alignment on IRPingableInterface");
static_assert(sizeof(IRPingableInterface) == 0x000001, "Wrong size on IRPingableInterface");

// Class RGame.RPingBeaconManager
// 0x0018 (0x02C0 - 0x02A8)
class ARPingBeaconManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARPingBeaconManager* GetPingBeaconManager(const class UObject* WorldContextObject);

	void QueuePingRequest(struct FBlueprintSessionResult& Session, TDelegate<void(int32 Latency)> Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingBeaconManager">();
	}
	static class ARPingBeaconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPingBeaconManager>();
	}
};
static_assert(alignof(ARPingBeaconManager) == 0x000008, "Wrong alignment on ARPingBeaconManager");
static_assert(sizeof(ARPingBeaconManager) == 0x0002C0, "Wrong size on ARPingBeaconManager");

// Class RGame.RPingClient
// 0x0018 (0x0350 - 0x0338)
class ARPingClient final : public AOnlineBeaconClient
{
public:
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Ping_Server();
	void PingResponse_Client();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingClient">();
	}
	static class ARPingClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPingClient>();
	}
};
static_assert(alignof(ARPingClient) == 0x000008, "Wrong alignment on ARPingClient");
static_assert(sizeof(ARPingClient) == 0x000350, "Wrong size on ARPingClient");

// Class RGame.RPingHost
// 0x0008 (0x03F0 - 0x03E8)
class ARPingHost final : public AOnlineBeaconHost
{
public:
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool InitializeHost();
	void RegisterHostObject(class AOnlineBeaconHostObject* HostObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingHost">();
	}
	static class ARPingHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPingHost>();
	}
};
static_assert(alignof(ARPingHost) == 0x000008, "Wrong alignment on ARPingHost");
static_assert(sizeof(ARPingHost) == 0x0003F0, "Wrong size on ARPingHost");

// Class RGame.RPingHostObject
// 0x0000 (0x02D0 - 0x02D0)
class ARPingHostObject final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingHostObject">();
	}
	static class ARPingHostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPingHostObject>();
	}
};
static_assert(alignof(ARPingHostObject) == 0x000008, "Wrong alignment on ARPingHostObject");
static_assert(sizeof(ARPingHostObject) == 0x0002D0, "Wrong size on ARPingHostObject");

// Class RGame.RPingIndicator
// 0x0008 (0x02B0 - 0x02A8)
class ARPingIndicator : public AActor
{
public:
	bool                                          bShouldShowPlayerName;                             // 0x02A8(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDefaultLifespan(float Duration);
	void SetIndicatorIcon(const class UTexture2D* IconTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPingIndicator">();
	}
	static class ARPingIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPingIndicator>();
	}
};
static_assert(alignof(ARPingIndicator) == 0x000008, "Wrong alignment on ARPingIndicator");
static_assert(sizeof(ARPingIndicator) == 0x0002B0, "Wrong size on ARPingIndicator");
static_assert(offsetof(ARPingIndicator, bShouldShowPlayerName) == 0x0002A8, "Member 'ARPingIndicator::bShouldShowPlayerName' has a wrong offset!");

// Class RGame.RPlayerAnimInstance
// 0x0450 (0x0810 - 0x03C0)
class URPlayerAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_3B8[0x20];                                     // 0x03B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwningSkeletalMesh;                                // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARPlayerPawn*                           PawnOwner;                                         // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URWeaponAnimInstance*                   GunAnimInstance;                                   // 0x03E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARWeapon*                               CurrentWeapon;                                     // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARWeapon>                   CurrentWeaponClass;                                // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            CurrentAimOffset;                                  // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentBasePose;                                   // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentDetailSequence;                             // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasGunMesh;                                       // 0x0418(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RHandIKTransform;                                  // 0x0420(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RHandJointTargetLocation;                          // 0x0480(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LHandIKTransform;                                  // 0x04A0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LHandJointTargetLocation;                          // 0x0500(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLeftHandIK;                                    // 0x0518(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimPitch;                                          // 0x051C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaYaw;                                          // 0x0520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_524[0x4];                                      // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimRotation;                                       // 0x0528(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               PawnViewRotation;                                  // 0x0540(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         YawThreshold;                                      // 0x0558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawCorrectionTolerance;                            // 0x055C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CorrectionRate;                                    // 0x0560(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGripType                                     RGripType;                                         // 0x0570(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGripType                                     LGripType;                                         // 0x0571(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_572[0x6];                                      // 0x0572(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   LGripMesh;                                         // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERPawnMovementMode                            MovementState;                                     // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementDirection                            MovementDirection;                                 // 0x0581(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_582[0xE];                                      // 0x0582(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0590(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousVelocity;                                  // 0x05A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeVelocityDirection;                         // 0x05C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeAcceleration;                              // 0x05D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelativeAccelerationSize;                          // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasMovementInput;                                 // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F6[0x2];                                      // 0x05F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVelocityBlend                         VelocityBlend;                                     // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLeanAmount                            LeanAmount;                                        // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DiagonalScaleAmount;                               // 0x0610(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkRunBlend;                                      // 0x0614(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrideBlendTarget;                                 // 0x0618(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrideBlend;                                       // 0x061C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x0620(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimatedRunSpeed;                                  // 0x0624(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimatedWalkSpeed;                                 // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               DirectionalYaw;                                    // 0x0630(0x0020)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDashing;                                        // 0x0650(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IKTraceAboveFoot;                                  // 0x0654(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKTraceBelowFoot;                                  // 0x0658(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootHeight;                                        // 0x065C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LFootTransformOffset;                              // 0x0660(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RFootTransformOffset;                              // 0x06C0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadIKRotation;                                    // 0x0720(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PelvisIKTransform;                                 // 0x0740(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x28];                                     // 0x07A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PelvisPitchRange;                                  // 0x07C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PelvisYawRange;                                    // 0x07D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DiagonalScaleCurve;                                // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StrideBlendCurve;                                  // 0x07F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           YawOffsetFB;                                       // 0x07F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           YawOffsetLR;                                       // 0x0800(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerAnimInstance">();
	}
	static class URPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPlayerAnimInstance>();
	}
};
static_assert(alignof(URPlayerAnimInstance) == 0x000010, "Wrong alignment on URPlayerAnimInstance");
static_assert(sizeof(URPlayerAnimInstance) == 0x000810, "Wrong size on URPlayerAnimInstance");
static_assert(offsetof(URPlayerAnimInstance, OwningSkeletalMesh) == 0x0003D8, "Member 'URPlayerAnimInstance::OwningSkeletalMesh' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PawnOwner) == 0x0003E0, "Member 'URPlayerAnimInstance::PawnOwner' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, GunAnimInstance) == 0x0003E8, "Member 'URPlayerAnimInstance::GunAnimInstance' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, CurrentWeapon) == 0x0003F0, "Member 'URPlayerAnimInstance::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, CurrentWeaponClass) == 0x0003F8, "Member 'URPlayerAnimInstance::CurrentWeaponClass' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, CurrentAimOffset) == 0x000400, "Member 'URPlayerAnimInstance::CurrentAimOffset' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, CurrentBasePose) == 0x000408, "Member 'URPlayerAnimInstance::CurrentBasePose' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, CurrentDetailSequence) == 0x000410, "Member 'URPlayerAnimInstance::CurrentDetailSequence' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, bHasGunMesh) == 0x000418, "Member 'URPlayerAnimInstance::bHasGunMesh' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RHandIKTransform) == 0x000420, "Member 'URPlayerAnimInstance::RHandIKTransform' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RHandJointTargetLocation) == 0x000480, "Member 'URPlayerAnimInstance::RHandJointTargetLocation' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, LHandIKTransform) == 0x0004A0, "Member 'URPlayerAnimInstance::LHandIKTransform' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, LHandJointTargetLocation) == 0x000500, "Member 'URPlayerAnimInstance::LHandJointTargetLocation' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, bUseLeftHandIK) == 0x000518, "Member 'URPlayerAnimInstance::bUseLeftHandIK' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, AimPitch) == 0x00051C, "Member 'URPlayerAnimInstance::AimPitch' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, DeltaYaw) == 0x000520, "Member 'URPlayerAnimInstance::DeltaYaw' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, AimRotation) == 0x000528, "Member 'URPlayerAnimInstance::AimRotation' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PawnViewRotation) == 0x000540, "Member 'URPlayerAnimInstance::PawnViewRotation' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, YawThreshold) == 0x000558, "Member 'URPlayerAnimInstance::YawThreshold' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, YawCorrectionTolerance) == 0x00055C, "Member 'URPlayerAnimInstance::YawCorrectionTolerance' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, CorrectionRate) == 0x000560, "Member 'URPlayerAnimInstance::CorrectionRate' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RGripType) == 0x000570, "Member 'URPlayerAnimInstance::RGripType' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, LGripType) == 0x000571, "Member 'URPlayerAnimInstance::LGripType' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, LGripMesh) == 0x000578, "Member 'URPlayerAnimInstance::LGripMesh' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, MovementState) == 0x000580, "Member 'URPlayerAnimInstance::MovementState' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, MovementDirection) == 0x000581, "Member 'URPlayerAnimInstance::MovementDirection' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, Velocity) == 0x000590, "Member 'URPlayerAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PreviousVelocity) == 0x0005A8, "Member 'URPlayerAnimInstance::PreviousVelocity' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RelativeVelocityDirection) == 0x0005C0, "Member 'URPlayerAnimInstance::RelativeVelocityDirection' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RelativeAcceleration) == 0x0005D8, "Member 'URPlayerAnimInstance::RelativeAcceleration' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RelativeAccelerationSize) == 0x0005F0, "Member 'URPlayerAnimInstance::RelativeAccelerationSize' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, bHasMovementInput) == 0x0005F4, "Member 'URPlayerAnimInstance::bHasMovementInput' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, bIsMoving) == 0x0005F5, "Member 'URPlayerAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, VelocityBlend) == 0x0005F8, "Member 'URPlayerAnimInstance::VelocityBlend' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, LeanAmount) == 0x000608, "Member 'URPlayerAnimInstance::LeanAmount' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, DiagonalScaleAmount) == 0x000610, "Member 'URPlayerAnimInstance::DiagonalScaleAmount' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, WalkRunBlend) == 0x000614, "Member 'URPlayerAnimInstance::WalkRunBlend' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, StrideBlendTarget) == 0x000618, "Member 'URPlayerAnimInstance::StrideBlendTarget' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, StrideBlend) == 0x00061C, "Member 'URPlayerAnimInstance::StrideBlend' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PlayRate) == 0x000620, "Member 'URPlayerAnimInstance::PlayRate' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, AnimatedRunSpeed) == 0x000624, "Member 'URPlayerAnimInstance::AnimatedRunSpeed' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, AnimatedWalkSpeed) == 0x000628, "Member 'URPlayerAnimInstance::AnimatedWalkSpeed' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, DirectionalYaw) == 0x000630, "Member 'URPlayerAnimInstance::DirectionalYaw' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, bIsDashing) == 0x000650, "Member 'URPlayerAnimInstance::bIsDashing' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, IKTraceAboveFoot) == 0x000654, "Member 'URPlayerAnimInstance::IKTraceAboveFoot' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, IKTraceBelowFoot) == 0x000658, "Member 'URPlayerAnimInstance::IKTraceBelowFoot' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, FootHeight) == 0x00065C, "Member 'URPlayerAnimInstance::FootHeight' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, LFootTransformOffset) == 0x000660, "Member 'URPlayerAnimInstance::LFootTransformOffset' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, RFootTransformOffset) == 0x0006C0, "Member 'URPlayerAnimInstance::RFootTransformOffset' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, HeadIKRotation) == 0x000720, "Member 'URPlayerAnimInstance::HeadIKRotation' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PelvisIKTransform) == 0x000740, "Member 'URPlayerAnimInstance::PelvisIKTransform' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PelvisPitchRange) == 0x0007C8, "Member 'URPlayerAnimInstance::PelvisPitchRange' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, PelvisYawRange) == 0x0007D8, "Member 'URPlayerAnimInstance::PelvisYawRange' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, DiagonalScaleCurve) == 0x0007E8, "Member 'URPlayerAnimInstance::DiagonalScaleCurve' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, StrideBlendCurve) == 0x0007F0, "Member 'URPlayerAnimInstance::StrideBlendCurve' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, YawOffsetFB) == 0x0007F8, "Member 'URPlayerAnimInstance::YawOffsetFB' has a wrong offset!");
static_assert(offsetof(URPlayerAnimInstance, YawOffsetLR) == 0x000800, "Member 'URPlayerAnimInstance::YawOffsetLR' has a wrong offset!");

// Class RGame.RPlayerFrameUserWidget
// 0x0000 (0x02D0 - 0x02D0)
class URPlayerFrameUserWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerFrameUserWidget">();
	}
	static class URPlayerFrameUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPlayerFrameUserWidget>();
	}
};
static_assert(alignof(URPlayerFrameUserWidget) == 0x000008, "Wrong alignment on URPlayerFrameUserWidget");
static_assert(sizeof(URPlayerFrameUserWidget) == 0x0002D0, "Wrong size on URPlayerFrameUserWidget");

// Class RGame.RPlayerGScriptComponent
// 0x00F8 (0x0638 - 0x0540)
class URPlayerGScriptComponent final : public URGScriptComponent
{
public:
	TArray<struct FProjectileMutator>             ProjectileMutators;                                // 0x0540(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponMutator>                 WeaponMutators;                                    // 0x0550(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentCharacterResources;                         // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentCharacterTier;                              // 0x0564(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCharacterMutator>              CharacterMutators;                                 // 0x0568(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class URProjectileMutatorPrimaryAsset*> ProjectileMutatorsSpawnedThisFrame;               // 0x0578(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URPlayerGScriptComponent* Owner)> OnWeaponMutatorsChanged;   // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URPlayerGScriptComponent* Owner)> OnProjectileMutatorsChanged; // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URPlayerGScriptComponent* Owner)> OnCharacterMutatorsChanged; // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URPlayerGScriptComponent* Owner)> OnMutatorsChanged;         // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URPlayerGScriptComponent* Owner)> OnResourcesGained;         // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 NewRank, class URMutatorPrimaryAsset* MutatorPrimaryAsset)> OnMutatorChangedRank; // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URPlayerGScriptComponent* Owner, class URMutatorPrimaryAsset* MutatorPrimaryAsset)> OnMutatorAdded; // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URMutatorPrimaryAsset* MutatorPrimaryAsset)> OnGainedGodBonusMutator; // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         NumMutatorSlots;                                   // 0x0608(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMutatorRewardCategories;                        // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ChosenMutatorRewardCategories;                     // 0x0610(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         NumMutatorCategoryRerolls;                         // 0x0630(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AddCharacterMutator(class URPlayerGScriptComponent* OwningComponent, class URCharacterMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	static void AddMutator(class URPlayerGScriptComponent* OwningComponent, class URMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	static void AddProjectileMutator(class URPlayerGScriptComponent* OwningComponent, class URProjectileMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	static void AddWeaponMutator(class URPlayerGScriptComponent* OwningComponent, class URWeaponMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	static bool CanSelectNewCharacterMutator(class URPlayerGScriptComponent* OwningComponent);
	static void ClearCharacterMutators(class URPlayerGScriptComponent* OwningComponent);
	static void ClearProjectileMutators(class URPlayerGScriptComponent* OwningComponent);
	static void ClearWeaponMutators(class URPlayerGScriptComponent* OwningComponent);
	static class URGAbilityCharacterMutatorScript* GetActivatableAbilityByIndex(class URGScriptComponent* OwningComponent, const int32 AbilityIndex);
	static class URGAbilityCharacterMutatorScript* GetActivatableAbilityByName(class URGScriptComponent* OwningComponent, class FName AbilityName);
	static TArray<class URGAbilityCharacterMutatorScript*> GetAllActivatableAbilityScripts(class URGScriptComponent* OwningComponent, bool bExcludeStartEquippedAbilities);
	static int32 GetCurrentResources(class URPlayerGScriptComponent* OwningComponent);
	static class URGAbilityCharacterMutatorScript* GetEquippedActivatableAbility(class URGScriptComponent* OwningComponent);
	static class URCharacterMutatorPrimaryAsset* GetEquippedActivatableAbilityPrimaryAsset(class URGScriptComponent* OwningComponent);
	static class URPlayerGScriptComponent* GetPlayerGScriptComponent(const class APlayerController* Controller);
	static int32 GetResourcesRequiredToGainNewMutator(class URPlayerGScriptComponent* OwningComponent);
	static void IncrementResources(class URPlayerGScriptComponent* OwningComponent, int32 Delta);
	static void RemoveAllStatusEffects(class URPlayerGScriptComponent* OwningComponent);
	static void RemoveCharacterMutator(class URPlayerGScriptComponent* OwningComponent, const class URCharacterMutatorPrimaryAsset* Mutator);
	static void RemoveMutator(class URPlayerGScriptComponent* OwningComponent, class URMutatorPrimaryAsset* Mutator);
	static void RemoveProjectileMutator(class URPlayerGScriptComponent* OwningComponent, const class URProjectileMutatorPrimaryAsset* Mutator);
	static void RemoveWeaponMutator(class URPlayerGScriptComponent* OwningComponent, const class URWeaponMutatorPrimaryAsset* Mutator);
	static void ResetGScriptComponent(class URPlayerGScriptComponent* OwningComponent);
	static bool SpawnProjectileMutators(class URPlayerGScriptComponent* OwningComponent, class FName Category, bool bNoRep);

	void CharacterMutators_RepNotify(const TArray<struct FCharacterMutator>& PreviousValue);
	int32 GetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	int32 GetNumUniqueEquippedMutatorCategories(const struct FGameplayTagContainer& Categories);
	bool HasCappedMutatorRewardCategories(const struct FGameplayTagContainer& Categories);
	void ProjectileMutators_RepNotify(const TArray<struct FProjectileMutator>& PreviousValue);
	void ServerAddCharacterMutator(class URCharacterMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	void ServerAddProjectileMutator(class URProjectileMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	void ServerAddWeaponMutator(class URWeaponMutatorPrimaryAsset* Mutator, int32 MutatorRank);
	void ServerRemoveCharacterMutator(const class URCharacterMutatorPrimaryAsset* Mutator);
	void ServerRemoveProjectileMutator(const class URProjectileMutatorPrimaryAsset* Mutator);
	void ServerRemoveWeaponMutator(const class URWeaponMutatorPrimaryAsset* Mutator);
	void SetChosenMutatorRewardCategories_Server(const struct FGameplayTagContainer& NewChosenMutatorRewardCategories);
	void SetMutatorRank(class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 NewRank);
	void SetMutatorRank_Server(class URMutatorPrimaryAsset* RMutatorPrimaryAsset, int32 NewRank);
	void SetNumMutatorCategoryRerolls(int32 NewNumMutatorCategoryRerolls);
	void SetNumMutatorCategoryRerolls_Server(int32 NewNumMutatorCategoryRerolls);
	void UpdateMutatorRewardCategoryBonusMutators(class URMutatorPrimaryAsset* RMutatorPrimaryAsset);
	void WeaponMutators_RepNotify(const TArray<struct FWeaponMutator>& PreviousValue);

	class URGCharacterMutatorScript* GetCharacterMutator(const class URCharacterMutatorPrimaryAsset* MutatorPrimaryAsset) const;
	class URCharacterMutatorPrimaryAsset* GetCharacterMutatorPrimaryAsset(const class URGCharacterMutatorScript* MutatorScript) const;
	TArray<class URMutatorPrimaryAsset*> GetDisplayEquippedMutators() const;
	TArray<class URMutatorPrimaryAsset*> GetDisplayEquippedMutatorsWithSlotSpace() const;
	TArray<class URMutatorPrimaryAsset*> GetEquippedMutators() const;
	TArray<class URMutatorPrimaryAsset*> GetEquippedMutatorsByGodCategories(const struct FGameplayTagContainer& Tags, const bool bIncludeTriggers) const;
	TArray<class URMutatorPrimaryAsset*> GetEquippedMutatorsByMutatorTypeTags(const struct FGameplayTagContainer& TagContainer) const;
	class URGlobalWeaponModifiers* GetGlobalWeaponModifiers() const;
	class URGWeaponMutatorScript* GetWeaponMutator(const class URWeaponMutatorPrimaryAsset* MutatorPrimaryAsset) const;
	class URWeaponMutatorPrimaryAsset* GetWeaponMutatorPrimaryAsset(const class URGWeaponMutatorScript* MutatorScript) const;
	bool HasCharacterMutator(const class URCharacterMutatorPrimaryAsset* MutatorPrimaryAsset) const;
	bool HasMutator(const class URMutatorPrimaryAsset* Mutator) const;
	bool HasProjectileMutator(const class URProjectileMutatorPrimaryAsset* MutatorPrimaryAsset) const;
	bool HasWeaponMutator(const class URWeaponMutatorPrimaryAsset* MutatorPrimaryAsset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerGScriptComponent">();
	}
	static class URPlayerGScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPlayerGScriptComponent>();
	}
};
static_assert(alignof(URPlayerGScriptComponent) == 0x000008, "Wrong alignment on URPlayerGScriptComponent");
static_assert(sizeof(URPlayerGScriptComponent) == 0x000638, "Wrong size on URPlayerGScriptComponent");
static_assert(offsetof(URPlayerGScriptComponent, ProjectileMutators) == 0x000540, "Member 'URPlayerGScriptComponent::ProjectileMutators' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, WeaponMutators) == 0x000550, "Member 'URPlayerGScriptComponent::WeaponMutators' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, CurrentCharacterResources) == 0x000560, "Member 'URPlayerGScriptComponent::CurrentCharacterResources' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, CurrentCharacterTier) == 0x000564, "Member 'URPlayerGScriptComponent::CurrentCharacterTier' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, CharacterMutators) == 0x000568, "Member 'URPlayerGScriptComponent::CharacterMutators' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, ProjectileMutatorsSpawnedThisFrame) == 0x000578, "Member 'URPlayerGScriptComponent::ProjectileMutatorsSpawnedThisFrame' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnWeaponMutatorsChanged) == 0x000588, "Member 'URPlayerGScriptComponent::OnWeaponMutatorsChanged' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnProjectileMutatorsChanged) == 0x000598, "Member 'URPlayerGScriptComponent::OnProjectileMutatorsChanged' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnCharacterMutatorsChanged) == 0x0005A8, "Member 'URPlayerGScriptComponent::OnCharacterMutatorsChanged' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnMutatorsChanged) == 0x0005B8, "Member 'URPlayerGScriptComponent::OnMutatorsChanged' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnResourcesGained) == 0x0005C8, "Member 'URPlayerGScriptComponent::OnResourcesGained' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnMutatorChangedRank) == 0x0005D8, "Member 'URPlayerGScriptComponent::OnMutatorChangedRank' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnMutatorAdded) == 0x0005E8, "Member 'URPlayerGScriptComponent::OnMutatorAdded' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, OnGainedGodBonusMutator) == 0x0005F8, "Member 'URPlayerGScriptComponent::OnGainedGodBonusMutator' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, NumMutatorSlots) == 0x000608, "Member 'URPlayerGScriptComponent::NumMutatorSlots' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, MaxMutatorRewardCategories) == 0x00060C, "Member 'URPlayerGScriptComponent::MaxMutatorRewardCategories' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, ChosenMutatorRewardCategories) == 0x000610, "Member 'URPlayerGScriptComponent::ChosenMutatorRewardCategories' has a wrong offset!");
static_assert(offsetof(URPlayerGScriptComponent, NumMutatorCategoryRerolls) == 0x000630, "Member 'URPlayerGScriptComponent::NumMutatorCategoryRerolls' has a wrong offset!");

// Class RGame.RPlayerInteractComponent
// 0x0090 (0x0130 - 0x00A0)
class URPlayerInteractComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x4C];                                      // 0x00A0(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScanLength;                                        // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanRadius;                                        // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanTime;                                          // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawLOSDebug;                                     // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawSphereTraceDebug;                             // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFocus;                                           // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFocusGone;                                       // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRInteractionData& RInteractionData)> OnCanInteractWithTooltip; // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GetAndCacheTargetResult(TDelegate<void(const TArray<struct FHitResult>& HitResults)> Callback);
	bool HasInteractableTarget();
	void OnGetTargetingResult(const TArray<struct FHitResult>& HitResults);
	void OnInteract();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerInteractComponent">();
	}
	static class URPlayerInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPlayerInteractComponent>();
	}
};
static_assert(alignof(URPlayerInteractComponent) == 0x000008, "Wrong alignment on URPlayerInteractComponent");
static_assert(sizeof(URPlayerInteractComponent) == 0x000130, "Wrong size on URPlayerInteractComponent");
static_assert(offsetof(URPlayerInteractComponent, ScanLength) == 0x0000EC, "Member 'URPlayerInteractComponent::ScanLength' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, ScanRadius) == 0x0000F0, "Member 'URPlayerInteractComponent::ScanRadius' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, ScanTime) == 0x0000F4, "Member 'URPlayerInteractComponent::ScanTime' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, bDrawLOSDebug) == 0x0000F8, "Member 'URPlayerInteractComponent::bDrawLOSDebug' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, bDrawSphereTraceDebug) == 0x0000F9, "Member 'URPlayerInteractComponent::bDrawSphereTraceDebug' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, OnFocus) == 0x000100, "Member 'URPlayerInteractComponent::OnFocus' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, OnFocusGone) == 0x000110, "Member 'URPlayerInteractComponent::OnFocusGone' has a wrong offset!");
static_assert(offsetof(URPlayerInteractComponent, OnCanInteractWithTooltip) == 0x000120, "Member 'URPlayerInteractComponent::OnCanInteractWithTooltip' has a wrong offset!");

// Class RGame.RPlayerPawnMovementComponent
// 0x0000 (0x0A10 - 0x0A10)
class URPlayerPawnMovementComponent final : public URPawnMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerPawnMovementComponent">();
	}
	static class URPlayerPawnMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPlayerPawnMovementComponent>();
	}
};
static_assert(alignof(URPlayerPawnMovementComponent) == 0x000008, "Wrong alignment on URPlayerPawnMovementComponent");
static_assert(sizeof(URPlayerPawnMovementComponent) == 0x000A10, "Wrong size on URPlayerPawnMovementComponent");

// Class RGame.RPlayerState
// 0x01E0 (0x0540 - 0x0360)
class ARPlayerState final : public APlayerState
{
public:
	bool                                          bEnableGoldGain;                                   // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRPlayerStats                          PlayerStats;                                       // 0x0368(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      VoiceQueryFloatDatabase;                           // 0x0428(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                VoiceQueryFNameDatabase;                           // 0x0478(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerNewToSession;                             // 0x04C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bWasLocalPlayerReconnect)> OnReconnectSyncDelegate;           // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRDisconnectedPlayerData& PlayerData)> OnLocalPlayerReconnectSyncDelegate; // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x44];                                     // 0x04F0(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasUsedSecondWind;                                // 0x0534(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_535[0x3];                                      // 0x0535(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URPlayerFrameUserWidget>    PlayerframeWidgetClass;                            // 0x0538(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddGold(int32 Delta);
	void AddKeys(int32 Value);
	class FString GetUniqueNetIdString();
	int32 GetViolentCommitmentStacks();
	bool HasKeys();
	void OnChallengeCompleted_Multicast(class FName ChallengeId);
	void OnChallengeCompleted_Server(class FName ChallengeId);
	void OnDamageDealt(class ARPawnBase* InstigatorPawn, const struct FDamageCombatEvent& DamageEventData);
	void OnDamageTaken(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageData);
	void OnFinishRun(bool RunFailed);
	void OnGoldCollected_Multicast(float Delta, float NewTotal);
	void OnGoldCollected_Server(float Delta);
	void OnHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData);
	void OnKeyCollected(int32 Delta, int32 NewTotal);
	void OnKeyCollected_Multicast(int32 Delta, int32 NewTotal);
	void OnKeyCollected_Server(int32 Delta, int32 NewTotal);
	void OnMaximumHealthChanged(class URHealthComponent* Component, float MaximumHealth);
	void OnMutatorsChanged(class URPlayerGScriptComponent* OwnerComponent);
	void OnPlayerPawnDowned(class ARPlayerPawn* RPlayerPawn);
	void OnProjectileHit(class ARPlayerPawn* Player, class AActor* HitActor, class ARProjectileBase* ProjectileActor);
	void OnRevivedCastFinished(class ARPlayerPawn* RevivingPlayer);
	void OnStartRun();
	void ReconnectSync_Multicast(const struct FRDisconnectedPlayerData& PlayerData);
	void ResetPlayerStats(class ARPlayerPawn* RPlayerPawn);
	void ResetRunStats();
	void SetBloodPassive7Value(float NewBloodPassive7Value);
	void SetEnableGoldGain(const bool bNewEnabled);
	void SetHealthBonusRank(int32 NewHealthBonusRank);
	void SetHealthyCommitmentStacks(int32 NewHealthyCommitmentStacks);
	void SetPlayerFrameWidgetClass_Multicast(TSubclassOf<class URPlayerFrameUserWidget> NewPlayerFrameWidgetClass);
	void SetPlayerFrameWidgetClass_Server(TSubclassOf<class URPlayerFrameUserWidget> NewPlayerFrameWidgetClass);
	void SetRunStats(const struct FRRunStats& RunStats);
	void SetRunSuccesful(bool RunSuccesful);
	void SetSecondWindUsed(bool bNewSecondWindUsed);
	void SetViolentCommitmentStacks(int32 NewViolentCommitmentStacks);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlayerState">();
	}
	static class ARPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPlayerState>();
	}
};
static_assert(alignof(ARPlayerState) == 0x000008, "Wrong alignment on ARPlayerState");
static_assert(sizeof(ARPlayerState) == 0x000540, "Wrong size on ARPlayerState");
static_assert(offsetof(ARPlayerState, bEnableGoldGain) == 0x000360, "Member 'ARPlayerState::bEnableGoldGain' has a wrong offset!");
static_assert(offsetof(ARPlayerState, PlayerStats) == 0x000368, "Member 'ARPlayerState::PlayerStats' has a wrong offset!");
static_assert(offsetof(ARPlayerState, VoiceQueryFloatDatabase) == 0x000428, "Member 'ARPlayerState::VoiceQueryFloatDatabase' has a wrong offset!");
static_assert(offsetof(ARPlayerState, VoiceQueryFNameDatabase) == 0x000478, "Member 'ARPlayerState::VoiceQueryFNameDatabase' has a wrong offset!");
static_assert(offsetof(ARPlayerState, bIsPlayerNewToSession) == 0x0004C8, "Member 'ARPlayerState::bIsPlayerNewToSession' has a wrong offset!");
static_assert(offsetof(ARPlayerState, OnReconnectSyncDelegate) == 0x0004D0, "Member 'ARPlayerState::OnReconnectSyncDelegate' has a wrong offset!");
static_assert(offsetof(ARPlayerState, OnLocalPlayerReconnectSyncDelegate) == 0x0004E0, "Member 'ARPlayerState::OnLocalPlayerReconnectSyncDelegate' has a wrong offset!");
static_assert(offsetof(ARPlayerState, bHasUsedSecondWind) == 0x000534, "Member 'ARPlayerState::bHasUsedSecondWind' has a wrong offset!");
static_assert(offsetof(ARPlayerState, PlayerframeWidgetClass) == 0x000538, "Member 'ARPlayerState::PlayerframeWidgetClass' has a wrong offset!");

// Class RGame.RPlaySyncedMontageCallbackProxy
// 0x0080 (0x00A8 - 0x0028)
class URPlaySyncedMontageCallbackProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void(class FName NotifyName)> OnCompleted;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnBlendOut;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnInterrupted;                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyBegin;                            // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyEnd;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URPlaySyncedMontageCallbackProxy* CreateProxyObjectForPlayMontage(const TArray<class USkeletalMeshComponent*>& InSkeletalMeshComponents, class ARPlayerPawn* PlayerPawn, const TArray<class UAnimMontage*>& MontagesToPlay, float PlayRate, float StartingPosition, class FName StartingSection, bool bShouldStopAllMontages);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPlaySyncedMontageCallbackProxy">();
	}
	static class URPlaySyncedMontageCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPlaySyncedMontageCallbackProxy>();
	}
};
static_assert(alignof(URPlaySyncedMontageCallbackProxy) == 0x000008, "Wrong alignment on URPlaySyncedMontageCallbackProxy");
static_assert(sizeof(URPlaySyncedMontageCallbackProxy) == 0x0000A8, "Wrong size on URPlaySyncedMontageCallbackProxy");
static_assert(offsetof(URPlaySyncedMontageCallbackProxy, OnCompleted) == 0x000028, "Member 'URPlaySyncedMontageCallbackProxy::OnCompleted' has a wrong offset!");
static_assert(offsetof(URPlaySyncedMontageCallbackProxy, OnBlendOut) == 0x000038, "Member 'URPlaySyncedMontageCallbackProxy::OnBlendOut' has a wrong offset!");
static_assert(offsetof(URPlaySyncedMontageCallbackProxy, OnInterrupted) == 0x000048, "Member 'URPlaySyncedMontageCallbackProxy::OnInterrupted' has a wrong offset!");
static_assert(offsetof(URPlaySyncedMontageCallbackProxy, OnNotifyBegin) == 0x000058, "Member 'URPlaySyncedMontageCallbackProxy::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(URPlaySyncedMontageCallbackProxy, OnNotifyEnd) == 0x000068, "Member 'URPlaySyncedMontageCallbackProxy::OnNotifyEnd' has a wrong offset!");

// Class RGame.RPool
// 0x0000 (0x0028 - 0x0028)
class URPool final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPool">();
	}
	static class URPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPool>();
	}
};
static_assert(alignof(URPool) == 0x000008, "Wrong alignment on URPool");
static_assert(sizeof(URPool) == 0x000028, "Wrong size on URPool");

// Class RGame.RPoolInterface
// 0x0000 (0x0000 - 0x0000)
class IRPoolInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPoolInterface">();
	}
	static class IRPoolInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRPoolInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRPoolInterface) == 0x000001, "Wrong alignment on IRPoolInterface");
static_assert(sizeof(IRPoolInterface) == 0x000001, "Wrong size on IRPoolInterface");

// Class RGame.RPoolManager
// 0x0070 (0x0318 - 0x02A8)
class ARPoolManager final : public AActor
{
public:
	TMap<class FName, struct FActorArray>         Items;                                             // 0x02A8(0x0050)(NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnPoolEnter;                                 // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnPoolExit;                                  // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class ARPoolManager* GetPoolManager(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPoolManager">();
	}
	static class ARPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPoolManager>();
	}
};
static_assert(alignof(ARPoolManager) == 0x000008, "Wrong alignment on ARPoolManager");
static_assert(sizeof(ARPoolManager) == 0x000318, "Wrong size on ARPoolManager");
static_assert(offsetof(ARPoolManager, Items) == 0x0002A8, "Member 'ARPoolManager::Items' has a wrong offset!");
static_assert(offsetof(ARPoolManager, OnPoolEnter) == 0x0002F8, "Member 'ARPoolManager::OnPoolEnter' has a wrong offset!");
static_assert(offsetof(ARPoolManager, OnPoolExit) == 0x000308, "Member 'ARPoolManager::OnPoolExit' has a wrong offset!");

// Class RGame.RPotGeometryCollectionActor
// 0x00E0 (0x03A8 - 0x02C8)
class ARPotGeometryCollectionActor final : public ARGeometryCollectionActor
{
public:
	bool                                          bRandomizeOnBeginPlay;                             // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBreakableSizeVariant                         Size;                                              // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBreakableSizeVariant, struct FBreakableVariants> VariantsMap;                              // 0x02D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMaterialInstance>> RandomMaterialInstances;                         // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         GoldenChanceWeight;                                // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARPotGeometryCollectionActor> GoldVariation;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinGoldReward;                                     // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGoldReward;                                     // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       GoldMaterialInstance;                              // 0x0348(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          GoldenParticleSystem;                              // 0x0370(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARDoor>                  DoorRef;                                           // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakingBlocked;                                  // 0x03A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGolden;                                         // 0x03A1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRandomized;                                     // 0x03A2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A3[0x5];                                      // 0x03A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CrumblePot(EBreakType BreakType, const struct FVector& Location);
	void OnRefDoorOpened();
	void RandomizeVariants();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPotGeometryCollectionActor">();
	}
	static class ARPotGeometryCollectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARPotGeometryCollectionActor>();
	}
};
static_assert(alignof(ARPotGeometryCollectionActor) == 0x000008, "Wrong alignment on ARPotGeometryCollectionActor");
static_assert(sizeof(ARPotGeometryCollectionActor) == 0x0003A8, "Wrong size on ARPotGeometryCollectionActor");
static_assert(offsetof(ARPotGeometryCollectionActor, bRandomizeOnBeginPlay) == 0x0002C8, "Member 'ARPotGeometryCollectionActor::bRandomizeOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, Size) == 0x0002C9, "Member 'ARPotGeometryCollectionActor::Size' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, VariantsMap) == 0x0002D0, "Member 'ARPotGeometryCollectionActor::VariantsMap' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, RandomMaterialInstances) == 0x000320, "Member 'ARPotGeometryCollectionActor::RandomMaterialInstances' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, GoldenChanceWeight) == 0x000330, "Member 'ARPotGeometryCollectionActor::GoldenChanceWeight' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, GoldVariation) == 0x000338, "Member 'ARPotGeometryCollectionActor::GoldVariation' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, MinGoldReward) == 0x000340, "Member 'ARPotGeometryCollectionActor::MinGoldReward' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, MaxGoldReward) == 0x000344, "Member 'ARPotGeometryCollectionActor::MaxGoldReward' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, GoldMaterialInstance) == 0x000348, "Member 'ARPotGeometryCollectionActor::GoldMaterialInstance' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, GoldenParticleSystem) == 0x000370, "Member 'ARPotGeometryCollectionActor::GoldenParticleSystem' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, DoorRef) == 0x000398, "Member 'ARPotGeometryCollectionActor::DoorRef' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, bBreakingBlocked) == 0x0003A0, "Member 'ARPotGeometryCollectionActor::bBreakingBlocked' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, bIsGolden) == 0x0003A1, "Member 'ARPotGeometryCollectionActor::bIsGolden' has a wrong offset!");
static_assert(offsetof(ARPotGeometryCollectionActor, bIsRandomized) == 0x0003A2, "Member 'ARPotGeometryCollectionActor::bIsRandomized' has a wrong offset!");

// Class RGame.RProjectileMovementComponent
// 0x0368 (0x0470 - 0x0108)
class alignas(0x10) URProjectileMovementComponent final : public UMovementComponent
{
public:
	float                                         InitialSpeed;                                      // 0x0108(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMutableFloat                         SpeedModifier;                                     // 0x0110(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bRotationFollowsVelocity : 1;                      // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRotationRemainsVertical : 1;                      // 0x0238(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBounce : 1;                                 // 0x0238(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitialVelocityInLocalSpace : 1;                  // 0x0238(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceSubStepping : 1;                             // 0x0238(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSimulationEnabled : 1;                            // 0x0238(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bSimulateShouldContinueAfterHit;                   // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStaticMeshCollisions;                       // 0x023A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSweepCollision : 1;                               // 0x023B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsHomingProjectile : 1;                           // 0x023B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoRetargetHoming : 1;                           // 0x023B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBounceAngleAffectsFriction : 1;                   // 0x023B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSliding : 1;                                    // 0x023B(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterpMovement : 1;                               // 0x023B(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterpRotation : 1;                               // 0x023B(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ERDamageFlag                                  ProjectileDamageFlag;                              // 0x023C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0xB];                                      // 0x023D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingProjectileForceIncreaseMultiplier;           // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingDistanceMultiplierValue;                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HomingSocketName;                                  // 0x0250(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HomingWorldOffset;                                 // 0x0258(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class USceneComponent>         HomingTarget;                                      // 0x0270(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCachePhysicsMaterialOnTraceHits;                  // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysReturnToOwner;                              // 0x0279(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A[0x2];                                      // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviousHitTime;                                   // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousHitNormal;                                 // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileGravityScale;                            // 0x0298(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buoyancy;                                          // 0x029C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bounciness;                                        // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityStopSimulatingThreshold;             // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFrictionFraction;                               // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)> OnProjectileBounce; // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHitResult& ImpactResult)> OnProjectileStop;          // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HomingAccelerationMagnitude;                       // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         HomingTargetComponent;                             // 0x02D4(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLineTraceByLength;                                // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceLength;                                       // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPiercing;                                         // 0x02E4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBounceOnPawns;                                 // 0x02E5(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E6[0x7A];                                     // 0x02E6(0x007A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReplicatedInitialLocalSpaceVelocity;               // 0x0360(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseReplicatedInitialLocalSpaceVelocity;           // 0x0378(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReplicatedInitialVelocity;                         // 0x0380(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseReplicatedInitialVelocity;                     // 0x0398(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockMovementTick;                                // 0x0399(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39A[0x2];                                      // 0x039A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSimulationTimeStep;                             // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BounceAdditionalIterations;                        // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationTime;                                // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpRotationTime;                                // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationMaxLagDistance;                      // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationSnapToTargetDistance;                // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0xB8];                                     // 0x03B8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveInterpolationTarget(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void OnHomingTargetHealthDepleted(class URHealthComponent* Component, const struct FDamageCombatEvent& DamageEventData);
	void OnRep_HomingTarget();
	void ResetInterpolation();
	void SetBlockMovementTick(bool bNewBlockMovementTick);
	void SetCanBounceOnPawns(bool bNewCanBounce);
	void SetHomingSocket(class FName InHomingSocketName);
	void SetHomingTarget(class USceneComponent* InHomingTarget);
	void SetInterpolatedComponent(class USceneComponent* Component);
	void SetPiercing(bool bNewPiercing);
	void SetVelocity(const struct FVector& NewVelocity);
	void SetVelocityInLocalSpace(const struct FVector& NewVelocity);
	void StopSimulating(const struct FHitResult& HitResult);

	struct FVector ComputeAcceleration(const struct FVector& InVelocity, float DeltaTime) const;
	bool IsInterpolationComplete() const;
	bool IsVelocityUnderSimulationThreshold() const;
	struct FVector LimitVelocity(const struct FVector& NewVelocity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RProjectileMovementComponent">();
	}
	static class URProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URProjectileMovementComponent>();
	}
};
static_assert(alignof(URProjectileMovementComponent) == 0x000010, "Wrong alignment on URProjectileMovementComponent");
static_assert(sizeof(URProjectileMovementComponent) == 0x000470, "Wrong size on URProjectileMovementComponent");
static_assert(offsetof(URProjectileMovementComponent, InitialSpeed) == 0x000108, "Member 'URProjectileMovementComponent::InitialSpeed' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, MaxSpeed) == 0x00010C, "Member 'URProjectileMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, SpeedModifier) == 0x000110, "Member 'URProjectileMovementComponent::SpeedModifier' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bSimulateShouldContinueAfterHit) == 0x000239, "Member 'URProjectileMovementComponent::bSimulateShouldContinueAfterHit' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bIgnoreStaticMeshCollisions) == 0x00023A, "Member 'URProjectileMovementComponent::bIgnoreStaticMeshCollisions' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, ProjectileDamageFlag) == 0x00023C, "Member 'URProjectileMovementComponent::ProjectileDamageFlag' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingProjectileForceIncreaseMultiplier) == 0x000248, "Member 'URProjectileMovementComponent::HomingProjectileForceIncreaseMultiplier' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingDistanceMultiplierValue) == 0x00024C, "Member 'URProjectileMovementComponent::HomingDistanceMultiplierValue' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingSocketName) == 0x000250, "Member 'URProjectileMovementComponent::HomingSocketName' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingWorldOffset) == 0x000258, "Member 'URProjectileMovementComponent::HomingWorldOffset' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingTarget) == 0x000270, "Member 'URProjectileMovementComponent::HomingTarget' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bCachePhysicsMaterialOnTraceHits) == 0x000278, "Member 'URProjectileMovementComponent::bCachePhysicsMaterialOnTraceHits' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bAlwaysReturnToOwner) == 0x000279, "Member 'URProjectileMovementComponent::bAlwaysReturnToOwner' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, PreviousHitTime) == 0x00027C, "Member 'URProjectileMovementComponent::PreviousHitTime' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, PreviousHitNormal) == 0x000280, "Member 'URProjectileMovementComponent::PreviousHitNormal' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, ProjectileGravityScale) == 0x000298, "Member 'URProjectileMovementComponent::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, Buoyancy) == 0x00029C, "Member 'URProjectileMovementComponent::Buoyancy' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, Bounciness) == 0x0002A0, "Member 'URProjectileMovementComponent::Bounciness' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, Friction) == 0x0002A4, "Member 'URProjectileMovementComponent::Friction' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, BounceVelocityStopSimulatingThreshold) == 0x0002A8, "Member 'URProjectileMovementComponent::BounceVelocityStopSimulatingThreshold' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, MinFrictionFraction) == 0x0002AC, "Member 'URProjectileMovementComponent::MinFrictionFraction' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, OnProjectileBounce) == 0x0002B0, "Member 'URProjectileMovementComponent::OnProjectileBounce' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, OnProjectileStop) == 0x0002C0, "Member 'URProjectileMovementComponent::OnProjectileStop' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingAccelerationMagnitude) == 0x0002D0, "Member 'URProjectileMovementComponent::HomingAccelerationMagnitude' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, HomingTargetComponent) == 0x0002D4, "Member 'URProjectileMovementComponent::HomingTargetComponent' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bLineTraceByLength) == 0x0002DC, "Member 'URProjectileMovementComponent::bLineTraceByLength' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, TraceLength) == 0x0002E0, "Member 'URProjectileMovementComponent::TraceLength' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bPiercing) == 0x0002E4, "Member 'URProjectileMovementComponent::bPiercing' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bCanBounceOnPawns) == 0x0002E5, "Member 'URProjectileMovementComponent::bCanBounceOnPawns' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, ReplicatedInitialLocalSpaceVelocity) == 0x000360, "Member 'URProjectileMovementComponent::ReplicatedInitialLocalSpaceVelocity' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bUseReplicatedInitialLocalSpaceVelocity) == 0x000378, "Member 'URProjectileMovementComponent::bUseReplicatedInitialLocalSpaceVelocity' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, ReplicatedInitialVelocity) == 0x000380, "Member 'URProjectileMovementComponent::ReplicatedInitialVelocity' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bUseReplicatedInitialVelocity) == 0x000398, "Member 'URProjectileMovementComponent::bUseReplicatedInitialVelocity' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, bBlockMovementTick) == 0x000399, "Member 'URProjectileMovementComponent::bBlockMovementTick' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, MaxSimulationTimeStep) == 0x00039C, "Member 'URProjectileMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, MaxSimulationIterations) == 0x0003A0, "Member 'URProjectileMovementComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, BounceAdditionalIterations) == 0x0003A4, "Member 'URProjectileMovementComponent::BounceAdditionalIterations' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, InterpLocationTime) == 0x0003A8, "Member 'URProjectileMovementComponent::InterpLocationTime' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, InterpRotationTime) == 0x0003AC, "Member 'URProjectileMovementComponent::InterpRotationTime' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, InterpLocationMaxLagDistance) == 0x0003B0, "Member 'URProjectileMovementComponent::InterpLocationMaxLagDistance' has a wrong offset!");
static_assert(offsetof(URProjectileMovementComponent, InterpLocationSnapToTargetDistance) == 0x0003B4, "Member 'URProjectileMovementComponent::InterpLocationSnapToTargetDistance' has a wrong offset!");

// Class RGame.RProjectileMutatorPrimaryAsset
// 0x0030 (0x0168 - 0x0138)
class URProjectileMutatorPrimaryAsset final : public URMutatorPrimaryAsset
{
public:
	TSoftClassPtr<class UClass>                   SoftProjectileMutatorScript;                       // 0x0138(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MutatorSpawnChance;                                // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySpawnOnFirstBulletPerFrame;                   // 0x0164(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RProjectileMutatorPrimaryAsset">();
	}
	static class URProjectileMutatorPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URProjectileMutatorPrimaryAsset>();
	}
};
static_assert(alignof(URProjectileMutatorPrimaryAsset) == 0x000008, "Wrong alignment on URProjectileMutatorPrimaryAsset");
static_assert(sizeof(URProjectileMutatorPrimaryAsset) == 0x000168, "Wrong size on URProjectileMutatorPrimaryAsset");
static_assert(offsetof(URProjectileMutatorPrimaryAsset, SoftProjectileMutatorScript) == 0x000138, "Member 'URProjectileMutatorPrimaryAsset::SoftProjectileMutatorScript' has a wrong offset!");
static_assert(offsetof(URProjectileMutatorPrimaryAsset, MutatorSpawnChance) == 0x000160, "Member 'URProjectileMutatorPrimaryAsset::MutatorSpawnChance' has a wrong offset!");
static_assert(offsetof(URProjectileMutatorPrimaryAsset, bOnlySpawnOnFirstBulletPerFrame) == 0x000164, "Member 'URProjectileMutatorPrimaryAsset::bOnlySpawnOnFirstBulletPerFrame' has a wrong offset!");

// Class RGame.RProjectileSpammerComponent
// 0x0018 (0x00B8 - 0x00A0)
class URProjectileSpammerComponent final : public UActorComponent
{
public:
	TSubclassOf<class ARProjectile>               ProjectileClass;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x4];                                       // 0x00A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WavesSpawned;                                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WavesToSpawn;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeBetweenWaves;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RProjectileSpammerComponent">();
	}
	static class URProjectileSpammerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URProjectileSpammerComponent>();
	}
};
static_assert(alignof(URProjectileSpammerComponent) == 0x000008, "Wrong alignment on URProjectileSpammerComponent");
static_assert(sizeof(URProjectileSpammerComponent) == 0x0000B8, "Wrong size on URProjectileSpammerComponent");
static_assert(offsetof(URProjectileSpammerComponent, ProjectileClass) == 0x0000A0, "Member 'URProjectileSpammerComponent::ProjectileClass' has a wrong offset!");
static_assert(offsetof(URProjectileSpammerComponent, WavesSpawned) == 0x0000AC, "Member 'URProjectileSpammerComponent::WavesSpawned' has a wrong offset!");
static_assert(offsetof(URProjectileSpammerComponent, WavesToSpawn) == 0x0000B0, "Member 'URProjectileSpammerComponent::WavesToSpawn' has a wrong offset!");
static_assert(offsetof(URProjectileSpammerComponent, TimeBetweenWaves) == 0x0000B4, "Member 'URProjectileSpammerComponent::TimeBetweenWaves' has a wrong offset!");

// Class RGame.RRadarManager
// 0x0010 (0x02B8 - 0x02A8)
class ARRadarManager final : public AActor
{
public:
	TArray<TWeakObjectPtr<class AActor>>          RadarObjects;                                      // 0x02A8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class ARRadarManager* GetRadarManager(const class UObject* WorldContextObject);

	void CleanupRadarObjectList();
	void RegisterRadarObject(class AActor* RadarObject);
	void UnregisterRadarObject(class AActor* ObjectToUnRegister);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRadarManager">();
	}
	static class ARRadarManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARRadarManager>();
	}
};
static_assert(alignof(ARRadarManager) == 0x000008, "Wrong alignment on ARRadarManager");
static_assert(sizeof(ARRadarManager) == 0x0002B8, "Wrong size on ARRadarManager");
static_assert(offsetof(ARRadarManager, RadarObjects) == 0x0002A8, "Member 'ARRadarManager::RadarObjects' has a wrong offset!");

// Class RGame.RRadarObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IRRadarObjectInterface final
{
public:
	struct FLinearColor GetRadarIconColor() const;
	struct FVector2D GetRadarIconSize() const;
	class USlateBrushAsset* GetRadarObjectIcon() const;
	bool ShouldShowOnRadar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRadarObjectInterface">();
	}
	static class IRRadarObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRRadarObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRRadarObjectInterface) == 0x000001, "Wrong alignment on IRRadarObjectInterface");
static_assert(sizeof(IRRadarObjectInterface) == 0x000001, "Wrong size on IRRadarObjectInterface");

// Class RGame.RRadarWidget
// 0x0120 (0x03F0 - 0x02D0)
class URRadarWidget : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadarUIRadius;                                     // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadarDistanceScale;                                // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightIndicatorThreshold;                          // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RadarCircleColor;                                  // 0x030C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RadarCircleFOVColor;                               // 0x031C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USlateBrushAsset*                       RadarIcon;                                         // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RadarIconSize;                                     // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RadarIconColor;                                    // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       PlayerIcon;                                        // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayerIconSize;                                    // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PlayerIconColor;                                   // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       EnemyIcon;                                         // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EnemyIconSize;                                     // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EnemyIconColor;                                    // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       RoomObjectiveIcon;                                 // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RoomObjectiveIconSize;                             // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RoomObjectiveIconColor;                            // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       HeightIndicatorUpIcon;                             // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       HeightIndicatorDownIcon;                           // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeightIndicatorIconSize;                           // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRadarWidget">();
	}
	static class URRadarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URRadarWidget>();
	}
};
static_assert(alignof(URRadarWidget) == 0x000008, "Wrong alignment on URRadarWidget");
static_assert(sizeof(URRadarWidget) == 0x0003F0, "Wrong size on URRadarWidget");
static_assert(offsetof(URRadarWidget, RadarUIRadius) == 0x000300, "Member 'URRadarWidget::RadarUIRadius' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RadarDistanceScale) == 0x000304, "Member 'URRadarWidget::RadarDistanceScale' has a wrong offset!");
static_assert(offsetof(URRadarWidget, HeightIndicatorThreshold) == 0x000308, "Member 'URRadarWidget::HeightIndicatorThreshold' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RadarCircleColor) == 0x00030C, "Member 'URRadarWidget::RadarCircleColor' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RadarCircleFOVColor) == 0x00031C, "Member 'URRadarWidget::RadarCircleFOVColor' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RadarIcon) == 0x000330, "Member 'URRadarWidget::RadarIcon' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RadarIconSize) == 0x000338, "Member 'URRadarWidget::RadarIconSize' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RadarIconColor) == 0x000348, "Member 'URRadarWidget::RadarIconColor' has a wrong offset!");
static_assert(offsetof(URRadarWidget, PlayerIcon) == 0x000358, "Member 'URRadarWidget::PlayerIcon' has a wrong offset!");
static_assert(offsetof(URRadarWidget, PlayerIconSize) == 0x000360, "Member 'URRadarWidget::PlayerIconSize' has a wrong offset!");
static_assert(offsetof(URRadarWidget, PlayerIconColor) == 0x000370, "Member 'URRadarWidget::PlayerIconColor' has a wrong offset!");
static_assert(offsetof(URRadarWidget, EnemyIcon) == 0x000380, "Member 'URRadarWidget::EnemyIcon' has a wrong offset!");
static_assert(offsetof(URRadarWidget, EnemyIconSize) == 0x000388, "Member 'URRadarWidget::EnemyIconSize' has a wrong offset!");
static_assert(offsetof(URRadarWidget, EnemyIconColor) == 0x000398, "Member 'URRadarWidget::EnemyIconColor' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RoomObjectiveIcon) == 0x0003A8, "Member 'URRadarWidget::RoomObjectiveIcon' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RoomObjectiveIconSize) == 0x0003B0, "Member 'URRadarWidget::RoomObjectiveIconSize' has a wrong offset!");
static_assert(offsetof(URRadarWidget, RoomObjectiveIconColor) == 0x0003C0, "Member 'URRadarWidget::RoomObjectiveIconColor' has a wrong offset!");
static_assert(offsetof(URRadarWidget, HeightIndicatorUpIcon) == 0x0003D0, "Member 'URRadarWidget::HeightIndicatorUpIcon' has a wrong offset!");
static_assert(offsetof(URRadarWidget, HeightIndicatorDownIcon) == 0x0003D8, "Member 'URRadarWidget::HeightIndicatorDownIcon' has a wrong offset!");
static_assert(offsetof(URRadarWidget, HeightIndicatorIconSize) == 0x0003E0, "Member 'URRadarWidget::HeightIndicatorIconSize' has a wrong offset!");

// Class RGame.RRelevancyInterface
// 0x0000 (0x0000 - 0x0000)
class IRRelevancyInterface final
{
public:
	void NativeOnRelevancyChanged(const struct FRRelevancyParams& ProximityParams);
	void ReceiveOnRelevancyChanged(const struct FRRelevancyParams& RelevancyParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRelevancyInterface">();
	}
	static class IRRelevancyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRRelevancyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRRelevancyInterface) == 0x000001, "Wrong alignment on IRRelevancyInterface");
static_assert(sizeof(IRRelevancyInterface) == 0x000001, "Wrong size on IRRelevancyInterface");

// Class RGame.RRelevancyManager
// 0x0030 (0x02D8 - 0x02A8)
class ARRelevancyManager final : public AActor
{
public:
	struct FRRelevancySettings                    RelevancySettings;                                 // 0x02A8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FRelevancyActor>                RelevancyActors;                                   // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRelevancyActor>                RelevancyActorsPendingRegister;                    // 0x02C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class FString DumpParams(const struct FRRelevancyParams& Params_0);
	static class ARRelevancyManager* GetRelevancyManager(const class UObject* WorldContextObject);
	static bool RegisterRelevancyActor(class AActor* Actor, const struct FRRelevancyRegisterParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRelevancyManager">();
	}
	static class ARRelevancyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARRelevancyManager>();
	}
};
static_assert(alignof(ARRelevancyManager) == 0x000008, "Wrong alignment on ARRelevancyManager");
static_assert(sizeof(ARRelevancyManager) == 0x0002D8, "Wrong size on ARRelevancyManager");
static_assert(offsetof(ARRelevancyManager, RelevancySettings) == 0x0002A8, "Member 'ARRelevancyManager::RelevancySettings' has a wrong offset!");
static_assert(offsetof(ARRelevancyManager, RelevancyActors) == 0x0002B8, "Member 'ARRelevancyManager::RelevancyActors' has a wrong offset!");
static_assert(offsetof(ARRelevancyManager, RelevancyActorsPendingRegister) == 0x0002C8, "Member 'ARRelevancyManager::RelevancyActorsPendingRegister' has a wrong offset!");

// Class RGame.RReplicatedLevelInstance
// 0x0090 (0x0338 - 0x02A8)
class ARReplicatedLevelInstance final : public AActor
{
public:
	class ULevelStreamingDynamic*                 StreamingLevel;                                    // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FReplicatedStreamingLevelInstanceInfo  StreamingLevelInstanceInfo;                        // 0x02B0(0x0068)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnBeginLoadClient;                                 // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEndLoadClient;                                   // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnAllLevelsUnloaded();
	void OnLevelLoaded();
	void OnRep_StreamingLevelInstanceInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RReplicatedLevelInstance">();
	}
	static class ARReplicatedLevelInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARReplicatedLevelInstance>();
	}
};
static_assert(alignof(ARReplicatedLevelInstance) == 0x000008, "Wrong alignment on ARReplicatedLevelInstance");
static_assert(sizeof(ARReplicatedLevelInstance) == 0x000338, "Wrong size on ARReplicatedLevelInstance");
static_assert(offsetof(ARReplicatedLevelInstance, StreamingLevel) == 0x0002A8, "Member 'ARReplicatedLevelInstance::StreamingLevel' has a wrong offset!");
static_assert(offsetof(ARReplicatedLevelInstance, StreamingLevelInstanceInfo) == 0x0002B0, "Member 'ARReplicatedLevelInstance::StreamingLevelInstanceInfo' has a wrong offset!");
static_assert(offsetof(ARReplicatedLevelInstance, OnBeginLoadClient) == 0x000318, "Member 'ARReplicatedLevelInstance::OnBeginLoadClient' has a wrong offset!");
static_assert(offsetof(ARReplicatedLevelInstance, OnEndLoadClient) == 0x000328, "Member 'ARReplicatedLevelInstance::OnEndLoadClient' has a wrong offset!");

// Class RGame.RResource
// 0x0008 (0x02B0 - 0x02A8)
class ARResource final : public AActor
{
public:
	float                                         ValueAmount;                                       // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetValueAmount(float newAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RResource">();
	}
	static class ARResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARResource>();
	}
};
static_assert(alignof(ARResource) == 0x000008, "Wrong alignment on ARResource");
static_assert(sizeof(ARResource) == 0x0002B0, "Wrong size on ARResource");
static_assert(offsetof(ARResource, ValueAmount) == 0x0002A8, "Member 'ARResource::ValueAmount' has a wrong offset!");

// Class RGame.RResourceProjectile
// 0x0070 (0x0318 - 0x02A8)
class ARResourceProjectile final : public AActor
{
public:
	uint8                                         Pad_2A8[0x38];                                     // 0x02A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereOverlapComponent;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResourceIncrementAmount;                           // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERResourceGatherType                          GatherType;                                        // 0x02F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FunnelSystemTemplate;                              // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopingSystem;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceFunnelAcceleration;                        // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceFunnelSpeed;                               // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceFunnelDistanceThreshold;                   // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceFunnelWaitTime;                            // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnResourcePickedUp(class ARPlayerPawn* PickedUpBy);
	void Pickup(class ARPlayerPawn* PickedUpBy);
	void SetResourceAmount(int32 Amount);
	void SetTargetPlayerPawn(class APawn* InPawn);

	class ARPlayerPawn* GetTargetPlayerPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RResourceProjectile">();
	}
	static class ARResourceProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARResourceProjectile>();
	}
};
static_assert(alignof(ARResourceProjectile) == 0x000008, "Wrong alignment on ARResourceProjectile");
static_assert(sizeof(ARResourceProjectile) == 0x000318, "Wrong size on ARResourceProjectile");
static_assert(offsetof(ARResourceProjectile, SphereOverlapComponent) == 0x0002E0, "Member 'ARResourceProjectile::SphereOverlapComponent' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, StaticMeshComponent) == 0x0002E8, "Member 'ARResourceProjectile::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, ResourceIncrementAmount) == 0x0002F0, "Member 'ARResourceProjectile::ResourceIncrementAmount' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, GatherType) == 0x0002F4, "Member 'ARResourceProjectile::GatherType' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, FunnelSystemTemplate) == 0x0002F8, "Member 'ARResourceProjectile::FunnelSystemTemplate' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, LoopingSystem) == 0x000300, "Member 'ARResourceProjectile::LoopingSystem' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, ResourceFunnelAcceleration) == 0x000308, "Member 'ARResourceProjectile::ResourceFunnelAcceleration' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, ResourceFunnelSpeed) == 0x00030C, "Member 'ARResourceProjectile::ResourceFunnelSpeed' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, ResourceFunnelDistanceThreshold) == 0x000310, "Member 'ARResourceProjectile::ResourceFunnelDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ARResourceProjectile, ResourceFunnelWaitTime) == 0x000314, "Member 'ARResourceProjectile::ResourceFunnelWaitTime' has a wrong offset!");

// Class RGame.RRewardTablePrimaryAsset
// 0x0010 (0x0080 - 0x0070)
class URRewardTablePrimaryAsset final : public URPrimaryDataAsset
{
public:
	class UDataTable*                             RewardTable;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RewardTableTypeTag;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRewardTablePrimaryAsset">();
	}
	static class URRewardTablePrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URRewardTablePrimaryAsset>();
	}
};
static_assert(alignof(URRewardTablePrimaryAsset) == 0x000008, "Wrong alignment on URRewardTablePrimaryAsset");
static_assert(sizeof(URRewardTablePrimaryAsset) == 0x000080, "Wrong size on URRewardTablePrimaryAsset");
static_assert(offsetof(URRewardTablePrimaryAsset, RewardTable) == 0x000070, "Member 'URRewardTablePrimaryAsset::RewardTable' has a wrong offset!");
static_assert(offsetof(URRewardTablePrimaryAsset, RewardTableTypeTag) == 0x000078, "Member 'URRewardTablePrimaryAsset::RewardTableTypeTag' has a wrong offset!");

// Class RGame.RRocket
// 0x0130 (0x06E8 - 0x05B8)
class ARRocket : public ARProjectileBase
{
public:
	float                                         BaseAreaOfEffectRadius;                            // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplosionTracesForObstacles;                      // 0x05BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeOnComponentHit;                            // 0x05BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeOnNPCPawnBaseHit;                          // 0x05BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunHitSequenceOnExplode;                          // 0x05BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToSubsequentExplosions;                        // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BouncesRemaining;                                  // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             RocketPrimaryHit;                                  // 0x05C8(0x0100)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class URGRocketScript>            RocketClass;                                       // 0x06C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URGRocketScript*                        RocketScript;                                      // 0x06D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnRocketBounced;                                   // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Explode();
	void SetBaseAreaOfEffectSize(float newBaseAreaOfEffectRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRocket">();
	}
	static class ARRocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARRocket>();
	}
};
static_assert(alignof(ARRocket) == 0x000008, "Wrong alignment on ARRocket");
static_assert(sizeof(ARRocket) == 0x0006E8, "Wrong size on ARRocket");
static_assert(offsetof(ARRocket, BaseAreaOfEffectRadius) == 0x0005B8, "Member 'ARRocket::BaseAreaOfEffectRadius' has a wrong offset!");
static_assert(offsetof(ARRocket, bExplosionTracesForObstacles) == 0x0005BC, "Member 'ARRocket::bExplosionTracesForObstacles' has a wrong offset!");
static_assert(offsetof(ARRocket, bExplodeOnComponentHit) == 0x0005BD, "Member 'ARRocket::bExplodeOnComponentHit' has a wrong offset!");
static_assert(offsetof(ARRocket, bExplodeOnNPCPawnBaseHit) == 0x0005BE, "Member 'ARRocket::bExplodeOnNPCPawnBaseHit' has a wrong offset!");
static_assert(offsetof(ARRocket, bRunHitSequenceOnExplode) == 0x0005BF, "Member 'ARRocket::bRunHitSequenceOnExplode' has a wrong offset!");
static_assert(offsetof(ARRocket, TimeToSubsequentExplosions) == 0x0005C0, "Member 'ARRocket::TimeToSubsequentExplosions' has a wrong offset!");
static_assert(offsetof(ARRocket, BouncesRemaining) == 0x0005C4, "Member 'ARRocket::BouncesRemaining' has a wrong offset!");
static_assert(offsetof(ARRocket, RocketPrimaryHit) == 0x0005C8, "Member 'ARRocket::RocketPrimaryHit' has a wrong offset!");
static_assert(offsetof(ARRocket, RocketClass) == 0x0006C8, "Member 'ARRocket::RocketClass' has a wrong offset!");
static_assert(offsetof(ARRocket, RocketScript) == 0x0006D0, "Member 'ARRocket::RocketScript' has a wrong offset!");
static_assert(offsetof(ARRocket, OnRocketBounced) == 0x0006D8, "Member 'ARRocket::OnRocketBounced' has a wrong offset!");

// Class RGame.RRoomObjectiveInterface
// 0x0000 (0x0000 - 0x0000)
class IRRoomObjectiveInterface final
{
public:
	float GetCompletionDecrementAmount() const;
	float GetCompletionIncrementAmount() const;
	float GetCurrentCompletionAmount() const;
	float GetRequiredCompletionAmount() const;
	bool IsObjectCompleted() const;
	void SetCurrentCompletionAmount(const float newAmount) const;
	void SetSharedCompletionAmount(const float newAmount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRoomObjectiveInterface">();
	}
	static class IRRoomObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRRoomObjectiveInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRRoomObjectiveInterface) == 0x000001, "Wrong alignment on IRRoomObjectiveInterface");
static_assert(sizeof(IRRoomObjectiveInterface) == 0x000001, "Wrong size on IRRoomObjectiveInterface");

// Class RGame.RRoomObjectiveObject
// 0x0098 (0x0340 - 0x02A8)
class ARRoomObjectiveObject : public AActor
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NativeSuperSelf;                                   // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredCompletionAmount;                          // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CompletionIncrementAmount;                         // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CompletionDecrementAmount;                         // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCompletionAmount;                           // 0x02D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsObjectCompleted;                                // 0x02D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRRoomObjectiveObjectProperties        RoomObjectiveObjectProperties;                     // 0x02F0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumCurrentCharges;                                 // 0x02F8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentChargeAmount;                               // 0x02FC(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeDuration;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CheckpointThresholds;                              // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CurrentCheckpointThreshold;                        // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRoomObjectiveObjectCompleted;                    // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float AmountCompleted, float AmountRequired)> OnRoomObjectiveObjectUpdated; // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CompleteObject();
	float GetChargeValueFromPlayers(const TArray<class AActor*>& PlayerActors);
	void OnIsObjectiveCompletedReplicated();
	void OnRep_IsObjectCompleted();

	void BroadcastOnRoomObjectiveObjectCompleted() const;
	void BroadcastOnRoomObjectiveObjectUpdated(const float AmountProgressed, const float AmountRequired) const;
	bool IsCurrentSegment(class AREnemySpawnAreaSegment* REnemySpawnAreaSegment) const;
	bool ShouldShowOnRadar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRoomObjectiveObject">();
	}
	static class ARRoomObjectiveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARRoomObjectiveObject>();
	}
};
static_assert(alignof(ARRoomObjectiveObject) == 0x000008, "Wrong alignment on ARRoomObjectiveObject");
static_assert(sizeof(ARRoomObjectiveObject) == 0x000340, "Wrong size on ARRoomObjectiveObject");
static_assert(offsetof(ARRoomObjectiveObject, NativeSuperSelf) == 0x0002C0, "Member 'ARRoomObjectiveObject::NativeSuperSelf' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, RequiredCompletionAmount) == 0x0002C8, "Member 'ARRoomObjectiveObject::RequiredCompletionAmount' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, CompletionIncrementAmount) == 0x0002CC, "Member 'ARRoomObjectiveObject::CompletionIncrementAmount' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, CompletionDecrementAmount) == 0x0002D0, "Member 'ARRoomObjectiveObject::CompletionDecrementAmount' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, CurrentCompletionAmount) == 0x0002D4, "Member 'ARRoomObjectiveObject::CurrentCompletionAmount' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, bIsObjectCompleted) == 0x0002D8, "Member 'ARRoomObjectiveObject::bIsObjectCompleted' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, SkeletalMesh) == 0x0002E0, "Member 'ARRoomObjectiveObject::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, StaticMesh) == 0x0002E8, "Member 'ARRoomObjectiveObject::StaticMesh' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, RoomObjectiveObjectProperties) == 0x0002F0, "Member 'ARRoomObjectiveObject::RoomObjectiveObjectProperties' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, NumCurrentCharges) == 0x0002F8, "Member 'ARRoomObjectiveObject::NumCurrentCharges' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, CurrentChargeAmount) == 0x0002FC, "Member 'ARRoomObjectiveObject::CurrentChargeAmount' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, ChargeDuration) == 0x000300, "Member 'ARRoomObjectiveObject::ChargeDuration' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, CheckpointThresholds) == 0x000308, "Member 'ARRoomObjectiveObject::CheckpointThresholds' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, CurrentCheckpointThreshold) == 0x000318, "Member 'ARRoomObjectiveObject::CurrentCheckpointThreshold' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, OnRoomObjectiveObjectCompleted) == 0x000320, "Member 'ARRoomObjectiveObject::OnRoomObjectiveObjectCompleted' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveObject, OnRoomObjectiveObjectUpdated) == 0x000330, "Member 'ARRoomObjectiveObject::OnRoomObjectiveObjectUpdated' has a wrong offset!");

// Class RGame.RRoomObjectivePawn
// 0x0040 (0x4828 - 0x47E8)
class ARRoomObjectivePawn final : public ARNPCPawnBase
{
public:
	uint8                                         Pad_47E8[0x8];                                     // 0x47E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AREnemySpawnAreaSegment*                AssociatedAreaSegment;                             // 0x47F0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x47F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ProgressedMessage;                                 // 0x4800(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CompletedMessage;                                  // 0x4810(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TargetHueShift;                                    // 0x4820(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyed;                                        // 0x4824(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4825[0x3];                                     // 0x4825(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableComponentVisuals();
	void DisableComponentVisuals_Multicast();
	void DisableDefaultInvulnerability_Multicast();
	int32 GetNumCompletedObjectiveObjects();
	int32 GetNumRemainingObjectiveObjects();
	void OnDestroyedReplicated();
	void OnHealthDepleted(class URHealthComponent* RHealthComponent, const struct FDamageCombatEvent& DamageCombatEvent);
	void OnObjectiveStarted(class URGObjectiveScript* ObjectiveScript);
	void OnRep_Destroyed();
	void OnSegmentCompleted(class AREnemySpawnAreaSegment* SegmentCompleted);
	void OnSegmentStarted(class AREnemySpawnAreaSegment* SegmentStarted);
	void OnSpawnedRoomObjectiveObject(class AREnemySpawnAreaSegment* SpawningSegment);
	void PushObjectiveProgressMessage_Multicast();
	void PushObjectiveProgressMessage_Server();
	void UpdateHealthVisuals(const float Health, const float HueShift);

	bool IsCurrentSegment(class AREnemySpawnAreaSegment* REnemySpawnAreaSegment) const;
	bool IsObjectCompleted() const;
	bool ShouldShowOnRadar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRoomObjectivePawn">();
	}
	static class ARRoomObjectivePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARRoomObjectivePawn>();
	}
};
static_assert(alignof(ARRoomObjectivePawn) == 0x000008, "Wrong alignment on ARRoomObjectivePawn");
static_assert(sizeof(ARRoomObjectivePawn) == 0x004828, "Wrong size on ARRoomObjectivePawn");
static_assert(offsetof(ARRoomObjectivePawn, AssociatedAreaSegment) == 0x0047F0, "Member 'ARRoomObjectivePawn::AssociatedAreaSegment' has a wrong offset!");
static_assert(offsetof(ARRoomObjectivePawn, StaticMesh) == 0x0047F8, "Member 'ARRoomObjectivePawn::StaticMesh' has a wrong offset!");
static_assert(offsetof(ARRoomObjectivePawn, ProgressedMessage) == 0x004800, "Member 'ARRoomObjectivePawn::ProgressedMessage' has a wrong offset!");
static_assert(offsetof(ARRoomObjectivePawn, CompletedMessage) == 0x004810, "Member 'ARRoomObjectivePawn::CompletedMessage' has a wrong offset!");
static_assert(offsetof(ARRoomObjectivePawn, TargetHueShift) == 0x004820, "Member 'ARRoomObjectivePawn::TargetHueShift' has a wrong offset!");
static_assert(offsetof(ARRoomObjectivePawn, bDestroyed) == 0x004824, "Member 'ARRoomObjectivePawn::bDestroyed' has a wrong offset!");

// Class RGame.RRoomObjectiveSpawnPoint
// 0x0020 (0x02C8 - 0x02A8)
class ARRoomObjectiveSpawnPoint final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x1];                                      // 0x02B0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ERoomObjectiveType                            RoomObjectiveType;                                 // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ObjectiveTag;                                      // 0x02B4(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     RoomObjectiveObjectTypeToSpawn;                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRoomObjectiveSpawnPoint">();
	}
	static class ARRoomObjectiveSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARRoomObjectiveSpawnPoint>();
	}
};
static_assert(alignof(ARRoomObjectiveSpawnPoint) == 0x000008, "Wrong alignment on ARRoomObjectiveSpawnPoint");
static_assert(sizeof(ARRoomObjectiveSpawnPoint) == 0x0002C8, "Wrong size on ARRoomObjectiveSpawnPoint");
static_assert(offsetof(ARRoomObjectiveSpawnPoint, SceneComponent) == 0x0002A8, "Member 'ARRoomObjectiveSpawnPoint::SceneComponent' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveSpawnPoint, RoomObjectiveType) == 0x0002B1, "Member 'ARRoomObjectiveSpawnPoint::RoomObjectiveType' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveSpawnPoint, ObjectiveTag) == 0x0002B4, "Member 'ARRoomObjectiveSpawnPoint::ObjectiveTag' has a wrong offset!");
static_assert(offsetof(ARRoomObjectiveSpawnPoint, RoomObjectiveObjectTypeToSpawn) == 0x0002C0, "Member 'ARRoomObjectiveSpawnPoint::RoomObjectiveObjectTypeToSpawn' has a wrong offset!");

// Class RGame.RRoutedObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IRRoutedObjectInterface final
{
public:
	void RunRoutedObjectBehaviour();
	void RunRoutedObjectBehaviourByName(class FName BehaviourName);
	void RunRoutedObjectBehaviourWithData(const struct FRoutedObjectData& RoutedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRoutedObjectInterface">();
	}
	static class IRRoutedObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRRoutedObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRRoutedObjectInterface) == 0x000001, "Wrong alignment on IRRoutedObjectInterface");
static_assert(sizeof(IRRoutedObjectInterface) == 0x000001, "Wrong size on IRRoutedObjectInterface");

// Class RGame.RRuntimeSettings
// 0x03E0 (0x0408 - 0x0028)
class URRuntimeSettings final : public UObject
{
public:
	bool                                          bIsPrereleaseBuild;                                // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDemoBuild;                                      // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinSaveGameCompatibleChangelist;                   // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              LightSettingsDataTable;                            // 0x0030(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              BadWordsDataTable;                                 // 0x0058(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CharacterMutatorSetTable;                          // 0x0080(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              WeaponDataTable;                                   // 0x00A8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataAsset>              DefaultMultiplayerSettings;                        // 0x00D0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataAsset>              DefaultAreaData;                                   // 0x00F8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              EnemySpawnDataTable;                               // 0x0120(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              EnemyGroupDataTable;                               // 0x0148(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              EnemyMutatorDataTable;                             // 0x0170(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              EnemyResourceDataTable;                            // 0x0198(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              MutatorScalingDataTable;                           // 0x01C0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              WeaponDropDataTable;                               // 0x01E8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARResourceProjectile>       ResourceProjectileClass;                           // 0x0210(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARResourceProjectile>       HealthProjectileClass;                             // 0x0218(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URHealthbarWidget>          EnemyHealthbarWidget;                              // 0x0220(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URHealthbarWidget>          BossHealthbarWidget;                               // 0x0228(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URPawnDownedWidget>         PawnDownedWidget;                                  // 0x0230(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GoldCoinActorClass;                                // 0x0238(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARSpectatorPawn>            SpectatorPawnClass;                                // 0x0260(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              HitEffectSurfaceTypeData;                          // 0x0268(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ProjectileImpactEffectDataTable;                   // 0x0290(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              PawnDamageTakenEffectDataTable;                    // 0x02B8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              EnemySpawnSound;                                   // 0x02E0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              HitSoundSurfaceTypeData;                           // 0x0308(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URFloatingTextSettings>  FloatingTextSettings;                              // 0x0330(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              KeywordsTable;                                     // 0x0358(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              KeyboardLayoutTable;                               // 0x0380(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      GlobalPreloadTables;                               // 0x03A8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      BoatyardPreloadTables;                             // 0x03B8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      GardensPreloadTables;                              // 0x03C8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      SanctuaryPreloadTables;                            // 0x03D8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      VoidPreloadTables;                                 // 0x03E8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      MutatorPreloadTables;                              // 0x03F8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static TArray<class UDataTable*> GetAreaPreloadTables(const class FName AreaName);
	static class UDataTable* GetCharacterMutatorSetTable();
	static class UDataAsset* GetDefaultAreaData();
	static class UDataAsset* GetDefaultMultiplayerSettings();
	static class UDataTable* GetEnemyGroupTable();
	static class UDataTable* GetEnemyMutatorTable();
	static class UDataTable* GetEnemyResourceTable();
	static class USoundBase* GetEnemySpawnSound();
	static class UDataTable* GetEnemySpawnTable();
	static class URFloatingTextSettings* GetFloatingTextSettings();
	static TArray<class UDataTable*> GetGlobalPreloadTables();
	static class UClass* GetGoldCoinActorClass();
	static class UDataTable* GetHitEffectSurfaceTypeData();
	static class UDataTable* GetHitSoundSurfaceTypeData();
	static bool GetIsDemoBuild();
	static bool GetIsPrereleaseBuild();
	static bool GetIsShippingBuild();
	static class UDataTable* GetKeyboardLayoutDataTable();
	static class UDataTable* GetKeywordsDataTable();
	static TArray<class UDataTable*> GetMutatorPreloadTables();
	static class UDataTable* GetMutatorScalingTable();
	static class UDataTable* GetPawnDamageTakenEffectDataTable();
	static class UDataTable* GetProjectileImpactEffectTable();
	static class UDataTable* GetWeaponDataTable();
	static class UDataTable* GetWeaponDropTable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RRuntimeSettings">();
	}
	static class URRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URRuntimeSettings>();
	}
};
static_assert(alignof(URRuntimeSettings) == 0x000008, "Wrong alignment on URRuntimeSettings");
static_assert(sizeof(URRuntimeSettings) == 0x000408, "Wrong size on URRuntimeSettings");
static_assert(offsetof(URRuntimeSettings, bIsPrereleaseBuild) == 0x000028, "Member 'URRuntimeSettings::bIsPrereleaseBuild' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, bIsDemoBuild) == 0x000029, "Member 'URRuntimeSettings::bIsDemoBuild' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, MinSaveGameCompatibleChangelist) == 0x00002C, "Member 'URRuntimeSettings::MinSaveGameCompatibleChangelist' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, LightSettingsDataTable) == 0x000030, "Member 'URRuntimeSettings::LightSettingsDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, BadWordsDataTable) == 0x000058, "Member 'URRuntimeSettings::BadWordsDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, CharacterMutatorSetTable) == 0x000080, "Member 'URRuntimeSettings::CharacterMutatorSetTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, WeaponDataTable) == 0x0000A8, "Member 'URRuntimeSettings::WeaponDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, DefaultMultiplayerSettings) == 0x0000D0, "Member 'URRuntimeSettings::DefaultMultiplayerSettings' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, DefaultAreaData) == 0x0000F8, "Member 'URRuntimeSettings::DefaultAreaData' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, EnemySpawnDataTable) == 0x000120, "Member 'URRuntimeSettings::EnemySpawnDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, EnemyGroupDataTable) == 0x000148, "Member 'URRuntimeSettings::EnemyGroupDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, EnemyMutatorDataTable) == 0x000170, "Member 'URRuntimeSettings::EnemyMutatorDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, EnemyResourceDataTable) == 0x000198, "Member 'URRuntimeSettings::EnemyResourceDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, MutatorScalingDataTable) == 0x0001C0, "Member 'URRuntimeSettings::MutatorScalingDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, WeaponDropDataTable) == 0x0001E8, "Member 'URRuntimeSettings::WeaponDropDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, ResourceProjectileClass) == 0x000210, "Member 'URRuntimeSettings::ResourceProjectileClass' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, HealthProjectileClass) == 0x000218, "Member 'URRuntimeSettings::HealthProjectileClass' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, EnemyHealthbarWidget) == 0x000220, "Member 'URRuntimeSettings::EnemyHealthbarWidget' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, BossHealthbarWidget) == 0x000228, "Member 'URRuntimeSettings::BossHealthbarWidget' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, PawnDownedWidget) == 0x000230, "Member 'URRuntimeSettings::PawnDownedWidget' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, GoldCoinActorClass) == 0x000238, "Member 'URRuntimeSettings::GoldCoinActorClass' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, SpectatorPawnClass) == 0x000260, "Member 'URRuntimeSettings::SpectatorPawnClass' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, HitEffectSurfaceTypeData) == 0x000268, "Member 'URRuntimeSettings::HitEffectSurfaceTypeData' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, ProjectileImpactEffectDataTable) == 0x000290, "Member 'URRuntimeSettings::ProjectileImpactEffectDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, PawnDamageTakenEffectDataTable) == 0x0002B8, "Member 'URRuntimeSettings::PawnDamageTakenEffectDataTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, EnemySpawnSound) == 0x0002E0, "Member 'URRuntimeSettings::EnemySpawnSound' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, HitSoundSurfaceTypeData) == 0x000308, "Member 'URRuntimeSettings::HitSoundSurfaceTypeData' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, FloatingTextSettings) == 0x000330, "Member 'URRuntimeSettings::FloatingTextSettings' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, KeywordsTable) == 0x000358, "Member 'URRuntimeSettings::KeywordsTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, KeyboardLayoutTable) == 0x000380, "Member 'URRuntimeSettings::KeyboardLayoutTable' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, GlobalPreloadTables) == 0x0003A8, "Member 'URRuntimeSettings::GlobalPreloadTables' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, BoatyardPreloadTables) == 0x0003B8, "Member 'URRuntimeSettings::BoatyardPreloadTables' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, GardensPreloadTables) == 0x0003C8, "Member 'URRuntimeSettings::GardensPreloadTables' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, SanctuaryPreloadTables) == 0x0003D8, "Member 'URRuntimeSettings::SanctuaryPreloadTables' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, VoidPreloadTables) == 0x0003E8, "Member 'URRuntimeSettings::VoidPreloadTables' has a wrong offset!");
static_assert(offsetof(URRuntimeSettings, MutatorPreloadTables) == 0x0003F8, "Member 'URRuntimeSettings::MutatorPreloadTables' has a wrong offset!");

// Class RGame.RSaveGame
// 0x05F0 (0x0618 - 0x0028)
class URSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreationChangelist;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRSaveGameData                         SaveGameData;                                      // 0x0050(0x05C8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void AddCompletedArea(const class FString& AreaName);
	void AddDifficultyPoints(int32 Amount);
	void AddNumTimesOpenedLogBook();
	void DecrementSoulFragments(int32 Amount);
	void GetEquippedLoadout(struct FRLoadout* Loadout, const class UObject* WorldContextObject);
	void GetLoadout(class URWeaponPrimaryAsset* Weapon, struct FRLoadout* Loadout, const class UObject* WorldContextObject);
	void IncrementSoulFragments(int32 Delta);
	bool IsLoadoutOptionUnlocked(class URPrimaryDataAsset* PrimaryAsset);
	void SetCosmeticLoadoutOption(const struct FPlayerCosmeticOption& CosmeticOption);
	void SetDemoDifficultyPointsCapped(const bool bNewValue);
	void SetEquippedLoadout(struct FRLoadout& Loadout);
	void SetHasEverSpentDifficultyPoints(const bool bNewValue);
	void SetHasSeenFirstDeathTutorial(bool bHasSeen);
	void SetHasSeenInitialTutorial(bool bHasSeen);
	void SetHasSeenWorkbenchFirstTime(bool bHasSeen);
	void SetHiddenCoinsFound(const class FString& Key, bool bFound);
	void SetIsDemoSaveGameData();
	void SetIsPrereleaseSaveGameData();
	void SetIsTutorialDone(bool bNewDone);
	void SetLatestSessionId(const class FString& LatestSessionId);
	void SetLoadout(struct FRLoadout& Loadout);
	void SetLoadoutSlot(class URWeaponPrimaryAsset* Weapon, ELoadoutSlot LoadoutSlot, class URPrimaryDataAsset* PrimaryAsset, const class UObject* WorldContextObject);
	void SetSkillTreeAssignedPoints(const class FName SkillKey, const int32 Points);
	void UnlockLoadoutOption(class URPrimaryDataAsset* PrimaryAsset);
	void UnlockWeaponModLoadoutOption(class URWeaponModPrimaryAsset* WeaponModPrimaryAsset);

	bool GetDemoDifficultyPointsCapped() const;
	int32 GetDifficultyTreeAssignedPoints(const class FName Key) const;
	int32 GetDifficultyTreeTotalAssignedPoints() const;
	bool GetHasEverSpentDifficultyPoints() const;
	bool GetIsTutorialDone() const;
	class FString GetLatestSessionId() const;
	int32 GetSkillTreeAssignedPoints(const class FName SkillKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSaveGame">();
	}
	static class URSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSaveGame>();
	}
};
static_assert(alignof(URSaveGame) == 0x000008, "Wrong alignment on URSaveGame");
static_assert(sizeof(URSaveGame) == 0x000618, "Wrong size on URSaveGame");
static_assert(offsetof(URSaveGame, SaveSlotName) == 0x000028, "Member 'URSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(URSaveGame, UserIndex) == 0x000038, "Member 'URSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(URSaveGame, Timestamp) == 0x000040, "Member 'URSaveGame::Timestamp' has a wrong offset!");
static_assert(offsetof(URSaveGame, CreationChangelist) == 0x000048, "Member 'URSaveGame::CreationChangelist' has a wrong offset!");
static_assert(offsetof(URSaveGame, SaveGameData) == 0x000050, "Member 'URSaveGame::SaveGameData' has a wrong offset!");

// Class RGame.RSaveGameManager
// 0x0000 (0x0028 - 0x0028)
class URSaveGameManager final : public UObject
{
public:
	static void ClearNonDemoSaveDataIfDemoBuild(const class UObject* WorldContextObject);
	static void ClearPrereleaseSaveData(const class UObject* WorldContextObject);
	static void ClearSaveGameSlotsIfInvalidChangelist(const class UObject* WorldContextObject);
	static class URSaveGame* CreateSaveGame(const class FString& SlotName);
	static void DeleteSaveSlot(const class FString& SlotName, const class UObject* WorldContextObject);
	static bool DoesSaveGameExist(const class FString& SlotName);
	static class URSaveGame* GetCurrentSaveGame(const class UObject* WorldContextObject);
	static int32 GetNumSavedRunStats(const class UObject* WorldContextObject);
	static int32 GetProjectVersionChangelist();
	static class URSaveGame* LoadGameFromSlot(const class FString& SlotName);
	static ERSavedGameResult QuickSave(const class UObject* WorldContextObject);
	static ERSavedGameResult SaveGameToSlot(const class UObject* WorldContextObject, const class FString& SlotName);
	static void SetCurrentSaveGame(const class UObject* WorldContextObject, class URSaveGame* SaveGame);
	static void SetCurrentSaveGameToLastSessionSaveGame(const class UObject* WorldContextObject);
	static void UpdateCreationChangelistIfDemoBuild(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSaveGameManager">();
	}
	static class URSaveGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSaveGameManager>();
	}
};
static_assert(alignof(URSaveGameManager) == 0x000008, "Wrong alignment on URSaveGameManager");
static_assert(sizeof(URSaveGameManager) == 0x000028, "Wrong size on URSaveGameManager");

// Class RGame.RSaveGameSession
// 0x0020 (0x0048 - 0x0028)
class URSaveGameSession final : public USaveGame
{
public:
	TArray<class FString>                         SaveGameSlots;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 LastSaveGameSlot;                                  // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class URSaveGameSession* GetLastSaveGameSession(const class UObject* WorldContextObject);

	void AddSaveGame(const class FString& SaveGameSlot);
	TArray<class URSaveGame*> GetAllSaveGames();
	class FString GetLastSaveGameSlot();
	void RemoveSaveGame(const class FString& SaveGameSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSaveGameSession">();
	}
	static class URSaveGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSaveGameSession>();
	}
};
static_assert(alignof(URSaveGameSession) == 0x000008, "Wrong alignment on URSaveGameSession");
static_assert(sizeof(URSaveGameSession) == 0x000048, "Wrong size on URSaveGameSession");
static_assert(offsetof(URSaveGameSession, SaveGameSlots) == 0x000028, "Member 'URSaveGameSession::SaveGameSlots' has a wrong offset!");
static_assert(offsetof(URSaveGameSession, LastSaveGameSlot) == 0x000038, "Member 'URSaveGameSession::LastSaveGameSlot' has a wrong offset!");

// Class RGame.RScalingCrosshair
// 0x0008 (0x0328 - 0x0320)
class URScalingCrosshair final : public URCrosshair
{
public:
	class UImage*                                 Crosshair;                                         // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RScalingCrosshair">();
	}
	static class URScalingCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<URScalingCrosshair>();
	}
};
static_assert(alignof(URScalingCrosshair) == 0x000008, "Wrong alignment on URScalingCrosshair");
static_assert(sizeof(URScalingCrosshair) == 0x000328, "Wrong size on URScalingCrosshair");
static_assert(offsetof(URScalingCrosshair, Crosshair) == 0x000320, "Member 'URScalingCrosshair::Crosshair' has a wrong offset!");

// Class RGame.RSettingTabWidget
// 0x0000 (0x02D0 - 0x02D0)
class URSettingTabWidget : public UUserWidget
{
public:
	void ApplySettings();
	class UWidget* GetDesiredFocusWidget();
	void ResetSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSettingTabWidget">();
	}
	static class URSettingTabWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSettingTabWidget>();
	}
};
static_assert(alignof(URSettingTabWidget) == 0x000008, "Wrong alignment on URSettingTabWidget");
static_assert(sizeof(URSettingTabWidget) == 0x0002D0, "Wrong size on URSettingTabWidget");

// Class RGame.RSkeletalMeshComponent
// 0x0000 (0x0F40 - 0x0F40)
class URSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSkeletalMeshComponent">();
	}
	static class URSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSkeletalMeshComponent>();
	}
};
static_assert(alignof(URSkeletalMeshComponent) == 0x000010, "Wrong alignment on URSkeletalMeshComponent");
static_assert(sizeof(URSkeletalMeshComponent) == 0x000F40, "Wrong size on URSkeletalMeshComponent");

// Class RGame.RSkillTreeCategoryPrimaryAsset
// 0x0020 (0x0090 - 0x0070)
class URSkillTreeCategoryPrimaryAsset final : public URPrimaryDataAsset
{
public:
	int32                                         NumPointsRequiredInPreviousTiers;                  // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkillTreeNodes>                SkillTreeNodes;                                    // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SlotPosition;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSkillTreeCategoryPrimaryAsset">();
	}
	static class URSkillTreeCategoryPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSkillTreeCategoryPrimaryAsset>();
	}
};
static_assert(alignof(URSkillTreeCategoryPrimaryAsset) == 0x000008, "Wrong alignment on URSkillTreeCategoryPrimaryAsset");
static_assert(sizeof(URSkillTreeCategoryPrimaryAsset) == 0x000090, "Wrong size on URSkillTreeCategoryPrimaryAsset");
static_assert(offsetof(URSkillTreeCategoryPrimaryAsset, NumPointsRequiredInPreviousTiers) == 0x000070, "Member 'URSkillTreeCategoryPrimaryAsset::NumPointsRequiredInPreviousTiers' has a wrong offset!");
static_assert(offsetof(URSkillTreeCategoryPrimaryAsset, SkillTreeNodes) == 0x000078, "Member 'URSkillTreeCategoryPrimaryAsset::SkillTreeNodes' has a wrong offset!");
static_assert(offsetof(URSkillTreeCategoryPrimaryAsset, SlotPosition) == 0x000088, "Member 'URSkillTreeCategoryPrimaryAsset::SlotPosition' has a wrong offset!");

// Class RGame.RSouvenirBase
// 0x0008 (0x02B0 - 0x02A8)
class ARSouvenirBase final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSouvenirBase">();
	}
	static class ARSouvenirBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSouvenirBase>();
	}
};
static_assert(alignof(ARSouvenirBase) == 0x000008, "Wrong alignment on ARSouvenirBase");
static_assert(sizeof(ARSouvenirBase) == 0x0002B0, "Wrong size on ARSouvenirBase");

// Class RGame.RSpacerCrosshair
// 0x0020 (0x0340 - 0x0320)
class URSpacerCrosshair : public URCrosshair
{
public:
	class UImage*                                 Top;                                               // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Bottom;                                            // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Left;                                              // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Right;                                             // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSpacerCrosshair">();
	}
	static class URSpacerCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSpacerCrosshair>();
	}
};
static_assert(alignof(URSpacerCrosshair) == 0x000008, "Wrong alignment on URSpacerCrosshair");
static_assert(sizeof(URSpacerCrosshair) == 0x000340, "Wrong size on URSpacerCrosshair");
static_assert(offsetof(URSpacerCrosshair, Top) == 0x000320, "Member 'URSpacerCrosshair::Top' has a wrong offset!");
static_assert(offsetof(URSpacerCrosshair, Bottom) == 0x000328, "Member 'URSpacerCrosshair::Bottom' has a wrong offset!");
static_assert(offsetof(URSpacerCrosshair, Left) == 0x000330, "Member 'URSpacerCrosshair::Left' has a wrong offset!");
static_assert(offsetof(URSpacerCrosshair, Right) == 0x000338, "Member 'URSpacerCrosshair::Right' has a wrong offset!");

// Class RGame.RSpectateHud
// 0x0018 (0x02E8 - 0x02D0)
class URSpectateHud final : public UUserWidget
{
public:
	class UCanvasPanel*                           Canvas;                                            // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ARPlayerPawn* NewSpectatedPlayer)> OnSpectatedPlayerChangedDelegate; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnSpectatedPlayerChanged(class ARPlayerPawn* NewSpectatedPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSpectateHud">();
	}
	static class URSpectateHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSpectateHud>();
	}
};
static_assert(alignof(URSpectateHud) == 0x000008, "Wrong alignment on URSpectateHud");
static_assert(sizeof(URSpectateHud) == 0x0002E8, "Wrong size on URSpectateHud");
static_assert(offsetof(URSpectateHud, Canvas) == 0x0002D0, "Member 'URSpectateHud::Canvas' has a wrong offset!");
static_assert(offsetof(URSpectateHud, OnSpectatedPlayerChangedDelegate) == 0x0002D8, "Member 'URSpectateHud::OnSpectatedPlayerChangedDelegate' has a wrong offset!");

// Class RGame.RSpectatorPawn
// 0x0088 (0x03B0 - 0x0328)
class ARSpectatorPawn : public APawn
{
public:
	class ARPlayerPawn*                           CurrentlySpectatingPawn;                           // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRootComponent;                                // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CameraComponent;                                   // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UInputAction>            SpectateNextInput;                                 // 0x0360(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            SpectatePreviousInput;                             // 0x0388(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnPlayerPawnKilled(class ARPlayerPawn* PlayerPawn);
	void OnPlayerPawnRevived(class ARPlayerPawn* PlayerPawn);
	void OnSpectatedPlayerChanged(class ARPlayerPawn* NewSpectatedPlayer);
	void SpectateNextPlayer();
	void SpectatePreviousPlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSpectatorPawn">();
	}
	static class ARSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSpectatorPawn>();
	}
};
static_assert(alignof(ARSpectatorPawn) == 0x000008, "Wrong alignment on ARSpectatorPawn");
static_assert(sizeof(ARSpectatorPawn) == 0x0003B0, "Wrong size on ARSpectatorPawn");
static_assert(offsetof(ARSpectatorPawn, CurrentlySpectatingPawn) == 0x000328, "Member 'ARSpectatorPawn::CurrentlySpectatingPawn' has a wrong offset!");
static_assert(offsetof(ARSpectatorPawn, SceneRootComponent) == 0x000348, "Member 'ARSpectatorPawn::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(ARSpectatorPawn, SpringArmComponent) == 0x000350, "Member 'ARSpectatorPawn::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ARSpectatorPawn, CameraComponent) == 0x000358, "Member 'ARSpectatorPawn::CameraComponent' has a wrong offset!");
static_assert(offsetof(ARSpectatorPawn, SpectateNextInput) == 0x000360, "Member 'ARSpectatorPawn::SpectateNextInput' has a wrong offset!");
static_assert(offsetof(ARSpectatorPawn, SpectatePreviousInput) == 0x000388, "Member 'ARSpectatorPawn::SpectatePreviousInput' has a wrong offset!");

// Class RGame.RStaticMeshComponent
// 0x0000 (0x05C0 - 0x05C0)
class URStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RStaticMeshComponent">();
	}
	static class URStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URStaticMeshComponent>();
	}
};
static_assert(alignof(URStaticMeshComponent) == 0x000010, "Wrong alignment on URStaticMeshComponent");
static_assert(sizeof(URStaticMeshComponent) == 0x0005C0, "Wrong size on URStaticMeshComponent");

// Class RGame.RStatTracker
// 0x0000 (0x02A8 - 0x02A8)
class ARStatTracker final : public AActor
{
public:
	static class ARStatTracker* GetStatTracker(const class UObject* WorldContextObject);

	void SaveLogToFile(TArray<class FString>& lines, const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RStatTracker">();
	}
	static class ARStatTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARStatTracker>();
	}
};
static_assert(alignof(ARStatTracker) == 0x000008, "Wrong alignment on ARStatTracker");
static_assert(sizeof(ARStatTracker) == 0x0002A8, "Wrong size on ARStatTracker");

// Class RGame.RStringLibrary
// 0x0000 (0x0028 - 0x0028)
class URStringLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText FilterBadWords(const class FText& InText);
	static class FText ParseDescriptionWithVariable(const class FText& InText, const struct FDescriptionVariable& DescriptionVariable);
	static class FText ParseDescriptionWithVariables(const class FText& InText, const TArray<struct FDescriptionVariable>& DescriptionVariables);
	static bool TextContainsBadWord(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RStringLibrary">();
	}
	static class URStringLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URStringLibrary>();
	}
};
static_assert(alignof(URStringLibrary) == 0x000008, "Wrong alignment on URStringLibrary");
static_assert(sizeof(URStringLibrary) == 0x000028, "Wrong size on URStringLibrary");

// Class RGame.RSubCrosshair
// 0x0020 (0x02F0 - 0x02D0)
class URSubCrosshair final : public UUserWidget
{
public:
	class UImage*                                 SubCrosshairImage;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetValue;                                       // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentValue;                                      // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetSpeed;                                       // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetParameterName;                               // 0x02E4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicCrosshairMaterial();
	void UpdateTarget(class FName PropertyName, float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSubCrosshair">();
	}
	static class URSubCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSubCrosshair>();
	}
};
static_assert(alignof(URSubCrosshair) == 0x000008, "Wrong alignment on URSubCrosshair");
static_assert(sizeof(URSubCrosshair) == 0x0002F0, "Wrong size on URSubCrosshair");
static_assert(offsetof(URSubCrosshair, SubCrosshairImage) == 0x0002D0, "Member 'URSubCrosshair::SubCrosshairImage' has a wrong offset!");
static_assert(offsetof(URSubCrosshair, TargetValue) == 0x0002D8, "Member 'URSubCrosshair::TargetValue' has a wrong offset!");
static_assert(offsetof(URSubCrosshair, CurrentValue) == 0x0002DC, "Member 'URSubCrosshair::CurrentValue' has a wrong offset!");
static_assert(offsetof(URSubCrosshair, TargetSpeed) == 0x0002E0, "Member 'URSubCrosshair::TargetSpeed' has a wrong offset!");
static_assert(offsetof(URSubCrosshair, TargetParameterName) == 0x0002E4, "Member 'URSubCrosshair::TargetParameterName' has a wrong offset!");

// Class RGame.RTargetDummy
// 0x0020 (0x02C8 - 0x02A8)
class ARTargetDummy final : public AActor
{
public:
	bool                                          bFinished;                                         // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DPS;                                               // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARPlayerPawn*                           ShootingPawn;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTestCompleted;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTargetDummy">();
	}
	static class ARTargetDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARTargetDummy>();
	}
};
static_assert(alignof(ARTargetDummy) == 0x000008, "Wrong alignment on ARTargetDummy");
static_assert(sizeof(ARTargetDummy) == 0x0002C8, "Wrong size on ARTargetDummy");
static_assert(offsetof(ARTargetDummy, bFinished) == 0x0002A8, "Member 'ARTargetDummy::bFinished' has a wrong offset!");
static_assert(offsetof(ARTargetDummy, DPS) == 0x0002AC, "Member 'ARTargetDummy::DPS' has a wrong offset!");
static_assert(offsetof(ARTargetDummy, ShootingPawn) == 0x0002B0, "Member 'ARTargetDummy::ShootingPawn' has a wrong offset!");
static_assert(offsetof(ARTargetDummy, OnTestCompleted) == 0x0002B8, "Member 'ARTargetDummy::OnTestCompleted' has a wrong offset!");

// Class RGame.RTelemetryManager
// 0x01C0 (0x0468 - 0x02A8)
class ARTelemetryManager final : public AActor
{
public:
	class FString                                 TitleId;                                           // 0x02A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableDebugLogging;                               // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x27];                                     // 0x02B9(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TeamID;                                            // 0x02E0(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CommonRunId;                                       // 0x02F0(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSendDataFromEditorMode;                           // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumLogBookTime;                                // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInLoadingScreen;                                  // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageDealtInEncounter;                            // 0x031C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDamageSource, float>                    DamageDealtInEncounterMap;                         // 0x0320(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EDamageSource, float>                    DamageDealtTotalMap;                               // 0x0370(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         DamageTakenInEncounter;                            // 0x03C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    DamageTakenInEncounterMap;                         // 0x03C8(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         FightStartTime;                                    // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NodeStartTime;                                     // 0x041C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoadingScreenStartTime;                            // 0x0420(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LogbookStartTime;                                  // 0x0424(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutsideEncounterStartTime;                         // 0x0428(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutsideEncounterTotalTime;                         // 0x042C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerHasEnteredEncounter;                        // 0x0430(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LobbyStartTime;                                    // 0x0434(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorkbenchStartTime;                                // 0x0438(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorkbenchTotalTime;                                // 0x043C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumHealUsagesInNode;                               // 0x0440(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumRevivesInNode;                                  // 0x0444(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         InteractablesInNode;                               // 0x0448(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         FoundInteractablesInNode;                          // 0x0458(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddFoundInteractableInNode(class AActor* FoundInteractableActor);
	void AddInteractableInNode(class AActor* InteractableActor);
	TArray<EDamageSource> ConvertBitmaskToEnumAsByte(int32 BitMask);
	void OnAllowTelemetryDataCollectionUpdated(const bool bNewValue);
	void PerformLogin();
	void ResetDamageDealtAndTakenInEncounter();
	void WriteOnChallengeCompleted(const struct FRChallenge& RChallenge);
	void WriteOnDeath(const struct FDamageCombatEvent& DamageCombatEvent);
	void WriteOnFightEnd(const bool bWasObjective, const class FString& RoomObjectiveType, const int32 NumMeleeUsages, const bool bIsEndBoss);
	void WriteOnLoadingScreen();
	void WriteOnLobbyEnd();
	void WriteOnLogBookUsed();
	void WriteOnPickupGodMutator(const class FString& ChosenGodCategoryName, const TArray<class FString>& DiscardedGodCategoryNames, const class FString& ChosenGodMutatorName, const TArray<class FString>& DiscardedGodMutatorNames);
	void WriteOnPurchase(const class FString& PurchasedItemName, const int32 PurchasedItemCost, const TArray<class AActor*>& NotPurchasedItems);
	void WriteOnRoomEnd();
	void WriteOnRunEnded(const bool bCurrentRunSuccesful);
	void WriteOnRunEnded_Multicast(const bool bCurrentRunSuccesful);

	class FString GetInstigatorDisplayName(class AActor* InstigatorActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTelemetryManager">();
	}
	static class ARTelemetryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARTelemetryManager>();
	}
};
static_assert(alignof(ARTelemetryManager) == 0x000008, "Wrong alignment on ARTelemetryManager");
static_assert(sizeof(ARTelemetryManager) == 0x000468, "Wrong size on ARTelemetryManager");
static_assert(offsetof(ARTelemetryManager, TitleId) == 0x0002A8, "Member 'ARTelemetryManager::TitleId' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, bEnableDebugLogging) == 0x0002B8, "Member 'ARTelemetryManager::bEnableDebugLogging' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, TeamID) == 0x0002E0, "Member 'ARTelemetryManager::TeamID' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, CommonRunId) == 0x0002F0, "Member 'ARTelemetryManager::CommonRunId' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, bSendDataFromEditorMode) == 0x000310, "Member 'ARTelemetryManager::bSendDataFromEditorMode' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, MinimumLogBookTime) == 0x000314, "Member 'ARTelemetryManager::MinimumLogBookTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, bInLoadingScreen) == 0x000318, "Member 'ARTelemetryManager::bInLoadingScreen' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, DamageDealtInEncounter) == 0x00031C, "Member 'ARTelemetryManager::DamageDealtInEncounter' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, DamageDealtInEncounterMap) == 0x000320, "Member 'ARTelemetryManager::DamageDealtInEncounterMap' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, DamageDealtTotalMap) == 0x000370, "Member 'ARTelemetryManager::DamageDealtTotalMap' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, DamageTakenInEncounter) == 0x0003C0, "Member 'ARTelemetryManager::DamageTakenInEncounter' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, DamageTakenInEncounterMap) == 0x0003C8, "Member 'ARTelemetryManager::DamageTakenInEncounterMap' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, FightStartTime) == 0x000418, "Member 'ARTelemetryManager::FightStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, NodeStartTime) == 0x00041C, "Member 'ARTelemetryManager::NodeStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, LoadingScreenStartTime) == 0x000420, "Member 'ARTelemetryManager::LoadingScreenStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, LogbookStartTime) == 0x000424, "Member 'ARTelemetryManager::LogbookStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, OutsideEncounterStartTime) == 0x000428, "Member 'ARTelemetryManager::OutsideEncounterStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, OutsideEncounterTotalTime) == 0x00042C, "Member 'ARTelemetryManager::OutsideEncounterTotalTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, bPlayerHasEnteredEncounter) == 0x000430, "Member 'ARTelemetryManager::bPlayerHasEnteredEncounter' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, LobbyStartTime) == 0x000434, "Member 'ARTelemetryManager::LobbyStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, WorkbenchStartTime) == 0x000438, "Member 'ARTelemetryManager::WorkbenchStartTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, WorkbenchTotalTime) == 0x00043C, "Member 'ARTelemetryManager::WorkbenchTotalTime' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, NumHealUsagesInNode) == 0x000440, "Member 'ARTelemetryManager::NumHealUsagesInNode' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, NumRevivesInNode) == 0x000444, "Member 'ARTelemetryManager::NumRevivesInNode' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, InteractablesInNode) == 0x000448, "Member 'ARTelemetryManager::InteractablesInNode' has a wrong offset!");
static_assert(offsetof(ARTelemetryManager, FoundInteractablesInNode) == 0x000458, "Member 'ARTelemetryManager::FoundInteractablesInNode' has a wrong offset!");

// Class RGame.RTempCharacter
// 0x0030 (0x0680 - 0x0650)
class ARTempCharacter final : public ACharacter
{
public:
	uint8                                         Pad_650[0x30];                                     // 0x0650(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRecoil(const struct FRotator& Recoil);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTempCharacter">();
	}
	static class ARTempCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARTempCharacter>();
	}
};
static_assert(alignof(ARTempCharacter) == 0x000010, "Wrong alignment on ARTempCharacter");
static_assert(sizeof(ARTempCharacter) == 0x000680, "Wrong size on ARTempCharacter");

// Class RGame.RTeslaGunLightningOrbScript
// 0x0058 (0x0160 - 0x0108)
class URTeslaGunLightningOrbScript final : public URGDefaultProjectileScript
{
public:
	class UNiagaraSystem*                         ZapEnemyVFX;                                       // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZapEnemyVFXStartPointParam;                        // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZapEnemyVFXEndPointParam;                          // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZapEnemyVFXSizeParam;                              // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZapEnemyVFXHueShiftParam;                          // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             LightningOrbHitSound;                              // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZapDamageSources;                                  // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URMutatorPrimaryAsset*                  HighVoltageMutatorPA;                              // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URStatusEffectGScript>      HighVoltageStatusEffectClass;                      // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         NativeZappedEnemies;                               // 0x0150(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void NativeCheckForChallengeProgression();
	bool NativeCheckHighVoltage();
	void NativeZapEnemy(class AActor* EnemyActor, const struct FVector& ZapOrigin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTeslaGunLightningOrbScript">();
	}
	static class URTeslaGunLightningOrbScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URTeslaGunLightningOrbScript>();
	}
};
static_assert(alignof(URTeslaGunLightningOrbScript) == 0x000008, "Wrong alignment on URTeslaGunLightningOrbScript");
static_assert(sizeof(URTeslaGunLightningOrbScript) == 0x000160, "Wrong size on URTeslaGunLightningOrbScript");
static_assert(offsetof(URTeslaGunLightningOrbScript, ZapEnemyVFX) == 0x000108, "Member 'URTeslaGunLightningOrbScript::ZapEnemyVFX' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, ZapEnemyVFXStartPointParam) == 0x000110, "Member 'URTeslaGunLightningOrbScript::ZapEnemyVFXStartPointParam' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, ZapEnemyVFXEndPointParam) == 0x000118, "Member 'URTeslaGunLightningOrbScript::ZapEnemyVFXEndPointParam' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, ZapEnemyVFXSizeParam) == 0x000120, "Member 'URTeslaGunLightningOrbScript::ZapEnemyVFXSizeParam' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, ZapEnemyVFXHueShiftParam) == 0x000128, "Member 'URTeslaGunLightningOrbScript::ZapEnemyVFXHueShiftParam' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, LightningOrbHitSound) == 0x000130, "Member 'URTeslaGunLightningOrbScript::LightningOrbHitSound' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, ZapDamageSources) == 0x000138, "Member 'URTeslaGunLightningOrbScript::ZapDamageSources' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, HighVoltageMutatorPA) == 0x000140, "Member 'URTeslaGunLightningOrbScript::HighVoltageMutatorPA' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, HighVoltageStatusEffectClass) == 0x000148, "Member 'URTeslaGunLightningOrbScript::HighVoltageStatusEffectClass' has a wrong offset!");
static_assert(offsetof(URTeslaGunLightningOrbScript, NativeZappedEnemies) == 0x000150, "Member 'URTeslaGunLightningOrbScript::NativeZappedEnemies' has a wrong offset!");

// Class RGame.RTotemDataPrimaryAsset
// 0x0008 (0x0078 - 0x0070)
class URTotemDataPrimaryAsset final : public URPrimaryDataAsset
{
public:
	class UDataTable*                             TotemTable;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTotemDataPrimaryAsset">();
	}
	static class URTotemDataPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URTotemDataPrimaryAsset>();
	}
};
static_assert(alignof(URTotemDataPrimaryAsset) == 0x000008, "Wrong alignment on URTotemDataPrimaryAsset");
static_assert(sizeof(URTotemDataPrimaryAsset) == 0x000078, "Wrong size on URTotemDataPrimaryAsset");
static_assert(offsetof(URTotemDataPrimaryAsset, TotemTable) == 0x000070, "Member 'URTotemDataPrimaryAsset::TotemTable' has a wrong offset!");

// Class RGame.RTotemTablePrimaryAsset
// 0x0008 (0x0078 - 0x0070)
class URTotemTablePrimaryAsset final : public URPrimaryDataAsset
{
public:
	class UDataTable*                             TotemTable;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTotemTablePrimaryAsset">();
	}
	static class URTotemTablePrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URTotemTablePrimaryAsset>();
	}
};
static_assert(alignof(URTotemTablePrimaryAsset) == 0x000008, "Wrong alignment on URTotemTablePrimaryAsset");
static_assert(sizeof(URTotemTablePrimaryAsset) == 0x000078, "Wrong size on URTotemTablePrimaryAsset");
static_assert(offsetof(URTotemTablePrimaryAsset, TotemTable) == 0x000070, "Member 'URTotemTablePrimaryAsset::TotemTable' has a wrong offset!");

// Class RGame.RTriggerMutatorScript
// 0x0048 (0x0150 - 0x0108)
class URTriggerMutatorScript final : public URGCharacterMutatorScript
{
public:
	TSoftObjectPtr<class URCharacterMutatorPrimaryAsset> SoftMutatorPA;                              // 0x0108(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URCharacterMutatorPrimaryAsset*> CachedBehaviorMutators;                            // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class URPlayerGScriptComponent*               CachedPlayerGScriptComponent;                      // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDamageSource                                 TriggerDamageSourceType;                           // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDealtDamageEvent(class ARPawnBase* RPawnBase, const struct FDamageCombatEvent& DamageEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTriggerMutatorScript">();
	}
	static class URTriggerMutatorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<URTriggerMutatorScript>();
	}
};
static_assert(alignof(URTriggerMutatorScript) == 0x000008, "Wrong alignment on URTriggerMutatorScript");
static_assert(sizeof(URTriggerMutatorScript) == 0x000150, "Wrong size on URTriggerMutatorScript");
static_assert(offsetof(URTriggerMutatorScript, SoftMutatorPA) == 0x000108, "Member 'URTriggerMutatorScript::SoftMutatorPA' has a wrong offset!");
static_assert(offsetof(URTriggerMutatorScript, CachedBehaviorMutators) == 0x000130, "Member 'URTriggerMutatorScript::CachedBehaviorMutators' has a wrong offset!");
static_assert(offsetof(URTriggerMutatorScript, CachedPlayerGScriptComponent) == 0x000140, "Member 'URTriggerMutatorScript::CachedPlayerGScriptComponent' has a wrong offset!");
static_assert(offsetof(URTriggerMutatorScript, TriggerDamageSourceType) == 0x000148, "Member 'URTriggerMutatorScript::TriggerDamageSourceType' has a wrong offset!");

// Class RGame.RGameOverScreenStatContainer
// 0x0028 (0x0050 - 0x0028)
class URGameOverScreenStatContainer final : public UObject
{
public:
	class FText                                   StatName;                                          // 0x0028(0x0010)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   StatValue;                                         // 0x0038(0x0010)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class UTexture2D*                             StatIcon;                                          // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RGameOverScreenStatContainer">();
	}
	static class URGameOverScreenStatContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URGameOverScreenStatContainer>();
	}
};
static_assert(alignof(URGameOverScreenStatContainer) == 0x000008, "Wrong alignment on URGameOverScreenStatContainer");
static_assert(sizeof(URGameOverScreenStatContainer) == 0x000050, "Wrong size on URGameOverScreenStatContainer");
static_assert(offsetof(URGameOverScreenStatContainer, StatName) == 0x000028, "Member 'URGameOverScreenStatContainer::StatName' has a wrong offset!");
static_assert(offsetof(URGameOverScreenStatContainer, StatValue) == 0x000038, "Member 'URGameOverScreenStatContainer::StatValue' has a wrong offset!");
static_assert(offsetof(URGameOverScreenStatContainer, StatIcon) == 0x000048, "Member 'URGameOverScreenStatContainer::StatIcon' has a wrong offset!");

// Class RGame.RSessionInfoContainer
// 0x0120 (0x0148 - 0x0028)
class URSessionInfoContainer final : public UObject
{
public:
	struct FBlueprintSessionResult                SessionInfo;                                       // 0x0028(0x0120)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSessionInfoContainer">();
	}
	static class URSessionInfoContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSessionInfoContainer>();
	}
};
static_assert(alignof(URSessionInfoContainer) == 0x000008, "Wrong alignment on URSessionInfoContainer");
static_assert(sizeof(URSessionInfoContainer) == 0x000148, "Wrong size on URSessionInfoContainer");
static_assert(offsetof(URSessionInfoContainer, SessionInfo) == 0x000028, "Member 'URSessionInfoContainer::SessionInfo' has a wrong offset!");

// Class RGame.RMultiplayerData
// 0x0020 (0x0050 - 0x0030)
class URMultiplayerData final : public UDataAsset
{
public:
	TArray<struct FLinearColor>                   PlayerSlotColors;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    PlayerSlotHelmets;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMultiplayerData">();
	}
	static class URMultiplayerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMultiplayerData>();
	}
};
static_assert(alignof(URMultiplayerData) == 0x000008, "Wrong alignment on URMultiplayerData");
static_assert(sizeof(URMultiplayerData) == 0x000050, "Wrong size on URMultiplayerData");
static_assert(offsetof(URMultiplayerData, PlayerSlotColors) == 0x000030, "Member 'URMultiplayerData::PlayerSlotColors' has a wrong offset!");
static_assert(offsetof(URMultiplayerData, PlayerSlotHelmets) == 0x000040, "Member 'URMultiplayerData::PlayerSlotHelmets' has a wrong offset!");

// Class RGame.RMutatorRewardCategoryDataAsset
// 0x0060 (0x00D0 - 0x0070)
class URMutatorRewardCategoryDataAsset final : public URPrimaryDataAsset
{
public:
	struct FGameplayTag                           MutatorRewardCategoryTag;                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRGodBonusMutatorRequirement>   GodBonusMutators;                                  // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CategorySymbol;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HoverMaterial;                                     // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconTint;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_0;                                            // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutatorRewardCategoryDataAsset">();
	}
	static class URMutatorRewardCategoryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutatorRewardCategoryDataAsset>();
	}
};
static_assert(alignof(URMutatorRewardCategoryDataAsset) == 0x000008, "Wrong alignment on URMutatorRewardCategoryDataAsset");
static_assert(sizeof(URMutatorRewardCategoryDataAsset) == 0x0000D0, "Wrong size on URMutatorRewardCategoryDataAsset");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, MutatorRewardCategoryTag) == 0x000070, "Member 'URMutatorRewardCategoryDataAsset::MutatorRewardCategoryTag' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, GodBonusMutators) == 0x000078, "Member 'URMutatorRewardCategoryDataAsset::GodBonusMutators' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, Icon) == 0x000088, "Member 'URMutatorRewardCategoryDataAsset::Icon' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, CategorySymbol) == 0x000090, "Member 'URMutatorRewardCategoryDataAsset::CategorySymbol' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, HoverMaterial) == 0x000098, "Member 'URMutatorRewardCategoryDataAsset::HoverMaterial' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, IconTint) == 0x0000A0, "Member 'URMutatorRewardCategoryDataAsset::IconTint' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, Name_0) == 0x0000B0, "Member 'URMutatorRewardCategoryDataAsset::Name_0' has a wrong offset!");
static_assert(offsetof(URMutatorRewardCategoryDataAsset, Description) == 0x0000C0, "Member 'URMutatorRewardCategoryDataAsset::Description' has a wrong offset!");

// Class RGame.RUIManager
// 0x0030 (0x03C8 - 0x0398)
class ARUIManager final : public AHUD
{
public:
	TMulticastInlineDelegate<void(class URCommonActivatableWidget* PushedWidget)> OnWidgetPushed;    // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URCommonActivatableWidget* PoppedWidget)> OnWidgetPopped;    // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDragDropOperationEvent OperationType)> OnWidgetDragDropOperationStarted; // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class ARUIManager* GetUIManager(class APlayerController* PlayerController);
	static bool IsWidgetStackEmpty(class APlayerController* PlayerController, bool bExcludeNonInputWidgets);
	static void PopWidget(class URCommonActivatableWidget* ActivatableWidget);
	static void PushWidget(TSubclassOf<class URCommonActivatableWidget> ActivatableWidgetClass, class URCommonActivatableWidget** OutWidget, class APlayerController* PlayerController);

	void DragDropOperationStarted(EDragDropOperationEvent OperationType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RUIManager">();
	}
	static class ARUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARUIManager>();
	}
};
static_assert(alignof(ARUIManager) == 0x000008, "Wrong alignment on ARUIManager");
static_assert(sizeof(ARUIManager) == 0x0003C8, "Wrong size on ARUIManager");
static_assert(offsetof(ARUIManager, OnWidgetPushed) == 0x000398, "Member 'ARUIManager::OnWidgetPushed' has a wrong offset!");
static_assert(offsetof(ARUIManager, OnWidgetPopped) == 0x0003A8, "Member 'ARUIManager::OnWidgetPopped' has a wrong offset!");
static_assert(offsetof(ARUIManager, OnWidgetDragDropOperationStarted) == 0x0003B8, "Member 'ARUIManager::OnWidgetDragDropOperationStarted' has a wrong offset!");

// Class RGame.RUngluMovementSpline
// 0x0010 (0x02B8 - 0x02A8)
class ARUngluMovementSpline final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnCloneFinishedMoving;                             // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void BroadcastOnCloneFinishedMoving();
	class UTimelineComponent* GetMoveTimelineComponent();
	class USplineComponent* GetSplineComponent();
	void MoveCloneToPosition(class ARPawnBase* CloneTarget, float PlayRate, const struct FVector& TargetLocation, float DistanceRequirement);
	void SetSplineStopped(const bool bStop);
	void StartMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RUngluMovementSpline">();
	}
	static class ARUngluMovementSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARUngluMovementSpline>();
	}
};
static_assert(alignof(ARUngluMovementSpline) == 0x000008, "Wrong alignment on ARUngluMovementSpline");
static_assert(sizeof(ARUngluMovementSpline) == 0x0002B8, "Wrong size on ARUngluMovementSpline");
static_assert(offsetof(ARUngluMovementSpline, OnCloneFinishedMoving) == 0x0002A8, "Member 'ARUngluMovementSpline::OnCloneFinishedMoving' has a wrong offset!");

// Class RGame.RWall
// 0x0008 (0x02B0 - 0x02A8)
class ARWall final : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWall">();
	}
	static class ARWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWall>();
	}
};
static_assert(alignof(ARWall) == 0x000008, "Wrong alignment on ARWall");
static_assert(sizeof(ARWall) == 0x0002B0, "Wrong size on ARWall");
static_assert(offsetof(ARWall, StaticMeshComponent) == 0x0002A8, "Member 'ARWall::StaticMeshComponent' has a wrong offset!");

// Class RGame.RWeaponAnimInstance
// 0x01A0 (0x0560 - 0x03C0)
class URWeaponAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFPSWeapon;                                      // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0xF];                                      // 0x03C1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             GunIKTransform;                                    // 0x03D0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RelativeGunIKOffset;                               // 0x0430(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             FinalGunIKOffset;                                  // 0x0490(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MainHandSocket;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OffhandSocket;                                     // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           MagazineBones;                                     // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           DefaultHiddenBones;                                // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x30];                                     // 0x0520(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasPawnOwner;                                     // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_551[0xF];                                      // 0x0551(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ARPlayerPawn* GetPawnOwner();
	void OnInstanceInitialized();
	void OnWeaponFired(bool IsPrimaryMod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponAnimInstance">();
	}
	static class URWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URWeaponAnimInstance>();
	}
};
static_assert(alignof(URWeaponAnimInstance) == 0x000010, "Wrong alignment on URWeaponAnimInstance");
static_assert(sizeof(URWeaponAnimInstance) == 0x000560, "Wrong size on URWeaponAnimInstance");
static_assert(offsetof(URWeaponAnimInstance, bIsFPSWeapon) == 0x0003C0, "Member 'URWeaponAnimInstance::bIsFPSWeapon' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, GunIKTransform) == 0x0003D0, "Member 'URWeaponAnimInstance::GunIKTransform' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, RelativeGunIKOffset) == 0x000430, "Member 'URWeaponAnimInstance::RelativeGunIKOffset' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, FinalGunIKOffset) == 0x000490, "Member 'URWeaponAnimInstance::FinalGunIKOffset' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, MainHandSocket) == 0x0004F0, "Member 'URWeaponAnimInstance::MainHandSocket' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, OffhandSocket) == 0x0004F8, "Member 'URWeaponAnimInstance::OffhandSocket' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, MagazineBones) == 0x000500, "Member 'URWeaponAnimInstance::MagazineBones' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, DefaultHiddenBones) == 0x000510, "Member 'URWeaponAnimInstance::DefaultHiddenBones' has a wrong offset!");
static_assert(offsetof(URWeaponAnimInstance, bHasPawnOwner) == 0x000550, "Member 'URWeaponAnimInstance::bHasPawnOwner' has a wrong offset!");

// Class RGame.RWeaponCosmeticPrimaryAsset
// 0x0020 (0x0090 - 0x0070)
class URWeaponCosmeticPrimaryAsset final : public URPrimaryDataAsset
{
public:
	class UMaterialInstance*                      MaterialInstance;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CosmeticDescription;                               // 0x0078(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsDefaultWeaponCosmetic;                          // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponCosmeticPrimaryAsset">();
	}
	static class URWeaponCosmeticPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URWeaponCosmeticPrimaryAsset>();
	}
};
static_assert(alignof(URWeaponCosmeticPrimaryAsset) == 0x000008, "Wrong alignment on URWeaponCosmeticPrimaryAsset");
static_assert(sizeof(URWeaponCosmeticPrimaryAsset) == 0x000090, "Wrong size on URWeaponCosmeticPrimaryAsset");
static_assert(offsetof(URWeaponCosmeticPrimaryAsset, MaterialInstance) == 0x000070, "Member 'URWeaponCosmeticPrimaryAsset::MaterialInstance' has a wrong offset!");
static_assert(offsetof(URWeaponCosmeticPrimaryAsset, CosmeticDescription) == 0x000078, "Member 'URWeaponCosmeticPrimaryAsset::CosmeticDescription' has a wrong offset!");
static_assert(offsetof(URWeaponCosmeticPrimaryAsset, bIsDefaultWeaponCosmetic) == 0x000088, "Member 'URWeaponCosmeticPrimaryAsset::bIsDefaultWeaponCosmetic' has a wrong offset!");

// Class RGame.RWeaponMod
// 0x0000 (0x02A8 - 0x02A8)
class ARWeaponMod : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponMod">();
	}
	static class ARWeaponMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeaponMod>();
	}
};
static_assert(alignof(ARWeaponMod) == 0x000008, "Wrong alignment on ARWeaponMod");
static_assert(sizeof(ARWeaponMod) == 0x0002A8, "Wrong size on ARWeaponMod");

// Class RGame.RWeaponModPrimaryAsset
// 0x00D8 (0x0148 - 0x0070)
class URWeaponModPrimaryAsset final : public URPrimaryDataAsset
{
public:
	bool                                          bIsEnabled;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SoftWeaponModScript;                               // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URBaseWeaponSettings>    SoftWeaponModStats;                                // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponModType                                WeaponModType;                                     // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableInWeaponWorkbench;                       // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ModDescription;                                    // 0x00D0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftCosmeticsScript;                               // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponModAttachmentSlot                      AttachmentSlot;                                    // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponModCosmeticData>         CosmeticDatas;                                     // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         HueShift;                                          // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x0124(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MaterialEmissiveColor;                             // 0x0134(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponModPrimaryAsset">();
	}
	static class URWeaponModPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URWeaponModPrimaryAsset>();
	}
};
static_assert(alignof(URWeaponModPrimaryAsset) == 0x000008, "Wrong alignment on URWeaponModPrimaryAsset");
static_assert(sizeof(URWeaponModPrimaryAsset) == 0x000148, "Wrong size on URWeaponModPrimaryAsset");
static_assert(offsetof(URWeaponModPrimaryAsset, bIsEnabled) == 0x000070, "Member 'URWeaponModPrimaryAsset::bIsEnabled' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, SoftWeaponModScript) == 0x000078, "Member 'URWeaponModPrimaryAsset::SoftWeaponModScript' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, SoftWeaponModStats) == 0x0000A0, "Member 'URWeaponModPrimaryAsset::SoftWeaponModStats' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, WeaponModType) == 0x0000C8, "Member 'URWeaponModPrimaryAsset::WeaponModType' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, bAvailableInWeaponWorkbench) == 0x0000C9, "Member 'URWeaponModPrimaryAsset::bAvailableInWeaponWorkbench' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, ModDescription) == 0x0000D0, "Member 'URWeaponModPrimaryAsset::ModDescription' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, SoftCosmeticsScript) == 0x0000E0, "Member 'URWeaponModPrimaryAsset::SoftCosmeticsScript' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, AttachmentSlot) == 0x000108, "Member 'URWeaponModPrimaryAsset::AttachmentSlot' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, CosmeticDatas) == 0x000110, "Member 'URWeaponModPrimaryAsset::CosmeticDatas' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, HueShift) == 0x000120, "Member 'URWeaponModPrimaryAsset::HueShift' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, LightColor) == 0x000124, "Member 'URWeaponModPrimaryAsset::LightColor' has a wrong offset!");
static_assert(offsetof(URWeaponModPrimaryAsset, MaterialEmissiveColor) == 0x000134, "Member 'URWeaponModPrimaryAsset::MaterialEmissiveColor' has a wrong offset!");

// Class RGame.RWeaponModSlot
// 0x0020 (0x0250 - 0x0230)
class URWeaponModSlot final : public USceneComponent
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URWeaponModPrimaryAsset*                WeaponModPrimaryAsset;                             // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponModAttachmentSlot                      SlotType;                                          // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARWeaponMod*                            SpawnedMod;                                        // 0x0248(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponModSlot">();
	}
	static class URWeaponModSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<URWeaponModSlot>();
	}
};
static_assert(alignof(URWeaponModSlot) == 0x000010, "Wrong alignment on URWeaponModSlot");
static_assert(sizeof(URWeaponModSlot) == 0x000250, "Wrong size on URWeaponModSlot");
static_assert(offsetof(URWeaponModSlot, WeaponModPrimaryAsset) == 0x000238, "Member 'URWeaponModSlot::WeaponModPrimaryAsset' has a wrong offset!");
static_assert(offsetof(URWeaponModSlot, SlotType) == 0x000240, "Member 'URWeaponModSlot::SlotType' has a wrong offset!");
static_assert(offsetof(URWeaponModSlot, SpawnedMod) == 0x000248, "Member 'URWeaponModSlot::SpawnedMod' has a wrong offset!");

// Class RGame.RWeaponMod_StaticMesh
// 0x0008 (0x02B0 - 0x02A8)
class ARWeaponMod_StaticMesh final : public ARWeaponMod
{
public:
	class URStaticMeshComponent*                  ModStaticMeshComponent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponMod_StaticMesh">();
	}
	static class ARWeaponMod_StaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeaponMod_StaticMesh>();
	}
};
static_assert(alignof(ARWeaponMod_StaticMesh) == 0x000008, "Wrong alignment on ARWeaponMod_StaticMesh");
static_assert(sizeof(ARWeaponMod_StaticMesh) == 0x0002B0, "Wrong size on ARWeaponMod_StaticMesh");
static_assert(offsetof(ARWeaponMod_StaticMesh, ModStaticMeshComponent) == 0x0002A8, "Member 'ARWeaponMod_StaticMesh::ModStaticMeshComponent' has a wrong offset!");

// Class RGame.RWeaponMutatorPrimaryAsset
// 0x0028 (0x0160 - 0x0138)
class URWeaponMutatorPrimaryAsset final : public URMutatorPrimaryAsset
{
public:
	TSoftClassPtr<class UClass>                   SoftWeaponMutatorScript;                           // 0x0138(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponMutatorPrimaryAsset">();
	}
	static class URWeaponMutatorPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URWeaponMutatorPrimaryAsset>();
	}
};
static_assert(alignof(URWeaponMutatorPrimaryAsset) == 0x000008, "Wrong alignment on URWeaponMutatorPrimaryAsset");
static_assert(sizeof(URWeaponMutatorPrimaryAsset) == 0x000160, "Wrong size on URWeaponMutatorPrimaryAsset");
static_assert(offsetof(URWeaponMutatorPrimaryAsset, SoftWeaponMutatorScript) == 0x000138, "Member 'URWeaponMutatorPrimaryAsset::SoftWeaponMutatorScript' has a wrong offset!");

// Class RGame.RWeaponPrimaryAsset
// 0x0140 (0x01B0 - 0x0070)
class URWeaponPrimaryAsset final : public URPrimaryDataAsset
{
public:
	class FText                                   AssetDescription;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class URWeaponModPrimaryAsset>> SoftCompatibleWeaponMods;                  // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftWeaponActor;                                   // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftWeaponScript;                                  // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URWeaponModPrimaryAsset> SoftFiringModeScript;                              // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URWeaponModPrimaryAsset> SoftBarrelModDefaultScript;                        // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URWeaponModPrimaryAsset> SoftAttachment0ModDefaultScript;                   // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URWeaponModPrimaryAsset> SoftAttachment1ModDefaultScript;                   // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMutatorLootTableRow>           WeaponSpecificMutators;                            // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             SmallIcon;                                         // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class URWeaponCosmeticPrimaryAsset>> CosmeticPAs;                          // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	TArray<class URWeaponModPrimaryAsset*> GetCompatibleModsBySlot(EWeaponModAttachmentSlot Slot);
	class URWeaponCosmeticPrimaryAsset* GetDefaultCosmeticPA();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponPrimaryAsset">();
	}
	static class URWeaponPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URWeaponPrimaryAsset>();
	}
};
static_assert(alignof(URWeaponPrimaryAsset) == 0x000008, "Wrong alignment on URWeaponPrimaryAsset");
static_assert(sizeof(URWeaponPrimaryAsset) == 0x0001B0, "Wrong size on URWeaponPrimaryAsset");
static_assert(offsetof(URWeaponPrimaryAsset, AssetDescription) == 0x000070, "Member 'URWeaponPrimaryAsset::AssetDescription' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, bIsEnabled) == 0x000080, "Member 'URWeaponPrimaryAsset::bIsEnabled' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftCompatibleWeaponMods) == 0x000088, "Member 'URWeaponPrimaryAsset::SoftCompatibleWeaponMods' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftWeaponActor) == 0x000098, "Member 'URWeaponPrimaryAsset::SoftWeaponActor' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftWeaponScript) == 0x0000C0, "Member 'URWeaponPrimaryAsset::SoftWeaponScript' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftFiringModeScript) == 0x0000E8, "Member 'URWeaponPrimaryAsset::SoftFiringModeScript' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftBarrelModDefaultScript) == 0x000110, "Member 'URWeaponPrimaryAsset::SoftBarrelModDefaultScript' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftAttachment0ModDefaultScript) == 0x000138, "Member 'URWeaponPrimaryAsset::SoftAttachment0ModDefaultScript' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SoftAttachment1ModDefaultScript) == 0x000160, "Member 'URWeaponPrimaryAsset::SoftAttachment1ModDefaultScript' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, WeaponSpecificMutators) == 0x000188, "Member 'URWeaponPrimaryAsset::WeaponSpecificMutators' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, SmallIcon) == 0x000198, "Member 'URWeaponPrimaryAsset::SmallIcon' has a wrong offset!");
static_assert(offsetof(URWeaponPrimaryAsset, CosmeticPAs) == 0x0001A0, "Member 'URWeaponPrimaryAsset::CosmeticPAs' has a wrong offset!");

// Class RGame.RBaseWeaponSettings
// 0x01F0 (0x0220 - 0x0030)
class URBaseWeaponSettings final : public UDataAsset
{
public:
	struct FFloatWeaponSetting                    BaseWeaponDamage;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseWeaponCriticalMultiplier;                      // 0x0048(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseRateOfFire;                                    // 0x0060(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseCooldown;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseRecoil;                                        // 0x0090(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseRecoilRecovery;                                // 0x00A8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseSpread;                                        // 0x00C0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseReloadTime;                                    // 0x00D8(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReloadTimeDelta;                                   // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntegerWeaponSetting                  BaseAmmoCost;                                      // 0x00F4(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntegerWeaponSetting                  BaseClipSize;                                      // 0x0100(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ClipSizeDelta;                                     // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseEffectiveRange;                                // 0x0110(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseProcChance;                                    // 0x0128(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseMinSpreadMultiplier;                           // 0x0140(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWeaponSetting                    BaseMaxSpreadMultiplier;                           // 0x0158(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReduceProjectileSpreadTime;                        // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARProjectileBase>           ProjectileClass;                                   // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ProjectileDummyClass;                              // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectileTraceOffset;                             // 0x0188(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RecoilAnimOverride;                                // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReloadAnimOverride;                                // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilInterpSpeedRotationPosition;                 // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilRotationRollMinMax;                          // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilRotationPitchMinMax;                         // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilRotationYawMinMax;                           // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilPositionXMinMax;                             // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilPositionYMinMax;                             // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilPositionZMinMax;                             // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBaseWeaponSettings">();
	}
	static class URBaseWeaponSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBaseWeaponSettings>();
	}
};
static_assert(alignof(URBaseWeaponSettings) == 0x000008, "Wrong alignment on URBaseWeaponSettings");
static_assert(sizeof(URBaseWeaponSettings) == 0x000220, "Wrong size on URBaseWeaponSettings");
static_assert(offsetof(URBaseWeaponSettings, BaseWeaponDamage) == 0x000030, "Member 'URBaseWeaponSettings::BaseWeaponDamage' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseWeaponCriticalMultiplier) == 0x000048, "Member 'URBaseWeaponSettings::BaseWeaponCriticalMultiplier' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseRateOfFire) == 0x000060, "Member 'URBaseWeaponSettings::BaseRateOfFire' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseCooldown) == 0x000078, "Member 'URBaseWeaponSettings::BaseCooldown' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseRecoil) == 0x000090, "Member 'URBaseWeaponSettings::BaseRecoil' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseRecoilRecovery) == 0x0000A8, "Member 'URBaseWeaponSettings::BaseRecoilRecovery' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseSpread) == 0x0000C0, "Member 'URBaseWeaponSettings::BaseSpread' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseReloadTime) == 0x0000D8, "Member 'URBaseWeaponSettings::BaseReloadTime' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ReloadTimeDelta) == 0x0000F0, "Member 'URBaseWeaponSettings::ReloadTimeDelta' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseAmmoCost) == 0x0000F4, "Member 'URBaseWeaponSettings::BaseAmmoCost' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseClipSize) == 0x000100, "Member 'URBaseWeaponSettings::BaseClipSize' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ClipSizeDelta) == 0x00010C, "Member 'URBaseWeaponSettings::ClipSizeDelta' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseEffectiveRange) == 0x000110, "Member 'URBaseWeaponSettings::BaseEffectiveRange' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseProcChance) == 0x000128, "Member 'URBaseWeaponSettings::BaseProcChance' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseMinSpreadMultiplier) == 0x000140, "Member 'URBaseWeaponSettings::BaseMinSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, BaseMaxSpreadMultiplier) == 0x000158, "Member 'URBaseWeaponSettings::BaseMaxSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ReduceProjectileSpreadTime) == 0x000170, "Member 'URBaseWeaponSettings::ReduceProjectileSpreadTime' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ProjectileClass) == 0x000178, "Member 'URBaseWeaponSettings::ProjectileClass' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ProjectileDummyClass) == 0x000180, "Member 'URBaseWeaponSettings::ProjectileDummyClass' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ProjectileTraceOffset) == 0x000188, "Member 'URBaseWeaponSettings::ProjectileTraceOffset' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilAnimOverride) == 0x0001A0, "Member 'URBaseWeaponSettings::RecoilAnimOverride' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, ReloadAnimOverride) == 0x0001A8, "Member 'URBaseWeaponSettings::ReloadAnimOverride' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilInterpSpeedRotationPosition) == 0x0001B0, "Member 'URBaseWeaponSettings::RecoilInterpSpeedRotationPosition' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilRotationRollMinMax) == 0x0001C0, "Member 'URBaseWeaponSettings::RecoilRotationRollMinMax' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilRotationPitchMinMax) == 0x0001D0, "Member 'URBaseWeaponSettings::RecoilRotationPitchMinMax' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilRotationYawMinMax) == 0x0001E0, "Member 'URBaseWeaponSettings::RecoilRotationYawMinMax' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilPositionXMinMax) == 0x0001F0, "Member 'URBaseWeaponSettings::RecoilPositionXMinMax' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilPositionYMinMax) == 0x000200, "Member 'URBaseWeaponSettings::RecoilPositionYMinMax' has a wrong offset!");
static_assert(offsetof(URBaseWeaponSettings, RecoilPositionZMinMax) == 0x000210, "Member 'URBaseWeaponSettings::RecoilPositionZMinMax' has a wrong offset!");

// Class RGame.RMutableWeaponSettings
// 0x0E88 (0x0EB0 - 0x0028)
class URMutableWeaponSettings final : public UObject
{
public:
	class URBaseWeaponSettings*                   BaseSettings;                                      // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(EFloatWeaponStat FloatWeaponStat)> OnMutableWeaponSettingFloatAltered; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             WeaponDamage;                                      // 0x0040(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             WeaponCriticalMultiplier;                          // 0x0148(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             RateOfFire;                                        // 0x0250(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             Cooldown;                                          // 0x0358(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             Recoil;                                            // 0x0460(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             RecoilRecovery;                                    // 0x0568(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             Spread;                                            // 0x0670(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             ReloadTime;                                        // 0x0778(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableIntegerWeaponSetting           AmmoCost;                                          // 0x0880(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableIntegerWeaponSetting           ClipSize;                                          // 0x0988(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             EffectiveRange;                                    // 0x0A90(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             ProcChance;                                        // 0x0B98(0x0108)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             MinSpreadMultiplier;                               // 0x0CA0(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMutableFloatWeaponSetting             MaxSpreadMultiplier;                               // 0x0DA8(0x0108)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void AddFloatCoefficient(EFloatWeaponStat Stat, class FName Key, float Value);
	void AddFloatPostAdditive(EFloatWeaponStat Stat, class FName Key, float Value);
	void AddFloatPreAdditive(EFloatWeaponStat Stat, class FName Key, float Value);
	void AddIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key, float Value);
	void AddIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value);
	void AddIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key, int32 Value);
	float GetFloatTotalPositiveCoefficients(EFloatWeaponStat Stat);
	float GetFloatTotalPositivePostAdditive(EFloatWeaponStat Stat);
	float GetFloatTotalPositivePreAdditive(EFloatWeaponStat Stat);
	float GetFloatValue(EFloatWeaponStat Stat);
	int32 GetIntegerValue(EIntegerWeaponStat Stat);
	void RemoveFloatCoefficient(EFloatWeaponStat Stat, class FName Key);
	void RemoveFloatPostAdditive(EFloatWeaponStat Stat, class FName Key);
	void RemoveFloatPreAdditive(EFloatWeaponStat Stat, class FName Key);
	void RemoveIntegerCoefficient(EIntegerWeaponStat Stat, class FName Key);
	void RemoveIntegerPostAdditive(EIntegerWeaponStat Stat, class FName Key);
	void RemoveIntegerPreAdditive(EIntegerWeaponStat Stat, class FName Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMutableWeaponSettings">();
	}
	static class URMutableWeaponSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMutableWeaponSettings>();
	}
};
static_assert(alignof(URMutableWeaponSettings) == 0x000008, "Wrong alignment on URMutableWeaponSettings");
static_assert(sizeof(URMutableWeaponSettings) == 0x000EB0, "Wrong size on URMutableWeaponSettings");
static_assert(offsetof(URMutableWeaponSettings, BaseSettings) == 0x000028, "Member 'URMutableWeaponSettings::BaseSettings' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, OnMutableWeaponSettingFloatAltered) == 0x000030, "Member 'URMutableWeaponSettings::OnMutableWeaponSettingFloatAltered' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, WeaponDamage) == 0x000040, "Member 'URMutableWeaponSettings::WeaponDamage' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, WeaponCriticalMultiplier) == 0x000148, "Member 'URMutableWeaponSettings::WeaponCriticalMultiplier' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, RateOfFire) == 0x000250, "Member 'URMutableWeaponSettings::RateOfFire' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, Cooldown) == 0x000358, "Member 'URMutableWeaponSettings::Cooldown' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, Recoil) == 0x000460, "Member 'URMutableWeaponSettings::Recoil' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, RecoilRecovery) == 0x000568, "Member 'URMutableWeaponSettings::RecoilRecovery' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, Spread) == 0x000670, "Member 'URMutableWeaponSettings::Spread' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, ReloadTime) == 0x000778, "Member 'URMutableWeaponSettings::ReloadTime' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, AmmoCost) == 0x000880, "Member 'URMutableWeaponSettings::AmmoCost' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, ClipSize) == 0x000988, "Member 'URMutableWeaponSettings::ClipSize' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, EffectiveRange) == 0x000A90, "Member 'URMutableWeaponSettings::EffectiveRange' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, ProcChance) == 0x000B98, "Member 'URMutableWeaponSettings::ProcChance' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, MinSpreadMultiplier) == 0x000CA0, "Member 'URMutableWeaponSettings::MinSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(URMutableWeaponSettings, MaxSpreadMultiplier) == 0x000DA8, "Member 'URMutableWeaponSettings::MaxSpreadMultiplier' has a wrong offset!");

// Class RGame.RWeaponWorkbench
// 0x0048 (0x02F0 - 0x02A8)
class ARWeaponWorkbench final : public AActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   WorkbenchMeshComponent;                            // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        WeaponPreviewTransform;                            // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARWeapon*                               GunBody;                                           // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URWeaponModPrimaryAsset*                FiringModeScript;                                  // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URWeaponPrimaryAsset*                   WeaponPrimaryAsset;                                // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URGScriptComponent*                     GScriptOwnerComponent;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URWeaponModPrimaryAsset*>        AttachedWeaponModCosmetics;                        // 0x02E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void ClearGScripts();
	void SortListOptions(TArray<class URPrimaryDataAsset*>& Options);
	void UpdateBody(class URWeaponPrimaryAsset* NewPrimaryAsset, class AController* Controller);
	void UpdateMod(class URWeaponModPrimaryAsset* NewPrimaryAsset, const EWeaponModAttachmentSlot TargetAttachmentSlot);

	TSubclassOf<class ARWeapon> GetCurrentBody() const;
	class URWeaponPrimaryAsset* GetCurrentWeaponPrimaryAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeaponWorkbench">();
	}
	static class ARWeaponWorkbench* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeaponWorkbench>();
	}
};
static_assert(alignof(ARWeaponWorkbench) == 0x000008, "Wrong alignment on ARWeaponWorkbench");
static_assert(sizeof(ARWeaponWorkbench) == 0x0002F0, "Wrong size on ARWeaponWorkbench");
static_assert(offsetof(ARWeaponWorkbench, WorkbenchMeshComponent) == 0x0002B0, "Member 'ARWeaponWorkbench::WorkbenchMeshComponent' has a wrong offset!");
static_assert(offsetof(ARWeaponWorkbench, WeaponPreviewTransform) == 0x0002B8, "Member 'ARWeaponWorkbench::WeaponPreviewTransform' has a wrong offset!");
static_assert(offsetof(ARWeaponWorkbench, GunBody) == 0x0002C0, "Member 'ARWeaponWorkbench::GunBody' has a wrong offset!");
static_assert(offsetof(ARWeaponWorkbench, FiringModeScript) == 0x0002C8, "Member 'ARWeaponWorkbench::FiringModeScript' has a wrong offset!");
static_assert(offsetof(ARWeaponWorkbench, WeaponPrimaryAsset) == 0x0002D0, "Member 'ARWeaponWorkbench::WeaponPrimaryAsset' has a wrong offset!");
static_assert(offsetof(ARWeaponWorkbench, GScriptOwnerComponent) == 0x0002D8, "Member 'ARWeaponWorkbench::GScriptOwnerComponent' has a wrong offset!");
static_assert(offsetof(ARWeaponWorkbench, AttachedWeaponModCosmetics) == 0x0002E0, "Member 'ARWeaponWorkbench::AttachedWeaponModCosmetics' has a wrong offset!");

// Class RGame.RWeapon_EngineRifle
// 0x0000 (0x0390 - 0x0390)
class ARWeapon_EngineRifle : public ARWeapon
{
public:
	void ToggleSecondaryModFX(const bool bNewVisibility);
	void UpdateProjectileShotFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWeapon_EngineRifle">();
	}
	static class ARWeapon_EngineRifle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWeapon_EngineRifle>();
	}
};
static_assert(alignof(ARWeapon_EngineRifle) == 0x000008, "Wrong alignment on ARWeapon_EngineRifle");
static_assert(sizeof(ARWeapon_EngineRifle) == 0x000390, "Wrong size on ARWeapon_EngineRifle");

// Class RGame.RWorldSettings
// 0x0000 (0x04D0 - 0x04D0)
class ARWorldSettings final : public AWorldSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RWorldSettings">();
	}
	static class ARWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARWorldSettings>();
	}
};
static_assert(alignof(ARWorldSettings) == 0x000008, "Wrong alignment on ARWorldSettings");
static_assert(sizeof(ARWorldSettings) == 0x0004D0, "Wrong size on ARWorldSettings");

}

