#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OptimusCore

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "ComputeFramework_structs.hpp"
#include "ComputeFramework_classes.hpp"
#include "Engine_classes.hpp"
#include "OptimusCore_structs.hpp"


namespace SDK
{

// Class OptimusCore.OptimusAlternativeSelectedObjectProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusAlternativeSelectedObjectProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAlternativeSelectedObjectProvider">();
	}
	static class IOptimusAlternativeSelectedObjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusAlternativeSelectedObjectProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusAlternativeSelectedObjectProvider) == 0x000001, "Wrong alignment on IOptimusAlternativeSelectedObjectProvider");
static_assert(sizeof(IOptimusAlternativeSelectedObjectProvider) == 0x000001, "Wrong size on IOptimusAlternativeSelectedObjectProvider");

// Class OptimusCore.OptimusComponentBindingProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusComponentBindingProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentBindingProvider">();
	}
	static class IOptimusComponentBindingProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusComponentBindingProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusComponentBindingProvider) == 0x000001, "Wrong alignment on IOptimusComponentBindingProvider");
static_assert(sizeof(IOptimusComponentBindingProvider) == 0x000001, "Wrong size on IOptimusComponentBindingProvider");

// Class OptimusCore.OptimusComputeDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusComputeDataInterface : public UComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeDataInterface">();
	}
	static class UOptimusComputeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComputeDataInterface>();
	}
};
static_assert(alignof(UOptimusComputeDataInterface) == 0x000008, "Wrong alignment on UOptimusComputeDataInterface");
static_assert(sizeof(UOptimusComputeDataInterface) == 0x000028, "Wrong size on UOptimusComputeDataInterface");

// Class OptimusCore.OptimusLoopTerminalDataInterface
// 0x0008 (0x0030 - 0x0028)
class UOptimusLoopTerminalDataInterface final : public UOptimusComputeDataInterface
{
public:
	uint32                                        Index_0;                                           // 0x0028(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        Count;                                             // 0x002C(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusLoopTerminalDataInterface">();
	}
	static class UOptimusLoopTerminalDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusLoopTerminalDataInterface>();
	}
};
static_assert(alignof(UOptimusLoopTerminalDataInterface) == 0x000008, "Wrong alignment on UOptimusLoopTerminalDataInterface");
static_assert(sizeof(UOptimusLoopTerminalDataInterface) == 0x000030, "Wrong size on UOptimusLoopTerminalDataInterface");
static_assert(offsetof(UOptimusLoopTerminalDataInterface, Index_0) == 0x000028, "Member 'UOptimusLoopTerminalDataInterface::Index_0' has a wrong offset!");
static_assert(offsetof(UOptimusLoopTerminalDataInterface, Count) == 0x00002C, "Member 'UOptimusLoopTerminalDataInterface::Count' has a wrong offset!");

// Class OptimusCore.OptimusComponentBindingReceiver
// 0x0000 (0x0000 - 0x0000)
class IOptimusComponentBindingReceiver final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentBindingReceiver">();
	}
	static class IOptimusComponentBindingReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusComponentBindingReceiver>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusComponentBindingReceiver) == 0x000001, "Wrong alignment on IOptimusComponentBindingReceiver");
static_assert(sizeof(IOptimusComponentBindingReceiver) == 0x000001, "Wrong size on IOptimusComponentBindingReceiver");

// Class OptimusCore.OptimusComputeKernelDataInterface
// 0x0000 (0x0000 - 0x0000)
class IOptimusComputeKernelDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeKernelDataInterface">();
	}
	static class IOptimusComputeKernelDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusComputeKernelDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusComputeKernelDataInterface) == 0x000001, "Wrong alignment on IOptimusComputeKernelDataInterface");
static_assert(sizeof(IOptimusComputeKernelDataInterface) == 0x000001, "Wrong size on IOptimusComputeKernelDataInterface");

// Class OptimusCore.OptimusComputeKernelProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusComputeKernelProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeKernelProvider">();
	}
	static class IOptimusComputeKernelProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusComputeKernelProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusComputeKernelProvider) == 0x000001, "Wrong alignment on IOptimusComputeKernelProvider");
static_assert(sizeof(IOptimusComputeKernelProvider) == 0x000001, "Wrong size on IOptimusComputeKernelProvider");

// Class OptimusCore.OptimusDataInterfaceProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusDataInterfaceProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDataInterfaceProvider">();
	}
	static class IOptimusDataInterfaceProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusDataInterfaceProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusDataInterfaceProvider) == 0x000001, "Wrong alignment on IOptimusDataInterfaceProvider");
static_assert(sizeof(IOptimusDataInterfaceProvider) == 0x000001, "Wrong size on IOptimusDataInterfaceProvider");

// Class OptimusCore.OptimusRawBufferDataInterface
// 0x0068 (0x0090 - 0x0028)
class UOptimusRawBufferDataInterface : public UOptimusComputeDataInterface
{
public:
	struct FShaderValueTypeHandle                 ValueType;                                         // 0x0028(0x0008)(BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0030(0x0040)(BlueprintReadOnly, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentSourceBinding;                     // 0x0070(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusConstantIdentifier             DomainConstantIdentifier;                          // 0x0078(0x0018)(BlueprintReadOnly, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusRawBufferDataInterface">();
	}
	static class UOptimusRawBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusRawBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusRawBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusRawBufferDataInterface");
static_assert(sizeof(UOptimusRawBufferDataInterface) == 0x000090, "Wrong size on UOptimusRawBufferDataInterface");
static_assert(offsetof(UOptimusRawBufferDataInterface, ValueType) == 0x000028, "Member 'UOptimusRawBufferDataInterface::ValueType' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataInterface, DataDomain) == 0x000030, "Member 'UOptimusRawBufferDataInterface::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataInterface, ComponentSourceBinding) == 0x000070, "Member 'UOptimusRawBufferDataInterface::ComponentSourceBinding' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataInterface, DomainConstantIdentifier) == 0x000078, "Member 'UOptimusRawBufferDataInterface::DomainConstantIdentifier' has a wrong offset!");

// Class OptimusCore.OptimusDeformerInstanceAccessor
// 0x0000 (0x0000 - 0x0000)
class IOptimusDeformerInstanceAccessor final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformerInstanceAccessor">();
	}
	static class IOptimusDeformerInstanceAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusDeformerInstanceAccessor>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusDeformerInstanceAccessor) == 0x000001, "Wrong alignment on IOptimusDeformerInstanceAccessor");
static_assert(sizeof(IOptimusDeformerInstanceAccessor) == 0x000001, "Wrong size on IOptimusDeformerInstanceAccessor");

// Class OptimusCore.OptimusDeprecatedExecutionDataInterface
// 0x0000 (0x0000 - 0x0000)
class IOptimusDeprecatedExecutionDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeprecatedExecutionDataInterface">();
	}
	static class IOptimusDeprecatedExecutionDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusDeprecatedExecutionDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusDeprecatedExecutionDataInterface) == 0x000001, "Wrong alignment on IOptimusDeprecatedExecutionDataInterface");
static_assert(sizeof(IOptimusDeprecatedExecutionDataInterface) == 0x000001, "Wrong size on IOptimusDeprecatedExecutionDataInterface");

// Class OptimusCore.OptimusHalfEdgeDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusHalfEdgeDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusHalfEdgeDataInterface">();
	}
	static class UOptimusHalfEdgeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusHalfEdgeDataInterface>();
	}
};
static_assert(alignof(UOptimusHalfEdgeDataInterface) == 0x000008, "Wrong alignment on UOptimusHalfEdgeDataInterface");
static_assert(sizeof(UOptimusHalfEdgeDataInterface) == 0x000028, "Wrong size on UOptimusHalfEdgeDataInterface");

// Class OptimusCore.OptimusVariableDescription
// 0x0090 (0x00B8 - 0x0028)
class UOptimusVariableDescription final : public UObject
{
public:
	struct FGuid                                  Guid;                                              // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VariableName;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0040(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FOptimusValueContainerStruct           DefaultValueStruct;                                // 0x0070(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FShaderValueContainer                  CachedShaderValue;                                 // 0x0080(0x0020)(Transient, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ValueData;                                         // 0x00A0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	class UOptimusValueContainer*                 DefaultValue;                                      // 0x00B0(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusVariableDescription">();
	}
	static class UOptimusVariableDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusVariableDescription>();
	}
};
static_assert(alignof(UOptimusVariableDescription) == 0x000008, "Wrong alignment on UOptimusVariableDescription");
static_assert(sizeof(UOptimusVariableDescription) == 0x0000B8, "Wrong size on UOptimusVariableDescription");
static_assert(offsetof(UOptimusVariableDescription, Guid) == 0x000028, "Member 'UOptimusVariableDescription::Guid' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, VariableName) == 0x000038, "Member 'UOptimusVariableDescription::VariableName' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, DataType) == 0x000040, "Member 'UOptimusVariableDescription::DataType' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, DefaultValueStruct) == 0x000070, "Member 'UOptimusVariableDescription::DefaultValueStruct' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, CachedShaderValue) == 0x000080, "Member 'UOptimusVariableDescription::CachedShaderValue' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, ValueData) == 0x0000A0, "Member 'UOptimusVariableDescription::ValueData' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, DefaultValue) == 0x0000B0, "Member 'UOptimusVariableDescription::DefaultValue' has a wrong offset!");

// Class OptimusCore.OptimusExecutionDomainProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusExecutionDomainProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusExecutionDomainProvider">();
	}
	static class IOptimusExecutionDomainProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusExecutionDomainProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusExecutionDomainProvider) == 0x000001, "Wrong alignment on IOptimusExecutionDomainProvider");
static_assert(sizeof(IOptimusExecutionDomainProvider) == 0x000001, "Wrong size on IOptimusExecutionDomainProvider");

// Class OptimusCore.OptimusGeneratedClassDefiner
// 0x0000 (0x0000 - 0x0000)
class IOptimusGeneratedClassDefiner final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusGeneratedClassDefiner">();
	}
	static class IOptimusGeneratedClassDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusGeneratedClassDefiner>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusGeneratedClassDefiner) == 0x000001, "Wrong alignment on IOptimusGeneratedClassDefiner");
static_assert(sizeof(IOptimusGeneratedClassDefiner) == 0x000001, "Wrong size on IOptimusGeneratedClassDefiner");

// Class OptimusCore.OptimusNodeAdderPinProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodeAdderPinProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeAdderPinProvider">();
	}
	static class IOptimusNodeAdderPinProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeAdderPinProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodeAdderPinProvider) == 0x000001, "Wrong alignment on IOptimusNodeAdderPinProvider");
static_assert(sizeof(IOptimusNodeAdderPinProvider) == 0x000001, "Wrong size on IOptimusNodeAdderPinProvider");

// Class OptimusCore.OptimusNodeFunctionLibraryOwner
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodeFunctionLibraryOwner final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeFunctionLibraryOwner">();
	}
	static class IOptimusNodeFunctionLibraryOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeFunctionLibraryOwner>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodeFunctionLibraryOwner) == 0x000001, "Wrong alignment on IOptimusNodeFunctionLibraryOwner");
static_assert(sizeof(IOptimusNodeFunctionLibraryOwner) == 0x000001, "Wrong size on IOptimusNodeFunctionLibraryOwner");

// Class OptimusCore.OptimusNodeGraphCollectionOwner
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodeGraphCollectionOwner final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeGraphCollectionOwner">();
	}
	static class IOptimusNodeGraphCollectionOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeGraphCollectionOwner>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodeGraphCollectionOwner) == 0x000001, "Wrong alignment on IOptimusNodeGraphCollectionOwner");
static_assert(sizeof(IOptimusNodeGraphCollectionOwner) == 0x000001, "Wrong size on IOptimusNodeGraphCollectionOwner");

// Class OptimusCore.OptimusNodeGraphProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodeGraphProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeGraphProvider">();
	}
	static class IOptimusNodeGraphProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeGraphProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodeGraphProvider) == 0x000001, "Wrong alignment on IOptimusNodeGraphProvider");
static_assert(sizeof(IOptimusNodeGraphProvider) == 0x000001, "Wrong size on IOptimusNodeGraphProvider");

// Class OptimusCore.OptimusNodePairProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodePairProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodePairProvider">();
	}
	static class IOptimusNodePairProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodePairProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodePairProvider) == 0x000001, "Wrong alignment on IOptimusNodePairProvider");
static_assert(sizeof(IOptimusNodePairProvider) == 0x000001, "Wrong size on IOptimusNodePairProvider");

// Class OptimusCore.OptimusNodePinRouter
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodePinRouter final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodePinRouter">();
	}
	static class IOptimusNodePinRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodePinRouter>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodePinRouter) == 0x000001, "Wrong alignment on IOptimusNodePinRouter");
static_assert(sizeof(IOptimusNodePinRouter) == 0x000001, "Wrong size on IOptimusNodePinRouter");

// Class OptimusCore.OptimusNodeSubGraphReferencer
// 0x0000 (0x0000 - 0x0000)
class IOptimusNodeSubGraphReferencer final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeSubGraphReferencer">();
	}
	static class IOptimusNodeSubGraphReferencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeSubGraphReferencer>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNodeSubGraphReferencer) == 0x000001, "Wrong alignment on IOptimusNodeSubGraphReferencer");
static_assert(sizeof(IOptimusNodeSubGraphReferencer) == 0x000001, "Wrong size on IOptimusNodeSubGraphReferencer");

// Class OptimusCore.OptimusNonCollapsibleNode
// 0x0000 (0x0000 - 0x0000)
class IOptimusNonCollapsibleNode final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNonCollapsibleNode">();
	}
	static class IOptimusNonCollapsibleNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNonCollapsibleNode>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNonCollapsibleNode) == 0x000001, "Wrong alignment on IOptimusNonCollapsibleNode");
static_assert(sizeof(IOptimusNonCollapsibleNode) == 0x000001, "Wrong size on IOptimusNonCollapsibleNode");

// Class OptimusCore.OptimusNonCopyableNode
// 0x0000 (0x0000 - 0x0000)
class IOptimusNonCopyableNode final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNonCopyableNode">();
	}
	static class IOptimusNonCopyableNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNonCopyableNode>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusNonCopyableNode) == 0x000001, "Wrong alignment on IOptimusNonCopyableNode");
static_assert(sizeof(IOptimusNonCopyableNode) == 0x000001, "Wrong size on IOptimusNonCopyableNode");

// Class OptimusCore.OptimusOutputBufferWriter
// 0x0000 (0x0000 - 0x0000)
class IOptimusOutputBufferWriter final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusOutputBufferWriter">();
	}
	static class IOptimusOutputBufferWriter* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusOutputBufferWriter>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusOutputBufferWriter) == 0x000001, "Wrong alignment on IOptimusOutputBufferWriter");
static_assert(sizeof(IOptimusOutputBufferWriter) == 0x000001, "Wrong size on IOptimusOutputBufferWriter");

// Class OptimusCore.OptimusParameterBindingProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusParameterBindingProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusParameterBindingProvider">();
	}
	static class IOptimusParameterBindingProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusParameterBindingProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusParameterBindingProvider) == 0x000001, "Wrong alignment on IOptimusParameterBindingProvider");
static_assert(sizeof(IOptimusParameterBindingProvider) == 0x000001, "Wrong size on IOptimusParameterBindingProvider");

// Class OptimusCore.OptimusPathResolver
// 0x0000 (0x0000 - 0x0000)
class IOptimusPathResolver final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPathResolver">();
	}
	static class IOptimusPathResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusPathResolver>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusPathResolver) == 0x000001, "Wrong alignment on IOptimusPathResolver");
static_assert(sizeof(IOptimusPathResolver) == 0x000001, "Wrong size on IOptimusPathResolver");

// Class OptimusCore.OptimusPersistentBufferProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusPersistentBufferProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPersistentBufferProvider">();
	}
	static class IOptimusPersistentBufferProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusPersistentBufferProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusPersistentBufferProvider) == 0x000001, "Wrong alignment on IOptimusPersistentBufferProvider");
static_assert(sizeof(IOptimusPersistentBufferProvider) == 0x000001, "Wrong size on IOptimusPersistentBufferProvider");

// Class OptimusCore.OptimusPinMutabilityDefiner
// 0x0000 (0x0000 - 0x0000)
class IOptimusPinMutabilityDefiner final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPinMutabilityDefiner">();
	}
	static class IOptimusPinMutabilityDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusPinMutabilityDefiner>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusPinMutabilityDefiner) == 0x000001, "Wrong alignment on IOptimusPinMutabilityDefiner");
static_assert(sizeof(IOptimusPinMutabilityDefiner) == 0x000001, "Wrong size on IOptimusPinMutabilityDefiner");

// Class OptimusCore.OptimusPropertyPinProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusPropertyPinProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPropertyPinProvider">();
	}
	static class IOptimusPropertyPinProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusPropertyPinProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusPropertyPinProvider) == 0x000001, "Wrong alignment on IOptimusPropertyPinProvider");
static_assert(sizeof(IOptimusPropertyPinProvider) == 0x000001, "Wrong size on IOptimusPropertyPinProvider");

// Class OptimusCore.OptimusShaderTextProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusShaderTextProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusShaderTextProvider">();
	}
	static class IOptimusShaderTextProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusShaderTextProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusShaderTextProvider) == 0x000001, "Wrong alignment on IOptimusShaderTextProvider");
static_assert(sizeof(IOptimusShaderTextProvider) == 0x000001, "Wrong size on IOptimusShaderTextProvider");

// Class OptimusCore.OptimusNode
// 0x00E0 (0x0108 - 0x0028)
class UOptimusNode : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(NonTransactional, NativeAccessSpecifierPrivate)
	struct FVector2D                              GraphPosition;                                     // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodePin*>                Pins;                                              // 0x0050(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ExpandedPins;                                      // 0x0060(0x0050)(NonTransactional, NativeAccessSpecifierPrivate)
	EOptimusDiagnosticLevel                       DiagnosticLevel;                                   // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x57];                                      // 0x00B1(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetGraphPosition(const struct FVector2D& InPosition);

	class FText GetDisplayName() const;
	struct FVector2D GetGraphPosition() const;
	class FName GetNodeCategory() const;
	class FName GetNodeName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode">();
	}
	static class UOptimusNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode>();
	}
};
static_assert(alignof(UOptimusNode) == 0x000008, "Wrong alignment on UOptimusNode");
static_assert(sizeof(UOptimusNode) == 0x000108, "Wrong size on UOptimusNode");
static_assert(offsetof(UOptimusNode, DisplayName) == 0x000030, "Member 'UOptimusNode::DisplayName' has a wrong offset!");
static_assert(offsetof(UOptimusNode, GraphPosition) == 0x000040, "Member 'UOptimusNode::GraphPosition' has a wrong offset!");
static_assert(offsetof(UOptimusNode, Pins) == 0x000050, "Member 'UOptimusNode::Pins' has a wrong offset!");
static_assert(offsetof(UOptimusNode, ExpandedPins) == 0x000060, "Member 'UOptimusNode::ExpandedPins' has a wrong offset!");
static_assert(offsetof(UOptimusNode, DiagnosticLevel) == 0x0000B0, "Member 'UOptimusNode::DiagnosticLevel' has a wrong offset!");

// Class OptimusCore.OptimusUnnamedNodePinProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusUnnamedNodePinProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusUnnamedNodePinProvider">();
	}
	static class IOptimusUnnamedNodePinProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusUnnamedNodePinProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusUnnamedNodePinProvider) == 0x000001, "Wrong alignment on IOptimusUnnamedNodePinProvider");
static_assert(sizeof(IOptimusUnnamedNodePinProvider) == 0x000001, "Wrong size on IOptimusUnnamedNodePinProvider");

// Class OptimusCore.OptimusValueProvider
// 0x0000 (0x0000 - 0x0000)
class IOptimusValueProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusValueProvider">();
	}
	static class IOptimusValueProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusValueProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOptimusValueProvider) == 0x000001, "Wrong alignment on IOptimusValueProvider");
static_assert(sizeof(IOptimusValueProvider) == 0x000001, "Wrong size on IOptimusValueProvider");

// Class OptimusCore.OptimusSkinnedMeshVertexAttributeDataInterface
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkinnedMeshVertexAttributeDataInterface final : public UOptimusComputeDataInterface
{
public:
	class FName                                   AttributeName;                                     // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshVertexAttributeDataInterface">();
	}
	static class UOptimusSkinnedMeshVertexAttributeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshVertexAttributeDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshVertexAttributeDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshVertexAttributeDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshVertexAttributeDataInterface) == 0x000030, "Wrong size on UOptimusSkinnedMeshVertexAttributeDataInterface");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataInterface, AttributeName) == 0x000028, "Member 'UOptimusSkinnedMeshVertexAttributeDataInterface::AttributeName' has a wrong offset!");

// Class OptimusCore.OptimusNode_ComputeKernelBase
// 0x0008 (0x0110 - 0x0108)
class UOptimusNode_ComputeKernelBase : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComputeKernelBase">();
	}
	static class UOptimusNode_ComputeKernelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComputeKernelBase>();
	}
};
static_assert(alignof(UOptimusNode_ComputeKernelBase) == 0x000008, "Wrong alignment on UOptimusNode_ComputeKernelBase");
static_assert(sizeof(UOptimusNode_ComputeKernelBase) == 0x000110, "Wrong size on UOptimusNode_ComputeKernelBase");

// Class OptimusCore.OptimusSkinnedMeshVertexAttributeDataProvider
// 0x0028 (0x0050 - 0x0028)
class UOptimusSkinnedMeshVertexAttributeDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedMeshComponent*                  SkinnedMeshComponent;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeName;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusDeformerInstance*               DeformerInstance;                                  // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshVertexAttributeDataProvider">();
	}
	static class UOptimusSkinnedMeshVertexAttributeDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshVertexAttributeDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshVertexAttributeDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshVertexAttributeDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshVertexAttributeDataProvider) == 0x000050, "Wrong size on UOptimusSkinnedMeshVertexAttributeDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataProvider, SkinnedMeshComponent) == 0x000030, "Member 'UOptimusSkinnedMeshVertexAttributeDataProvider::SkinnedMeshComponent' has a wrong offset!");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataProvider, AttributeName) == 0x000038, "Member 'UOptimusSkinnedMeshVertexAttributeDataProvider::AttributeName' has a wrong offset!");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataProvider, DeformerInstance) == 0x000048, "Member 'UOptimusSkinnedMeshVertexAttributeDataProvider::DeformerInstance' has a wrong offset!");

// Class OptimusCore.OptimusSkinWeightsAsVertexMaskDataInterface
// 0x0058 (0x0080 - 0x0028)
class UOptimusSkinWeightsAsVertexMaskDataInterface final : public UOptimusComputeDataInterface
{
public:
	class FName                                   SkinWeightProfile;                                 // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNames;                                         // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ExpandTowardsRoot;                                 // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpandTowardsLeaf;                                 // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawIncludedBones;                           // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 DebugDrawColor;                                    // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinWeightsAsVertexMaskDataInterface">();
	}
	static class UOptimusSkinWeightsAsVertexMaskDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinWeightsAsVertexMaskDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinWeightsAsVertexMaskDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinWeightsAsVertexMaskDataInterface");
static_assert(sizeof(UOptimusSkinWeightsAsVertexMaskDataInterface) == 0x000080, "Wrong size on UOptimusSkinWeightsAsVertexMaskDataInterface");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataInterface, SkinWeightProfile) == 0x000028, "Member 'UOptimusSkinWeightsAsVertexMaskDataInterface::SkinWeightProfile' has a wrong offset!");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataInterface, BoneNames) == 0x000030, "Member 'UOptimusSkinWeightsAsVertexMaskDataInterface::BoneNames' has a wrong offset!");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataInterface, ExpandTowardsRoot) == 0x000040, "Member 'UOptimusSkinWeightsAsVertexMaskDataInterface::ExpandTowardsRoot' has a wrong offset!");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataInterface, ExpandTowardsLeaf) == 0x000044, "Member 'UOptimusSkinWeightsAsVertexMaskDataInterface::ExpandTowardsLeaf' has a wrong offset!");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataInterface, bDebugDrawIncludedBones) == 0x000048, "Member 'UOptimusSkinWeightsAsVertexMaskDataInterface::bDebugDrawIncludedBones' has a wrong offset!");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataInterface, DebugDrawColor) == 0x00004C, "Member 'UOptimusSkinWeightsAsVertexMaskDataInterface::DebugDrawColor' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshWriteDataInterface
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkinnedMeshWriteDataInterface final : public UOptimusComputeDataInterface
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshWriteDataInterface">();
	}
	static class UOptimusSkinnedMeshWriteDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshWriteDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshWriteDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshWriteDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshWriteDataInterface) == 0x000030, "Wrong size on UOptimusSkinnedMeshWriteDataInterface");

// Class OptimusCore.OptimusSkinWeightsAsVertexMaskDataProvider
// 0x00B0 (0x00D8 - 0x0028)
class UOptimusSkinWeightsAsVertexMaskDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusDeformerInstance*               DeformerInstance;                                  // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinWeightsAsVertexMaskDataProvider">();
	}
	static class UOptimusSkinWeightsAsVertexMaskDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinWeightsAsVertexMaskDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinWeightsAsVertexMaskDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinWeightsAsVertexMaskDataProvider");
static_assert(sizeof(UOptimusSkinWeightsAsVertexMaskDataProvider) == 0x0000D8, "Wrong size on UOptimusSkinWeightsAsVertexMaskDataProvider");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataProvider, SkeletalMesh) == 0x000030, "Member 'UOptimusSkinWeightsAsVertexMaskDataProvider::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UOptimusSkinWeightsAsVertexMaskDataProvider, DeformerInstance) == 0x0000C8, "Member 'UOptimusSkinWeightsAsVertexMaskDataProvider::DeformerInstance' has a wrong offset!");

// Class OptimusCore.OptimusDeformerDynamicInstanceManager
// 0x0108 (0x0130 - 0x0028)
class UOptimusDeformerDynamicInstanceManager final : public UMeshDeformerInstance
{
public:
	class UOptimusDeformerInstance*               DefaultInstance;                                   // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UOptimusDeformerInstance*> GuidToRigDeformerInstanceMap;                // 0x0030(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0xB0];                                      // 0x0080(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformerDynamicInstanceManager">();
	}
	static class UOptimusDeformerDynamicInstanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformerDynamicInstanceManager>();
	}
};
static_assert(alignof(UOptimusDeformerDynamicInstanceManager) == 0x000008, "Wrong alignment on UOptimusDeformerDynamicInstanceManager");
static_assert(sizeof(UOptimusDeformerDynamicInstanceManager) == 0x000130, "Wrong size on UOptimusDeformerDynamicInstanceManager");
static_assert(offsetof(UOptimusDeformerDynamicInstanceManager, DefaultInstance) == 0x000028, "Member 'UOptimusDeformerDynamicInstanceManager::DefaultInstance' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerDynamicInstanceManager, GuidToRigDeformerInstanceMap) == 0x000030, "Member 'UOptimusDeformerDynamicInstanceManager::GuidToRigDeformerInstanceMap' has a wrong offset!");

// Class OptimusCore.OptimusKernelSource
// 0x0010 (0x00A8 - 0x0098)
class UOptimusKernelSource final : public UComputeKernelSource
{
public:
	class FString                                 Source;                                            // 0x0098(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusKernelSource">();
	}
	static class UOptimusKernelSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusKernelSource>();
	}
};
static_assert(alignof(UOptimusKernelSource) == 0x000008, "Wrong alignment on UOptimusKernelSource");
static_assert(sizeof(UOptimusKernelSource) == 0x0000A8, "Wrong size on UOptimusKernelSource");
static_assert(offsetof(UOptimusKernelSource, Source) == 0x000098, "Member 'UOptimusKernelSource::Source' has a wrong offset!");

// Class OptimusCore.OptimusComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusComponentSource : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentSource">();
	}
	static class UOptimusComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComponentSource>();
	}
};
static_assert(alignof(UOptimusComponentSource) == 0x000008, "Wrong alignment on UOptimusComponentSource");
static_assert(sizeof(UOptimusComponentSource) == 0x000028, "Wrong size on UOptimusComponentSource");

// Class OptimusCore.OptimusSceneComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusSceneComponentSource final : public UOptimusComponentSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSceneComponentSource">();
	}
	static class UOptimusSceneComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSceneComponentSource>();
	}
};
static_assert(alignof(UOptimusSceneComponentSource) == 0x000008, "Wrong alignment on UOptimusSceneComponentSource");
static_assert(sizeof(UOptimusSceneComponentSource) == 0x000028, "Wrong size on UOptimusSceneComponentSource");

// Class OptimusCore.OptimusSkinnedMeshComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkinnedMeshComponentSource : public UOptimusComponentSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshComponentSource">();
	}
	static class UOptimusSkinnedMeshComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshComponentSource>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshComponentSource) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshComponentSource");
static_assert(sizeof(UOptimusSkinnedMeshComponentSource) == 0x000028, "Wrong size on UOptimusSkinnedMeshComponentSource");

// Class OptimusCore.OptimusSkeletalMeshComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkeletalMeshComponentSource final : public UOptimusSkinnedMeshComponentSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkeletalMeshComponentSource">();
	}
	static class UOptimusSkeletalMeshComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkeletalMeshComponentSource>();
	}
};
static_assert(alignof(UOptimusSkeletalMeshComponentSource) == 0x000008, "Wrong alignment on UOptimusSkeletalMeshComponentSource");
static_assert(sizeof(UOptimusSkeletalMeshComponentSource) == 0x000028, "Wrong size on UOptimusSkeletalMeshComponentSource");

// Class OptimusCore.OptimusAdvancedSkeletonDataInterface
// 0x0050 (0x0078 - 0x0028)
class UOptimusAdvancedSkeletonDataInterface final : public UOptimusComputeDataInterface
{
public:
	class FName                                   SkinWeightProfile;                                 // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLayeredSkinning;                            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusAnimAttributeBufferArray       AttributeBufferArray;                              // 0x0038(0x0010)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAdvancedSkeletonDataInterface">();
	}
	static class UOptimusAdvancedSkeletonDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusAdvancedSkeletonDataInterface>();
	}
};
static_assert(alignof(UOptimusAdvancedSkeletonDataInterface) == 0x000008, "Wrong alignment on UOptimusAdvancedSkeletonDataInterface");
static_assert(sizeof(UOptimusAdvancedSkeletonDataInterface) == 0x000078, "Wrong size on UOptimusAdvancedSkeletonDataInterface");
static_assert(offsetof(UOptimusAdvancedSkeletonDataInterface, SkinWeightProfile) == 0x000028, "Member 'UOptimusAdvancedSkeletonDataInterface::SkinWeightProfile' has a wrong offset!");
static_assert(offsetof(UOptimusAdvancedSkeletonDataInterface, bEnableLayeredSkinning) == 0x000030, "Member 'UOptimusAdvancedSkeletonDataInterface::bEnableLayeredSkinning' has a wrong offset!");
static_assert(offsetof(UOptimusAdvancedSkeletonDataInterface, AttributeBufferArray) == 0x000038, "Member 'UOptimusAdvancedSkeletonDataInterface::AttributeBufferArray' has a wrong offset!");

// Class OptimusCore.OptimusAdvancedSkeletonDataProvider
// 0x00B0 (0x00D8 - 0x0028)
class UOptimusAdvancedSkeletonDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusDeformerInstance*               DeformerInstance;                                  // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAdvancedSkeletonDataProvider">();
	}
	static class UOptimusAdvancedSkeletonDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusAdvancedSkeletonDataProvider>();
	}
};
static_assert(alignof(UOptimusAdvancedSkeletonDataProvider) == 0x000008, "Wrong alignment on UOptimusAdvancedSkeletonDataProvider");
static_assert(sizeof(UOptimusAdvancedSkeletonDataProvider) == 0x0000D8, "Wrong size on UOptimusAdvancedSkeletonDataProvider");
static_assert(offsetof(UOptimusAdvancedSkeletonDataProvider, SkeletalMesh) == 0x000030, "Member 'UOptimusAdvancedSkeletonDataProvider::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UOptimusAdvancedSkeletonDataProvider, DeformerInstance) == 0x0000C8, "Member 'UOptimusAdvancedSkeletonDataProvider::DeformerInstance' has a wrong offset!");

// Class OptimusCore.OptimusAnimAttributeDataInterface
// 0x0030 (0x0058 - 0x0028)
class UOptimusAnimAttributeDataInterface final : public UOptimusComputeDataInterface
{
public:
	struct FOptimusAnimAttributeArray             AttributeArray;                                    // 0x0028(0x0010)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAnimAttributeDataInterface">();
	}
	static class UOptimusAnimAttributeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusAnimAttributeDataInterface>();
	}
};
static_assert(alignof(UOptimusAnimAttributeDataInterface) == 0x000008, "Wrong alignment on UOptimusAnimAttributeDataInterface");
static_assert(sizeof(UOptimusAnimAttributeDataInterface) == 0x000058, "Wrong size on UOptimusAnimAttributeDataInterface");
static_assert(offsetof(UOptimusAnimAttributeDataInterface, AttributeArray) == 0x000028, "Member 'UOptimusAnimAttributeDataInterface::AttributeArray' has a wrong offset!");

// Class OptimusCore.OptimusAnimAttributeDataProvider
// 0x0020 (0x0048 - 0x0028)
class UOptimusAnimAttributeDataProvider final : public UComputeDataProvider
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAnimAttributeDataProvider">();
	}
	static class UOptimusAnimAttributeDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusAnimAttributeDataProvider>();
	}
};
static_assert(alignof(UOptimusAnimAttributeDataProvider) == 0x000008, "Wrong alignment on UOptimusAnimAttributeDataProvider");
static_assert(sizeof(UOptimusAnimAttributeDataProvider) == 0x000048, "Wrong size on UOptimusAnimAttributeDataProvider");
static_assert(offsetof(UOptimusAnimAttributeDataProvider, SkeletalMesh) == 0x000028, "Member 'UOptimusAnimAttributeDataProvider::SkeletalMesh' has a wrong offset!");

// Class OptimusCore.OptimusClothDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusClothDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusClothDataInterface">();
	}
	static class UOptimusClothDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusClothDataInterface>();
	}
};
static_assert(alignof(UOptimusClothDataInterface) == 0x000008, "Wrong alignment on UOptimusClothDataInterface");
static_assert(sizeof(UOptimusClothDataInterface) == 0x000028, "Wrong size on UOptimusClothDataInterface");

// Class OptimusCore.OptimusClothDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusClothDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusClothDataProvider">();
	}
	static class UOptimusClothDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusClothDataProvider>();
	}
};
static_assert(alignof(UOptimusClothDataProvider) == 0x000008, "Wrong alignment on UOptimusClothDataProvider");
static_assert(sizeof(UOptimusClothDataProvider) == 0x000030, "Wrong size on UOptimusClothDataProvider");
static_assert(offsetof(UOptimusClothDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusClothDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusConnectivityDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusConnectivityDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusConnectivityDataInterface">();
	}
	static class UOptimusConnectivityDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusConnectivityDataInterface>();
	}
};
static_assert(alignof(UOptimusConnectivityDataInterface) == 0x000008, "Wrong alignment on UOptimusConnectivityDataInterface");
static_assert(sizeof(UOptimusConnectivityDataInterface) == 0x000028, "Wrong size on UOptimusConnectivityDataInterface");

// Class OptimusCore.OptimusConnectivityDataProvider
// 0x0018 (0x0040 - 0x0028)
class UOptimusConnectivityDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusConnectivityDataProvider">();
	}
	static class UOptimusConnectivityDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusConnectivityDataProvider>();
	}
};
static_assert(alignof(UOptimusConnectivityDataProvider) == 0x000008, "Wrong alignment on UOptimusConnectivityDataProvider");
static_assert(sizeof(UOptimusConnectivityDataProvider) == 0x000040, "Wrong size on UOptimusConnectivityDataProvider");
static_assert(offsetof(UOptimusConnectivityDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusConnectivityDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusCopyKernelDataInterface
// 0x0020 (0x0048 - 0x0028)
class UOptimusCopyKernelDataInterface final : public UComputeDataInterface
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentSourceBinding;                     // 0x0030(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NumThreadsExpression;                              // 0x0038(0x0010)(BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusCopyKernelDataInterface">();
	}
	static class UOptimusCopyKernelDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusCopyKernelDataInterface>();
	}
};
static_assert(alignof(UOptimusCopyKernelDataInterface) == 0x000008, "Wrong alignment on UOptimusCopyKernelDataInterface");
static_assert(sizeof(UOptimusCopyKernelDataInterface) == 0x000048, "Wrong size on UOptimusCopyKernelDataInterface");
static_assert(offsetof(UOptimusCopyKernelDataInterface, ComponentSourceBinding) == 0x000030, "Member 'UOptimusCopyKernelDataInterface::ComponentSourceBinding' has a wrong offset!");
static_assert(offsetof(UOptimusCopyKernelDataInterface, NumThreadsExpression) == 0x000038, "Member 'UOptimusCopyKernelDataInterface::NumThreadsExpression' has a wrong offset!");

// Class OptimusCore.OptimusCopyKernelDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusCopyKernelDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusCopyKernelDataProvider">();
	}
	static class UOptimusCopyKernelDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusCopyKernelDataProvider>();
	}
};
static_assert(alignof(UOptimusCopyKernelDataProvider) == 0x000008, "Wrong alignment on UOptimusCopyKernelDataProvider");
static_assert(sizeof(UOptimusCopyKernelDataProvider) == 0x000038, "Wrong size on UOptimusCopyKernelDataProvider");

// Class OptimusCore.OptimusCustomComputeKernelDataInterface
// 0x0038 (0x0060 - 0x0028)
class UOptimusCustomComputeKernelDataInterface final : public UComputeDataInterface
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentSourceBinding;                     // 0x0030(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NumThreadsExpression;                              // 0x0038(0x0010)(BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusConstantIdentifier             ExecutionDomainConstantIdentifier;                 // 0x0048(0x0018)(BlueprintReadOnly, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusCustomComputeKernelDataInterface">();
	}
	static class UOptimusCustomComputeKernelDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusCustomComputeKernelDataInterface>();
	}
};
static_assert(alignof(UOptimusCustomComputeKernelDataInterface) == 0x000008, "Wrong alignment on UOptimusCustomComputeKernelDataInterface");
static_assert(sizeof(UOptimusCustomComputeKernelDataInterface) == 0x000060, "Wrong size on UOptimusCustomComputeKernelDataInterface");
static_assert(offsetof(UOptimusCustomComputeKernelDataInterface, ComponentSourceBinding) == 0x000030, "Member 'UOptimusCustomComputeKernelDataInterface::ComponentSourceBinding' has a wrong offset!");
static_assert(offsetof(UOptimusCustomComputeKernelDataInterface, NumThreadsExpression) == 0x000038, "Member 'UOptimusCustomComputeKernelDataInterface::NumThreadsExpression' has a wrong offset!");
static_assert(offsetof(UOptimusCustomComputeKernelDataInterface, ExecutionDomainConstantIdentifier) == 0x000048, "Member 'UOptimusCustomComputeKernelDataInterface::ExecutionDomainConstantIdentifier' has a wrong offset!");

// Class OptimusCore.OptimusCustomComputeKernelDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusCustomComputeKernelDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusCustomComputeKernelDataProvider">();
	}
	static class UOptimusCustomComputeKernelDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusCustomComputeKernelDataProvider>();
	}
};
static_assert(alignof(UOptimusCustomComputeKernelDataProvider) == 0x000008, "Wrong alignment on UOptimusCustomComputeKernelDataProvider");
static_assert(sizeof(UOptimusCustomComputeKernelDataProvider) == 0x000038, "Wrong size on UOptimusCustomComputeKernelDataProvider");

// Class OptimusCore.OptimusHalfEdgeDataProvider
// 0x0020 (0x0048 - 0x0028)
class UOptimusHalfEdgeDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusHalfEdgeDataProvider">();
	}
	static class UOptimusHalfEdgeDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusHalfEdgeDataProvider>();
	}
};
static_assert(alignof(UOptimusHalfEdgeDataProvider) == 0x000008, "Wrong alignment on UOptimusHalfEdgeDataProvider");
static_assert(sizeof(UOptimusHalfEdgeDataProvider) == 0x000048, "Wrong size on UOptimusHalfEdgeDataProvider");
static_assert(offsetof(UOptimusHalfEdgeDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusHalfEdgeDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusDebugDrawDataInterface
// 0x0018 (0x0040 - 0x0028)
class UOptimusDebugDrawDataInterface final : public UOptimusComputeDataInterface
{
public:
	bool                                          bIsSupported;                                      // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusDebugDrawParameters            DebugDrawParameters;                               // 0x002C(0x0014)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDebugDrawDataInterface">();
	}
	static class UOptimusDebugDrawDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDebugDrawDataInterface>();
	}
};
static_assert(alignof(UOptimusDebugDrawDataInterface) == 0x000008, "Wrong alignment on UOptimusDebugDrawDataInterface");
static_assert(sizeof(UOptimusDebugDrawDataInterface) == 0x000040, "Wrong size on UOptimusDebugDrawDataInterface");
static_assert(offsetof(UOptimusDebugDrawDataInterface, bIsSupported) == 0x000028, "Member 'UOptimusDebugDrawDataInterface::bIsSupported' has a wrong offset!");
static_assert(offsetof(UOptimusDebugDrawDataInterface, DebugDrawParameters) == 0x00002C, "Member 'UOptimusDebugDrawDataInterface::DebugDrawParameters' has a wrong offset!");

// Class OptimusCore.OptimusDebugDrawDataProvider
// 0x0020 (0x0048 - 0x0028)
class UOptimusDebugDrawDataProvider final : public UComputeDataProvider
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDebugDrawParameters            DebugDrawParameters;                               // 0x0030(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDebugDrawDataProvider">();
	}
	static class UOptimusDebugDrawDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDebugDrawDataProvider>();
	}
};
static_assert(alignof(UOptimusDebugDrawDataProvider) == 0x000008, "Wrong alignment on UOptimusDebugDrawDataProvider");
static_assert(sizeof(UOptimusDebugDrawDataProvider) == 0x000048, "Wrong size on UOptimusDebugDrawDataProvider");
static_assert(offsetof(UOptimusDebugDrawDataProvider, PrimitiveComponent) == 0x000028, "Member 'UOptimusDebugDrawDataProvider::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UOptimusDebugDrawDataProvider, DebugDrawParameters) == 0x000030, "Member 'UOptimusDebugDrawDataProvider::DebugDrawParameters' has a wrong offset!");

// Class OptimusCore.OptimusDuplicateVerticesDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusDuplicateVerticesDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDuplicateVerticesDataInterface">();
	}
	static class UOptimusDuplicateVerticesDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDuplicateVerticesDataInterface>();
	}
};
static_assert(alignof(UOptimusDuplicateVerticesDataInterface) == 0x000008, "Wrong alignment on UOptimusDuplicateVerticesDataInterface");
static_assert(sizeof(UOptimusDuplicateVerticesDataInterface) == 0x000028, "Wrong size on UOptimusDuplicateVerticesDataInterface");

// Class OptimusCore.OptimusDuplicateVerticesDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusDuplicateVerticesDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDuplicateVerticesDataProvider">();
	}
	static class UOptimusDuplicateVerticesDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDuplicateVerticesDataProvider>();
	}
};
static_assert(alignof(UOptimusDuplicateVerticesDataProvider) == 0x000008, "Wrong alignment on UOptimusDuplicateVerticesDataProvider");
static_assert(sizeof(UOptimusDuplicateVerticesDataProvider) == 0x000030, "Wrong size on UOptimusDuplicateVerticesDataProvider");
static_assert(offsetof(UOptimusDuplicateVerticesDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusDuplicateVerticesDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusMorphTargetDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusMorphTargetDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusMorphTargetDataProvider">();
	}
	static class UOptimusMorphTargetDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusMorphTargetDataProvider>();
	}
};
static_assert(alignof(UOptimusMorphTargetDataProvider) == 0x000008, "Wrong alignment on UOptimusMorphTargetDataProvider");
static_assert(sizeof(UOptimusMorphTargetDataProvider) == 0x000030, "Wrong size on UOptimusMorphTargetDataProvider");
static_assert(offsetof(UOptimusMorphTargetDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusMorphTargetDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusGraphDataInterface
// 0x0018 (0x0040 - 0x0028)
class UOptimusGraphDataInterface final : public UComputeDataInterface
{
public:
	TArray<struct FOptimusGraphVariableDescription> Variables;                                       // 0x0028(0x0010)(BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         ParameterBufferSize;                               // 0x0038(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusGraphDataInterface">();
	}
	static class UOptimusGraphDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusGraphDataInterface>();
	}
};
static_assert(alignof(UOptimusGraphDataInterface) == 0x000008, "Wrong alignment on UOptimusGraphDataInterface");
static_assert(sizeof(UOptimusGraphDataInterface) == 0x000040, "Wrong size on UOptimusGraphDataInterface");
static_assert(offsetof(UOptimusGraphDataInterface, Variables) == 0x000028, "Member 'UOptimusGraphDataInterface::Variables' has a wrong offset!");
static_assert(offsetof(UOptimusGraphDataInterface, ParameterBufferSize) == 0x000038, "Member 'UOptimusGraphDataInterface::ParameterBufferSize' has a wrong offset!");

// Class OptimusCore.OptimusGraphDataProvider
// 0x0040 (0x0068 - 0x0028)
class UOptimusGraphDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MeshComponent;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOptimusGraphVariableDescription> Variables;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusDeformerInstance*               DeformerInstance;                                  // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusGraphDataProvider">();
	}
	static class UOptimusGraphDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusGraphDataProvider>();
	}
};
static_assert(alignof(UOptimusGraphDataProvider) == 0x000008, "Wrong alignment on UOptimusGraphDataProvider");
static_assert(sizeof(UOptimusGraphDataProvider) == 0x000068, "Wrong size on UOptimusGraphDataProvider");
static_assert(offsetof(UOptimusGraphDataProvider, MeshComponent) == 0x000030, "Member 'UOptimusGraphDataProvider::MeshComponent' has a wrong offset!");
static_assert(offsetof(UOptimusGraphDataProvider, Variables) == 0x000038, "Member 'UOptimusGraphDataProvider::Variables' has a wrong offset!");
static_assert(offsetof(UOptimusGraphDataProvider, DeformerInstance) == 0x000060, "Member 'UOptimusGraphDataProvider::DeformerInstance' has a wrong offset!");

// Class OptimusCore.OptimusLoopTerminalDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusLoopTerminalDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusLoopTerminalDataProvider">();
	}
	static class UOptimusLoopTerminalDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusLoopTerminalDataProvider>();
	}
};
static_assert(alignof(UOptimusLoopTerminalDataProvider) == 0x000008, "Wrong alignment on UOptimusLoopTerminalDataProvider");
static_assert(sizeof(UOptimusLoopTerminalDataProvider) == 0x000030, "Wrong size on UOptimusLoopTerminalDataProvider");

// Class OptimusCore.OptimusMorphTargetDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusMorphTargetDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusMorphTargetDataInterface">();
	}
	static class UOptimusMorphTargetDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusMorphTargetDataInterface>();
	}
};
static_assert(alignof(UOptimusMorphTargetDataInterface) == 0x000008, "Wrong alignment on UOptimusMorphTargetDataInterface");
static_assert(sizeof(UOptimusMorphTargetDataInterface) == 0x000028, "Wrong size on UOptimusMorphTargetDataInterface");

// Class OptimusCore.OptimusTransientBufferDataInterface
// 0x0008 (0x0098 - 0x0090)
class UOptimusTransientBufferDataInterface final : public UOptimusRawBufferDataInterface
{
public:
	bool                                          bZeroInitForAtomicWrites;                          // 0x0090(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusTransientBufferDataInterface">();
	}
	static class UOptimusTransientBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusTransientBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusTransientBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusTransientBufferDataInterface");
static_assert(sizeof(UOptimusTransientBufferDataInterface) == 0x000098, "Wrong size on UOptimusTransientBufferDataInterface");
static_assert(offsetof(UOptimusTransientBufferDataInterface, bZeroInitForAtomicWrites) == 0x000090, "Member 'UOptimusTransientBufferDataInterface::bZeroInitForAtomicWrites' has a wrong offset!");

// Class OptimusCore.OptimusImplicitPersistentBufferDataInterface
// 0x0008 (0x0098 - 0x0090)
class UOptimusImplicitPersistentBufferDataInterface final : public UOptimusRawBufferDataInterface
{
public:
	bool                                          bZeroInitForAtomicWrites;                          // 0x0090(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusImplicitPersistentBufferDataInterface">();
	}
	static class UOptimusImplicitPersistentBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusImplicitPersistentBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusImplicitPersistentBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusImplicitPersistentBufferDataInterface");
static_assert(sizeof(UOptimusImplicitPersistentBufferDataInterface) == 0x000098, "Wrong size on UOptimusImplicitPersistentBufferDataInterface");
static_assert(offsetof(UOptimusImplicitPersistentBufferDataInterface, bZeroInitForAtomicWrites) == 0x000090, "Member 'UOptimusImplicitPersistentBufferDataInterface::bZeroInitForAtomicWrites' has a wrong offset!");

// Class OptimusCore.OptimusPersistentBufferDataInterface
// 0x0008 (0x0098 - 0x0090)
class UOptimusPersistentBufferDataInterface final : public UOptimusRawBufferDataInterface
{
public:
	class FName                                   ResourceName;                                      // 0x0090(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPersistentBufferDataInterface">();
	}
	static class UOptimusPersistentBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusPersistentBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusPersistentBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusPersistentBufferDataInterface");
static_assert(sizeof(UOptimusPersistentBufferDataInterface) == 0x000098, "Wrong size on UOptimusPersistentBufferDataInterface");
static_assert(offsetof(UOptimusPersistentBufferDataInterface, ResourceName) == 0x000090, "Member 'UOptimusPersistentBufferDataInterface::ResourceName' has a wrong offset!");

// Class OptimusCore.OptimusRawBufferDataProvider
// 0x0058 (0x0080 - 0x0028)
class UOptimusRawBufferDataProvider : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusRawBufferDataProvider">();
	}
	static class UOptimusRawBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusRawBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusRawBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusRawBufferDataProvider");
static_assert(sizeof(UOptimusRawBufferDataProvider) == 0x000080, "Wrong size on UOptimusRawBufferDataProvider");

// Class OptimusCore.OptimusTransientBufferDataProvider
// 0x0008 (0x0088 - 0x0080)
class UOptimusTransientBufferDataProvider final : public UOptimusRawBufferDataProvider
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusTransientBufferDataProvider">();
	}
	static class UOptimusTransientBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusTransientBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusTransientBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusTransientBufferDataProvider");
static_assert(sizeof(UOptimusTransientBufferDataProvider) == 0x000088, "Wrong size on UOptimusTransientBufferDataProvider");

// Class OptimusCore.OptimusImplicitPersistentBufferDataProvider
// 0x0028 (0x00A8 - 0x0080)
class UOptimusImplicitPersistentBufferDataProvider final : public UOptimusRawBufferDataProvider
{
public:
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusImplicitPersistentBufferDataProvider">();
	}
	static class UOptimusImplicitPersistentBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusImplicitPersistentBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusImplicitPersistentBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusImplicitPersistentBufferDataProvider");
static_assert(sizeof(UOptimusImplicitPersistentBufferDataProvider) == 0x0000A8, "Wrong size on UOptimusImplicitPersistentBufferDataProvider");

// Class OptimusCore.OptimusPersistentBufferDataProvider
// 0x0020 (0x00A0 - 0x0080)
class UOptimusPersistentBufferDataProvider final : public UOptimusRawBufferDataProvider
{
public:
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPersistentBufferDataProvider">();
	}
	static class UOptimusPersistentBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusPersistentBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusPersistentBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusPersistentBufferDataProvider");
static_assert(sizeof(UOptimusPersistentBufferDataProvider) == 0x0000A0, "Wrong size on UOptimusPersistentBufferDataProvider");

// Class OptimusCore.OptimusSceneDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSceneDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSceneDataInterface">();
	}
	static class UOptimusSceneDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSceneDataInterface>();
	}
};
static_assert(alignof(UOptimusSceneDataInterface) == 0x000008, "Wrong alignment on UOptimusSceneDataInterface");
static_assert(sizeof(UOptimusSceneDataInterface) == 0x000028, "Wrong size on UOptimusSceneDataInterface");

// Class OptimusCore.OptimusSceneDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusSceneDataProvider final : public UComputeDataProvider
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSceneDataProvider">();
	}
	static class UOptimusSceneDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSceneDataProvider>();
	}
};
static_assert(alignof(UOptimusSceneDataProvider) == 0x000008, "Wrong alignment on UOptimusSceneDataProvider");
static_assert(sizeof(UOptimusSceneDataProvider) == 0x000030, "Wrong size on UOptimusSceneDataProvider");
static_assert(offsetof(UOptimusSceneDataProvider, SceneComponent) == 0x000028, "Member 'UOptimusSceneDataProvider::SceneComponent' has a wrong offset!");

// Class OptimusCore.OptimusSkeletonDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkeletonDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkeletonDataInterface">();
	}
	static class UOptimusSkeletonDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkeletonDataInterface>();
	}
};
static_assert(alignof(UOptimusSkeletonDataInterface) == 0x000008, "Wrong alignment on UOptimusSkeletonDataInterface");
static_assert(sizeof(UOptimusSkeletonDataInterface) == 0x000028, "Wrong size on UOptimusSkeletonDataInterface");

// Class OptimusCore.OptimusSkeletonDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkeletonDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkeletonDataProvider">();
	}
	static class UOptimusSkeletonDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkeletonDataProvider>();
	}
};
static_assert(alignof(UOptimusSkeletonDataProvider) == 0x000008, "Wrong alignment on UOptimusSkeletonDataProvider");
static_assert(sizeof(UOptimusSkeletonDataProvider) == 0x000030, "Wrong size on UOptimusSkeletonDataProvider");
static_assert(offsetof(UOptimusSkeletonDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkeletonDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkinnedMeshDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshDataInterface">();
	}
	static class UOptimusSkinnedMeshDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshDataInterface) == 0x000028, "Wrong size on UOptimusSkinnedMeshDataInterface");

// Class OptimusCore.OptimusSkinnedMeshDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkinnedMeshDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshDataProvider">();
	}
	static class UOptimusSkinnedMeshDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshDataProvider) == 0x000030, "Wrong size on UOptimusSkinnedMeshDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkinnedMeshDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshExecDataInterface
// 0x0010 (0x0038 - 0x0028)
class UOptimusSkinnedMeshExecDataInterface final : public UOptimusComputeDataInterface
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusSkinnedMeshExecDomain                 Domain;                                            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshExecDataInterface">();
	}
	static class UOptimusSkinnedMeshExecDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshExecDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshExecDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshExecDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshExecDataInterface) == 0x000038, "Wrong size on UOptimusSkinnedMeshExecDataInterface");
static_assert(offsetof(UOptimusSkinnedMeshExecDataInterface, Domain) == 0x000030, "Member 'UOptimusSkinnedMeshExecDataInterface::Domain' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshExecDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusSkinnedMeshExecDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptimusSkinnedMeshExecDomain                 Domain;                                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshExecDataProvider">();
	}
	static class UOptimusSkinnedMeshExecDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshExecDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshExecDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshExecDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshExecDataProvider) == 0x000038, "Wrong size on UOptimusSkinnedMeshExecDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshExecDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkinnedMeshExecDataProvider::SkinnedMesh' has a wrong offset!");
static_assert(offsetof(UOptimusSkinnedMeshExecDataProvider, Domain) == 0x000030, "Member 'UOptimusSkinnedMeshExecDataProvider::Domain' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshReadDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkinnedMeshReadDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshReadDataInterface">();
	}
	static class UOptimusSkinnedMeshReadDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshReadDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshReadDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshReadDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshReadDataInterface) == 0x000028, "Wrong size on UOptimusSkinnedMeshReadDataInterface");

// Class OptimusCore.OptimusSkinnedMeshReadDataProvider
// 0x0028 (0x0050 - 0x0028)
class UOptimusSkinnedMeshReadDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusDeformerInstance*               DeformerInstance;                                  // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshReadDataProvider">();
	}
	static class UOptimusSkinnedMeshReadDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshReadDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshReadDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshReadDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshReadDataProvider) == 0x000050, "Wrong size on UOptimusSkinnedMeshReadDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshReadDataProvider, SkinnedMesh) == 0x000030, "Member 'UOptimusSkinnedMeshReadDataProvider::SkinnedMesh' has a wrong offset!");
static_assert(offsetof(UOptimusSkinnedMeshReadDataProvider, DeformerInstance) == 0x000048, "Member 'UOptimusSkinnedMeshReadDataProvider::DeformerInstance' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshWriteDataProvider
// 0x0018 (0x0040 - 0x0028)
class UOptimusSkinnedMeshWriteDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshWriteDataProvider">();
	}
	static class UOptimusSkinnedMeshWriteDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshWriteDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshWriteDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshWriteDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshWriteDataProvider) == 0x000040, "Wrong size on UOptimusSkinnedMeshWriteDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshWriteDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkinnedMeshWriteDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusNode_DataInterface
// 0x0030 (0x0138 - 0x0108)
class UOptimusNode_DataInterface : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    DataInterfaceClass;                                // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptimusComputeDataInterface*           DataInterfaceData;                                 // 0x0130(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_DataInterface">();
	}
	static class UOptimusNode_DataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_DataInterface>();
	}
};
static_assert(alignof(UOptimusNode_DataInterface) == 0x000008, "Wrong alignment on UOptimusNode_DataInterface");
static_assert(sizeof(UOptimusNode_DataInterface) == 0x000138, "Wrong size on UOptimusNode_DataInterface");
static_assert(offsetof(UOptimusNode_DataInterface, DataInterfaceClass) == 0x000128, "Member 'UOptimusNode_DataInterface::DataInterfaceClass' has a wrong offset!");
static_assert(offsetof(UOptimusNode_DataInterface, DataInterfaceData) == 0x000130, "Member 'UOptimusNode_DataInterface::DataInterfaceData' has a wrong offset!");

// Class OptimusCore.OptimusNode_AnimAttributeDataInterface
// 0x0000 (0x0138 - 0x0138)
class UOptimusNode_AnimAttributeDataInterface final : public UOptimusNode_DataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_AnimAttributeDataInterface">();
	}
	static class UOptimusNode_AnimAttributeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_AnimAttributeDataInterface>();
	}
};
static_assert(alignof(UOptimusNode_AnimAttributeDataInterface) == 0x000008, "Wrong alignment on UOptimusNode_AnimAttributeDataInterface");
static_assert(sizeof(UOptimusNode_AnimAttributeDataInterface) == 0x000138, "Wrong size on UOptimusNode_AnimAttributeDataInterface");

// Class OptimusCore.OptimusNode_ComponentSource
// 0x0028 (0x0130 - 0x0108)
class UOptimusNode_ComponentSource final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusComponentSourceBinding*         Binding;                                           // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOptimusNode_ComponentSource_DuplicationInfo DuplicationInfo;                             // 0x0120(0x0010)(DuplicateTransient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComponentSource">();
	}
	static class UOptimusNode_ComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComponentSource>();
	}
};
static_assert(alignof(UOptimusNode_ComponentSource) == 0x000008, "Wrong alignment on UOptimusNode_ComponentSource");
static_assert(sizeof(UOptimusNode_ComponentSource) == 0x000130, "Wrong size on UOptimusNode_ComponentSource");
static_assert(offsetof(UOptimusNode_ComponentSource, Binding) == 0x000118, "Member 'UOptimusNode_ComponentSource::Binding' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComponentSource, DuplicationInfo) == 0x000120, "Member 'UOptimusNode_ComponentSource::DuplicationInfo' has a wrong offset!");

// Class OptimusCore.OptimusNode_ComputeKernelFunctionGeneratorClass
// 0x0070 (0x0270 - 0x0200)
class UOptimusNode_ComputeKernelFunctionGeneratorClass final : public UClass
{
public:
	class FName                                   Category;                                          // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KernelName;                                        // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusExecutionDomain                ExecutionDomain;                                   // 0x0210(0x0020)(NativeAccessSpecifierPublic)
	struct FIntVector                             GroupSize;                                         // 0x0230(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimusParameterBinding>       InputBindings;                                     // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       OutputBindings;                                    // 0x0250(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ShaderSource;                                      // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComputeKernelFunctionGeneratorClass">();
	}
	static class UOptimusNode_ComputeKernelFunctionGeneratorClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComputeKernelFunctionGeneratorClass>();
	}
};
static_assert(alignof(UOptimusNode_ComputeKernelFunctionGeneratorClass) == 0x000008, "Wrong alignment on UOptimusNode_ComputeKernelFunctionGeneratorClass");
static_assert(sizeof(UOptimusNode_ComputeKernelFunctionGeneratorClass) == 0x000270, "Wrong size on UOptimusNode_ComputeKernelFunctionGeneratorClass");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, Category) == 0x000200, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::Category' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, KernelName) == 0x000208, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::KernelName' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, ExecutionDomain) == 0x000210, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::ExecutionDomain' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, GroupSize) == 0x000230, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::GroupSize' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, InputBindings) == 0x000240, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::InputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, OutputBindings) == 0x000250, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::OutputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, ShaderSource) == 0x000260, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::ShaderSource' has a wrong offset!");

// Class OptimusCore.OptimusNode_ComputeKernelFunction
// 0x0000 (0x0110 - 0x0110)
class UOptimusNode_ComputeKernelFunction final : public UOptimusNode_ComputeKernelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComputeKernelFunction">();
	}
	static class UOptimusNode_ComputeKernelFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComputeKernelFunction>();
	}
};
static_assert(alignof(UOptimusNode_ComputeKernelFunction) == 0x000008, "Wrong alignment on UOptimusNode_ComputeKernelFunction");
static_assert(sizeof(UOptimusNode_ComputeKernelFunction) == 0x000110, "Wrong size on UOptimusNode_ComputeKernelFunction");

// Class OptimusCore.OptimusNode_ConstantValueGeneratorClass
// 0x0030 (0x0230 - 0x0200)
class UOptimusNode_ConstantValueGeneratorClass final : public UClass
{
public:
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0200(0x0030)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ConstantValueGeneratorClass">();
	}
	static class UOptimusNode_ConstantValueGeneratorClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ConstantValueGeneratorClass>();
	}
};
static_assert(alignof(UOptimusNode_ConstantValueGeneratorClass) == 0x000008, "Wrong alignment on UOptimusNode_ConstantValueGeneratorClass");
static_assert(sizeof(UOptimusNode_ConstantValueGeneratorClass) == 0x000230, "Wrong size on UOptimusNode_ConstantValueGeneratorClass");
static_assert(offsetof(UOptimusNode_ConstantValueGeneratorClass, DataType) == 0x000200, "Member 'UOptimusNode_ConstantValueGeneratorClass::DataType' has a wrong offset!");

// Class OptimusCore.OptimusNode_ConstantValue
// 0x0018 (0x0120 - 0x0108)
class UOptimusNode_ConstantValue final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ConstantValue">();
	}
	static class UOptimusNode_ConstantValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ConstantValue>();
	}
};
static_assert(alignof(UOptimusNode_ConstantValue) == 0x000008, "Wrong alignment on UOptimusNode_ConstantValue");
static_assert(sizeof(UOptimusNode_ConstantValue) == 0x000120, "Wrong size on UOptimusNode_ConstantValue");

// Class OptimusCore.OptimusNode_CustomComputeKernel
// 0x00F0 (0x0200 - 0x0110)
class UOptimusNode_CustomComputeKernel final : public UOptimusNode_ComputeKernelBase
{
public:
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Category;                                          // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusValidatedName                  KernelName;                                        // 0x0138(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptimusExecutionDomain                ExecutionDomain;                                   // 0x0140(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FIntVector                             GroupSize;                                         // 0x0160(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimus_ShaderBinding>         Parameters;                                        // 0x0170(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       InputBindings;                                     // 0x0180(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       OutputBindings;                                    // 0x0190(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	struct FOptimusParameterBindingArray          InputBindingArray;                                 // 0x01A0(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FOptimusParameterBindingArray          OutputBindingArray;                                // 0x01B0(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FOptimusSecondaryInputBindingsGroup> SecondaryInputBindingGroups;                  // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UComputeSource*>                 AdditionalSources;                                 // 0x01D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FOptimusShaderText                     ShaderSource;                                      // 0x01E0(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_CustomComputeKernel">();
	}
	static class UOptimusNode_CustomComputeKernel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_CustomComputeKernel>();
	}
};
static_assert(alignof(UOptimusNode_CustomComputeKernel) == 0x000008, "Wrong alignment on UOptimusNode_CustomComputeKernel");
static_assert(sizeof(UOptimusNode_CustomComputeKernel) == 0x000200, "Wrong size on UOptimusNode_CustomComputeKernel");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, Category) == 0x000130, "Member 'UOptimusNode_CustomComputeKernel::Category' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, KernelName) == 0x000138, "Member 'UOptimusNode_CustomComputeKernel::KernelName' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, ExecutionDomain) == 0x000140, "Member 'UOptimusNode_CustomComputeKernel::ExecutionDomain' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, GroupSize) == 0x000160, "Member 'UOptimusNode_CustomComputeKernel::GroupSize' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, Parameters) == 0x000170, "Member 'UOptimusNode_CustomComputeKernel::Parameters' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, InputBindings) == 0x000180, "Member 'UOptimusNode_CustomComputeKernel::InputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, OutputBindings) == 0x000190, "Member 'UOptimusNode_CustomComputeKernel::OutputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, InputBindingArray) == 0x0001A0, "Member 'UOptimusNode_CustomComputeKernel::InputBindingArray' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, OutputBindingArray) == 0x0001B0, "Member 'UOptimusNode_CustomComputeKernel::OutputBindingArray' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, SecondaryInputBindingGroups) == 0x0001C0, "Member 'UOptimusNode_CustomComputeKernel::SecondaryInputBindingGroups' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, AdditionalSources) == 0x0001D0, "Member 'UOptimusNode_CustomComputeKernel::AdditionalSources' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, ShaderSource) == 0x0001E0, "Member 'UOptimusNode_CustomComputeKernel::ShaderSource' has a wrong offset!");

// Class OptimusCore.OptimusNode_FunctionReference
// 0x0048 (0x0150 - 0x0108)
class UOptimusNode_FunctionReference final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOptimusFunctionNodeGraph> FunctionGraph;                                   // 0x0120(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UOptimusNodePin>         DefaultComponentPin;                               // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_FunctionReference">();
	}
	static class UOptimusNode_FunctionReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_FunctionReference>();
	}
};
static_assert(alignof(UOptimusNode_FunctionReference) == 0x000008, "Wrong alignment on UOptimusNode_FunctionReference");
static_assert(sizeof(UOptimusNode_FunctionReference) == 0x000150, "Wrong size on UOptimusNode_FunctionReference");
static_assert(offsetof(UOptimusNode_FunctionReference, FunctionGraph) == 0x000120, "Member 'UOptimusNode_FunctionReference::FunctionGraph' has a wrong offset!");
static_assert(offsetof(UOptimusNode_FunctionReference, DefaultComponentPin) == 0x000148, "Member 'UOptimusNode_FunctionReference::DefaultComponentPin' has a wrong offset!");

// Class OptimusCore.OptimusNode_ResourceAccessorBase
// 0x00A8 (0x01B0 - 0x0108)
class UOptimusNode_ResourceAccessorBase : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOptimusResourceDescription> ResourceDesc;                                  // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOptimusBufferWriteType                       WriteType;                                         // 0x0130(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusNode_ResourceAccessorBase_DuplicationInfo DuplicationInfo;                        // 0x0138(0x0078)(DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ResourceAccessorBase">();
	}
	static class UOptimusNode_ResourceAccessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ResourceAccessorBase>();
	}
};
static_assert(alignof(UOptimusNode_ResourceAccessorBase) == 0x000008, "Wrong alignment on UOptimusNode_ResourceAccessorBase");
static_assert(sizeof(UOptimusNode_ResourceAccessorBase) == 0x0001B0, "Wrong size on UOptimusNode_ResourceAccessorBase");
static_assert(offsetof(UOptimusNode_ResourceAccessorBase, ResourceDesc) == 0x000128, "Member 'UOptimusNode_ResourceAccessorBase::ResourceDesc' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ResourceAccessorBase, WriteType) == 0x000130, "Member 'UOptimusNode_ResourceAccessorBase::WriteType' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ResourceAccessorBase, DuplicationInfo) == 0x000138, "Member 'UOptimusNode_ResourceAccessorBase::DuplicationInfo' has a wrong offset!");

// Class OptimusCore.OptimusNode_GetResource
// 0x0000 (0x01B0 - 0x01B0)
class UOptimusNode_GetResource final : public UOptimusNode_ResourceAccessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_GetResource">();
	}
	static class UOptimusNode_GetResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_GetResource>();
	}
};
static_assert(alignof(UOptimusNode_GetResource) == 0x000008, "Wrong alignment on UOptimusNode_GetResource");
static_assert(sizeof(UOptimusNode_GetResource) == 0x0001B0, "Wrong size on UOptimusNode_GetResource");

// Class OptimusCore.OptimusNode_GetVariable
// 0x0068 (0x0170 - 0x0108)
class UOptimusNode_GetVariable final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOptimusVariableDescription> VariableDesc;                                  // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOptimusNode_GetVariable_DuplicationInfo DuplicationInfo;                                 // 0x0128(0x0048)(DuplicateTransient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_GetVariable">();
	}
	static class UOptimusNode_GetVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_GetVariable>();
	}
};
static_assert(alignof(UOptimusNode_GetVariable) == 0x000008, "Wrong alignment on UOptimusNode_GetVariable");
static_assert(sizeof(UOptimusNode_GetVariable) == 0x000170, "Wrong size on UOptimusNode_GetVariable");
static_assert(offsetof(UOptimusNode_GetVariable, VariableDesc) == 0x000120, "Member 'UOptimusNode_GetVariable::VariableDesc' has a wrong offset!");
static_assert(offsetof(UOptimusNode_GetVariable, DuplicationInfo) == 0x000128, "Member 'UOptimusNode_GetVariable::DuplicationInfo' has a wrong offset!");

// Class OptimusCore.OptimusNode_GraphTerminal
// 0x0038 (0x0140 - 0x0108)
class UOptimusNode_GraphTerminal final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusTerminalType                          TerminalType;                                      // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UOptimusNodePin>         DefaultComponentPin;                               // 0x012C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_GraphTerminal">();
	}
	static class UOptimusNode_GraphTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_GraphTerminal>();
	}
};
static_assert(alignof(UOptimusNode_GraphTerminal) == 0x000008, "Wrong alignment on UOptimusNode_GraphTerminal");
static_assert(sizeof(UOptimusNode_GraphTerminal) == 0x000140, "Wrong size on UOptimusNode_GraphTerminal");
static_assert(offsetof(UOptimusNode_GraphTerminal, TerminalType) == 0x000128, "Member 'UOptimusNode_GraphTerminal::TerminalType' has a wrong offset!");
static_assert(offsetof(UOptimusNode_GraphTerminal, DefaultComponentPin) == 0x00012C, "Member 'UOptimusNode_GraphTerminal::DefaultComponentPin' has a wrong offset!");

// Class OptimusCore.OptimusNode_LoopTerminal
// 0x0068 (0x0170 - 0x0108)
class UOptimusNode_LoopTerminal final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusTerminalType                          TerminalType;                                      // 0x0130(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusLoopTerminalInfo               LoopInfo;                                          // 0x0138(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class UOptimusNodePin*                        IndexPin;                                          // 0x0150(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptimusNodePin*                        CountPin;                                          // 0x0158(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOptimusPinPairInfo>            PinPairInfos;                                      // 0x0160(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_LoopTerminal">();
	}
	static class UOptimusNode_LoopTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_LoopTerminal>();
	}
};
static_assert(alignof(UOptimusNode_LoopTerminal) == 0x000008, "Wrong alignment on UOptimusNode_LoopTerminal");
static_assert(sizeof(UOptimusNode_LoopTerminal) == 0x000170, "Wrong size on UOptimusNode_LoopTerminal");
static_assert(offsetof(UOptimusNode_LoopTerminal, TerminalType) == 0x000130, "Member 'UOptimusNode_LoopTerminal::TerminalType' has a wrong offset!");
static_assert(offsetof(UOptimusNode_LoopTerminal, LoopInfo) == 0x000138, "Member 'UOptimusNode_LoopTerminal::LoopInfo' has a wrong offset!");
static_assert(offsetof(UOptimusNode_LoopTerminal, IndexPin) == 0x000150, "Member 'UOptimusNode_LoopTerminal::IndexPin' has a wrong offset!");
static_assert(offsetof(UOptimusNode_LoopTerminal, CountPin) == 0x000158, "Member 'UOptimusNode_LoopTerminal::CountPin' has a wrong offset!");
static_assert(offsetof(UOptimusNode_LoopTerminal, PinPairInfos) == 0x000160, "Member 'UOptimusNode_LoopTerminal::PinPairInfos' has a wrong offset!");

// Class OptimusCore.OptimusNode_Resource
// 0x0000 (0x01B0 - 0x01B0)
class UOptimusNode_Resource final : public UOptimusNode_ResourceAccessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_Resource">();
	}
	static class UOptimusNode_Resource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_Resource>();
	}
};
static_assert(alignof(UOptimusNode_Resource) == 0x000008, "Wrong alignment on UOptimusNode_Resource");
static_assert(sizeof(UOptimusNode_Resource) == 0x0001B0, "Wrong size on UOptimusNode_Resource");

// Class OptimusCore.OptimusNode_SetResource
// 0x0000 (0x01B0 - 0x01B0)
class UOptimusNode_SetResource final : public UOptimusNode_ResourceAccessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_SetResource">();
	}
	static class UOptimusNode_SetResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_SetResource>();
	}
};
static_assert(alignof(UOptimusNode_SetResource) == 0x000008, "Wrong alignment on UOptimusNode_SetResource");
static_assert(sizeof(UOptimusNode_SetResource) == 0x0001B0, "Wrong size on UOptimusNode_SetResource");

// Class OptimusCore.OptimusNode_SubGraphReference
// 0x0030 (0x0138 - 0x0108)
class UOptimusNode_SubGraphReference final : public UOptimusNode
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SubgraphName;                                      // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UOptimusNodePin>         DefaultComponentPin;                               // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_SubGraphReference">();
	}
	static class UOptimusNode_SubGraphReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_SubGraphReference>();
	}
};
static_assert(alignof(UOptimusNode_SubGraphReference) == 0x000008, "Wrong alignment on UOptimusNode_SubGraphReference");
static_assert(sizeof(UOptimusNode_SubGraphReference) == 0x000138, "Wrong size on UOptimusNode_SubGraphReference");
static_assert(offsetof(UOptimusNode_SubGraphReference, SubgraphName) == 0x000120, "Member 'UOptimusNode_SubGraphReference::SubgraphName' has a wrong offset!");
static_assert(offsetof(UOptimusNode_SubGraphReference, DefaultComponentPin) == 0x000128, "Member 'UOptimusNode_SubGraphReference::DefaultComponentPin' has a wrong offset!");

// Class OptimusCore.OptimusActionStack
// 0x00B8 (0x00E0 - 0x0028)
class UOptimusActionStack final : public UObject
{
public:
	int32                                         TransactedActionIndex;                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0xB4];                                      // 0x002C(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusActionStack">();
	}
	static class UOptimusActionStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusActionStack>();
	}
};
static_assert(alignof(UOptimusActionStack) == 0x000008, "Wrong alignment on UOptimusActionStack");
static_assert(sizeof(UOptimusActionStack) == 0x0000E0, "Wrong size on UOptimusActionStack");
static_assert(offsetof(UOptimusActionStack, TransactedActionIndex) == 0x000028, "Member 'UOptimusActionStack::TransactedActionIndex' has a wrong offset!");

// Class OptimusCore.OptimusComponentSourceBinding
// 0x0028 (0x0050 - 0x0028)
class UOptimusComponentSourceBinding final : public UObject
{
public:
	class FName                                   BindingName;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOptimusComponentSource>    ComponentType;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ComponentTags;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsPrimaryBinding;                                 // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentSourceBinding">();
	}
	static class UOptimusComponentSourceBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComponentSourceBinding>();
	}
};
static_assert(alignof(UOptimusComponentSourceBinding) == 0x000008, "Wrong alignment on UOptimusComponentSourceBinding");
static_assert(sizeof(UOptimusComponentSourceBinding) == 0x000050, "Wrong size on UOptimusComponentSourceBinding");
static_assert(offsetof(UOptimusComponentSourceBinding, BindingName) == 0x000028, "Member 'UOptimusComponentSourceBinding::BindingName' has a wrong offset!");
static_assert(offsetof(UOptimusComponentSourceBinding, ComponentType) == 0x000030, "Member 'UOptimusComponentSourceBinding::ComponentType' has a wrong offset!");
static_assert(offsetof(UOptimusComponentSourceBinding, ComponentTags) == 0x000038, "Member 'UOptimusComponentSourceBinding::ComponentTags' has a wrong offset!");
static_assert(offsetof(UOptimusComponentSourceBinding, bIsPrimaryBinding) == 0x000048, "Member 'UOptimusComponentSourceBinding::bIsPrimaryBinding' has a wrong offset!");

// Class OptimusCore.OptimusComputeGraph
// 0x0010 (0x00F0 - 0x00E0)
class UOptimusComputeGraph final : public UComputeGraph
{
public:
	TArray<TWeakObjectPtr<class UOptimusNode>>    KernelToNode;                                      // 0x00E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeGraph">();
	}
	static class UOptimusComputeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComputeGraph>();
	}
};
static_assert(alignof(UOptimusComputeGraph) == 0x000008, "Wrong alignment on UOptimusComputeGraph");
static_assert(sizeof(UOptimusComputeGraph) == 0x0000F0, "Wrong size on UOptimusComputeGraph");
static_assert(offsetof(UOptimusComputeGraph, KernelToNode) == 0x0000E0, "Member 'UOptimusComputeGraph::KernelToNode' has a wrong offset!");

// Class OptimusCore.OptimusComponentSourceBindingContainer
// 0x0010 (0x0038 - 0x0028)
class UOptimusComponentSourceBindingContainer final : public UObject
{
public:
	TArray<class UOptimusComponentSourceBinding*> Bindings;                                          // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentSourceBindingContainer">();
	}
	static class UOptimusComponentSourceBindingContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComponentSourceBindingContainer>();
	}
};
static_assert(alignof(UOptimusComponentSourceBindingContainer) == 0x000008, "Wrong alignment on UOptimusComponentSourceBindingContainer");
static_assert(sizeof(UOptimusComponentSourceBindingContainer) == 0x000038, "Wrong size on UOptimusComponentSourceBindingContainer");
static_assert(offsetof(UOptimusComponentSourceBindingContainer, Bindings) == 0x000028, "Member 'UOptimusComponentSourceBindingContainer::Bindings' has a wrong offset!");

// Class OptimusCore.OptimusVariableContainer
// 0x0010 (0x0038 - 0x0028)
class UOptimusVariableContainer final : public UObject
{
public:
	TArray<class UOptimusVariableDescription*>    Descriptions;                                      // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusVariableContainer">();
	}
	static class UOptimusVariableContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusVariableContainer>();
	}
};
static_assert(alignof(UOptimusVariableContainer) == 0x000008, "Wrong alignment on UOptimusVariableContainer");
static_assert(sizeof(UOptimusVariableContainer) == 0x000038, "Wrong size on UOptimusVariableContainer");
static_assert(offsetof(UOptimusVariableContainer, Descriptions) == 0x000028, "Member 'UOptimusVariableContainer::Descriptions' has a wrong offset!");

// Class OptimusCore.OptimusResourceContainer
// 0x0010 (0x0038 - 0x0028)
class UOptimusResourceContainer final : public UObject
{
public:
	TArray<class UOptimusResourceDescription*>    Descriptions;                                      // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusResourceContainer">();
	}
	static class UOptimusResourceContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusResourceContainer>();
	}
};
static_assert(alignof(UOptimusResourceContainer) == 0x000008, "Wrong alignment on UOptimusResourceContainer");
static_assert(sizeof(UOptimusResourceContainer) == 0x000038, "Wrong size on UOptimusResourceContainer");
static_assert(offsetof(UOptimusResourceContainer, Descriptions) == 0x000028, "Member 'UOptimusResourceContainer::Descriptions' has a wrong offset!");

// Class OptimusCore.OptimusDeformer
// 0x01A0 (0x01C8 - 0x0028)
class UOptimusDeformer final : public UMeshDeformer
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Mesh;                                              // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOptimusComputeGraphInfo>       ComputeGraphs;                                     // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class UComputeDataInterface>, struct FOptimusDataInterfacePropertyOverrideInfo> DataInterfacePropertyOverrideMap; // 0x0060(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FOptimusValueIdentifier, struct FOptimusValueDescription> ValueMap;                  // 0x00B0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UOptimusActionStack*                    ActionStack;                                       // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOptimusDeformerStatus                        Status;                                            // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOptimusNodeGraph*>              Graphs;                                            // 0x0110(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UOptimusComponentSourceBindingContainer* Bindings;                                         // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOptimusVariableContainer*              Variables;                                         // 0x0128(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOptimusResourceContainer*              Resources;                                         // 0x0130(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x90];                                     // 0x0138(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class UOptimusComponentSourceBinding*> GetComponentBindings() const;
	class UOptimusComponentSourceBinding* GetPrimaryComponentBinding() const;
	const TArray<class UOptimusResourceDescription*> GetResources() const;
	const TArray<class UOptimusVariableDescription*> GetVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformer">();
	}
	static class UOptimusDeformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformer>();
	}
};
static_assert(alignof(UOptimusDeformer) == 0x000008, "Wrong alignment on UOptimusDeformer");
static_assert(sizeof(UOptimusDeformer) == 0x0001C8, "Wrong size on UOptimusDeformer");
static_assert(offsetof(UOptimusDeformer, Mesh) == 0x000048, "Member 'UOptimusDeformer::Mesh' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, ComputeGraphs) == 0x000050, "Member 'UOptimusDeformer::ComputeGraphs' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, DataInterfacePropertyOverrideMap) == 0x000060, "Member 'UOptimusDeformer::DataInterfacePropertyOverrideMap' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, ValueMap) == 0x0000B0, "Member 'UOptimusDeformer::ValueMap' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, ActionStack) == 0x000100, "Member 'UOptimusDeformer::ActionStack' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Status) == 0x000108, "Member 'UOptimusDeformer::Status' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Graphs) == 0x000110, "Member 'UOptimusDeformer::Graphs' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Bindings) == 0x000120, "Member 'UOptimusDeformer::Bindings' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Variables) == 0x000128, "Member 'UOptimusDeformer::Variables' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Resources) == 0x000130, "Member 'UOptimusDeformer::Resources' has a wrong offset!");

// Class OptimusCore.OptimusDeformerInstanceSettings
// 0x0018 (0x0040 - 0x0028)
class UOptimusDeformerInstanceSettings final : public UMeshDeformerInstanceSettings
{
public:
	TWeakObjectPtr<class UOptimusDeformer>        Deformer;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOptimusDeformerInstanceComponentBinding> Bindings;                                // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformerInstanceSettings">();
	}
	static class UOptimusDeformerInstanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformerInstanceSettings>();
	}
};
static_assert(alignof(UOptimusDeformerInstanceSettings) == 0x000008, "Wrong alignment on UOptimusDeformerInstanceSettings");
static_assert(sizeof(UOptimusDeformerInstanceSettings) == 0x000040, "Wrong size on UOptimusDeformerInstanceSettings");
static_assert(offsetof(UOptimusDeformerInstanceSettings, Deformer) == 0x000028, "Member 'UOptimusDeformerInstanceSettings::Deformer' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstanceSettings, Bindings) == 0x000030, "Member 'UOptimusDeformerInstanceSettings::Bindings' has a wrong offset!");

// Class OptimusCore.OptimusDeformerInstance
// 0x0180 (0x01A8 - 0x0028)
class UOptimusDeformerInstance final : public UMeshDeformerInstance
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UMeshComponent>          MeshComponent;                                     // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UOptimusDeformerInstanceSettings> InstanceSettings;                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOptimusDeformerInstanceExecInfo> ComputeGraphExecInfos;                           // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x158];                                     // 0x0050(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EnqueueTriggerGraph(class FName InTriggerGraphName);
	bool SetBoolArrayVariable(class FName InVariableName, const TArray<bool>& InValue);
	bool SetBoolVariable(class FName InVariableName, bool InValue);
	bool SetFloatArrayVariable(class FName InVariableName, const TArray<double>& InValue);
	bool SetFloatVariable(class FName InVariableName, double InValue);
	bool SetInt2ArrayVariable(class FName InVariableName, const TArray<struct FIntPoint>& InValue);
	bool SetInt2Variable(class FName InVariableName, const struct FIntPoint& InValue);
	bool SetInt3ArrayVariable(class FName InVariableName, const TArray<struct FIntVector>& InValue);
	bool SetInt3Variable(class FName InVariableName, const struct FIntVector& InValue);
	bool SetInt4ArrayVariable(class FName InVariableName, const TArray<struct FIntVector4>& InValue);
	bool SetInt4Variable(class FName InVariableName, const struct FIntVector4& InValue);
	bool SetIntArrayVariable(class FName InVariableName, const TArray<int32>& InValue);
	bool SetIntVariable(class FName InVariableName, int32 InValue);
	bool SetLinearColorArrayVariable(class FName InVariableName, const TArray<struct FLinearColor>& InValue);
	bool SetLinearColorVariable(class FName InVariableName, const struct FLinearColor& InValue);
	bool SetNameArrayVariable(class FName InVariableName, const TArray<class FName>& InValue);
	bool SetNameVariable(class FName InVariableName, const class FName& InValue);
	bool SetQuatArrayVariable(class FName InVariableName, const TArray<struct FQuat>& InValue);
	bool SetQuatVariable(class FName InVariableName, const struct FQuat& InValue);
	bool SetRotatorArrayVariable(class FName InVariableName, const TArray<struct FRotator>& InValue);
	bool SetRotatorVariable(class FName InVariableName, const struct FRotator& InValue);
	bool SetTransformArrayVariable(class FName InVariableName, const TArray<struct FTransform>& InValue);
	bool SetTransformVariable(class FName InVariableName, const struct FTransform& InValue);
	bool SetVector2ArrayVariable(class FName InVariableName, const TArray<struct FVector2D>& InValue);
	bool SetVector2Variable(class FName InVariableName, const struct FVector2D& InValue);
	bool SetVector4ArrayVariable(class FName InVariableName, const TArray<struct FVector4>& InValue);
	bool SetVector4Variable(class FName InVariableName, const struct FVector4& InValue);
	bool SetVectorArrayVariable(class FName InVariableName, const TArray<struct FVector>& InValue);
	bool SetVectorVariable(class FName InVariableName, const struct FVector& InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformerInstance">();
	}
	static class UOptimusDeformerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformerInstance>();
	}
};
static_assert(alignof(UOptimusDeformerInstance) == 0x000008, "Wrong alignment on UOptimusDeformerInstance");
static_assert(sizeof(UOptimusDeformerInstance) == 0x0001A8, "Wrong size on UOptimusDeformerInstance");
static_assert(offsetof(UOptimusDeformerInstance, MeshComponent) == 0x000030, "Member 'UOptimusDeformerInstance::MeshComponent' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstance, InstanceSettings) == 0x000038, "Member 'UOptimusDeformerInstance::InstanceSettings' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstance, ComputeGraphExecInfos) == 0x000040, "Member 'UOptimusDeformerInstance::ComputeGraphExecInfos' has a wrong offset!");

// Class OptimusCore.OptimusNodeGraph
// 0x0068 (0x0090 - 0x0028)
class UOptimusNodeGraph : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusNodeGraphType                         GraphType;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOptimusNode*>                   Nodes;                                             // 0x0038(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodeLink*>               Links;                                             // 0x0048(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodePair*>               NodePairs;                                         // 0x0058(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodeGraph*>              Subgraphs;                                         // 0x0068(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOptimusNode* AddComponentBindingGetNode(class UOptimusComponentSourceBinding* InComponentBinding, const struct FVector2D& InPosition);
	class UOptimusNode* AddDataInterfaceNode(const TSubclassOf<class UOptimusComputeDataInterface> InDataInterfaceClass, const struct FVector2D& InPosition);
	class UOptimusNode* AddFunctionReferenceNode(TSoftObjectPtr<class UOptimusFunctionNodeGraph> InFunctionGraph, const struct FVector2D& InPosition);
	bool AddLink(class UOptimusNodePin* InNodeOutputPin, class UOptimusNodePin* InNodeInputPin);
	TArray<class UOptimusNode*> AddLoopTerminalNodes(const struct FVector2D& InPosition);
	class UOptimusNode* AddNode(const TSubclassOf<class UOptimusNode> InNodeClass, const struct FVector2D& InPosition);
	class UOptimusNode* AddResourceGetNode(class UOptimusResourceDescription* InResourceDesc, const struct FVector2D& InPosition);
	class UOptimusNode* AddResourceNode(class UOptimusResourceDescription* InResourceDesc, const struct FVector2D& InPosition);
	class UOptimusNode* AddResourceSetNode(class UOptimusResourceDescription* InResourceDesc, const struct FVector2D& InPosition);
	class UOptimusNode* AddValueNode(const struct FOptimusDataTypeRef& InDataTypeRef, const struct FVector2D& InPosition);
	class UOptimusNode* AddVariableGetNode(class UOptimusVariableDescription* InVariableDesc, const struct FVector2D& InPosition);
	class UOptimusNode* CollapseNodesToFunction(const TArray<class UOptimusNode*>& InNodes);
	class UOptimusNode* CollapseNodesToSubGraph(const TArray<class UOptimusNode*>& InNodes);
	class UOptimusNode* ConvertCustomKernelToFunction(class UOptimusNode* InCustomKernel);
	class UOptimusNode* ConvertFunctionToCustomKernel(class UOptimusNode* InKernelFunction);
	bool ConvertToFunction(class UOptimusNode* InSubGraphNode);
	bool ConvertToSubGraph(class UOptimusNode* InFunctionNode);
	class UOptimusNode* DuplicateNode(class UOptimusNode* InNode, const struct FVector2D& InPosition);
	bool DuplicateNodes(const TArray<class UOptimusNode*>& InNodes, const struct FVector2D& InPosition);
	TArray<class UOptimusNode*> ExpandCollapsedNodes(class UOptimusNode* InGraphReferenceNode);
	bool MoveGraphDirect(class UOptimusNodeGraph* InGraph, int32 InInsertBefore);
	bool RemoveAllLinks(class UOptimusNodePin* InNodePin);
	bool RemoveLink(class UOptimusNodePin* InNodeOutputPin, class UOptimusNodePin* InNodeInputPin);
	bool RemoveNode(class UOptimusNode* InNode);
	bool RemoveNodes(const TArray<class UOptimusNode*>& InNodes);
	bool RenameGraph(class UOptimusNodeGraph* InGraph, const class FString& InNewName);
	bool RenameGraphDirect(class UOptimusNodeGraph* InGraph, const class FString& InNewName);

	int32 GetGraphIndex() const;
	const TArray<class UOptimusNodeGraph*> GetGraphs() const;
	EOptimusNodeGraphType GetGraphType() const;
	bool IsCustomKernel(class UOptimusNode* InNode) const;
	bool IsExecutionGraph() const;
	bool IsFunctionGraph() const;
	bool IsFunctionReference(class UOptimusNode* InNode) const;
	bool IsKernelFunction(class UOptimusNode* InNode) const;
	bool IsSubGraphReference(class UOptimusNode* InNode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeGraph">();
	}
	static class UOptimusNodeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodeGraph>();
	}
};
static_assert(alignof(UOptimusNodeGraph) == 0x000008, "Wrong alignment on UOptimusNodeGraph");
static_assert(sizeof(UOptimusNodeGraph) == 0x000090, "Wrong size on UOptimusNodeGraph");
static_assert(offsetof(UOptimusNodeGraph, GraphType) == 0x000030, "Member 'UOptimusNodeGraph::GraphType' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, Nodes) == 0x000038, "Member 'UOptimusNodeGraph::Nodes' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, Links) == 0x000048, "Member 'UOptimusNodeGraph::Links' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, NodePairs) == 0x000058, "Member 'UOptimusNodeGraph::NodePairs' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, Subgraphs) == 0x000068, "Member 'UOptimusNodeGraph::Subgraphs' has a wrong offset!");

// Class OptimusCore.OptimusNodeSubGraph
// 0x00B8 (0x0148 - 0x0090)
class UOptimusNodeSubGraph : public UOptimusNodeGraph
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusParameterBindingArray          InputBindings;                                     // 0x0098(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FOptimusParameterBindingArray          OutputBindings;                                    // 0x00A8(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x90];                                      // 0x00B8(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeSubGraph">();
	}
	static class UOptimusNodeSubGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodeSubGraph>();
	}
};
static_assert(alignof(UOptimusNodeSubGraph) == 0x000008, "Wrong alignment on UOptimusNodeSubGraph");
static_assert(sizeof(UOptimusNodeSubGraph) == 0x000148, "Wrong size on UOptimusNodeSubGraph");
static_assert(offsetof(UOptimusNodeSubGraph, InputBindings) == 0x000098, "Member 'UOptimusNodeSubGraph::InputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNodeSubGraph, OutputBindings) == 0x0000A8, "Member 'UOptimusNodeSubGraph::OutputBindings' has a wrong offset!");

// Class OptimusCore.OptimusFunctionNodeGraph
// 0x0010 (0x0158 - 0x0148)
class UOptimusFunctionNodeGraph final : public UOptimusNodeSubGraph
{
public:
	class FName                                   Category;                                          // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AccessSpecifier;                                   // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetAccessSpecifierOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusFunctionNodeGraph">();
	}
	static class UOptimusFunctionNodeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusFunctionNodeGraph>();
	}
};
static_assert(alignof(UOptimusFunctionNodeGraph) == 0x000008, "Wrong alignment on UOptimusFunctionNodeGraph");
static_assert(sizeof(UOptimusFunctionNodeGraph) == 0x000158, "Wrong size on UOptimusFunctionNodeGraph");
static_assert(offsetof(UOptimusFunctionNodeGraph, Category) == 0x000148, "Member 'UOptimusFunctionNodeGraph::Category' has a wrong offset!");
static_assert(offsetof(UOptimusFunctionNodeGraph, AccessSpecifier) == 0x000150, "Member 'UOptimusFunctionNodeGraph::AccessSpecifier' has a wrong offset!");

// Class OptimusCore.OptimusNodeLink
// 0x0010 (0x0038 - 0x0028)
class UOptimusNodeLink final : public UObject
{
public:
	class UOptimusNodePin*                        NodeOutputPin;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptimusNodePin*                        NodeInputPin;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeLink">();
	}
	static class UOptimusNodeLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodeLink>();
	}
};
static_assert(alignof(UOptimusNodeLink) == 0x000008, "Wrong alignment on UOptimusNodeLink");
static_assert(sizeof(UOptimusNodeLink) == 0x000038, "Wrong size on UOptimusNodeLink");
static_assert(offsetof(UOptimusNodeLink, NodeOutputPin) == 0x000028, "Member 'UOptimusNodeLink::NodeOutputPin' has a wrong offset!");
static_assert(offsetof(UOptimusNodeLink, NodeInputPin) == 0x000030, "Member 'UOptimusNodeLink::NodeInputPin' has a wrong offset!");

// Class OptimusCore.OptimusNodePair
// 0x0010 (0x0038 - 0x0028)
class UOptimusNodePair final : public UObject
{
public:
	class UOptimusNode*                           First;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptimusNode*                           Second;                                            // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodePair">();
	}
	static class UOptimusNodePair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodePair>();
	}
};
static_assert(alignof(UOptimusNodePair) == 0x000008, "Wrong alignment on UOptimusNodePair");
static_assert(sizeof(UOptimusNodePair) == 0x000038, "Wrong size on UOptimusNodePair");
static_assert(offsetof(UOptimusNodePair, First) == 0x000028, "Member 'UOptimusNodePair::First' has a wrong offset!");
static_assert(offsetof(UOptimusNodePair, Second) == 0x000030, "Member 'UOptimusNodePair::Second' has a wrong offset!");

// Class OptimusCore.OptimusNodePin
// 0x0088 (0x00B0 - 0x0028)
class UOptimusNodePin final : public UObject
{
public:
	bool                                          bIsGroupingPin;                                    // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOptimusNodePinDirection                      Direction;                                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOptimusNodePinStorageType                    StorageType;                                       // 0x002A(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0030(0x0040)(NativeAccessSpecifierPrivate)
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0070(0x0030)(NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodePin*>                SubPins;                                           // 0x00A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodePin">();
	}
	static class UOptimusNodePin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodePin>();
	}
};
static_assert(alignof(UOptimusNodePin) == 0x000008, "Wrong alignment on UOptimusNodePin");
static_assert(sizeof(UOptimusNodePin) == 0x0000B0, "Wrong size on UOptimusNodePin");
static_assert(offsetof(UOptimusNodePin, bIsGroupingPin) == 0x000028, "Member 'UOptimusNodePin::bIsGroupingPin' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, Direction) == 0x000029, "Member 'UOptimusNodePin::Direction' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, StorageType) == 0x00002A, "Member 'UOptimusNodePin::StorageType' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, DataDomain) == 0x000030, "Member 'UOptimusNodePin::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, DataType) == 0x000070, "Member 'UOptimusNodePin::DataType' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, SubPins) == 0x0000A0, "Member 'UOptimusNodePin::SubPins' has a wrong offset!");

// Class OptimusCore.OptimusResourceDescription
// 0x0088 (0x00B0 - 0x0028)
class UOptimusResourceDescription final : public UObject
{
public:
	class FName                                   ResourceName;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentBinding;                           // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0068(0x0040)(Edit, NativeAccessSpecifierPublic)
	class UOptimusPersistentBufferDataInterface*  DataInterface;                                     // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusResourceDescription">();
	}
	static class UOptimusResourceDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusResourceDescription>();
	}
};
static_assert(alignof(UOptimusResourceDescription) == 0x000008, "Wrong alignment on UOptimusResourceDescription");
static_assert(sizeof(UOptimusResourceDescription) == 0x0000B0, "Wrong size on UOptimusResourceDescription");
static_assert(offsetof(UOptimusResourceDescription, ResourceName) == 0x000028, "Member 'UOptimusResourceDescription::ResourceName' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, DataType) == 0x000030, "Member 'UOptimusResourceDescription::DataType' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, ComponentBinding) == 0x000060, "Member 'UOptimusResourceDescription::ComponentBinding' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, DataDomain) == 0x000068, "Member 'UOptimusResourceDescription::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, DataInterface) == 0x0000A8, "Member 'UOptimusResourceDescription::DataInterface' has a wrong offset!");

// Class OptimusCore.OptimusSource
// 0x0018 (0x0050 - 0x0038)
class UOptimusSource final : public UComputeSource
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SourceText;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSource">();
	}
	static class UOptimusSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSource>();
	}
};
static_assert(alignof(UOptimusSource) == 0x000008, "Wrong alignment on UOptimusSource");
static_assert(sizeof(UOptimusSource) == 0x000050, "Wrong size on UOptimusSource");
static_assert(offsetof(UOptimusSource, SourceText) == 0x000040, "Member 'UOptimusSource::SourceText' has a wrong offset!");

// Class OptimusCore.OptimusValueContainerGeneratorClass
// 0x0030 (0x0230 - 0x0200)
class UOptimusValueContainerGeneratorClass final : public UClass
{
public:
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0200(0x0030)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusValueContainerGeneratorClass">();
	}
	static class UOptimusValueContainerGeneratorClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusValueContainerGeneratorClass>();
	}
};
static_assert(alignof(UOptimusValueContainerGeneratorClass) == 0x000008, "Wrong alignment on UOptimusValueContainerGeneratorClass");
static_assert(sizeof(UOptimusValueContainerGeneratorClass) == 0x000230, "Wrong size on UOptimusValueContainerGeneratorClass");
static_assert(offsetof(UOptimusValueContainerGeneratorClass, DataType) == 0x000200, "Member 'UOptimusValueContainerGeneratorClass::DataType' has a wrong offset!");

// Class OptimusCore.OptimusValueContainer
// 0x0000 (0x0028 - 0x0028)
class UOptimusValueContainer final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusValueContainer">();
	}
	static class UOptimusValueContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusValueContainer>();
	}
};
static_assert(alignof(UOptimusValueContainer) == 0x000008, "Wrong alignment on UOptimusValueContainer");
static_assert(sizeof(UOptimusValueContainer) == 0x000028, "Wrong size on UOptimusValueContainer");

}

