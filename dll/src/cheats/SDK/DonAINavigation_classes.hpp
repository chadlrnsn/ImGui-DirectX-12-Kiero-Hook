#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DonAINavigation

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "DonAINavigation_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class DonAINavigation.BTTask_FlyTo
// 0x0248 (0x02B8 - 0x0070)
class UBTTask_FlyTo final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FlightLocationKey;                                 // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FlightResultKey;                                   // 0x0098(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 KeyToFlipFlopWhenTaskExits;                        // 0x00C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MovementType;                                      // 0x00E8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MinimumHeightRequired;                             // 0x0110(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaximumFlyHeight;                                  // 0x0138(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HasValidActivePath;                                // 0x0160(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CombatRange;                                       // 0x0188(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 AllowJumping;                                      // 0x01B0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaxJumpDistance;                                   // 0x01D8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUsePathingOffset;                                 // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumProximityRequired;                          // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceExpectedToMovePerTick;                     // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTicksStuckAtLocation;                           // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDisengageWhenStuck;                            // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              NavigationEQS;                                     // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecalcPathOnDestinationChanged : 1;               // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecalculatePathTolerance;                          // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDoNNavigationQueryParams              DonQueryParams;                                    // 0x0228(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBT_FlyToTarget_DebugParams            DebugParams;                                       // 0x0248(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class ADonNavigationManager*                  NavigationManager;                                 // 0x0258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleportToDestinationUponFailure;                 // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeBeforeTeleport;                             // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x50];                                     // 0x0268(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pathfinding_OnDynamicCollisionAlert(const struct FDonNavigationDynamicCollisionPayload& Data);
	void Pathfinding_OnFinish(const struct FDoNNavigationQueryData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo">();
	}
	static class UBTTask_FlyTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo>();
	}
};
static_assert(alignof(UBTTask_FlyTo) == 0x000008, "Wrong alignment on UBTTask_FlyTo");
static_assert(sizeof(UBTTask_FlyTo) == 0x0002B8, "Wrong size on UBTTask_FlyTo");
static_assert(offsetof(UBTTask_FlyTo, FlightLocationKey) == 0x000070, "Member 'UBTTask_FlyTo::FlightLocationKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, FlightResultKey) == 0x000098, "Member 'UBTTask_FlyTo::FlightResultKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, KeyToFlipFlopWhenTaskExits) == 0x0000C0, "Member 'UBTTask_FlyTo::KeyToFlipFlopWhenTaskExits' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MovementType) == 0x0000E8, "Member 'UBTTask_FlyTo::MovementType' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MinimumHeightRequired) == 0x000110, "Member 'UBTTask_FlyTo::MinimumHeightRequired' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MaximumFlyHeight) == 0x000138, "Member 'UBTTask_FlyTo::MaximumFlyHeight' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, HasValidActivePath) == 0x000160, "Member 'UBTTask_FlyTo::HasValidActivePath' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, CombatRange) == 0x000188, "Member 'UBTTask_FlyTo::CombatRange' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, AllowJumping) == 0x0001B0, "Member 'UBTTask_FlyTo::AllowJumping' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MaxJumpDistance) == 0x0001D8, "Member 'UBTTask_FlyTo::MaxJumpDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, bUsePathingOffset) == 0x000200, "Member 'UBTTask_FlyTo::bUsePathingOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MinimumProximityRequired) == 0x000204, "Member 'UBTTask_FlyTo::MinimumProximityRequired' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, DistanceExpectedToMovePerTick) == 0x000208, "Member 'UBTTask_FlyTo::DistanceExpectedToMovePerTick' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MaxTicksStuckAtLocation) == 0x00020C, "Member 'UBTTask_FlyTo::MaxTicksStuckAtLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, bUseDisengageWhenStuck) == 0x000210, "Member 'UBTTask_FlyTo::bUseDisengageWhenStuck' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, NavigationEQS) == 0x000218, "Member 'UBTTask_FlyTo::NavigationEQS' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, RecalculatePathTolerance) == 0x000224, "Member 'UBTTask_FlyTo::RecalculatePathTolerance' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, DonQueryParams) == 0x000228, "Member 'UBTTask_FlyTo::DonQueryParams' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, DebugParams) == 0x000248, "Member 'UBTTask_FlyTo::DebugParams' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, NavigationManager) == 0x000258, "Member 'UBTTask_FlyTo::NavigationManager' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, bTeleportToDestinationUponFailure) == 0x000260, "Member 'UBTTask_FlyTo::bTeleportToDestinationUponFailure' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MaxTimeBeforeTeleport) == 0x000264, "Member 'UBTTask_FlyTo::MaxTimeBeforeTeleport' has a wrong offset!");

// Class DonAINavigation.DonEnvQueryTest_Navigation
// 0x0008 (0x0200 - 0x01F8)
class UDonEnvQueryTest_Navigation final : public UEnvQueryTest
{
public:
	EVoxelNavigationType                          VoxelNavigationType;                               // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonEnvQueryTest_Navigation">();
	}
	static class UDonEnvQueryTest_Navigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDonEnvQueryTest_Navigation>();
	}
};
static_assert(alignof(UDonEnvQueryTest_Navigation) == 0x000008, "Wrong alignment on UDonEnvQueryTest_Navigation");
static_assert(sizeof(UDonEnvQueryTest_Navigation) == 0x000200, "Wrong size on UDonEnvQueryTest_Navigation");
static_assert(offsetof(UDonEnvQueryTest_Navigation, VoxelNavigationType) == 0x0001F8, "Member 'UDonEnvQueryTest_Navigation::VoxelNavigationType' has a wrong offset!");

// Class DonAINavigation.DonNavigationHelper
// 0x0000 (0x0028 - 0x0028)
class UDonNavigationHelper final : public UBlueprintFunctionLibrary
{
public:
	static class ADonNavigationManager* DonNavigationManager(class UObject* WorldContextObject);
	static class ADonNavigationManager* DonNavigationManagerForActor(const class AActor* Actor);
	static class ADonNavigationManager* DonNavigationManagerForLocation(class UObject* WorldContextObject, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonNavigationHelper">();
	}
	static class UDonNavigationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDonNavigationHelper>();
	}
};
static_assert(alignof(UDonNavigationHelper) == 0x000008, "Wrong alignment on UDonNavigationHelper");
static_assert(sizeof(UDonNavigationHelper) == 0x000028, "Wrong size on UDonNavigationHelper");

// Class DonAINavigation.DonNavigationManager
// 0x9B78 (0x9E20 - 0x02A8)
class alignas(0x10) ADonNavigationManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x280];                                    // 0x02A8(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    Billboard;                                         // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             NavMeshDataTable;                                  // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingJumpVoxelMultiplier;                        // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeight;                                     // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelSize;                                         // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XGridSize;                                         // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YGridSize;                                         // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZGridSize;                                         // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ObstacleQueryChannels;                             // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnoreForCollision;                        // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AutoCorrectionGuessList;                           // 0x0590(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UnrealPhyxPenetrationDepth;                        // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PerformCollisionChecksOnStartup;                   // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateNavmeshJSONIfNoneExist;                   // 0x05A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiThreadingEnabled;                            // 0x05A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A7[0x1];                                      // 0x05A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorkerThreadsToSpawn;                              // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSolutionsPerWorkerThread;                       // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         neighborSearchMaxDepth;                            // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPathSolverIterationsPerTick;                    // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollisionSolverIterationsPerTick;               // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPathSolverIterationsOnThread;                   // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollisionSolverIterationsOnThread;              // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalItterations;                               // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxItterationDuration;                             // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   FilledBoxWorldVisualizer;                          // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          WorldBoundaryVisualizer;                           // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundary;                             // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundaryFilled;                       // 0x05E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundaryInGame;                       // 0x05E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E3[0x1];                                      // 0x05E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugVoxelsLineThickness;                          // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunDebugValidationsForDynamicCollisions;          // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWalkableVoxels;                            // 0x05E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayClimbableVoxels;                           // 0x05EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayFlyableVoxels;                             // 0x05EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayBlockedVoxels;                             // 0x05EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5ED[0x95A3];                                   // 0x05ED(0x95A3)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           ActiveNavigationTaskOwners;                        // 0x9B90(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class UPrimitiveComponent*>              ActiveCollisionTaskOwners;                         // 0x9BE0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C30[0x1F0];                                   // 0x9C30(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortPathfindingTask(class AActor* Actor);
	void CacheVoxelCollision();
	bool CanNavigate(const struct FVector& Location, EVoxelNavigationType NavigationType);
	struct FVector ClampLocationToNavigableWorld(const struct FVector& DesiredLocation);
	void ConstructBuilder();
	void Debug_ClearAllVolumes();
	void Debug_DrawAllVolumes(float LineThickness);
	void Debug_DrawVolumesAroundPoint(const struct FVector& Location, int32 CubeSize, bool DrawPersistentLines, float Duration, float LineThickness, bool bAutoInitializeVolumes);
	void Debug_DrawVoxelCollisionProfile(class UPrimitiveComponent* MeshOrPrimitive, const struct FVector& OriginLocation, bool bDrawPersistent, float Duration);
	void Debug_ToggleWorldBoundaryInGame();
	bool FindPathSolution(class AActor* Actor, const struct FVector& Destination, const struct FDoNNavigationQueryParams& QueryParams, const struct FDoNNavigationDebugParams& DebugParams, EVoxelNavigationType NavigationType, bool bAllowJump, float MaxJumpDistance, float MinFlightHeight, float MaxFlightHeight);
	struct FVector FindRandomPointAroundOriginInNavWorld(class AActor* NavigationActor, const struct FVector& Origin, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts, EVoxelNavigationType NavigationType);
	struct FVector FindRandomPointFromActorInNavWorld(class AActor* Actor, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts, EVoxelNavigationType NavigationType);
	struct FVector GetClosestNavigableLocation(const struct FVector& DesiredLocation, EVoxelNavigationType NavigationType, int32 NeighborSearchMaxDepthOverride, bool bAllowClimbable);
	bool HasTask(class AActor* Actor);
	void InitVoxelCollision();
	bool IsDirectPathLineSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation);
	bool IsDirectPathSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation);
	bool IsLocationBeneathLandscape(const struct FVector& Location, float LineTraceHeight);
	bool IsLocationWithinNavigableWorld(const struct FVector& DesiredLocation);
	bool IsMeshBoundsWithinNavigableWorld(class UPrimitiveComponent* Mesh, float BoundsScaleFactor);
	bool ScheduleDynamicCollisionUpdate(class UPrimitiveComponent* Mesh, TDelegate<void(bool bTaskSuccessful)> ResultHandler, class FName CustomCacheIdentifier, bool bReplaceExistingTask, bool bDisableCacheUsage, bool bReloadCollisionCache, bool bUseCheapBoundsCollision, float BoundsScaleFactor, bool bForceSynchronousExecution, bool bDrawDebug);
	bool SchedulePathfindingTask(class AActor* Actor, const struct FVector& Destination, const struct FDoNNavigationQueryParams& QueryParams, const struct FDoNNavigationDebugParams& DebugParams, TDelegate<void(const struct FDoNNavigationQueryData& Data)> ResultHandlerDelegate, TDelegate<void(const struct FDonNavigationDynamicCollisionPayload& Data)> DynamicCollisionListener, EVoxelNavigationType NavigationType, bool bAllowJump, float MaxJumpDistance, float MinFlightHeight, float MaxFlightHeight);
	void StopListeningToDynamicCollisionsForPath(TDelegate<void(const struct FDonNavigationDynamicCollisionPayload& Data)> ListenerToClear, const struct FDoNNavigationQueryData& QueryData);
	void StopListeningToDynamicCollisionsForPathIndex(TDelegate<void(const struct FDonNavigationDynamicCollisionPayload& Data)> ListenerToClear, const struct FDoNNavigationQueryData& QueryData, const int32 VolumeIndex);
	void VisualizeDynamicCollisionListeners(TDelegate<void(const struct FDonNavigationDynamicCollisionPayload& Data)> Listener, const struct FDoNNavigationQueryData& QueryData);
	void VisualizeNAVResult(const TArray<struct FVector>& PathSolution, const struct FVector& Source, const struct FVector& Destination, bool Reset, const struct FDoNNavigationDebugParams& DebugParams, const struct FColor& LineColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonNavigationManager">();
	}
	static class ADonNavigationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADonNavigationManager>();
	}
};
static_assert(alignof(ADonNavigationManager) == 0x000010, "Wrong alignment on ADonNavigationManager");
static_assert(sizeof(ADonNavigationManager) == 0x009E20, "Wrong size on ADonNavigationManager");
static_assert(offsetof(ADonNavigationManager, SceneComponent) == 0x000528, "Member 'ADonNavigationManager::SceneComponent' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, Billboard) == 0x000530, "Member 'ADonNavigationManager::Billboard' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, NavMeshDataTable) == 0x000538, "Member 'ADonNavigationManager::NavMeshDataTable' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, WalkingJumpVoxelMultiplier) == 0x000550, "Member 'ADonNavigationManager::WalkingJumpVoxelMultiplier' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxStepHeight) == 0x000554, "Member 'ADonNavigationManager::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxJumpHeight) == 0x000558, "Member 'ADonNavigationManager::MaxJumpHeight' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, VoxelSize) == 0x00055C, "Member 'ADonNavigationManager::VoxelSize' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, XGridSize) == 0x000560, "Member 'ADonNavigationManager::XGridSize' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, YGridSize) == 0x000564, "Member 'ADonNavigationManager::YGridSize' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ZGridSize) == 0x000568, "Member 'ADonNavigationManager::ZGridSize' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ObstacleQueryChannels) == 0x000570, "Member 'ADonNavigationManager::ObstacleQueryChannels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ActorsToIgnoreForCollision) == 0x000580, "Member 'ADonNavigationManager::ActorsToIgnoreForCollision' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, AutoCorrectionGuessList) == 0x000590, "Member 'ADonNavigationManager::AutoCorrectionGuessList' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, UnrealPhyxPenetrationDepth) == 0x0005A0, "Member 'ADonNavigationManager::UnrealPhyxPenetrationDepth' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, PerformCollisionChecksOnStartup) == 0x0005A4, "Member 'ADonNavigationManager::PerformCollisionChecksOnStartup' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bGenerateNavmeshJSONIfNoneExist) == 0x0005A5, "Member 'ADonNavigationManager::bGenerateNavmeshJSONIfNoneExist' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bMultiThreadingEnabled) == 0x0005A6, "Member 'ADonNavigationManager::bMultiThreadingEnabled' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, WorkerThreadsToSpawn) == 0x0005A8, "Member 'ADonNavigationManager::WorkerThreadsToSpawn' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxSolutionsPerWorkerThread) == 0x0005AC, "Member 'ADonNavigationManager::MaxSolutionsPerWorkerThread' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, neighborSearchMaxDepth) == 0x0005B0, "Member 'ADonNavigationManager::neighborSearchMaxDepth' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxPathSolverIterationsPerTick) == 0x0005B4, "Member 'ADonNavigationManager::MaxPathSolverIterationsPerTick' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxCollisionSolverIterationsPerTick) == 0x0005B8, "Member 'ADonNavigationManager::MaxCollisionSolverIterationsPerTick' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxPathSolverIterationsOnThread) == 0x0005BC, "Member 'ADonNavigationManager::MaxPathSolverIterationsOnThread' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxCollisionSolverIterationsOnThread) == 0x0005C0, "Member 'ADonNavigationManager::MaxCollisionSolverIterationsOnThread' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxTotalItterations) == 0x0005C4, "Member 'ADonNavigationManager::MaxTotalItterations' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxItterationDuration) == 0x0005C8, "Member 'ADonNavigationManager::MaxItterationDuration' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, FilledBoxWorldVisualizer) == 0x0005D0, "Member 'ADonNavigationManager::FilledBoxWorldVisualizer' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, WorldBoundaryVisualizer) == 0x0005D8, "Member 'ADonNavigationManager::WorldBoundaryVisualizer' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayWorldBoundary) == 0x0005E0, "Member 'ADonNavigationManager::bDisplayWorldBoundary' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayWorldBoundaryFilled) == 0x0005E1, "Member 'ADonNavigationManager::bDisplayWorldBoundaryFilled' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayWorldBoundaryInGame) == 0x0005E2, "Member 'ADonNavigationManager::bDisplayWorldBoundaryInGame' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, DebugVoxelsLineThickness) == 0x0005E4, "Member 'ADonNavigationManager::DebugVoxelsLineThickness' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bRunDebugValidationsForDynamicCollisions) == 0x0005E8, "Member 'ADonNavigationManager::bRunDebugValidationsForDynamicCollisions' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayWalkableVoxels) == 0x0005E9, "Member 'ADonNavigationManager::bDisplayWalkableVoxels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayClimbableVoxels) == 0x0005EA, "Member 'ADonNavigationManager::bDisplayClimbableVoxels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayFlyableVoxels) == 0x0005EB, "Member 'ADonNavigationManager::bDisplayFlyableVoxels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayBlockedVoxels) == 0x0005EC, "Member 'ADonNavigationManager::bDisplayBlockedVoxels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ActiveNavigationTaskOwners) == 0x009B90, "Member 'ADonNavigationManager::ActiveNavigationTaskOwners' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ActiveCollisionTaskOwners) == 0x009BE0, "Member 'ADonNavigationManager::ActiveCollisionTaskOwners' has a wrong offset!");

// Class DonAINavigation.DonNavigator
// 0x0000 (0x0000 - 0x0000)
class IDonNavigator final
{
public:
	void AddMovementInputCustom(const struct FVector& WorldDirection, float ScaleValue);
	void OnLocomotionAbort();
	void OnLocomotionBegin();
	void OnLocomotionEnd(const bool bLocomotionSuccess);
	void OnNextSegment(const struct FVector& NextPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonNavigator">();
	}
	static class IDonNavigator* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDonNavigator>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDonNavigator) == 0x000001, "Wrong alignment on IDonNavigator");
static_assert(sizeof(IDonNavigator) == 0x000001, "Wrong size on IDonNavigator");

}

