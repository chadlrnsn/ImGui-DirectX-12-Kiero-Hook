#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DMFlowControl

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DMFlowControl.FCDummyBlueprintProxy
// 0x0000 (0x0028 - 0x0028)
class UFCDummyBlueprintProxy final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCDummyBlueprintProxy">();
	}
	static class UFCDummyBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCDummyBlueprintProxy>();
	}
};
static_assert(alignof(UFCDummyBlueprintProxy) == 0x000008, "Wrong alignment on UFCDummyBlueprintProxy");
static_assert(sizeof(UFCDummyBlueprintProxy) == 0x000028, "Wrong size on UFCDummyBlueprintProxy");

// Class DMFlowControl.FCInvokeBlueprintProxy
// 0x0010 (0x0038 - 0x0028)
class UFCInvokeBlueprintProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnInvoke;                                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCInvokeBlueprintProxy">();
	}
	static class UFCInvokeBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCInvokeBlueprintProxy>();
	}
};
static_assert(alignof(UFCInvokeBlueprintProxy) == 0x000008, "Wrong alignment on UFCInvokeBlueprintProxy");
static_assert(sizeof(UFCInvokeBlueprintProxy) == 0x000038, "Wrong size on UFCInvokeBlueprintProxy");
static_assert(offsetof(UFCInvokeBlueprintProxy, OnInvoke) == 0x000028, "Member 'UFCInvokeBlueprintProxy::OnInvoke' has a wrong offset!");

// Class DMFlowControl.FCLerpFloatBlueprintProxy
// 0x0020 (0x0048 - 0x0028)
class UFCLerpFloatBlueprintProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void(float Value)>   Tick;                                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCLerpFloatBlueprintProxy">();
	}
	static class UFCLerpFloatBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCLerpFloatBlueprintProxy>();
	}
};
static_assert(alignof(UFCLerpFloatBlueprintProxy) == 0x000008, "Wrong alignment on UFCLerpFloatBlueprintProxy");
static_assert(sizeof(UFCLerpFloatBlueprintProxy) == 0x000048, "Wrong size on UFCLerpFloatBlueprintProxy");
static_assert(offsetof(UFCLerpFloatBlueprintProxy, Tick) == 0x000028, "Member 'UFCLerpFloatBlueprintProxy::Tick' has a wrong offset!");
static_assert(offsetof(UFCLerpFloatBlueprintProxy, OnFinish) == 0x000038, "Member 'UFCLerpFloatBlueprintProxy::OnFinish' has a wrong offset!");

// Class DMFlowControl.FCLerpVectorBlueprintProxy
// 0x0020 (0x0048 - 0x0028)
class UFCLerpVectorBlueprintProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FVector& Value)> Tick;                                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCLerpVectorBlueprintProxy">();
	}
	static class UFCLerpVectorBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCLerpVectorBlueprintProxy>();
	}
};
static_assert(alignof(UFCLerpVectorBlueprintProxy) == 0x000008, "Wrong alignment on UFCLerpVectorBlueprintProxy");
static_assert(sizeof(UFCLerpVectorBlueprintProxy) == 0x000048, "Wrong size on UFCLerpVectorBlueprintProxy");
static_assert(offsetof(UFCLerpVectorBlueprintProxy, Tick) == 0x000028, "Member 'UFCLerpVectorBlueprintProxy::Tick' has a wrong offset!");
static_assert(offsetof(UFCLerpVectorBlueprintProxy, OnFinish) == 0x000038, "Member 'UFCLerpVectorBlueprintProxy::OnFinish' has a wrong offset!");

// Class DMFlowControl.FCLerpRotatorBlueprintProxy
// 0x0020 (0x0048 - 0x0028)
class UFCLerpRotatorBlueprintProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FRotator& Value)> Tick;                               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCLerpRotatorBlueprintProxy">();
	}
	static class UFCLerpRotatorBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCLerpRotatorBlueprintProxy>();
	}
};
static_assert(alignof(UFCLerpRotatorBlueprintProxy) == 0x000008, "Wrong alignment on UFCLerpRotatorBlueprintProxy");
static_assert(sizeof(UFCLerpRotatorBlueprintProxy) == 0x000048, "Wrong size on UFCLerpRotatorBlueprintProxy");
static_assert(offsetof(UFCLerpRotatorBlueprintProxy, Tick) == 0x000028, "Member 'UFCLerpRotatorBlueprintProxy::Tick' has a wrong offset!");
static_assert(offsetof(UFCLerpRotatorBlueprintProxy, OnFinish) == 0x000038, "Member 'UFCLerpRotatorBlueprintProxy::OnFinish' has a wrong offset!");

// Class DMFlowControl.FCLerpTransformBlueprintProxy
// 0x0020 (0x0048 - 0x0028)
class UFCLerpTransformBlueprintProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FTransform& Value)> Tick;                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCLerpTransformBlueprintProxy">();
	}
	static class UFCLerpTransformBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCLerpTransformBlueprintProxy>();
	}
};
static_assert(alignof(UFCLerpTransformBlueprintProxy) == 0x000008, "Wrong alignment on UFCLerpTransformBlueprintProxy");
static_assert(sizeof(UFCLerpTransformBlueprintProxy) == 0x000048, "Wrong size on UFCLerpTransformBlueprintProxy");
static_assert(offsetof(UFCLerpTransformBlueprintProxy, Tick) == 0x000028, "Member 'UFCLerpTransformBlueprintProxy::Tick' has a wrong offset!");
static_assert(offsetof(UFCLerpTransformBlueprintProxy, OnFinish) == 0x000038, "Member 'UFCLerpTransformBlueprintProxy::OnFinish' has a wrong offset!");

// Class DMFlowControl.DMFlowControlLibrary
// 0x0000 (0x0028 - 0x0028)
class UDMFlowControlLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UFCDummyBlueprintProxy* CreateDummyProxyObject(class UObject* WorldContextObject);
	static class UFCInvokeBlueprintProxy* CreateInvokeProxyObject(class UObject* WorldContextObject, TDelegate<void(bool* RetValue)> Predicate);
	static class UFCLerpFloatBlueprintProxy* CreateLerpFloatProxyObject(class UObject* WorldContextObject, float Start, float End, float Time);
	static class UFCLerpRotatorBlueprintProxy* CreateLerpRotatorProxyObject(class UObject* WorldContextObject, const struct FRotator& Start, const struct FRotator& End, float Time);
	static class UFCLerpTransformBlueprintProxy* CreateLerpTransformProxyObject(class UObject* WorldContextObject, const struct FTransform& Start, const struct FTransform& End, float Time, ELerpInterpolationMode LerpInterpolationMode);
	static class UFCLerpVectorBlueprintProxy* CreateLerpVectorProxyObject(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DMFlowControlLibrary">();
	}
	static class UDMFlowControlLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDMFlowControlLibrary>();
	}
};
static_assert(alignof(UDMFlowControlLibrary) == 0x000008, "Wrong alignment on UDMFlowControlLibrary");
static_assert(sizeof(UDMFlowControlLibrary) == 0x000028, "Wrong size on UDMFlowControlLibrary");

}

