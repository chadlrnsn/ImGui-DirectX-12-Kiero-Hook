#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ComputeFramework

#include "Basic.hpp"


namespace SDK
{

// Enum ComputeFramework.EComputeKernelFlags
// NumValues: 0x0003
enum class EComputeKernelFlags : uint8
{
	IsDefaultKernel                          = 1,
	IsolatedMemoryWrites                     = 2,
	EComputeKernelFlags_MAX                  = 3,
};

// Enum ComputeFramework.EShaderFundamentalType
// NumValues: 0x0007
enum class EShaderFundamentalType : uint8
{
	Bool                                     = 0,
	Int                                      = 1,
	Uint                                     = 2,
	Float                                    = 3,
	Struct                                   = 4,
	None                                     = 255,
	EShaderFundamentalType_MAX               = 256,
};

// Enum ComputeFramework.EShaderFundamentalDimensionType
// NumValues: 0x0004
enum class EShaderFundamentalDimensionType : uint8
{
	Scalar                                   = 0,
	Vector                                   = 1,
	Matrix                                   = 2,
	EShaderFundamentalDimensionType_MAX      = 3,
};

// Enum ComputeFramework.EShaderParamBindingType
// NumValues: 0x0005
enum class EShaderParamBindingType : uint8
{
	None                                     = 0,
	ConstantParameter                        = 1,
	ReadOnlyResource                         = 2,
	ReadWriteResource                        = 3,
	EShaderParamBindingType_MAX              = 4,
};

// Enum ComputeFramework.EShaderResourceType
// NumValues: 0x0009
enum class EShaderResourceType : uint8
{
	None                                     = 0,
	Texture1D                                = 1,
	Texture2D                                = 2,
	Texture3D                                = 3,
	TextureCube                              = 4,
	Buffer                                   = 5,
	StructuredBuffer                         = 6,
	ByteAddressBuffer                        = 7,
	EShaderResourceType_MAX                  = 8,
};

// Enum ComputeFramework.EShaderParamModifier
// NumValues: 0x0005
enum class EShaderParamModifier : uint8
{
	None                                     = 0,
	In                                       = 1,
	Out                                      = 2,
	InOut                                    = 3,
	EShaderParamModifier_MAX                 = 4,
};

// ScriptStruct ComputeFramework.ComputeGraphEdge
// 0x0038 (0x0038 - 0x0000)
struct FComputeGraphEdge final
{
public:
	int32                                         KernelIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KernelBindingIndex;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataInterfaceIndex;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataInterfaceBindingIndex;                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKernelInput;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BindingFunctionNameOverride;                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BindingFunctionNamespace;                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComputeGraphEdge) == 0x000008, "Wrong alignment on FComputeGraphEdge");
static_assert(sizeof(FComputeGraphEdge) == 0x000038, "Wrong size on FComputeGraphEdge");
static_assert(offsetof(FComputeGraphEdge, KernelIndex) == 0x000000, "Member 'FComputeGraphEdge::KernelIndex' has a wrong offset!");
static_assert(offsetof(FComputeGraphEdge, KernelBindingIndex) == 0x000004, "Member 'FComputeGraphEdge::KernelBindingIndex' has a wrong offset!");
static_assert(offsetof(FComputeGraphEdge, DataInterfaceIndex) == 0x000008, "Member 'FComputeGraphEdge::DataInterfaceIndex' has a wrong offset!");
static_assert(offsetof(FComputeGraphEdge, DataInterfaceBindingIndex) == 0x00000C, "Member 'FComputeGraphEdge::DataInterfaceBindingIndex' has a wrong offset!");
static_assert(offsetof(FComputeGraphEdge, bKernelInput) == 0x000010, "Member 'FComputeGraphEdge::bKernelInput' has a wrong offset!");
static_assert(offsetof(FComputeGraphEdge, BindingFunctionNameOverride) == 0x000018, "Member 'FComputeGraphEdge::BindingFunctionNameOverride' has a wrong offset!");
static_assert(offsetof(FComputeGraphEdge, BindingFunctionNamespace) == 0x000028, "Member 'FComputeGraphEdge::BindingFunctionNamespace' has a wrong offset!");

// ScriptStruct ComputeFramework.ComputeGraphInstance
// 0x0018 (0x0018 - 0x0000)
struct FComputeGraphInstance final
{
public:
	TArray<class UComputeDataProvider*>           DataProviders;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComputeGraphInstance) == 0x000008, "Wrong alignment on FComputeGraphInstance");
static_assert(sizeof(FComputeGraphInstance) == 0x000018, "Wrong size on FComputeGraphInstance");
static_assert(offsetof(FComputeGraphInstance, DataProviders) == 0x000000, "Member 'FComputeGraphInstance::DataProviders' has a wrong offset!");

// ScriptStruct ComputeFramework.ComputeKernelPermutationBool
// 0x0018 (0x0018 - 0x0000)
struct FComputeKernelPermutationBool final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComputeKernelPermutationBool) == 0x000008, "Wrong alignment on FComputeKernelPermutationBool");
static_assert(sizeof(FComputeKernelPermutationBool) == 0x000018, "Wrong size on FComputeKernelPermutationBool");
static_assert(offsetof(FComputeKernelPermutationBool, Name) == 0x000000, "Member 'FComputeKernelPermutationBool::Name' has a wrong offset!");
static_assert(offsetof(FComputeKernelPermutationBool, Value) == 0x000010, "Member 'FComputeKernelPermutationBool::Value' has a wrong offset!");

// ScriptStruct ComputeFramework.ComputeKernelPermutationSet
// 0x0010 (0x0010 - 0x0000)
struct FComputeKernelPermutationSet final
{
public:
	TArray<struct FComputeKernelPermutationBool>  BooleanOptions;                                    // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComputeKernelPermutationSet) == 0x000008, "Wrong alignment on FComputeKernelPermutationSet");
static_assert(sizeof(FComputeKernelPermutationSet) == 0x000010, "Wrong size on FComputeKernelPermutationSet");
static_assert(offsetof(FComputeKernelPermutationSet, BooleanOptions) == 0x000000, "Member 'FComputeKernelPermutationSet::BooleanOptions' has a wrong offset!");

// ScriptStruct ComputeFramework.ComputeKernelDefinition
// 0x0020 (0x0020 - 0x0000)
struct FComputeKernelDefinition final
{
public:
	class FString                                 Symbol;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Define;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComputeKernelDefinition) == 0x000008, "Wrong alignment on FComputeKernelDefinition");
static_assert(sizeof(FComputeKernelDefinition) == 0x000020, "Wrong size on FComputeKernelDefinition");
static_assert(offsetof(FComputeKernelDefinition, Symbol) == 0x000000, "Member 'FComputeKernelDefinition::Symbol' has a wrong offset!");
static_assert(offsetof(FComputeKernelDefinition, Define) == 0x000010, "Member 'FComputeKernelDefinition::Define' has a wrong offset!");

// ScriptStruct ComputeFramework.ComputeKernelDefinitionSet
// 0x0010 (0x0010 - 0x0000)
struct FComputeKernelDefinitionSet final
{
public:
	TArray<struct FComputeKernelDefinition>       Defines;                                           // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComputeKernelDefinitionSet) == 0x000008, "Wrong alignment on FComputeKernelDefinitionSet");
static_assert(sizeof(FComputeKernelDefinitionSet) == 0x000010, "Wrong size on FComputeKernelDefinitionSet");
static_assert(offsetof(FComputeKernelDefinitionSet, Defines) == 0x000000, "Member 'FComputeKernelDefinitionSet::Defines' has a wrong offset!");

// ScriptStruct ComputeFramework.ComputeKernelPermutationVector
// 0x0058 (0x0058 - 0x0000)
struct FComputeKernelPermutationVector final
{
public:
	TMap<class FString, uint32>                   Permutations;                                      // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	uint32                                        BitCount;                                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComputeKernelPermutationVector) == 0x000008, "Wrong alignment on FComputeKernelPermutationVector");
static_assert(sizeof(FComputeKernelPermutationVector) == 0x000058, "Wrong size on FComputeKernelPermutationVector");
static_assert(offsetof(FComputeKernelPermutationVector, Permutations) == 0x000000, "Member 'FComputeKernelPermutationVector::Permutations' has a wrong offset!");
static_assert(offsetof(FComputeKernelPermutationVector, BitCount) == 0x000050, "Member 'FComputeKernelPermutationVector::BitCount' has a wrong offset!");

// ScriptStruct ComputeFramework.ShaderValueTypeHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FShaderValueTypeHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShaderValueTypeHandle) == 0x000008, "Wrong alignment on FShaderValueTypeHandle");
static_assert(sizeof(FShaderValueTypeHandle) == 0x000008, "Wrong size on FShaderValueTypeHandle");

// ScriptStruct ComputeFramework.ArrayShaderValue
// 0x0010 (0x0010 - 0x0000)
struct FArrayShaderValue final
{
public:
	TArray<uint8>                                 ArrayOfValues;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayShaderValue) == 0x000008, "Wrong alignment on FArrayShaderValue");
static_assert(sizeof(FArrayShaderValue) == 0x000010, "Wrong size on FArrayShaderValue");
static_assert(offsetof(FArrayShaderValue, ArrayOfValues) == 0x000000, "Member 'FArrayShaderValue::ArrayOfValues' has a wrong offset!");

// ScriptStruct ComputeFramework.ShaderValueContainer
// 0x0020 (0x0020 - 0x0000)
struct FShaderValueContainer final
{
public:
	TArray<uint8>                                 ShaderValue;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FArrayShaderValue>              ArrayList;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShaderValueContainer) == 0x000008, "Wrong alignment on FShaderValueContainer");
static_assert(sizeof(FShaderValueContainer) == 0x000020, "Wrong size on FShaderValueContainer");
static_assert(offsetof(FShaderValueContainer, ShaderValue) == 0x000000, "Member 'FShaderValueContainer::ShaderValue' has a wrong offset!");
static_assert(offsetof(FShaderValueContainer, ArrayList) == 0x000010, "Member 'FShaderValueContainer::ArrayList' has a wrong offset!");

// ScriptStruct ComputeFramework.ShaderValueType
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FShaderValueType final
{
public:
	EShaderFundamentalType                        Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShaderFundamentalDimensionType               DimensionType;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDynamicArray;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x13];                                       // 0x000D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShaderValueType) == 0x000008, "Wrong alignment on FShaderValueType");
static_assert(sizeof(FShaderValueType) == 0x000020, "Wrong size on FShaderValueType");
static_assert(offsetof(FShaderValueType, Type) == 0x000000, "Member 'FShaderValueType::Type' has a wrong offset!");
static_assert(offsetof(FShaderValueType, DimensionType) == 0x000001, "Member 'FShaderValueType::DimensionType' has a wrong offset!");
static_assert(offsetof(FShaderValueType, Name) == 0x000004, "Member 'FShaderValueType::Name' has a wrong offset!");
static_assert(offsetof(FShaderValueType, bIsDynamicArray) == 0x00000C, "Member 'FShaderValueType::bIsDynamicArray' has a wrong offset!");

// ScriptStruct ComputeFramework.ShaderParamTypeDefinition
// 0x0030 (0x0030 - 0x0000)
struct FShaderParamTypeDefinition final
{
public:
	class FString                                 TypeDeclaration;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShaderValueTypeHandle                 ValueType;                                         // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ArrayElementCount;                                 // 0x0028(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShaderParamBindingType                       BindingType;                                       // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShaderResourceType                           ResourceType;                                      // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShaderParamModifier                          Modifier;                                          // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShaderParamTypeDefinition) == 0x000008, "Wrong alignment on FShaderParamTypeDefinition");
static_assert(sizeof(FShaderParamTypeDefinition) == 0x000030, "Wrong size on FShaderParamTypeDefinition");
static_assert(offsetof(FShaderParamTypeDefinition, TypeDeclaration) == 0x000000, "Member 'FShaderParamTypeDefinition::TypeDeclaration' has a wrong offset!");
static_assert(offsetof(FShaderParamTypeDefinition, Name) == 0x000010, "Member 'FShaderParamTypeDefinition::Name' has a wrong offset!");
static_assert(offsetof(FShaderParamTypeDefinition, ValueType) == 0x000020, "Member 'FShaderParamTypeDefinition::ValueType' has a wrong offset!");
static_assert(offsetof(FShaderParamTypeDefinition, ArrayElementCount) == 0x000028, "Member 'FShaderParamTypeDefinition::ArrayElementCount' has a wrong offset!");
static_assert(offsetof(FShaderParamTypeDefinition, BindingType) == 0x00002A, "Member 'FShaderParamTypeDefinition::BindingType' has a wrong offset!");
static_assert(offsetof(FShaderParamTypeDefinition, ResourceType) == 0x00002B, "Member 'FShaderParamTypeDefinition::ResourceType' has a wrong offset!");
static_assert(offsetof(FShaderParamTypeDefinition, Modifier) == 0x00002C, "Member 'FShaderParamTypeDefinition::Modifier' has a wrong offset!");

// ScriptStruct ComputeFramework.ShaderFunctionDefinition
// 0x0028 (0x0028 - 0x0000)
struct FShaderFunctionDefinition final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShaderParamTypeDefinition>     ParamTypes;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bHasReturnType;                                    // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShaderFunctionDefinition) == 0x000008, "Wrong alignment on FShaderFunctionDefinition");
static_assert(sizeof(FShaderFunctionDefinition) == 0x000028, "Wrong size on FShaderFunctionDefinition");
static_assert(offsetof(FShaderFunctionDefinition, Name) == 0x000000, "Member 'FShaderFunctionDefinition::Name' has a wrong offset!");
static_assert(offsetof(FShaderFunctionDefinition, ParamTypes) == 0x000010, "Member 'FShaderFunctionDefinition::ParamTypes' has a wrong offset!");
static_assert(offsetof(FShaderFunctionDefinition, bHasReturnType) == 0x000020, "Member 'FShaderFunctionDefinition::bHasReturnType' has a wrong offset!");

}

