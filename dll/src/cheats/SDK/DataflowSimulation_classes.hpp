#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DataflowSimulation

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DataflowSimulation.DataflowSimulationInterface
// 0x0000 (0x0000 - 0x0000)
class IDataflowSimulationInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowSimulationInterface">();
	}
	static class IDataflowSimulationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowSimulationInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowSimulationInterface) == 0x000001, "Wrong alignment on IDataflowSimulationInterface");
static_assert(sizeof(IDataflowSimulationInterface) == 0x000001, "Wrong size on IDataflowSimulationInterface");

// Class DataflowSimulation.DataflowCollisionObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IDataflowCollisionObjectInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowCollisionObjectInterface">();
	}
	static class IDataflowCollisionObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowCollisionObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowCollisionObjectInterface) == 0x000001, "Wrong alignment on IDataflowCollisionObjectInterface");
static_assert(sizeof(IDataflowCollisionObjectInterface) == 0x000001, "Wrong size on IDataflowCollisionObjectInterface");

// Class DataflowSimulation.DataflowConstraintObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IDataflowConstraintObjectInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowConstraintObjectInterface">();
	}
	static class IDataflowConstraintObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowConstraintObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowConstraintObjectInterface) == 0x000001, "Wrong alignment on IDataflowConstraintObjectInterface");
static_assert(sizeof(IDataflowConstraintObjectInterface) == 0x000001, "Wrong size on IDataflowConstraintObjectInterface");

// Class DataflowSimulation.DataflowGeometryCachable
// 0x0000 (0x0000 - 0x0000)
class IDataflowGeometryCachable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowGeometryCachable">();
	}
	static class IDataflowGeometryCachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowGeometryCachable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowGeometryCachable) == 0x000001, "Wrong alignment on IDataflowGeometryCachable");
static_assert(sizeof(IDataflowGeometryCachable) == 0x000001, "Wrong size on IDataflowGeometryCachable");

// Class DataflowSimulation.DataflowPhysicsObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IDataflowPhysicsObjectInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowPhysicsObjectInterface">();
	}
	static class IDataflowPhysicsObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowPhysicsObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowPhysicsObjectInterface) == 0x000001, "Wrong alignment on IDataflowPhysicsObjectInterface");
static_assert(sizeof(IDataflowPhysicsObjectInterface) == 0x000001, "Wrong size on IDataflowPhysicsObjectInterface");

// Class DataflowSimulation.DataflowPhysicsSolverInterface
// 0x0000 (0x0000 - 0x0000)
class IDataflowPhysicsSolverInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowPhysicsSolverInterface">();
	}
	static class IDataflowPhysicsSolverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowPhysicsSolverInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowPhysicsSolverInterface) == 0x000001, "Wrong alignment on IDataflowPhysicsSolverInterface");
static_assert(sizeof(IDataflowPhysicsSolverInterface) == 0x000001, "Wrong size on IDataflowPhysicsSolverInterface");

// Class DataflowSimulation.DataflowSimulationManager
// 0x0068 (0x00A8 - 0x0040)
class UDataflowSimulationManager final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x68];                                      // 0x0040(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowSimulationManager">();
	}
	static class UDataflowSimulationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataflowSimulationManager>();
	}
};
static_assert(alignof(UDataflowSimulationManager) == 0x000008, "Wrong alignment on UDataflowSimulationManager");
static_assert(sizeof(UDataflowSimulationManager) == 0x0000A8, "Wrong size on UDataflowSimulationManager");

// Class DataflowSimulation.DataflowSimulationActor
// 0x0000 (0x0000 - 0x0000)
class IDataflowSimulationActor final
{
public:
	void PostDataflowSimulationTick(const float SimulationTime, const float DeltaTime);
	void PreDataflowSimulationTick(const float SimulationTime, const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataflowSimulationActor">();
	}
	static class IDataflowSimulationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDataflowSimulationActor>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDataflowSimulationActor) == 0x000001, "Wrong alignment on IDataflowSimulationActor");
static_assert(sizeof(IDataflowSimulationActor) == 0x000001, "Wrong size on IDataflowSimulationActor");

}

