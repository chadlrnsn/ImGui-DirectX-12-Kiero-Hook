#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StateTreeModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK
{

// Enum StateTreeModule.EStateTreeBreakpointType
// NumValues: 0x0005
enum class EStateTreeBreakpointType : uint8
{
	Unset                                    = 0,
	OnEnter                                  = 1,
	OnExit                                   = 2,
	OnTransition                             = 3,
	EStateTreeBreakpointType_MAX             = 4,
};

// Enum StateTreeModule.EStateTreeUpdatePhase
// NumValues: 0x0012
enum class EStateTreeUpdatePhase : uint8
{
	Unset                                    = 0,
	StartTree                                = 1,
	StopTree                                 = 2,
	StartGlobalTasks                         = 3,
	StopGlobalTasks                          = 4,
	TickStateTree                            = 5,
	ApplyTransitions                         = 6,
	TriggerTransitions                       = 7,
	TickingGlobalTasks                       = 8,
	TickingTasks                             = 9,
	TransitionConditions                     = 10,
	StateSelection                           = 11,
	TrySelectBehavior                        = 12,
	EnterConditions                          = 13,
	EnterStates                              = 14,
	ExitStates                               = 15,
	StateCompleted                           = 16,
	EStateTreeUpdatePhase_MAX                = 17,
};

// Enum StateTreeModule.EStateTreeRunStatus
// NumValues: 0x0006
enum class EStateTreeRunStatus : uint8
{
	Running                                  = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	Stopped                                  = 3,
	Unset                                    = 4,
	EStateTreeRunStatus_MAX                  = 5,
};

// Enum StateTreeModule.EStateTreeStateChangeType
// NumValues: 0x0004
enum class EStateTreeStateChangeType : uint8
{
	None                                     = 0,
	Changed                                  = 1,
	Sustained                                = 2,
	EStateTreeStateChangeType_MAX            = 3,
};

// Enum StateTreeModule.EStateTreeConditionEvaluationMode
// NumValues: 0x0004
enum class EStateTreeConditionEvaluationMode : uint8
{
	Evaluated                                = 0,
	ForcedTrue                               = 1,
	ForcedFalse                              = 2,
	EStateTreeConditionEvaluationMode_MAX    = 3,
};

// Enum StateTreeModule.EStateTreeTransitionSourceType
// NumValues: 0x0005
enum class EStateTreeTransitionSourceType : uint8
{
	Unset                                    = 0,
	Asset                                    = 1,
	ExternalRequest                          = 2,
	Internal                                 = 3,
	EStateTreeTransitionSourceType_MAX       = 4,
};

// Enum StateTreeModule.EStateTreeRecordTransitions
// NumValues: 0x0003
enum class EStateTreeRecordTransitions : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	EStateTreeRecordTransitions_MAX          = 2,
};

// Enum StateTreeModule.EStateTreeLinkerStatus
// NumValues: 0x0003
enum class EStateTreeLinkerStatus : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	EStateTreeLinkerStatus_MAX               = 2,
};

// Enum StateTreeModule.EStateTreeNodeFormatting
// NumValues: 0x0003
enum class EStateTreeNodeFormatting : uint8
{
	RichText                                 = 0,
	Text                                     = 1,
	EStateTreeNodeFormatting_MAX             = 2,
};

// Enum StateTreeModule.EStateTreePropertyRefType
// NumValues: 0x0011
enum class EStateTreePropertyRefType : uint8
{
	None                                     = 0,
	Bool                                     = 1,
	Byte                                     = 2,
	Int32                                    = 3,
	Int64                                    = 4,
	Float                                    = 5,
	Double                                   = 6,
	Name                                     = 7,
	String                                   = 8,
	Text                                     = 9,
	Enum                                     = 10,
	Struct                                   = 11,
	Object                                   = 12,
	SoftObject                               = 13,
	Class                                    = 14,
	SoftClass                                = 15,
	EStateTreePropertyRefType_MAX            = 16,
};

// Enum StateTreeModule.EStateTreeTraceStatus
// NumValues: 0x0004
enum class EStateTreeTraceStatus : uint8
{
	TracesStarted                            = 0,
	StoppingTrace                            = 1,
	TracesStopped                            = 2,
	EStateTreeTraceStatus_MAX                = 3,
};

// Enum StateTreeModule.EStateTreeTraceEventType
// NumValues: 0x0016
enum class EStateTreeTraceEventType : uint8
{
	Unset                                    = 0,
	OnEntering                               = 1,
	OnEntered                                = 2,
	OnExiting                                = 3,
	OnExited                                 = 4,
	Push                                     = 5,
	Pop                                      = 6,
	OnStateSelected                          = 7,
	OnStateCompleted                         = 8,
	OnTicking                                = 9,
	OnTaskCompleted                          = 10,
	OnTicked                                 = 11,
	Passed                                   = 12,
	Failed                                   = 13,
	ForcedSuccess                            = 14,
	ForcedFailure                            = 15,
	InternalForcedFailure                    = 16,
	OnEvaluating                             = 17,
	OnTransition                             = 18,
	OnTreeStarted                            = 19,
	OnTreeStopped                            = 20,
	EStateTreeTraceEventType_MAX             = 21,
};

// Enum StateTreeModule.EStateTreeBlueprintPropertyCategory
// NumValues: 0x0006
enum class EStateTreeBlueprintPropertyCategory : uint8
{
	NotSet                                   = 0,
	Input                                    = 1,
	Parameter                                = 2,
	Output                                   = 3,
	ContextObject                            = 4,
	EStateTreeBlueprintPropertyCategory_MAX  = 5,
};

// Enum StateTreeModule.EStateTreeLoopEvents
// NumValues: 0x0004
enum class EStateTreeLoopEvents : uint8
{
	Next                                     = 0,
	Break                                    = 1,
	Consume                                  = 2,
	EStateTreeLoopEvents_MAX                 = 3,
};

// Enum StateTreeModule.EStateTreeBindableStructSource
// NumValues: 0x000C
enum class EStateTreeBindableStructSource : uint8
{
	Context                                  = 0,
	Parameter                                = 1,
	Evaluator                                = 2,
	GlobalTask                               = 3,
	StateParameter                           = 4,
	Task                                     = 5,
	Condition                                = 6,
	Consideration                            = 7,
	TransitionEvent                          = 8,
	StateEvent                               = 9,
	PropertyFunction                         = 10,
	EStateTreeBindableStructSource_MAX       = 11,
};

// Enum StateTreeModule.EStateTreePropertyAccessType
// NumValues: 0x0008
enum class EStateTreePropertyAccessType : uint8
{
	Offset                                   = 0,
	Object                                   = 1,
	WeakObject                               = 2,
	SoftObject                               = 3,
	ObjectInstance                           = 4,
	StructInstance                           = 5,
	IndexArray                               = 6,
	EStateTreePropertyAccessType_MAX         = 7,
};

// Enum StateTreeModule.EStateTreePropertyCopyType
// NumValues: 0x0021
enum class EStateTreePropertyCopyType : uint8
{
	None                                     = 0,
	CopyPlain                                = 1,
	CopyComplex                              = 2,
	CopyBool                                 = 3,
	CopyStruct                               = 4,
	CopyObject                               = 5,
	CopyName                                 = 6,
	CopyFixedArray                           = 7,
	StructReference                          = 8,
	PromoteBoolToByte                        = 9,
	PromoteBoolToInt32                       = 10,
	PromoteBoolToUInt32                      = 11,
	PromoteBoolToInt64                       = 12,
	PromoteBoolToFloat                       = 13,
	PromoteBoolToDouble                      = 14,
	PromoteByteToInt32                       = 15,
	PromoteByteToUInt32                      = 16,
	PromoteByteToInt64                       = 17,
	PromoteByteToFloat                       = 18,
	PromoteByteToDouble                      = 19,
	PromoteInt32ToInt64                      = 20,
	PromoteInt32ToFloat                      = 21,
	PromoteInt32ToDouble                     = 22,
	PromoteUInt32ToInt64                     = 23,
	PromoteUInt32ToFloat                     = 24,
	PromoteUInt32ToDouble                    = 25,
	PromoteFloatToInt32                      = 26,
	PromoteFloatToInt64                      = 27,
	PromoteFloatToDouble                     = 28,
	DemoteDoubleToInt32                      = 29,
	DemoteDoubleToInt64                      = 30,
	DemoteDoubleToFloat                      = 31,
	EStateTreePropertyCopyType_MAX           = 32,
};

// Enum StateTreeModule.EStateTreeTransitionType
// NumValues: 0x0008
enum class EStateTreeTransitionType : uint8
{
	None                                     = 0,
	Succeeded                                = 1,
	Failed                                   = 2,
	GotoState                                = 3,
	NextState                                = 4,
	NextSelectableState                      = 5,
	NotSet                                   = 6,
	EStateTreeTransitionType_MAX             = 7,
};

// Enum StateTreeModule.EStateTreeExpressionOperand
// NumValues: 0x0004
enum class EStateTreeExpressionOperand : uint8
{
	Copy                                     = 0,
	And                                      = 1,
	Or                                       = 2,
	EStateTreeExpressionOperand_MAX          = 3,
};

// Enum StateTreeModule.EStateTreeStateType
// NumValues: 0x0006
enum class EStateTreeStateType : uint8
{
	State                                    = 0,
	Group                                    = 1,
	Linked                                   = 2,
	LinkedAsset                              = 3,
	Subtree                                  = 4,
	EStateTreeStateType_MAX                  = 5,
};

// Enum StateTreeModule.EStateTreeStateSelectionBehavior
// NumValues: 0x000A
enum class EStateTreeStateSelectionBehavior : uint8
{
	None                                     = 0,
	TryEnterState                            = 1,
	TrySelectChildrenInOrder                 = 2,
	TrySelectChildrenAtRandom                = 3,
	TrySelectChildrenWithHighestUtility      = 4,
	TrySelectChildrenAtRandomWeightedByUtility = 5,
	TryFollowTransitions                     = 6,
	TrySelectChildrenAtUniformRandom         = 3,
	TrySelectChildrenBasedOnRelativeUtility  = 5,
	EStateTreeStateSelectionBehavior_MAX     = 7,
};

// Enum StateTreeModule.EStateTreeTransitionTrigger
// NumValues: 0x0007
enum class EStateTreeTransitionTrigger : uint8
{
	None                                     = 0,
	OnStateCompleted                         = 3,
	OnStateSucceeded                         = 1,
	OnStateFailed                            = 2,
	OnTick                                   = 4,
	OnEvent                                  = 8,
	MAX                                      = 9,
};

// Enum StateTreeModule.EStateTreeTransitionPriority
// NumValues: 0x0007
enum class EStateTreeTransitionPriority : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Normal                                   = 2,
	Medium                                   = 3,
	High                                     = 4,
	Critical                                 = 5,
	EStateTreeTransitionPriority_MAX         = 6,
};

// Enum StateTreeModule.EStateTreeDataSourceType
// NumValues: 0x000F
enum class EStateTreeDataSourceType : uint8
{
	None                                     = 0,
	GlobalInstanceData                       = 1,
	GlobalInstanceDataObject                 = 2,
	ActiveInstanceData                       = 3,
	ActiveInstanceDataObject                 = 4,
	SharedInstanceData                       = 5,
	SharedInstanceDataObject                 = 6,
	ContextData                              = 7,
	ExternalData                             = 8,
	GlobalParameterData                      = 9,
	SubtreeParameterData                     = 10,
	StateParameterData                       = 11,
	TransitionEvent                          = 12,
	StateEvent                               = 13,
	EStateTreeDataSourceType_MAX             = 14,
};

// Enum StateTreeModule.EStateTreeSelectionFallback
// NumValues: 0x0003
enum class EStateTreeSelectionFallback : uint8
{
	None                                     = 0,
	NextSelectableSibling                    = 1,
	EStateTreeSelectionFallback_MAX          = 2,
};

// Enum StateTreeModule.EStateTreeExternalDataRequirement
// NumValues: 0x0003
enum class EStateTreeExternalDataRequirement : uint8
{
	Required                                 = 0,
	Optional                                 = 1,
	EStateTreeExternalDataRequirement_MAX    = 2,
};

// Enum StateTreeModule.EStateTreePropertyUsage
// NumValues: 0x0006
enum class EStateTreePropertyUsage : uint8
{
	Invalid                                  = 0,
	Context                                  = 1,
	Input                                    = 2,
	Parameter                                = 3,
	Output                                   = 4,
	EStateTreePropertyUsage_MAX              = 5,
};

// ScriptStruct StateTreeModule.StateTreeIndex16
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeIndex16 final
{
public:
	uint16                                        Value;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeIndex16) == 0x000002, "Wrong alignment on FStateTreeIndex16");
static_assert(sizeof(FStateTreeIndex16) == 0x000002, "Wrong size on FStateTreeIndex16");
static_assert(offsetof(FStateTreeIndex16, Value) == 0x000000, "Member 'FStateTreeIndex16::Value' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStateHandle
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeStateHandle final
{
public:
	uint16                                        Index;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeStateHandle) == 0x000002, "Wrong alignment on FStateTreeStateHandle");
static_assert(sizeof(FStateTreeStateHandle) == 0x000002, "Wrong size on FStateTreeStateHandle");
static_assert(offsetof(FStateTreeStateHandle, Index) == 0x000000, "Member 'FStateTreeStateHandle::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDataHandle
// 0x0006 (0x0006 - 0x0000)
struct FStateTreeDataHandle final
{
public:
	EStateTreeDataSourceType                      Source;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Index;                                             // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStateTreeStateHandle                  StateHandle;                                       // 0x0004(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreeDataHandle) == 0x000002, "Wrong alignment on FStateTreeDataHandle");
static_assert(sizeof(FStateTreeDataHandle) == 0x000006, "Wrong size on FStateTreeDataHandle");
static_assert(offsetof(FStateTreeDataHandle, Source) == 0x000000, "Member 'FStateTreeDataHandle::Source' has a wrong offset!");
static_assert(offsetof(FStateTreeDataHandle, Index) == 0x000002, "Member 'FStateTreeDataHandle::Index' has a wrong offset!");
static_assert(offsetof(FStateTreeDataHandle, StateHandle) == 0x000004, "Member 'FStateTreeDataHandle::StateHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeNodeBase
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FStateTreeNodeBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      BindingsBatch;                                     // 0x0010(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      InstanceTemplateIndex;                             // 0x0012(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   InstanceDataHandle;                                // 0x0014(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeNodeBase) == 0x000008, "Wrong alignment on FStateTreeNodeBase");
static_assert(sizeof(FStateTreeNodeBase) == 0x000020, "Wrong size on FStateTreeNodeBase");
static_assert(offsetof(FStateTreeNodeBase, Name) == 0x000008, "Member 'FStateTreeNodeBase::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeBase, BindingsBatch) == 0x000010, "Member 'FStateTreeNodeBase::BindingsBatch' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeBase, InstanceTemplateIndex) == 0x000012, "Member 'FStateTreeNodeBase::InstanceTemplateIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeBase, InstanceDataHandle) == 0x000014, "Member 'FStateTreeNodeBase::InstanceDataHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvaluatorBase
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeEvaluatorBase : public FStateTreeNodeBase
{
};
static_assert(alignof(FStateTreeEvaluatorBase) == 0x000008, "Wrong alignment on FStateTreeEvaluatorBase");
static_assert(sizeof(FStateTreeEvaluatorBase) == 0x000020, "Wrong size on FStateTreeEvaluatorBase");

// ScriptStruct StateTreeModule.StateTreeNodeIdToIndex
// 0x0014 (0x0014 - 0x0000)
struct FStateTreeNodeIdToIndex final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      Index;                                             // 0x0010(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeNodeIdToIndex) == 0x000004, "Wrong alignment on FStateTreeNodeIdToIndex");
static_assert(sizeof(FStateTreeNodeIdToIndex) == 0x000014, "Wrong size on FStateTreeNodeIdToIndex");
static_assert(offsetof(FStateTreeNodeIdToIndex, ID) == 0x000000, "Member 'FStateTreeNodeIdToIndex::ID' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeIdToIndex, Index) == 0x000010, "Member 'FStateTreeNodeIdToIndex::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeAnyEnum
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeAnyEnum final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  Enum;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeAnyEnum) == 0x000008, "Wrong alignment on FStateTreeAnyEnum");
static_assert(sizeof(FStateTreeAnyEnum) == 0x000010, "Wrong size on FStateTreeAnyEnum");
static_assert(offsetof(FStateTreeAnyEnum, Value) == 0x000000, "Member 'FStateTreeAnyEnum::Value' has a wrong offset!");
static_assert(offsetof(FStateTreeAnyEnum, Enum) == 0x000008, "Member 'FStateTreeAnyEnum::Enum' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBooleanOperationPropertyFunctionInstanceData
// 0x0003 (0x0003 - 0x0000)
struct FStateTreeBooleanOperationPropertyFunctionInstanceData final
{
public:
	bool                                          bLeft;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRight;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBooleanOperationPropertyFunctionInstanceData) == 0x000001, "Wrong alignment on FStateTreeBooleanOperationPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeBooleanOperationPropertyFunctionInstanceData) == 0x000003, "Wrong size on FStateTreeBooleanOperationPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeBooleanOperationPropertyFunctionInstanceData, bLeft) == 0x000000, "Member 'FStateTreeBooleanOperationPropertyFunctionInstanceData::bLeft' has a wrong offset!");
static_assert(offsetof(FStateTreeBooleanOperationPropertyFunctionInstanceData, bRight) == 0x000001, "Member 'FStateTreeBooleanOperationPropertyFunctionInstanceData::bRight' has a wrong offset!");
static_assert(offsetof(FStateTreeBooleanOperationPropertyFunctionInstanceData, bResult) == 0x000002, "Member 'FStateTreeBooleanOperationPropertyFunctionInstanceData::bResult' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTaskBase
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeTaskBase : public FStateTreeNodeBase
{
public:
	uint8                                         BitPad_20_0 : 6;                                   // 0x0020(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bTaskEnabled : 1;                                  // 0x0020(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EStateTreeTransitionPriority                  TransitionHandlingPriority;                        // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTaskBase) == 0x000008, "Wrong alignment on FStateTreeTaskBase");
static_assert(sizeof(FStateTreeTaskBase) == 0x000028, "Wrong size on FStateTreeTaskBase");
static_assert(offsetof(FStateTreeTaskBase, TransitionHandlingPriority) == 0x000021, "Member 'FStateTreeTaskBase::TransitionHandlingPriority' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTaskCommonBase
// 0x0000 (0x0028 - 0x0028)
struct FStateTreeTaskCommonBase : public FStateTreeTaskBase
{
};
static_assert(alignof(FStateTreeTaskCommonBase) == 0x000008, "Wrong alignment on FStateTreeTaskCommonBase");
static_assert(sizeof(FStateTreeTaskCommonBase) == 0x000028, "Wrong size on FStateTreeTaskCommonBase");

// ScriptStruct StateTreeModule.StateTreeRandomTimeDuration
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeRandomTimeDuration final
{
public:
	uint16                                        Duration;                                          // 0x0000(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        RandomVariance;                                    // 0x0002(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeRandomTimeDuration) == 0x000002, "Wrong alignment on FStateTreeRandomTimeDuration");
static_assert(sizeof(FStateTreeRandomTimeDuration) == 0x000004, "Wrong size on FStateTreeRandomTimeDuration");
static_assert(offsetof(FStateTreeRandomTimeDuration, Duration) == 0x000000, "Member 'FStateTreeRandomTimeDuration::Duration' has a wrong offset!");
static_assert(offsetof(FStateTreeRandomTimeDuration, RandomVariance) == 0x000002, "Member 'FStateTreeRandomTimeDuration::RandomVariance' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeSharedEvent
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStateTreeSharedEvent final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeSharedEvent) == 0x000008, "Wrong alignment on FStateTreeSharedEvent");
static_assert(sizeof(FStateTreeSharedEvent) == 0x000010, "Wrong size on FStateTreeSharedEvent");

// ScriptStruct StateTreeModule.StateTreeTransitionDelayedState
// 0x0028 (0x0028 - 0x0000)
struct FStateTreeTransitionDelayedState final
{
public:
	class UStateTree*                             StateTree;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      TransitionIndex;                                   // 0x0008(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLeft;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeSharedEvent                  CapturedEvent;                                     // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	uint32                                        CapturedEventHash;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionDelayedState) == 0x000008, "Wrong alignment on FStateTreeTransitionDelayedState");
static_assert(sizeof(FStateTreeTransitionDelayedState) == 0x000028, "Wrong size on FStateTreeTransitionDelayedState");
static_assert(offsetof(FStateTreeTransitionDelayedState, StateTree) == 0x000000, "Member 'FStateTreeTransitionDelayedState::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionDelayedState, TransitionIndex) == 0x000008, "Member 'FStateTreeTransitionDelayedState::TransitionIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionDelayedState, TimeLeft) == 0x00000C, "Member 'FStateTreeTransitionDelayedState::TimeLeft' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionDelayedState, CapturedEvent) == 0x000010, "Member 'FStateTreeTransitionDelayedState::CapturedEvent' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionDelayedState, CapturedEventHash) == 0x000020, "Member 'FStateTreeTransitionDelayedState::CapturedEventHash' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConditionBase
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeConditionBase : public FStateTreeNodeBase
{
public:
	EStateTreeExpressionOperand                   Operand;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          DeltaIndent;                                       // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeConditionEvaluationMode             EvaluationMode;                                    // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeConditionBase) == 0x000008, "Wrong alignment on FStateTreeConditionBase");
static_assert(sizeof(FStateTreeConditionBase) == 0x000028, "Wrong size on FStateTreeConditionBase");
static_assert(offsetof(FStateTreeConditionBase, Operand) == 0x000020, "Member 'FStateTreeConditionBase::Operand' has a wrong offset!");
static_assert(offsetof(FStateTreeConditionBase, DeltaIndent) == 0x000021, "Member 'FStateTreeConditionBase::DeltaIndent' has a wrong offset!");
static_assert(offsetof(FStateTreeConditionBase, EvaluationMode) == 0x000022, "Member 'FStateTreeConditionBase::EvaluationMode' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConditionCommonBase
// 0x0000 (0x0028 - 0x0028)
struct FStateTreeConditionCommonBase : public FStateTreeConditionBase
{
};
static_assert(alignof(FStateTreeConditionCommonBase) == 0x000008, "Wrong alignment on FStateTreeConditionCommonBase");
static_assert(sizeof(FStateTreeConditionCommonBase) == 0x000028, "Wrong size on FStateTreeConditionCommonBase");

// ScriptStruct StateTreeModule.StateTreeDebugTextTaskInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeDebugTextTaskInstanceData final
{
public:
	class AActor*                                 ReferenceActor;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeDebugTextTaskInstanceData) == 0x000008, "Wrong alignment on FStateTreeDebugTextTaskInstanceData");
static_assert(sizeof(FStateTreeDebugTextTaskInstanceData) == 0x000008, "Wrong size on FStateTreeDebugTextTaskInstanceData");
static_assert(offsetof(FStateTreeDebugTextTaskInstanceData, ReferenceActor) == 0x000000, "Member 'FStateTreeDebugTextTaskInstanceData::ReferenceActor' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyFunctionBase
// 0x0000 (0x0020 - 0x0020)
struct FStateTreePropertyFunctionBase : public FStateTreeNodeBase
{
};
static_assert(alignof(FStateTreePropertyFunctionBase) == 0x000008, "Wrong alignment on FStateTreePropertyFunctionBase");
static_assert(sizeof(FStateTreePropertyFunctionBase) == 0x000020, "Wrong size on FStateTreePropertyFunctionBase");

// ScriptStruct StateTreeModule.StateTreePropertyFunctionCommonBase
// 0x0000 (0x0020 - 0x0020)
struct FStateTreePropertyFunctionCommonBase : public FStateTreePropertyFunctionBase
{
};
static_assert(alignof(FStateTreePropertyFunctionCommonBase) == 0x000008, "Wrong alignment on FStateTreePropertyFunctionCommonBase");
static_assert(sizeof(FStateTreePropertyFunctionCommonBase) == 0x000020, "Wrong size on FStateTreePropertyFunctionCommonBase");

// ScriptStruct StateTreeModule.StateTreeBooleanNotPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeBooleanNotPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeBooleanNotPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeBooleanNotPropertyFunction");
static_assert(sizeof(FStateTreeBooleanNotPropertyFunction) == 0x000020, "Wrong size on FStateTreeBooleanNotPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeBooleanAndPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeBooleanAndPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeBooleanAndPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeBooleanAndPropertyFunction");
static_assert(sizeof(FStateTreeBooleanAndPropertyFunction) == 0x000020, "Wrong size on FStateTreeBooleanAndPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeActiveStates
// 0x0012 (0x0012 - 0x0000)
struct FStateTreeActiveStates final
{
public:
	struct FStateTreeStateHandle                  States[0x8];                                       // 0x0000(0x0002)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumStates;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1];                                       // 0x0011(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeActiveStates) == 0x000002, "Wrong alignment on FStateTreeActiveStates");
static_assert(sizeof(FStateTreeActiveStates) == 0x000012, "Wrong size on FStateTreeActiveStates");
static_assert(offsetof(FStateTreeActiveStates, States) == 0x000000, "Member 'FStateTreeActiveStates::States' has a wrong offset!");
static_assert(offsetof(FStateTreeActiveStates, NumStates) == 0x000010, "Member 'FStateTreeActiveStates::NumStates' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBooleanOrPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeBooleanOrPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeBooleanOrPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeBooleanOrPropertyFunction");
static_assert(sizeof(FStateTreeBooleanOrPropertyFunction) == 0x000020, "Wrong size on FStateTreeBooleanOrPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeBlueprintTaskWrapper
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeBlueprintTaskWrapper final : public FStateTreeTaskBase
{
public:
	TSubclassOf<class UStateTreeTaskBlueprintBase> TaskClass;                                        // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintTaskWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintTaskWrapper");
static_assert(sizeof(FStateTreeBlueprintTaskWrapper) == 0x000030, "Wrong size on FStateTreeBlueprintTaskWrapper");
static_assert(offsetof(FStateTreeBlueprintTaskWrapper, TaskClass) == 0x000028, "Member 'FStateTreeBlueprintTaskWrapper::TaskClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStructRef
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStateTreeStructRef final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeStructRef) == 0x000008, "Wrong alignment on FStateTreeStructRef");
static_assert(sizeof(FStateTreeStructRef) == 0x000010, "Wrong size on FStateTreeStructRef");

// ScriptStruct StateTreeModule.StateTreeBooleanXOrPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeBooleanXOrPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeBooleanXOrPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeBooleanXOrPropertyFunction");
static_assert(sizeof(FStateTreeBooleanXOrPropertyFunction) == 0x000020, "Wrong size on FStateTreeBooleanXOrPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeBooleanNotOperationPropertyFunctionInstanceData
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeBooleanNotOperationPropertyFunctionInstanceData final
{
public:
	bool                                          bInput;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBooleanNotOperationPropertyFunctionInstanceData) == 0x000001, "Wrong alignment on FStateTreeBooleanNotOperationPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeBooleanNotOperationPropertyFunctionInstanceData) == 0x000002, "Wrong size on FStateTreeBooleanNotOperationPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeBooleanNotOperationPropertyFunctionInstanceData, bInput) == 0x000000, "Member 'FStateTreeBooleanNotOperationPropertyFunctionInstanceData::bInput' has a wrong offset!");
static_assert(offsetof(FStateTreeBooleanNotOperationPropertyFunctionInstanceData, bResult) == 0x000001, "Member 'FStateTreeBooleanNotOperationPropertyFunctionInstanceData::bResult' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExternalDataHandle
// 0x0006 (0x0006 - 0x0000)
struct FStateTreeExternalDataHandle final
{
public:
	struct FStateTreeDataHandle                   DataHandle;                                        // 0x0000(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeExternalDataHandle) == 0x000002, "Wrong alignment on FStateTreeExternalDataHandle");
static_assert(sizeof(FStateTreeExternalDataHandle) == 0x000006, "Wrong size on FStateTreeExternalDataHandle");
static_assert(offsetof(FStateTreeExternalDataHandle, DataHandle) == 0x000000, "Member 'FStateTreeExternalDataHandle::DataHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExternalDataDesc
// 0x0018 (0x0018 - 0x0000)
struct FStateTreeExternalDataDesc final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeExternalDataHandle           Handle;                                            // 0x0010(0x0006)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeExternalDataRequirement             Requirement;                                       // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExternalDataDesc) == 0x000008, "Wrong alignment on FStateTreeExternalDataDesc");
static_assert(sizeof(FStateTreeExternalDataDesc) == 0x000018, "Wrong size on FStateTreeExternalDataDesc");
static_assert(offsetof(FStateTreeExternalDataDesc, Struct) == 0x000000, "Member 'FStateTreeExternalDataDesc::Struct' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Name) == 0x000008, "Member 'FStateTreeExternalDataDesc::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Handle) == 0x000010, "Member 'FStateTreeExternalDataDesc::Handle' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Requirement) == 0x000016, "Member 'FStateTreeExternalDataDesc::Requirement' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionRequest
// 0x0018 (0x0018 - 0x0000)
struct FStateTreeTransitionRequest final
{
public:
	struct FStateTreeStateHandle                  SourceState;                                       // 0x0000(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStateTree*                             SourceStateTree;                                   // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  SourceRootState;                                   // 0x0010(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  TargetState;                                       // 0x0012(0x0002)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionRequest) == 0x000008, "Wrong alignment on FStateTreeTransitionRequest");
static_assert(sizeof(FStateTreeTransitionRequest) == 0x000018, "Wrong size on FStateTreeTransitionRequest");
static_assert(offsetof(FStateTreeTransitionRequest, SourceState) == 0x000000, "Member 'FStateTreeTransitionRequest::SourceState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionRequest, SourceStateTree) == 0x000008, "Member 'FStateTreeTransitionRequest::SourceStateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionRequest, SourceRootState) == 0x000010, "Member 'FStateTreeTransitionRequest::SourceRootState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionRequest, TargetState) == 0x000012, "Member 'FStateTreeTransitionRequest::TargetState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionRequest, Priority) == 0x000014, "Member 'FStateTreeTransitionRequest::Priority' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionSource
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x02) FStateTreeTransitionSource final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionSource) == 0x000002, "Wrong alignment on FStateTreeTransitionSource");
static_assert(sizeof(FStateTreeTransitionSource) == 0x000008, "Wrong size on FStateTreeTransitionSource");

// ScriptStruct StateTreeModule.StateTreeExecutionFrame
// 0x0030 (0x0030 - 0x0000)
struct FStateTreeExecutionFrame final
{
public:
	class UStateTree*                             StateTree;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  RootState;                                         // 0x0008(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeActiveStates                 ActiveStates;                                      // 0x000A(0x0012)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ExternalDataBaseIndex;                             // 0x001C(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      GlobalInstanceIndexBase;                           // 0x001E(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ActiveInstanceIndexBase;                           // 0x0020(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   StateParameterDataHandle;                          // 0x0022(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   GlobalParameterDataHandle;                         // 0x0028(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x1];                                       // 0x002E(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsGlobalFrame : 1;                                // 0x002F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FStateTreeExecutionFrame) == 0x000008, "Wrong alignment on FStateTreeExecutionFrame");
static_assert(sizeof(FStateTreeExecutionFrame) == 0x000030, "Wrong size on FStateTreeExecutionFrame");
static_assert(offsetof(FStateTreeExecutionFrame, StateTree) == 0x000000, "Member 'FStateTreeExecutionFrame::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, RootState) == 0x000008, "Member 'FStateTreeExecutionFrame::RootState' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, ActiveStates) == 0x00000A, "Member 'FStateTreeExecutionFrame::ActiveStates' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, ExternalDataBaseIndex) == 0x00001C, "Member 'FStateTreeExecutionFrame::ExternalDataBaseIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, GlobalInstanceIndexBase) == 0x00001E, "Member 'FStateTreeExecutionFrame::GlobalInstanceIndexBase' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, ActiveInstanceIndexBase) == 0x000020, "Member 'FStateTreeExecutionFrame::ActiveInstanceIndexBase' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, StateParameterDataHandle) == 0x000022, "Member 'FStateTreeExecutionFrame::StateParameterDataHandle' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionFrame, GlobalParameterDataHandle) == 0x000028, "Member 'FStateTreeExecutionFrame::GlobalParameterDataHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExecutionState
// 0x0038 (0x0038 - 0x0000)
struct FStateTreeExecutionState final
{
public:
	TArray<struct FStateTreeExecutionFrame>       ActiveFrames;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStateTreeTransitionDelayedState> DelayedTransitions;                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      EnterStateFailedFrameIndex;                        // 0x0020(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      EnterStateFailedTaskIndex;                         // 0x0022(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeRunStatus                           LastTickStatus;                                    // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeRunStatus                           TreeRunStatus;                                     // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeRunStatus                           RequestedStop;                                     // 0x0026(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeUpdatePhase                         CurrentPhase;                                      // 0x0027(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      CompletedFrameIndex;                               // 0x0028(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  CompletedStateHandle;                              // 0x002A(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        StateChangeCount;                                  // 0x002C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          RandomStream;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeExecutionState) == 0x000008, "Wrong alignment on FStateTreeExecutionState");
static_assert(sizeof(FStateTreeExecutionState) == 0x000038, "Wrong size on FStateTreeExecutionState");
static_assert(offsetof(FStateTreeExecutionState, ActiveFrames) == 0x000000, "Member 'FStateTreeExecutionState::ActiveFrames' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, DelayedTransitions) == 0x000010, "Member 'FStateTreeExecutionState::DelayedTransitions' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, EnterStateFailedFrameIndex) == 0x000020, "Member 'FStateTreeExecutionState::EnterStateFailedFrameIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, EnterStateFailedTaskIndex) == 0x000022, "Member 'FStateTreeExecutionState::EnterStateFailedTaskIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, LastTickStatus) == 0x000024, "Member 'FStateTreeExecutionState::LastTickStatus' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, TreeRunStatus) == 0x000025, "Member 'FStateTreeExecutionState::TreeRunStatus' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, RequestedStop) == 0x000026, "Member 'FStateTreeExecutionState::RequestedStop' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, CurrentPhase) == 0x000027, "Member 'FStateTreeExecutionState::CurrentPhase' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, CompletedFrameIndex) == 0x000028, "Member 'FStateTreeExecutionState::CompletedFrameIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, CompletedStateHandle) == 0x00002A, "Member 'FStateTreeExecutionState::CompletedStateHandle' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, StateChangeCount) == 0x00002C, "Member 'FStateTreeExecutionState::StateChangeCount' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionState, RandomStream) == 0x000030, "Member 'FStateTreeExecutionState::RandomStream' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionResult
// 0x0040 (0x0040 - 0x0000)
struct FStateTreeTransitionResult final
{
public:
	TArray<struct FStateTreeExecutionFrame>       NextActiveFrames;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EStateTreeRunStatus                           CurrentRunStatus;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x1];                                       // 0x0021(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateTreeStateHandle                  SourceState;                                       // 0x0022(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  TargetState;                                       // 0x0024(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  CurrentState;                                      // 0x0026(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeStateChangeType                     ChangeType;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStateTree*                             SourceStateTree;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  SourceRootState;                                   // 0x0038(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionResult) == 0x000008, "Wrong alignment on FStateTreeTransitionResult");
static_assert(sizeof(FStateTreeTransitionResult) == 0x000040, "Wrong size on FStateTreeTransitionResult");
static_assert(offsetof(FStateTreeTransitionResult, NextActiveFrames) == 0x000000, "Member 'FStateTreeTransitionResult::NextActiveFrames' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, CurrentRunStatus) == 0x000020, "Member 'FStateTreeTransitionResult::CurrentRunStatus' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, SourceState) == 0x000022, "Member 'FStateTreeTransitionResult::SourceState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, TargetState) == 0x000024, "Member 'FStateTreeTransitionResult::TargetState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, CurrentState) == 0x000026, "Member 'FStateTreeTransitionResult::CurrentState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, ChangeType) == 0x000028, "Member 'FStateTreeTransitionResult::ChangeType' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, Priority) == 0x000029, "Member 'FStateTreeTransitionResult::Priority' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, SourceStateTree) == 0x000030, "Member 'FStateTreeTransitionResult::SourceStateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, SourceRootState) == 0x000038, "Member 'FStateTreeTransitionResult::SourceRootState' has a wrong offset!");

// ScriptStruct StateTreeModule.RecordedStateTreeExecutionFrame
// 0x0028 (0x0028 - 0x0000)
struct FRecordedStateTreeExecutionFrame final
{
public:
	class UStateTree*                             StateTree;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  RootState;                                         // 0x0008(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeActiveStates                 ActiveStates;                                      // 0x000A(0x0012)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bIsGlobalFrame : 1;                                // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0xB];                                       // 0x001D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecordedStateTreeExecutionFrame) == 0x000008, "Wrong alignment on FRecordedStateTreeExecutionFrame");
static_assert(sizeof(FRecordedStateTreeExecutionFrame) == 0x000028, "Wrong size on FRecordedStateTreeExecutionFrame");
static_assert(offsetof(FRecordedStateTreeExecutionFrame, StateTree) == 0x000000, "Member 'FRecordedStateTreeExecutionFrame::StateTree' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeExecutionFrame, RootState) == 0x000008, "Member 'FRecordedStateTreeExecutionFrame::RootState' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeExecutionFrame, ActiveStates) == 0x00000A, "Member 'FRecordedStateTreeExecutionFrame::ActiveStates' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvent
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeEvent final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInstancedStruct                       Payload;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   Origin;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeEvent) == 0x000008, "Wrong alignment on FStateTreeEvent");
static_assert(sizeof(FStateTreeEvent) == 0x000020, "Wrong size on FStateTreeEvent");
static_assert(offsetof(FStateTreeEvent, Tag) == 0x000000, "Member 'FStateTreeEvent::Tag' has a wrong offset!");
static_assert(offsetof(FStateTreeEvent, Payload) == 0x000008, "Member 'FStateTreeEvent::Payload' has a wrong offset!");
static_assert(offsetof(FStateTreeEvent, Origin) == 0x000018, "Member 'FStateTreeEvent::Origin' has a wrong offset!");

// ScriptStruct StateTreeModule.RecordedStateTreeTransitionResult
// 0x0038 (0x0038 - 0x0000)
struct FRecordedStateTreeTransitionResult final
{
public:
	TArray<struct FRecordedStateTreeExecutionFrame> NextActiveFrames;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStateTreeEvent>                NextActiveFrameEvents;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  SourceState;                                       // 0x0020(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  TargetState;                                       // 0x0022(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UStateTree*                             SourceStateTree;                                   // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  SourceRootState;                                   // 0x0030(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecordedStateTreeTransitionResult) == 0x000008, "Wrong alignment on FRecordedStateTreeTransitionResult");
static_assert(sizeof(FRecordedStateTreeTransitionResult) == 0x000038, "Wrong size on FRecordedStateTreeTransitionResult");
static_assert(offsetof(FRecordedStateTreeTransitionResult, NextActiveFrames) == 0x000000, "Member 'FRecordedStateTreeTransitionResult::NextActiveFrames' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeTransitionResult, NextActiveFrameEvents) == 0x000010, "Member 'FRecordedStateTreeTransitionResult::NextActiveFrameEvents' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeTransitionResult, SourceState) == 0x000020, "Member 'FRecordedStateTreeTransitionResult::SourceState' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeTransitionResult, TargetState) == 0x000022, "Member 'FRecordedStateTreeTransitionResult::TargetState' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeTransitionResult, Priority) == 0x000024, "Member 'FRecordedStateTreeTransitionResult::Priority' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeTransitionResult, SourceStateTree) == 0x000028, "Member 'FRecordedStateTreeTransitionResult::SourceStateTree' has a wrong offset!");
static_assert(offsetof(FRecordedStateTreeTransitionResult, SourceRootState) == 0x000030, "Member 'FRecordedStateTreeTransitionResult::SourceRootState' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeFloatCombinaisonPropertyFunctionInstanceData
// 0x000C (0x000C - 0x0000)
struct FStateTreeFloatCombinaisonPropertyFunctionInstanceData final
{
public:
	float                                         Left;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Right;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeFloatCombinaisonPropertyFunctionInstanceData) == 0x000004, "Wrong alignment on FStateTreeFloatCombinaisonPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeFloatCombinaisonPropertyFunctionInstanceData) == 0x00000C, "Wrong size on FStateTreeFloatCombinaisonPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeFloatCombinaisonPropertyFunctionInstanceData, Left) == 0x000000, "Member 'FStateTreeFloatCombinaisonPropertyFunctionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeFloatCombinaisonPropertyFunctionInstanceData, Right) == 0x000004, "Member 'FStateTreeFloatCombinaisonPropertyFunctionInstanceData::Right' has a wrong offset!");
static_assert(offsetof(FStateTreeFloatCombinaisonPropertyFunctionInstanceData, Result) == 0x000008, "Member 'FStateTreeFloatCombinaisonPropertyFunctionInstanceData::Result' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeAddFloatPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeAddFloatPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeAddFloatPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeAddFloatPropertyFunction");
static_assert(sizeof(FStateTreeAddFloatPropertyFunction) == 0x000020, "Wrong size on FStateTreeAddFloatPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeSubtractFloatPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeSubtractFloatPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeSubtractFloatPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeSubtractFloatPropertyFunction");
static_assert(sizeof(FStateTreeSubtractFloatPropertyFunction) == 0x000020, "Wrong size on FStateTreeSubtractFloatPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeMultiplyFloatPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeMultiplyFloatPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeMultiplyFloatPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeMultiplyFloatPropertyFunction");
static_assert(sizeof(FStateTreeMultiplyFloatPropertyFunction) == 0x000020, "Wrong size on FStateTreeMultiplyFloatPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeDivideFloatPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeDivideFloatPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeDivideFloatPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeDivideFloatPropertyFunction");
static_assert(sizeof(FStateTreeDivideFloatPropertyFunction) == 0x000020, "Wrong size on FStateTreeDivideFloatPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeSingleFloatPropertyFunctionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeSingleFloatPropertyFunctionInstanceData final
{
public:
	float                                         Input;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeSingleFloatPropertyFunctionInstanceData) == 0x000004, "Wrong alignment on FStateTreeSingleFloatPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeSingleFloatPropertyFunctionInstanceData) == 0x000008, "Wrong size on FStateTreeSingleFloatPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeSingleFloatPropertyFunctionInstanceData, Input) == 0x000000, "Member 'FStateTreeSingleFloatPropertyFunctionInstanceData::Input' has a wrong offset!");
static_assert(offsetof(FStateTreeSingleFloatPropertyFunctionInstanceData, Result) == 0x000004, "Member 'FStateTreeSingleFloatPropertyFunctionInstanceData::Result' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInvertFloatPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeInvertFloatPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeInvertFloatPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeInvertFloatPropertyFunction");
static_assert(sizeof(FStateTreeInvertFloatPropertyFunction) == 0x000020, "Wrong size on FStateTreeInvertFloatPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeAbsoluteFloatPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeAbsoluteFloatPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeAbsoluteFloatPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeAbsoluteFloatPropertyFunction");
static_assert(sizeof(FStateTreeAbsoluteFloatPropertyFunction) == 0x000020, "Wrong size on FStateTreeAbsoluteFloatPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeIndex8
// 0x0001 (0x0001 - 0x0000)
struct FStateTreeIndex8 final
{
public:
	uint8                                         Value;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeIndex8) == 0x000001, "Wrong alignment on FStateTreeIndex8");
static_assert(sizeof(FStateTreeIndex8) == 0x000001, "Wrong size on FStateTreeIndex8");
static_assert(offsetof(FStateTreeIndex8, Value) == 0x000000, "Member 'FStateTreeIndex8::Value' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeMakeIntervalPropertyFunctionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeMakeIntervalPropertyFunctionInstanceData final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Result;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeMakeIntervalPropertyFunctionInstanceData) == 0x000004, "Wrong alignment on FStateTreeMakeIntervalPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeMakeIntervalPropertyFunctionInstanceData) == 0x000010, "Wrong size on FStateTreeMakeIntervalPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeMakeIntervalPropertyFunctionInstanceData, Min) == 0x000000, "Member 'FStateTreeMakeIntervalPropertyFunctionInstanceData::Min' has a wrong offset!");
static_assert(offsetof(FStateTreeMakeIntervalPropertyFunctionInstanceData, Max) == 0x000004, "Member 'FStateTreeMakeIntervalPropertyFunctionInstanceData::Max' has a wrong offset!");
static_assert(offsetof(FStateTreeMakeIntervalPropertyFunctionInstanceData, Result) == 0x000008, "Member 'FStateTreeMakeIntervalPropertyFunctionInstanceData::Result' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeMakeIntervalPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeMakeIntervalPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeMakeIntervalPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeMakeIntervalPropertyFunction");
static_assert(sizeof(FStateTreeMakeIntervalPropertyFunction) == 0x000020, "Wrong size on FStateTreeMakeIntervalPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeIntCombinaisonPropertyFunctionInstanceData
// 0x000C (0x000C - 0x0000)
struct FStateTreeIntCombinaisonPropertyFunctionInstanceData final
{
public:
	int32                                         Left;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Right;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeIntCombinaisonPropertyFunctionInstanceData) == 0x000004, "Wrong alignment on FStateTreeIntCombinaisonPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeIntCombinaisonPropertyFunctionInstanceData) == 0x00000C, "Wrong size on FStateTreeIntCombinaisonPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeIntCombinaisonPropertyFunctionInstanceData, Left) == 0x000000, "Member 'FStateTreeIntCombinaisonPropertyFunctionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeIntCombinaisonPropertyFunctionInstanceData, Right) == 0x000004, "Member 'FStateTreeIntCombinaisonPropertyFunctionInstanceData::Right' has a wrong offset!");
static_assert(offsetof(FStateTreeIntCombinaisonPropertyFunctionInstanceData, Result) == 0x000008, "Member 'FStateTreeIntCombinaisonPropertyFunctionInstanceData::Result' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeAddIntPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeAddIntPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeAddIntPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeAddIntPropertyFunction");
static_assert(sizeof(FStateTreeAddIntPropertyFunction) == 0x000020, "Wrong size on FStateTreeAddIntPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeSubtractIntPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeSubtractIntPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeSubtractIntPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeSubtractIntPropertyFunction");
static_assert(sizeof(FStateTreeSubtractIntPropertyFunction) == 0x000020, "Wrong size on FStateTreeSubtractIntPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeMultiplyIntPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeMultiplyIntPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeMultiplyIntPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeMultiplyIntPropertyFunction");
static_assert(sizeof(FStateTreeMultiplyIntPropertyFunction) == 0x000020, "Wrong size on FStateTreeMultiplyIntPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeDivideIntPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeDivideIntPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeDivideIntPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeDivideIntPropertyFunction");
static_assert(sizeof(FStateTreeDivideIntPropertyFunction) == 0x000020, "Wrong size on FStateTreeDivideIntPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeSingleIntPropertyFunctionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeSingleIntPropertyFunctionInstanceData final
{
public:
	int32                                         Input;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeSingleIntPropertyFunctionInstanceData) == 0x000004, "Wrong alignment on FStateTreeSingleIntPropertyFunctionInstanceData");
static_assert(sizeof(FStateTreeSingleIntPropertyFunctionInstanceData) == 0x000008, "Wrong size on FStateTreeSingleIntPropertyFunctionInstanceData");
static_assert(offsetof(FStateTreeSingleIntPropertyFunctionInstanceData, Input) == 0x000000, "Member 'FStateTreeSingleIntPropertyFunctionInstanceData::Input' has a wrong offset!");
static_assert(offsetof(FStateTreeSingleIntPropertyFunctionInstanceData, Result) == 0x000004, "Member 'FStateTreeSingleIntPropertyFunctionInstanceData::Result' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInvertIntPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeInvertIntPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeInvertIntPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeInvertIntPropertyFunction");
static_assert(sizeof(FStateTreeInvertIntPropertyFunction) == 0x000020, "Wrong size on FStateTreeInvertIntPropertyFunction");

// ScriptStruct StateTreeModule.StateTreeAbsoluteIntPropertyFunction
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeAbsoluteIntPropertyFunction final : public FStateTreePropertyFunctionCommonBase
{
};
static_assert(alignof(FStateTreeAbsoluteIntPropertyFunction) == 0x000008, "Wrong alignment on FStateTreeAbsoluteIntPropertyFunction");
static_assert(sizeof(FStateTreeAbsoluteIntPropertyFunction) == 0x000020, "Wrong size on FStateTreeAbsoluteIntPropertyFunction");

// ScriptStruct StateTreeModule.StateTreePropertyRef
// 0x0002 (0x0002 - 0x0000)
struct FStateTreePropertyRef
{
public:
	struct FStateTreeIndex16                      RefAccessIndex;                                    // 0x0000(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreePropertyRef) == 0x000002, "Wrong alignment on FStateTreePropertyRef");
static_assert(sizeof(FStateTreePropertyRef) == 0x000002, "Wrong size on FStateTreePropertyRef");
static_assert(offsetof(FStateTreePropertyRef, RefAccessIndex) == 0x000000, "Member 'FStateTreePropertyRef::RefAccessIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintPropertyRef
// 0x000E (0x0010 - 0x0002)
struct FStateTreeBlueprintPropertyRef final : public FStateTreePropertyRef
{
public:
	EStateTreePropertyRefType                     RefType;                                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsRefToArray : 1;                                 // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsOptional : 1;                                   // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                TypeObject;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreeBlueprintPropertyRef) == 0x000008, "Wrong alignment on FStateTreeBlueprintPropertyRef");
static_assert(sizeof(FStateTreeBlueprintPropertyRef) == 0x000010, "Wrong size on FStateTreeBlueprintPropertyRef");
static_assert(offsetof(FStateTreeBlueprintPropertyRef, RefType) == 0x000002, "Member 'FStateTreeBlueprintPropertyRef::RefType' has a wrong offset!");
static_assert(offsetof(FStateTreeBlueprintPropertyRef, TypeObject) == 0x000008, "Member 'FStateTreeBlueprintPropertyRef::TypeObject' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeReference
// 0x0028 (0x0028 - 0x0000)
struct FStateTreeReference final
{
public:
	class UStateTree*                             StateTree;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInstancedPropertyBag                  Parameters;                                        // 0x0008(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          PropertyOverrides;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeReference) == 0x000008, "Wrong alignment on FStateTreeReference");
static_assert(sizeof(FStateTreeReference) == 0x000028, "Wrong size on FStateTreeReference");
static_assert(offsetof(FStateTreeReference, StateTree) == 0x000000, "Member 'FStateTreeReference::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeReference, Parameters) == 0x000008, "Member 'FStateTreeReference::Parameters' has a wrong offset!");
static_assert(offsetof(FStateTreeReference, PropertyOverrides) == 0x000018, "Member 'FStateTreeReference::PropertyOverrides' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInstanceData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStateTreeInstanceData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeInstanceData) == 0x000008, "Wrong alignment on FStateTreeInstanceData");
static_assert(sizeof(FStateTreeInstanceData) == 0x000010, "Wrong size on FStateTreeInstanceData");

// ScriptStruct StateTreeModule.StateTreeRunParallelStateTreeTaskInstanceData
// 0x0040 (0x0040 - 0x0000)
struct FStateTreeRunParallelStateTreeTaskInstanceData final
{
public:
	struct FStateTreeReference                    StateTree;                                         // 0x0000(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FStateTreeInstanceData                 TreeInstanceData;                                  // 0x0028(0x0010)(Transient, NativeAccessSpecifierPublic)
	class UStateTree*                             RunningStateTree;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeRunParallelStateTreeTaskInstanceData) == 0x000008, "Wrong alignment on FStateTreeRunParallelStateTreeTaskInstanceData");
static_assert(sizeof(FStateTreeRunParallelStateTreeTaskInstanceData) == 0x000040, "Wrong size on FStateTreeRunParallelStateTreeTaskInstanceData");
static_assert(offsetof(FStateTreeRunParallelStateTreeTaskInstanceData, StateTree) == 0x000000, "Member 'FStateTreeRunParallelStateTreeTaskInstanceData::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeRunParallelStateTreeTaskInstanceData, TreeInstanceData) == 0x000028, "Member 'FStateTreeRunParallelStateTreeTaskInstanceData::TreeInstanceData' has a wrong offset!");
static_assert(offsetof(FStateTreeRunParallelStateTreeTaskInstanceData, RunningStateTree) == 0x000038, "Member 'FStateTreeRunParallelStateTreeTaskInstanceData::RunningStateTree' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeRunParallelStateTreeTask
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeRunParallelStateTreeTask final : public FStateTreeTaskCommonBase
{
public:
	struct FGameplayTag                           StateTreeOverrideTag;                              // 0x0028(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeRunParallelStateTreeTask) == 0x000008, "Wrong alignment on FStateTreeRunParallelStateTreeTask");
static_assert(sizeof(FStateTreeRunParallelStateTreeTask) == 0x000030, "Wrong size on FStateTreeRunParallelStateTreeTask");
static_assert(offsetof(FStateTreeRunParallelStateTreeTask, StateTreeOverrideTag) == 0x000028, "Member 'FStateTreeRunParallelStateTreeTask::StateTreeOverrideTag' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintConditionWrapper
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeBlueprintConditionWrapper final : public FStateTreeConditionBase
{
public:
	TSubclassOf<class UStateTreeConditionBlueprintBase> ConditionClass;                              // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintConditionWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintConditionWrapper");
static_assert(sizeof(FStateTreeBlueprintConditionWrapper) == 0x000030, "Wrong size on FStateTreeBlueprintConditionWrapper");
static_assert(offsetof(FStateTreeBlueprintConditionWrapper, ConditionClass) == 0x000028, "Member 'FStateTreeBlueprintConditionWrapper::ConditionClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConsiderationBase
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeConsiderationBase : public FStateTreeNodeBase
{
public:
	EStateTreeExpressionOperand                   Operand;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          DeltaIndent;                                       // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeConsiderationBase) == 0x000008, "Wrong alignment on FStateTreeConsiderationBase");
static_assert(sizeof(FStateTreeConsiderationBase) == 0x000028, "Wrong size on FStateTreeConsiderationBase");
static_assert(offsetof(FStateTreeConsiderationBase, Operand) == 0x000020, "Member 'FStateTreeConsiderationBase::Operand' has a wrong offset!");
static_assert(offsetof(FStateTreeConsiderationBase, DeltaIndent) == 0x000021, "Member 'FStateTreeConsiderationBase::DeltaIndent' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintConsiderationWrapper
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeBlueprintConsiderationWrapper final : public FStateTreeConsiderationBase
{
public:
	TSubclassOf<class UStateTreeConsiderationBlueprintBase> ConsiderationClass;                      // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintConsiderationWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintConsiderationWrapper");
static_assert(sizeof(FStateTreeBlueprintConsiderationWrapper) == 0x000030, "Wrong size on FStateTreeBlueprintConsiderationWrapper");
static_assert(offsetof(FStateTreeBlueprintConsiderationWrapper, ConsiderationClass) == 0x000028, "Member 'FStateTreeBlueprintConsiderationWrapper::ConsiderationClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintEvaluatorWrapper
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeBlueprintEvaluatorWrapper final : public FStateTreeEvaluatorBase
{
public:
	TSubclassOf<class UStateTreeEvaluatorBlueprintBase> EvaluatorClass;                              // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintEvaluatorWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintEvaluatorWrapper");
static_assert(sizeof(FStateTreeBlueprintEvaluatorWrapper) == 0x000028, "Wrong size on FStateTreeBlueprintEvaluatorWrapper");
static_assert(offsetof(FStateTreeBlueprintEvaluatorWrapper, EvaluatorClass) == 0x000020, "Member 'FStateTreeBlueprintEvaluatorWrapper::EvaluatorClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareIntConditionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeCompareIntConditionInstanceData final
{
public:
	int32                                         Left;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Right;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareIntConditionInstanceData) == 0x000004, "Wrong alignment on FStateTreeCompareIntConditionInstanceData");
static_assert(sizeof(FStateTreeCompareIntConditionInstanceData) == 0x000008, "Wrong size on FStateTreeCompareIntConditionInstanceData");
static_assert(offsetof(FStateTreeCompareIntConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeCompareIntConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareIntConditionInstanceData, Right) == 0x000004, "Member 'FStateTreeCompareIntConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareIntCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeCompareIntCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareIntCondition) == 0x000008, "Wrong alignment on FStateTreeCompareIntCondition");
static_assert(sizeof(FStateTreeCompareIntCondition) == 0x000030, "Wrong size on FStateTreeCompareIntCondition");
static_assert(offsetof(FStateTreeCompareIntCondition, bInvert) == 0x000028, "Member 'FStateTreeCompareIntCondition::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareIntCondition, Operator) == 0x000029, "Member 'FStateTreeCompareIntCondition::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareFloatConditionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeCompareFloatConditionInstanceData final
{
public:
	double                                        Left;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Right;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareFloatConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeCompareFloatConditionInstanceData");
static_assert(sizeof(FStateTreeCompareFloatConditionInstanceData) == 0x000010, "Wrong size on FStateTreeCompareFloatConditionInstanceData");
static_assert(offsetof(FStateTreeCompareFloatConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeCompareFloatConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareFloatConditionInstanceData, Right) == 0x000008, "Member 'FStateTreeCompareFloatConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareFloatCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeCompareFloatCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareFloatCondition) == 0x000008, "Wrong alignment on FStateTreeCompareFloatCondition");
static_assert(sizeof(FStateTreeCompareFloatCondition) == 0x000030, "Wrong size on FStateTreeCompareFloatCondition");
static_assert(offsetof(FStateTreeCompareFloatCondition, bInvert) == 0x000028, "Member 'FStateTreeCompareFloatCondition::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareFloatCondition, Operator) == 0x000029, "Member 'FStateTreeCompareFloatCondition::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareBoolConditionInstanceData
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeCompareBoolConditionInstanceData final
{
public:
	bool                                          bLeft;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRight;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareBoolConditionInstanceData) == 0x000001, "Wrong alignment on FStateTreeCompareBoolConditionInstanceData");
static_assert(sizeof(FStateTreeCompareBoolConditionInstanceData) == 0x000002, "Wrong size on FStateTreeCompareBoolConditionInstanceData");
static_assert(offsetof(FStateTreeCompareBoolConditionInstanceData, bLeft) == 0x000000, "Member 'FStateTreeCompareBoolConditionInstanceData::bLeft' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareBoolConditionInstanceData, bRight) == 0x000001, "Member 'FStateTreeCompareBoolConditionInstanceData::bRight' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareBoolCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeCompareBoolCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareBoolCondition) == 0x000008, "Wrong alignment on FStateTreeCompareBoolCondition");
static_assert(sizeof(FStateTreeCompareBoolCondition) == 0x000030, "Wrong size on FStateTreeCompareBoolCondition");
static_assert(offsetof(FStateTreeCompareBoolCondition, bInvert) == 0x000028, "Member 'FStateTreeCompareBoolCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareEnumConditionInstanceData
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeCompareEnumConditionInstanceData final
{
public:
	struct FStateTreeAnyEnum                      Left;                                              // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeAnyEnum                      Right;                                             // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareEnumConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeCompareEnumConditionInstanceData");
static_assert(sizeof(FStateTreeCompareEnumConditionInstanceData) == 0x000020, "Wrong size on FStateTreeCompareEnumConditionInstanceData");
static_assert(offsetof(FStateTreeCompareEnumConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeCompareEnumConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareEnumConditionInstanceData, Right) == 0x000010, "Member 'FStateTreeCompareEnumConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareEnumCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeCompareEnumCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareEnumCondition) == 0x000008, "Wrong alignment on FStateTreeCompareEnumCondition");
static_assert(sizeof(FStateTreeCompareEnumCondition) == 0x000030, "Wrong size on FStateTreeCompareEnumCondition");
static_assert(offsetof(FStateTreeCompareEnumCondition, bInvert) == 0x000028, "Member 'FStateTreeCompareEnumCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareDistanceConditionInstanceData
// 0x0038 (0x0038 - 0x0000)
struct FStateTreeCompareDistanceConditionInstanceData final
{
public:
	struct FVector                                Source;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Distance;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareDistanceConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeCompareDistanceConditionInstanceData");
static_assert(sizeof(FStateTreeCompareDistanceConditionInstanceData) == 0x000038, "Wrong size on FStateTreeCompareDistanceConditionInstanceData");
static_assert(offsetof(FStateTreeCompareDistanceConditionInstanceData, Source) == 0x000000, "Member 'FStateTreeCompareDistanceConditionInstanceData::Source' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareDistanceConditionInstanceData, Target) == 0x000018, "Member 'FStateTreeCompareDistanceConditionInstanceData::Target' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareDistanceConditionInstanceData, Distance) == 0x000030, "Member 'FStateTreeCompareDistanceConditionInstanceData::Distance' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareDistanceCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeCompareDistanceCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareDistanceCondition) == 0x000008, "Wrong alignment on FStateTreeCompareDistanceCondition");
static_assert(sizeof(FStateTreeCompareDistanceCondition) == 0x000030, "Wrong size on FStateTreeCompareDistanceCondition");
static_assert(offsetof(FStateTreeCompareDistanceCondition, bInvert) == 0x000028, "Member 'FStateTreeCompareDistanceCondition::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareDistanceCondition, Operator) == 0x000029, "Member 'FStateTreeCompareDistanceCondition::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeRandomConditionInstanceData
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeRandomConditionInstanceData final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeRandomConditionInstanceData) == 0x000004, "Wrong alignment on FStateTreeRandomConditionInstanceData");
static_assert(sizeof(FStateTreeRandomConditionInstanceData) == 0x000004, "Wrong size on FStateTreeRandomConditionInstanceData");
static_assert(offsetof(FStateTreeRandomConditionInstanceData, Threshold) == 0x000000, "Member 'FStateTreeRandomConditionInstanceData::Threshold' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeRandomCondition
// 0x0000 (0x0028 - 0x0028)
struct FStateTreeRandomCondition final : public FStateTreeConditionCommonBase
{
};
static_assert(alignof(FStateTreeRandomCondition) == 0x000008, "Wrong alignment on FStateTreeRandomCondition");
static_assert(sizeof(FStateTreeRandomCondition) == 0x000028, "Wrong size on FStateTreeRandomCondition");

// ScriptStruct StateTreeModule.GameplayTagMatchConditionInstanceData
// 0x0028 (0x0028 - 0x0000)
struct FGameplayTagMatchConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagMatchConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagMatchConditionInstanceData");
static_assert(sizeof(FGameplayTagMatchConditionInstanceData) == 0x000028, "Wrong size on FGameplayTagMatchConditionInstanceData");
static_assert(offsetof(FGameplayTagMatchConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagMatchConditionInstanceData::TagContainer' has a wrong offset!");
static_assert(offsetof(FGameplayTagMatchConditionInstanceData, Tag) == 0x000020, "Member 'FGameplayTagMatchConditionInstanceData::Tag' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagMatchCondition
// 0x0008 (0x0030 - 0x0028)
struct FGameplayTagMatchCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bExactMatch;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagMatchCondition) == 0x000008, "Wrong alignment on FGameplayTagMatchCondition");
static_assert(sizeof(FGameplayTagMatchCondition) == 0x000030, "Wrong size on FGameplayTagMatchCondition");
static_assert(offsetof(FGameplayTagMatchCondition, bExactMatch) == 0x000028, "Member 'FGameplayTagMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayTagMatchCondition, bInvert) == 0x000029, "Member 'FGameplayTagMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagContainerMatchConditionInstanceData
// 0x0040 (0x0040 - 0x0000)
struct FGameplayTagContainerMatchConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OtherContainer;                                    // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagContainerMatchConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagContainerMatchConditionInstanceData");
static_assert(sizeof(FGameplayTagContainerMatchConditionInstanceData) == 0x000040, "Wrong size on FGameplayTagContainerMatchConditionInstanceData");
static_assert(offsetof(FGameplayTagContainerMatchConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagContainerMatchConditionInstanceData::TagContainer' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchConditionInstanceData, OtherContainer) == 0x000020, "Member 'FGameplayTagContainerMatchConditionInstanceData::OtherContainer' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagContainerMatchCondition
// 0x0008 (0x0030 - 0x0028)
struct FGameplayTagContainerMatchCondition final : public FStateTreeConditionCommonBase
{
public:
	EGameplayContainerMatchType                   MatchType;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagContainerMatchCondition) == 0x000008, "Wrong alignment on FGameplayTagContainerMatchCondition");
static_assert(sizeof(FGameplayTagContainerMatchCondition) == 0x000030, "Wrong size on FGameplayTagContainerMatchCondition");
static_assert(offsetof(FGameplayTagContainerMatchCondition, MatchType) == 0x000028, "Member 'FGameplayTagContainerMatchCondition::MatchType' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchCondition, bExactMatch) == 0x000029, "Member 'FGameplayTagContainerMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchCondition, bInvert) == 0x00002A, "Member 'FGameplayTagContainerMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagQueryConditionInstanceData
// 0x0020 (0x0020 - 0x0000)
struct FGameplayTagQueryConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagQueryConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagQueryConditionInstanceData");
static_assert(sizeof(FGameplayTagQueryConditionInstanceData) == 0x000020, "Wrong size on FGameplayTagQueryConditionInstanceData");
static_assert(offsetof(FGameplayTagQueryConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagQueryConditionInstanceData::TagContainer' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagQueryCondition
// 0x0050 (0x0078 - 0x0028)
struct FGameplayTagQueryCondition final : public FStateTreeConditionCommonBase
{
public:
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0028(0x0048)(Edit, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagQueryCondition) == 0x000008, "Wrong alignment on FGameplayTagQueryCondition");
static_assert(sizeof(FGameplayTagQueryCondition) == 0x000078, "Wrong size on FGameplayTagQueryCondition");
static_assert(offsetof(FGameplayTagQueryCondition, TagQuery) == 0x000028, "Member 'FGameplayTagQueryCondition::TagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayTagQueryCondition, bInvert) == 0x000070, "Member 'FGameplayTagQueryCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsValidConditionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeObjectIsValidConditionInstanceData final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeObjectIsValidConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeObjectIsValidConditionInstanceData");
static_assert(sizeof(FStateTreeObjectIsValidConditionInstanceData) == 0x000008, "Wrong size on FStateTreeObjectIsValidConditionInstanceData");
static_assert(offsetof(FStateTreeObjectIsValidConditionInstanceData, Object) == 0x000000, "Member 'FStateTreeObjectIsValidConditionInstanceData::Object' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsValidCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeObjectIsValidCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeObjectIsValidCondition) == 0x000008, "Wrong alignment on FStateTreeObjectIsValidCondition");
static_assert(sizeof(FStateTreeObjectIsValidCondition) == 0x000030, "Wrong size on FStateTreeObjectIsValidCondition");
static_assert(offsetof(FStateTreeObjectIsValidCondition, bInvert) == 0x000028, "Member 'FStateTreeObjectIsValidCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectEqualsConditionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeObjectEqualsConditionInstanceData final
{
public:
	class UObject*                                Left;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Right;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeObjectEqualsConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeObjectEqualsConditionInstanceData");
static_assert(sizeof(FStateTreeObjectEqualsConditionInstanceData) == 0x000010, "Wrong size on FStateTreeObjectEqualsConditionInstanceData");
static_assert(offsetof(FStateTreeObjectEqualsConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeObjectEqualsConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeObjectEqualsConditionInstanceData, Right) == 0x000008, "Member 'FStateTreeObjectEqualsConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectEqualsCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeObjectEqualsCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeObjectEqualsCondition) == 0x000008, "Wrong alignment on FStateTreeObjectEqualsCondition");
static_assert(sizeof(FStateTreeObjectEqualsCondition) == 0x000030, "Wrong size on FStateTreeObjectEqualsCondition");
static_assert(offsetof(FStateTreeObjectEqualsCondition, bInvert) == 0x000028, "Member 'FStateTreeObjectEqualsCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsChildOfClassConditionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeObjectIsChildOfClassConditionInstanceData final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    Class;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeObjectIsChildOfClassConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeObjectIsChildOfClassConditionInstanceData");
static_assert(sizeof(FStateTreeObjectIsChildOfClassConditionInstanceData) == 0x000010, "Wrong size on FStateTreeObjectIsChildOfClassConditionInstanceData");
static_assert(offsetof(FStateTreeObjectIsChildOfClassConditionInstanceData, Object) == 0x000000, "Member 'FStateTreeObjectIsChildOfClassConditionInstanceData::Object' has a wrong offset!");
static_assert(offsetof(FStateTreeObjectIsChildOfClassConditionInstanceData, Class) == 0x000008, "Member 'FStateTreeObjectIsChildOfClassConditionInstanceData::Class' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsChildOfClassCondition
// 0x0008 (0x0030 - 0x0028)
struct FStateTreeObjectIsChildOfClassCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeObjectIsChildOfClassCondition) == 0x000008, "Wrong alignment on FStateTreeObjectIsChildOfClassCondition");
static_assert(sizeof(FStateTreeObjectIsChildOfClassCondition) == 0x000030, "Wrong size on FStateTreeObjectIsChildOfClassCondition");
static_assert(offsetof(FStateTreeObjectIsChildOfClassCondition, bInvert) == 0x000028, "Member 'FStateTreeObjectIsChildOfClassCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConstantConsiderationInstanceData
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeConstantConsiderationInstanceData final
{
public:
	float                                         Constant;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeConstantConsiderationInstanceData) == 0x000004, "Wrong alignment on FStateTreeConstantConsiderationInstanceData");
static_assert(sizeof(FStateTreeConstantConsiderationInstanceData) == 0x000004, "Wrong size on FStateTreeConstantConsiderationInstanceData");
static_assert(offsetof(FStateTreeConstantConsiderationInstanceData, Constant) == 0x000000, "Member 'FStateTreeConstantConsiderationInstanceData::Constant' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConsiderationCommonBase
// 0x0000 (0x0028 - 0x0028)
struct FStateTreeConsiderationCommonBase : public FStateTreeConsiderationBase
{
};
static_assert(alignof(FStateTreeConsiderationCommonBase) == 0x000008, "Wrong alignment on FStateTreeConsiderationCommonBase");
static_assert(sizeof(FStateTreeConsiderationCommonBase) == 0x000028, "Wrong size on FStateTreeConsiderationCommonBase");

// ScriptStruct StateTreeModule.StateTreeConstantConsideration
// 0x0000 (0x0028 - 0x0028)
struct FStateTreeConstantConsideration final : public FStateTreeConsiderationCommonBase
{
};
static_assert(alignof(FStateTreeConstantConsideration) == 0x000008, "Wrong alignment on FStateTreeConstantConsideration");
static_assert(sizeof(FStateTreeConstantConsideration) == 0x000028, "Wrong size on FStateTreeConstantConsideration");

// ScriptStruct StateTreeModule.StateTreeConsiderationResponseCurve
// 0x0088 (0x0088 - 0x0000)
struct FStateTreeConsiderationResponseCurve final
{
public:
	struct FRuntimeFloatCurve                     CurveInfo;                                         // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeConsiderationResponseCurve) == 0x000008, "Wrong alignment on FStateTreeConsiderationResponseCurve");
static_assert(sizeof(FStateTreeConsiderationResponseCurve) == 0x000088, "Wrong size on FStateTreeConsiderationResponseCurve");
static_assert(offsetof(FStateTreeConsiderationResponseCurve, CurveInfo) == 0x000000, "Member 'FStateTreeConsiderationResponseCurve::CurveInfo' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeFloatInputConsiderationInstanceData
// 0x000C (0x000C - 0x0000)
struct FStateTreeFloatInputConsiderationInstanceData final
{
public:
	float                                         Input;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Interval;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeFloatInputConsiderationInstanceData) == 0x000004, "Wrong alignment on FStateTreeFloatInputConsiderationInstanceData");
static_assert(sizeof(FStateTreeFloatInputConsiderationInstanceData) == 0x00000C, "Wrong size on FStateTreeFloatInputConsiderationInstanceData");
static_assert(offsetof(FStateTreeFloatInputConsiderationInstanceData, Input) == 0x000000, "Member 'FStateTreeFloatInputConsiderationInstanceData::Input' has a wrong offset!");
static_assert(offsetof(FStateTreeFloatInputConsiderationInstanceData, Interval) == 0x000004, "Member 'FStateTreeFloatInputConsiderationInstanceData::Interval' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeFloatInputConsideration
// 0x0088 (0x00B0 - 0x0028)
struct FStateTreeFloatInputConsideration final : public FStateTreeConsiderationCommonBase
{
public:
	struct FStateTreeConsiderationResponseCurve   ResponseCurve;                                     // 0x0028(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeFloatInputConsideration) == 0x000008, "Wrong alignment on FStateTreeFloatInputConsideration");
static_assert(sizeof(FStateTreeFloatInputConsideration) == 0x0000B0, "Wrong size on FStateTreeFloatInputConsideration");
static_assert(offsetof(FStateTreeFloatInputConsideration, ResponseCurve) == 0x000028, "Member 'FStateTreeFloatInputConsideration::ResponseCurve' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEnumValueScorePair
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeEnumValueScorePair final
{
public:
	int64                                         EnumValue;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeEnumValueScorePair) == 0x000008, "Wrong alignment on FStateTreeEnumValueScorePair");
static_assert(sizeof(FStateTreeEnumValueScorePair) == 0x000010, "Wrong size on FStateTreeEnumValueScorePair");
static_assert(offsetof(FStateTreeEnumValueScorePair, EnumValue) == 0x000000, "Member 'FStateTreeEnumValueScorePair::EnumValue' has a wrong offset!");
static_assert(offsetof(FStateTreeEnumValueScorePair, Score) == 0x000008, "Member 'FStateTreeEnumValueScorePair::Score' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEnumValueScorePairs
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeEnumValueScorePairs final
{
public:
	TArray<struct FStateTreeEnumValueScorePair>   Data;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeEnumValueScorePairs) == 0x000008, "Wrong alignment on FStateTreeEnumValueScorePairs");
static_assert(sizeof(FStateTreeEnumValueScorePairs) == 0x000010, "Wrong size on FStateTreeEnumValueScorePairs");
static_assert(offsetof(FStateTreeEnumValueScorePairs, Data) == 0x000000, "Member 'FStateTreeEnumValueScorePairs::Data' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEnumInputConsiderationInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeEnumInputConsiderationInstanceData final
{
public:
	struct FStateTreeAnyEnum                      Input;                                             // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeEnumInputConsiderationInstanceData) == 0x000008, "Wrong alignment on FStateTreeEnumInputConsiderationInstanceData");
static_assert(sizeof(FStateTreeEnumInputConsiderationInstanceData) == 0x000010, "Wrong size on FStateTreeEnumInputConsiderationInstanceData");
static_assert(offsetof(FStateTreeEnumInputConsiderationInstanceData, Input) == 0x000000, "Member 'FStateTreeEnumInputConsiderationInstanceData::Input' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEnumInputConsideration
// 0x0010 (0x0038 - 0x0028)
struct FStateTreeEnumInputConsideration final : public FStateTreeConsiderationCommonBase
{
public:
	struct FStateTreeEnumValueScorePairs          EnumValueScorePairs;                               // 0x0028(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeEnumInputConsideration) == 0x000008, "Wrong alignment on FStateTreeEnumInputConsideration");
static_assert(sizeof(FStateTreeEnumInputConsideration) == 0x000038, "Wrong size on FStateTreeEnumInputConsideration");
static_assert(offsetof(FStateTreeEnumInputConsideration, EnumValueScorePairs) == 0x000028, "Member 'FStateTreeEnumInputConsideration::EnumValueScorePairs' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvaluatorCommonBase
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeEvaluatorCommonBase final : public FStateTreeEvaluatorBase
{
};
static_assert(alignof(FStateTreeEvaluatorCommonBase) == 0x000008, "Wrong alignment on FStateTreeEvaluatorCommonBase");
static_assert(sizeof(FStateTreeEvaluatorCommonBase) == 0x000020, "Wrong size on FStateTreeEvaluatorCommonBase");

// ScriptStruct StateTreeModule.StateTreeEventQueue
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeEventQueue final
{
public:
	TArray<struct FStateTreeSharedEvent>          SharedEvents;                                      // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeEventQueue) == 0x000008, "Wrong alignment on FStateTreeEventQueue");
static_assert(sizeof(FStateTreeEventQueue) == 0x000010, "Wrong size on FStateTreeEventQueue");
static_assert(offsetof(FStateTreeEventQueue, SharedEvents) == 0x000000, "Member 'FStateTreeEventQueue::SharedEvents' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInstanceObjectWrapper
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeInstanceObjectWrapper final
{
public:
	class UObject*                                InstanceObject;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeInstanceObjectWrapper) == 0x000008, "Wrong alignment on FStateTreeInstanceObjectWrapper");
static_assert(sizeof(FStateTreeInstanceObjectWrapper) == 0x000008, "Wrong size on FStateTreeInstanceObjectWrapper");
static_assert(offsetof(FStateTreeInstanceObjectWrapper, InstanceObject) == 0x000000, "Member 'FStateTreeInstanceObjectWrapper::InstanceObject' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTemporaryInstanceData
// 0x0028 (0x0028 - 0x0000)
struct FStateTreeTemporaryInstanceData final
{
public:
	class UStateTree*                             StateTree;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  RootState;                                         // 0x0008(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   DataHandle;                                        // 0x000A(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      OwnerNodeIndex;                                    // 0x0010(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       Instance;                                          // 0x0018(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeTemporaryInstanceData) == 0x000008, "Wrong alignment on FStateTreeTemporaryInstanceData");
static_assert(sizeof(FStateTreeTemporaryInstanceData) == 0x000028, "Wrong size on FStateTreeTemporaryInstanceData");
static_assert(offsetof(FStateTreeTemporaryInstanceData, StateTree) == 0x000000, "Member 'FStateTreeTemporaryInstanceData::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeTemporaryInstanceData, RootState) == 0x000008, "Member 'FStateTreeTemporaryInstanceData::RootState' has a wrong offset!");
static_assert(offsetof(FStateTreeTemporaryInstanceData, DataHandle) == 0x00000A, "Member 'FStateTreeTemporaryInstanceData::DataHandle' has a wrong offset!");
static_assert(offsetof(FStateTreeTemporaryInstanceData, OwnerNodeIndex) == 0x000010, "Member 'FStateTreeTemporaryInstanceData::OwnerNodeIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeTemporaryInstanceData, Instance) == 0x000018, "Member 'FStateTreeTemporaryInstanceData::Instance' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInstanceStorage
// 0x0090 (0x0090 - 0x0000)
struct FStateTreeInstanceStorage final
{
public:
	struct FInstancedStructContainer              InstanceStructs;                                   // 0x0000(0x0010)(Protected, NativeAccessSpecifierProtected)
	struct FStateTreeExecutionState               ExecutionState;                                    // 0x0010(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreeTemporaryInstanceData> TemporaryInstances;                               // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStateTreeTransitionRequest>    TransitionRequests;                                // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FInstancedPropertyBag                  GlobalParameters;                                  // 0x0080(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeInstanceStorage) == 0x000008, "Wrong alignment on FStateTreeInstanceStorage");
static_assert(sizeof(FStateTreeInstanceStorage) == 0x000090, "Wrong size on FStateTreeInstanceStorage");
static_assert(offsetof(FStateTreeInstanceStorage, InstanceStructs) == 0x000000, "Member 'FStateTreeInstanceStorage::InstanceStructs' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, ExecutionState) == 0x000010, "Member 'FStateTreeInstanceStorage::ExecutionState' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, TemporaryInstances) == 0x000048, "Member 'FStateTreeInstanceStorage::TemporaryInstances' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, TransitionRequests) == 0x000070, "Member 'FStateTreeInstanceStorage::TransitionRequests' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, GlobalParameters) == 0x000080, "Member 'FStateTreeInstanceStorage::GlobalParameters' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBindableStructDesc
// 0x0018 (0x0018 - 0x0000)
struct FStateTreeBindableStructDesc final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   DataHandle;                                        // 0x0010(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeBindableStructSource                DataSource;                                        // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBindableStructDesc) == 0x000008, "Wrong alignment on FStateTreeBindableStructDesc");
static_assert(sizeof(FStateTreeBindableStructDesc) == 0x000018, "Wrong size on FStateTreeBindableStructDesc");
static_assert(offsetof(FStateTreeBindableStructDesc, Struct) == 0x000000, "Member 'FStateTreeBindableStructDesc::Struct' has a wrong offset!");
static_assert(offsetof(FStateTreeBindableStructDesc, Name) == 0x000008, "Member 'FStateTreeBindableStructDesc::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeBindableStructDesc, DataHandle) == 0x000010, "Member 'FStateTreeBindableStructDesc::DataHandle' has a wrong offset!");
static_assert(offsetof(FStateTreeBindableStructDesc, DataSource) == 0x000016, "Member 'FStateTreeBindableStructDesc::DataSource' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPathSegment
// 0x0018 (0x0018 - 0x0000)
struct FStateTreePropertyPathSegment final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ArrayIndex;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStruct*                                InstanceStruct;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreePropertyPathSegment) == 0x000008, "Wrong alignment on FStateTreePropertyPathSegment");
static_assert(sizeof(FStateTreePropertyPathSegment) == 0x000018, "Wrong size on FStateTreePropertyPathSegment");
static_assert(offsetof(FStateTreePropertyPathSegment, Name) == 0x000000, "Member 'FStateTreePropertyPathSegment::Name' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathSegment, ArrayIndex) == 0x000008, "Member 'FStateTreePropertyPathSegment::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathSegment, InstanceStruct) == 0x000010, "Member 'FStateTreePropertyPathSegment::InstanceStruct' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPath
// 0x0010 (0x0010 - 0x0000)
struct FStateTreePropertyPath final
{
public:
	TArray<struct FStateTreePropertyPathSegment>  Segments;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreePropertyPath) == 0x000008, "Wrong alignment on FStateTreePropertyPath");
static_assert(sizeof(FStateTreePropertyPath) == 0x000010, "Wrong size on FStateTreePropertyPath");
static_assert(offsetof(FStateTreePropertyPath, Segments) == 0x000000, "Member 'FStateTreePropertyPath::Segments' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEditorPropertyPath
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeEditorPropertyPath final
{
public:
	struct FGuid                                  StructID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Path;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeEditorPropertyPath) == 0x000008, "Wrong alignment on FStateTreeEditorPropertyPath");
static_assert(sizeof(FStateTreeEditorPropertyPath) == 0x000020, "Wrong size on FStateTreeEditorPropertyPath");
static_assert(offsetof(FStateTreeEditorPropertyPath, StructID) == 0x000000, "Member 'FStateTreeEditorPropertyPath::StructID' has a wrong offset!");
static_assert(offsetof(FStateTreeEditorPropertyPath, Path) == 0x000010, "Member 'FStateTreeEditorPropertyPath::Path' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPathBinding
// 0x0028 (0x0028 - 0x0000)
struct FStateTreePropertyPathBinding final
{
public:
	struct FStateTreePropertyPath                 SourcePropertyPath;                                // 0x0000(0x0010)(NativeAccessSpecifierPrivate)
	struct FStateTreePropertyPath                 TargetPropertyPath;                                // 0x0010(0x0010)(NativeAccessSpecifierPrivate)
	struct FStateTreeDataHandle                   SourceDataHandle;                                  // 0x0020(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyPathBinding) == 0x000008, "Wrong alignment on FStateTreePropertyPathBinding");
static_assert(sizeof(FStateTreePropertyPathBinding) == 0x000028, "Wrong size on FStateTreePropertyPathBinding");
static_assert(offsetof(FStateTreePropertyPathBinding, SourcePropertyPath) == 0x000000, "Member 'FStateTreePropertyPathBinding::SourcePropertyPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathBinding, TargetPropertyPath) == 0x000010, "Member 'FStateTreePropertyPathBinding::TargetPropertyPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathBinding, SourceDataHandle) == 0x000020, "Member 'FStateTreePropertyPathBinding::SourceDataHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyRefPath
// 0x0018 (0x0018 - 0x0000)
struct FStateTreePropertyRefPath final
{
public:
	struct FStateTreePropertyPath                 SourcePropertyPath;                                // 0x0000(0x0010)(NativeAccessSpecifierPrivate)
	struct FStateTreeDataHandle                   SourceDataHandle;                                  // 0x0010(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyRefPath) == 0x000008, "Wrong alignment on FStateTreePropertyRefPath");
static_assert(sizeof(FStateTreePropertyRefPath) == 0x000018, "Wrong size on FStateTreePropertyRefPath");
static_assert(offsetof(FStateTreePropertyRefPath, SourcePropertyPath) == 0x000000, "Member 'FStateTreePropertyRefPath::SourcePropertyPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyRefPath, SourceDataHandle) == 0x000010, "Member 'FStateTreePropertyRefPath::SourceDataHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertySegment
// 0x0010 (0x0010 - 0x0000)
struct FStateTreePropertySegment final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ArrayIndex;                                        // 0x0008(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      NextIndex;                                         // 0x000A(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyAccessType                  Type;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertySegment) == 0x000004, "Wrong alignment on FStateTreePropertySegment");
static_assert(sizeof(FStateTreePropertySegment) == 0x000010, "Wrong size on FStateTreePropertySegment");
static_assert(offsetof(FStateTreePropertySegment, Name) == 0x000000, "Member 'FStateTreePropertySegment::Name' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, ArrayIndex) == 0x000008, "Member 'FStateTreePropertySegment::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, NextIndex) == 0x00000A, "Member 'FStateTreePropertySegment::NextIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, Type) == 0x00000C, "Member 'FStateTreePropertySegment::Type' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyBinding
// 0x0024 (0x0024 - 0x0000)
struct FStateTreePropertyBinding final
{
public:
	struct FStateTreePropertySegment              SourcePath;                                        // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreePropertySegment              TargetPath;                                        // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      SourceStructIndex;                                 // 0x0020(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyCopyType                    CopyType;                                          // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyBinding) == 0x000004, "Wrong alignment on FStateTreePropertyBinding");
static_assert(sizeof(FStateTreePropertyBinding) == 0x000024, "Wrong size on FStateTreePropertyBinding");
static_assert(offsetof(FStateTreePropertyBinding, SourcePath) == 0x000000, "Member 'FStateTreePropertyBinding::SourcePath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, TargetPath) == 0x000010, "Member 'FStateTreePropertyBinding::TargetPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, SourceStructIndex) == 0x000020, "Member 'FStateTreePropertyBinding::SourceStructIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, CopyType) == 0x000022, "Member 'FStateTreePropertyBinding::CopyType' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyIndirection
// 0x0018 (0x0018 - 0x0000)
struct FStateTreePropertyIndirection final
{
public:
	struct FStateTreeIndex16                      ArrayIndex;                                        // 0x0000(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Offset;                                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      NextIndex;                                         // 0x0004(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyAccessType                  Type;                                              // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UStruct*                                InstanceStruct;                                    // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyIndirection) == 0x000008, "Wrong alignment on FStateTreePropertyIndirection");
static_assert(sizeof(FStateTreePropertyIndirection) == 0x000018, "Wrong size on FStateTreePropertyIndirection");
static_assert(offsetof(FStateTreePropertyIndirection, ArrayIndex) == 0x000000, "Member 'FStateTreePropertyIndirection::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, Offset) == 0x000002, "Member 'FStateTreePropertyIndirection::Offset' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, NextIndex) == 0x000004, "Member 'FStateTreePropertyIndirection::NextIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, Type) == 0x000006, "Member 'FStateTreePropertyIndirection::Type' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, InstanceStruct) == 0x000008, "Member 'FStateTreePropertyIndirection::InstanceStruct' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyCopy
// 0x0058 (0x0058 - 0x0000)
struct FStateTreePropertyCopy final
{
public:
	struct FStateTreePropertyIndirection          SourceIndirection;                                 // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreePropertyIndirection          TargetIndirection;                                 // 0x0018(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStruct*                                SourceStructType;                                  // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CopySize;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   SourceDataHandle;                                  // 0x004C(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyCopyType                    Type;                                              // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateTreeIndex16                      SourceStructIndex;                                 // 0x0054(0x0002)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyCopy) == 0x000008, "Wrong alignment on FStateTreePropertyCopy");
static_assert(sizeof(FStateTreePropertyCopy) == 0x000058, "Wrong size on FStateTreePropertyCopy");
static_assert(offsetof(FStateTreePropertyCopy, SourceIndirection) == 0x000000, "Member 'FStateTreePropertyCopy::SourceIndirection' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, TargetIndirection) == 0x000018, "Member 'FStateTreePropertyCopy::TargetIndirection' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, SourceStructType) == 0x000040, "Member 'FStateTreePropertyCopy::SourceStructType' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, CopySize) == 0x000048, "Member 'FStateTreePropertyCopy::CopySize' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, SourceDataHandle) == 0x00004C, "Member 'FStateTreePropertyCopy::SourceDataHandle' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, Type) == 0x000052, "Member 'FStateTreePropertyCopy::Type' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, SourceStructIndex) == 0x000054, "Member 'FStateTreePropertyCopy::SourceStructIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyCopyBatch
// 0x0020 (0x0020 - 0x0000)
struct FStateTreePropertyCopyBatch final
{
public:
	struct FStateTreeBindableStructDesc           TargetStruct;                                      // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      BindingsBegin;                                     // 0x0018(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      BindingsEnd;                                       // 0x001A(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      PropertyFunctionsBegin;                            // 0x001C(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      PropertyFunctionsEnd;                              // 0x001E(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreePropertyCopyBatch) == 0x000008, "Wrong alignment on FStateTreePropertyCopyBatch");
static_assert(sizeof(FStateTreePropertyCopyBatch) == 0x000020, "Wrong size on FStateTreePropertyCopyBatch");
static_assert(offsetof(FStateTreePropertyCopyBatch, TargetStruct) == 0x000000, "Member 'FStateTreePropertyCopyBatch::TargetStruct' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopyBatch, BindingsBegin) == 0x000018, "Member 'FStateTreePropertyCopyBatch::BindingsBegin' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopyBatch, BindingsEnd) == 0x00001A, "Member 'FStateTreePropertyCopyBatch::BindingsEnd' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopyBatch, PropertyFunctionsBegin) == 0x00001C, "Member 'FStateTreePropertyCopyBatch::PropertyFunctionsBegin' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopyBatch, PropertyFunctionsEnd) == 0x00001E, "Member 'FStateTreePropertyCopyBatch::PropertyFunctionsEnd' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyAccess
// 0x0030 (0x0030 - 0x0000)
struct FStateTreePropertyAccess final
{
public:
	struct FStateTreePropertyIndirection          SourceIndirection;                                 // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStruct*                                SourceStructType;                                  // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   SourceDataHandle;                                  // 0x0028(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyAccess) == 0x000008, "Wrong alignment on FStateTreePropertyAccess");
static_assert(sizeof(FStateTreePropertyAccess) == 0x000030, "Wrong size on FStateTreePropertyAccess");
static_assert(offsetof(FStateTreePropertyAccess, SourceIndirection) == 0x000000, "Member 'FStateTreePropertyAccess::SourceIndirection' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyAccess, SourceStructType) == 0x000020, "Member 'FStateTreePropertyAccess::SourceStructType' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyAccess, SourceDataHandle) == 0x000028, "Member 'FStateTreePropertyAccess::SourceDataHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyBindings
// 0x0078 (0x0078 - 0x0000)
struct FStateTreePropertyBindings final
{
public:
	TArray<struct FStateTreeBindableStructDesc>   SourceStructs;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyCopyBatch>    CopyBatches;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyPathBinding>  PropertyPathBindings;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyCopy>         PropertyCopies;                                    // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyRefPath>      PropertyReferencePaths;                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyAccess>       PropertyAccesses;                                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyIndirection>  PropertyIndirections;                              // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyBindings) == 0x000008, "Wrong alignment on FStateTreePropertyBindings");
static_assert(sizeof(FStateTreePropertyBindings) == 0x000078, "Wrong size on FStateTreePropertyBindings");
static_assert(offsetof(FStateTreePropertyBindings, SourceStructs) == 0x000000, "Member 'FStateTreePropertyBindings::SourceStructs' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, CopyBatches) == 0x000010, "Member 'FStateTreePropertyBindings::CopyBatches' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyPathBindings) == 0x000020, "Member 'FStateTreePropertyBindings::PropertyPathBindings' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyCopies) == 0x000030, "Member 'FStateTreePropertyBindings::PropertyCopies' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyReferencePaths) == 0x000040, "Member 'FStateTreePropertyBindings::PropertyReferencePaths' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyAccesses) == 0x000050, "Member 'FStateTreePropertyBindings::PropertyAccesses' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyIndirections) == 0x000060, "Member 'FStateTreePropertyBindings::PropertyIndirections' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeReferenceOverrideItem
// 0x0030 (0x0030 - 0x0000)
struct FStateTreeReferenceOverrideItem final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStateTreeReference                    StateTreeReference;                                // 0x0008(0x0028)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreeReferenceOverrideItem) == 0x000008, "Wrong alignment on FStateTreeReferenceOverrideItem");
static_assert(sizeof(FStateTreeReferenceOverrideItem) == 0x000030, "Wrong size on FStateTreeReferenceOverrideItem");
static_assert(offsetof(FStateTreeReferenceOverrideItem, StateTag) == 0x000000, "Member 'FStateTreeReferenceOverrideItem::StateTag' has a wrong offset!");
static_assert(offsetof(FStateTreeReferenceOverrideItem, StateTreeReference) == 0x000008, "Member 'FStateTreeReferenceOverrideItem::StateTreeReference' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeReferenceOverrides
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeReferenceOverrides final
{
public:
	TArray<struct FStateTreeReferenceOverrideItem> OverrideItems;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreeReferenceOverrides) == 0x000008, "Wrong alignment on FStateTreeReferenceOverrides");
static_assert(sizeof(FStateTreeReferenceOverrides) == 0x000010, "Wrong size on FStateTreeReferenceOverrides");
static_assert(offsetof(FStateTreeReferenceOverrides, OverrideItems) == 0x000000, "Member 'FStateTreeReferenceOverrides::OverrideItems' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactEventDesc
// 0x0010 (0x0010 - 0x0000)
struct FCompactEventDesc final
{
public:
	class UScriptStruct*                          PayloadStruct;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompactEventDesc) == 0x000008, "Wrong alignment on FCompactEventDesc");
static_assert(sizeof(FCompactEventDesc) == 0x000010, "Wrong size on FCompactEventDesc");
static_assert(offsetof(FCompactEventDesc, PayloadStruct) == 0x000000, "Member 'FCompactEventDesc::PayloadStruct' has a wrong offset!");
static_assert(offsetof(FCompactEventDesc, Tag) == 0x000008, "Member 'FCompactEventDesc::Tag' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactStateTransition
// 0x0020 (0x0020 - 0x0000)
struct FCompactStateTransition final
{
public:
	struct FCompactEventDesc                      RequiredEvent;                                     // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        ConditionsBegin;                                   // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  State;                                             // 0x0012(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeRandomTimeDuration           Delay;                                             // 0x0014(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeTransitionTrigger                   Trigger;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeSelectionFallback                   Fallback;                                          // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionsNum;                                     // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTransitionEnabled : 1;                            // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConsumeEventOnSelect : 1;                         // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompactStateTransition) == 0x000008, "Wrong alignment on FCompactStateTransition");
static_assert(sizeof(FCompactStateTransition) == 0x000020, "Wrong size on FCompactStateTransition");
static_assert(offsetof(FCompactStateTransition, RequiredEvent) == 0x000000, "Member 'FCompactStateTransition::RequiredEvent' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, ConditionsBegin) == 0x000010, "Member 'FCompactStateTransition::ConditionsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, State) == 0x000012, "Member 'FCompactStateTransition::State' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Delay) == 0x000014, "Member 'FCompactStateTransition::Delay' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Trigger) == 0x000018, "Member 'FCompactStateTransition::Trigger' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Priority) == 0x000019, "Member 'FCompactStateTransition::Priority' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Fallback) == 0x00001A, "Member 'FCompactStateTransition::Fallback' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, ConditionsNum) == 0x00001B, "Member 'FCompactStateTransition::ConditionsNum' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactStateTreeState
// 0x0058 (0x0058 - 0x0000)
struct FCompactStateTreeState final
{
public:
	struct FCompactEventDesc                      RequiredEventToEnter;                              // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStateTree*                             LinkedAsset;                                       // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  LinkedState;                                       // 0x0028(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  Parent;                                            // 0x002A(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ChildrenBegin;                                     // 0x002C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ChildrenEnd;                                       // 0x002E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EnterConditionsBegin;                              // 0x0030(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        UtilityConsiderationsBegin;                        // 0x0032(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TransitionsBegin;                                  // 0x0034(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TasksBegin;                                        // 0x0036(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ParameterTemplateIndex;                            // 0x0038(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeDataHandle                   ParameterDataHandle;                               // 0x003A(0x0006)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ParameterBindingsBatch;                            // 0x0040(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      EventDataIndex;                                    // 0x0042(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnterConditionsNum;                                // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UtilityConsiderationsNum;                          // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TransitionsNum;                                    // 0x0046(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TasksNum;                                          // 0x0047(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InstanceDataNum;                                   // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Depth;                                             // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeStateType                           Type;                                              // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeStateSelectionBehavior              SelectionBehavior;                                 // 0x004B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasTransitionTasks : 1;                           // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasStateChangeConditions : 1;                     // 0x004C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckPrerequisitesWhenActivatingChildDirectly : 1; // 0x004C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConsumeEventOnSelect : 1;                         // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompactStateTreeState) == 0x000008, "Wrong alignment on FCompactStateTreeState");
static_assert(sizeof(FCompactStateTreeState) == 0x000058, "Wrong size on FCompactStateTreeState");
static_assert(offsetof(FCompactStateTreeState, RequiredEventToEnter) == 0x000000, "Member 'FCompactStateTreeState::RequiredEventToEnter' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Name) == 0x000010, "Member 'FCompactStateTreeState::Name' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Tag) == 0x000018, "Member 'FCompactStateTreeState::Tag' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, LinkedAsset) == 0x000020, "Member 'FCompactStateTreeState::LinkedAsset' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, LinkedState) == 0x000028, "Member 'FCompactStateTreeState::LinkedState' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Parent) == 0x00002A, "Member 'FCompactStateTreeState::Parent' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ChildrenBegin) == 0x00002C, "Member 'FCompactStateTreeState::ChildrenBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ChildrenEnd) == 0x00002E, "Member 'FCompactStateTreeState::ChildrenEnd' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, EnterConditionsBegin) == 0x000030, "Member 'FCompactStateTreeState::EnterConditionsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, UtilityConsiderationsBegin) == 0x000032, "Member 'FCompactStateTreeState::UtilityConsiderationsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TransitionsBegin) == 0x000034, "Member 'FCompactStateTreeState::TransitionsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TasksBegin) == 0x000036, "Member 'FCompactStateTreeState::TasksBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ParameterTemplateIndex) == 0x000038, "Member 'FCompactStateTreeState::ParameterTemplateIndex' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ParameterDataHandle) == 0x00003A, "Member 'FCompactStateTreeState::ParameterDataHandle' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ParameterBindingsBatch) == 0x000040, "Member 'FCompactStateTreeState::ParameterBindingsBatch' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, EventDataIndex) == 0x000042, "Member 'FCompactStateTreeState::EventDataIndex' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, EnterConditionsNum) == 0x000044, "Member 'FCompactStateTreeState::EnterConditionsNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, UtilityConsiderationsNum) == 0x000045, "Member 'FCompactStateTreeState::UtilityConsiderationsNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TransitionsNum) == 0x000046, "Member 'FCompactStateTreeState::TransitionsNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TasksNum) == 0x000047, "Member 'FCompactStateTreeState::TasksNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, InstanceDataNum) == 0x000048, "Member 'FCompactStateTreeState::InstanceDataNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Depth) == 0x000049, "Member 'FCompactStateTreeState::Depth' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Type) == 0x00004A, "Member 'FCompactStateTreeState::Type' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, SelectionBehavior) == 0x00004B, "Member 'FCompactStateTreeState::SelectionBehavior' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Weight) == 0x000050, "Member 'FCompactStateTreeState::Weight' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactStateTreeParameters
// 0x0010 (0x0010 - 0x0000)
struct FCompactStateTreeParameters final
{
public:
	struct FInstancedPropertyBag                  Parameters;                                        // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompactStateTreeParameters) == 0x000008, "Wrong alignment on FCompactStateTreeParameters");
static_assert(sizeof(FCompactStateTreeParameters) == 0x000010, "Wrong size on FCompactStateTreeParameters");
static_assert(offsetof(FCompactStateTreeParameters, Parameters) == 0x000000, "Member 'FCompactStateTreeParameters::Parameters' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStateIdToHandle
// 0x0014 (0x0014 - 0x0000)
struct FStateTreeStateIdToHandle final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  Handle;                                            // 0x0010(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeStateIdToHandle) == 0x000004, "Wrong alignment on FStateTreeStateIdToHandle");
static_assert(sizeof(FStateTreeStateIdToHandle) == 0x000014, "Wrong size on FStateTreeStateIdToHandle");
static_assert(offsetof(FStateTreeStateIdToHandle, ID) == 0x000000, "Member 'FStateTreeStateIdToHandle::ID' has a wrong offset!");
static_assert(offsetof(FStateTreeStateIdToHandle, Handle) == 0x000010, "Member 'FStateTreeStateIdToHandle::Handle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionIdToIndex
// 0x0014 (0x0014 - 0x0000)
struct FStateTreeTransitionIdToIndex final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      Index;                                             // 0x0010(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionIdToIndex) == 0x000004, "Wrong alignment on FStateTreeTransitionIdToIndex");
static_assert(sizeof(FStateTreeTransitionIdToIndex) == 0x000014, "Wrong size on FStateTreeTransitionIdToIndex");
static_assert(offsetof(FStateTreeTransitionIdToIndex, ID) == 0x000000, "Member 'FStateTreeTransitionIdToIndex::ID' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionIdToIndex, Index) == 0x000010, "Member 'FStateTreeTransitionIdToIndex::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStateLink
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeStateLink final
{
public:
	struct FStateTreeStateHandle                  StateHandle;                                       // 0x0000(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeStateLink) == 0x000002, "Wrong alignment on FStateTreeStateLink");
static_assert(sizeof(FStateTreeStateLink) == 0x000002, "Wrong size on FStateTreeStateLink");
static_assert(offsetof(FStateTreeStateLink, StateHandle) == 0x000000, "Member 'FStateTreeStateLink::StateHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDebugTextTask
// 0x0038 (0x0060 - 0x0028)
struct FStateTreeDebugTextTask final : public FStateTreeTaskCommonBase
{
public:
	class FString                                 Text;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontScale;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0040(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeDebugTextTask) == 0x000008, "Wrong alignment on FStateTreeDebugTextTask");
static_assert(sizeof(FStateTreeDebugTextTask) == 0x000060, "Wrong size on FStateTreeDebugTextTask");
static_assert(offsetof(FStateTreeDebugTextTask, Text) == 0x000028, "Member 'FStateTreeDebugTextTask::Text' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, TextColor) == 0x000038, "Member 'FStateTreeDebugTextTask::TextColor' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, FontScale) == 0x00003C, "Member 'FStateTreeDebugTextTask::FontScale' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, Offset) == 0x000040, "Member 'FStateTreeDebugTextTask::Offset' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, bEnabled) == 0x000058, "Member 'FStateTreeDebugTextTask::bEnabled' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDelayTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeDelayTaskInstanceData final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunForever;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeDelayTaskInstanceData) == 0x000004, "Wrong alignment on FStateTreeDelayTaskInstanceData");
static_assert(sizeof(FStateTreeDelayTaskInstanceData) == 0x000010, "Wrong size on FStateTreeDelayTaskInstanceData");
static_assert(offsetof(FStateTreeDelayTaskInstanceData, Duration) == 0x000000, "Member 'FStateTreeDelayTaskInstanceData::Duration' has a wrong offset!");
static_assert(offsetof(FStateTreeDelayTaskInstanceData, RandomDeviation) == 0x000004, "Member 'FStateTreeDelayTaskInstanceData::RandomDeviation' has a wrong offset!");
static_assert(offsetof(FStateTreeDelayTaskInstanceData, bRunForever) == 0x000008, "Member 'FStateTreeDelayTaskInstanceData::bRunForever' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDelayTask
// 0x0000 (0x0028 - 0x0028)
struct FStateTreeDelayTask final : public FStateTreeTaskCommonBase
{
};
static_assert(alignof(FStateTreeDelayTask) == 0x000008, "Wrong alignment on FStateTreeDelayTask");
static_assert(sizeof(FStateTreeDelayTask) == 0x000028, "Wrong size on FStateTreeDelayTask");

}

